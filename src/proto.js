/*eslint-disable block-scoped-var, no-redeclare, no-control-regex, no-prototype-builtins*/
"use strict";

var $protobuf = require("protobufjs/minimal");

// Common aliases
var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

$root.errors = (function() {

    /**
     * Namespace errors.
     * @exports errors
     * @namespace
     */
    var errors = {};

    errors.ProtoError = (function() {

        /**
         * Properties of a ProtoError.
         * @memberof errors
         * @interface IProtoError
         * @property {number|null} [code] ProtoError code
         * @property {errors.PepsErrorKind|null} [kind] ProtoError kind
         * @property {google.protobuf.IAny|null} [payload] ProtoError payload
         */

        /**
         * Constructs a new ProtoError.
         * @memberof errors
         * @classdesc Represents a ProtoError.
         * @implements IProtoError
         * @constructor
         * @param {errors.IProtoError=} [properties] Properties to set
         */
        function ProtoError(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtoError code.
         * @member {number} code
         * @memberof errors.ProtoError
         * @instance
         */
        ProtoError.prototype.code = 0;

        /**
         * ProtoError kind.
         * @member {errors.PepsErrorKind} kind
         * @memberof errors.ProtoError
         * @instance
         */
        ProtoError.prototype.kind = 0;

        /**
         * ProtoError payload.
         * @member {google.protobuf.IAny|null|undefined} payload
         * @memberof errors.ProtoError
         * @instance
         */
        ProtoError.prototype.payload = null;

        /**
         * Creates a new ProtoError instance using the specified properties.
         * @function create
         * @memberof errors.ProtoError
         * @static
         * @param {errors.IProtoError=} [properties] Properties to set
         * @returns {errors.ProtoError} ProtoError instance
         */
        ProtoError.create = function create(properties) {
            return new ProtoError(properties);
        };

        /**
         * Encodes the specified ProtoError message. Does not implicitly {@link errors.ProtoError.verify|verify} messages.
         * @function encode
         * @memberof errors.ProtoError
         * @static
         * @param {errors.IProtoError} message ProtoError message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoError.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.code != null && message.hasOwnProperty("code"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.code);
            if (message.kind != null && message.hasOwnProperty("kind"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.kind);
            if (message.payload != null && message.hasOwnProperty("payload"))
                $root.google.protobuf.Any.encode(message.payload, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ProtoError message, length delimited. Does not implicitly {@link errors.ProtoError.verify|verify} messages.
         * @function encodeDelimited
         * @memberof errors.ProtoError
         * @static
         * @param {errors.IProtoError} message ProtoError message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoError.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoError message from the specified reader or buffer.
         * @function decode
         * @memberof errors.ProtoError
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {errors.ProtoError} ProtoError
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoError.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.errors.ProtoError();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.code = reader.uint32();
                    break;
                case 2:
                    message.kind = reader.int32();
                    break;
                case 3:
                    message.payload = $root.google.protobuf.Any.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoError message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof errors.ProtoError
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {errors.ProtoError} ProtoError
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoError.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoError message.
         * @function verify
         * @memberof errors.ProtoError
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoError.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.code != null && message.hasOwnProperty("code"))
                if (!$util.isInteger(message.code))
                    return "code: integer expected";
            if (message.kind != null && message.hasOwnProperty("kind"))
                switch (message.kind) {
                default:
                    return "kind: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                case 21:
                case 22:
                case 23:
                case 24:
                    break;
                }
            if (message.payload != null && message.hasOwnProperty("payload")) {
                var error = $root.google.protobuf.Any.verify(message.payload);
                if (error)
                    return "payload." + error;
            }
            return null;
        };

        /**
         * Creates a ProtoError message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof errors.ProtoError
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {errors.ProtoError} ProtoError
         */
        ProtoError.fromObject = function fromObject(object) {
            if (object instanceof $root.errors.ProtoError)
                return object;
            var message = new $root.errors.ProtoError();
            if (object.code != null)
                message.code = object.code >>> 0;
            switch (object.kind) {
            case "ServerInternalError":
            case 0:
                message.kind = 0;
                break;
            case "SessionExpired":
            case 1:
                message.kind = 1;
                break;
            case "SessionStale":
            case 2:
                message.kind = 2;
                break;
            case "SessionInvalidSalt":
            case 3:
                message.kind = 3;
                break;
            case "AssumeStale":
            case 4:
                message.kind = 4;
                break;
            case "RequestBadUriParams":
            case 6:
                message.kind = 6;
                break;
            case "RequestMissingHeader":
            case 7:
                message.kind = 7;
                break;
            case "RequestDecodeHeader":
            case 8:
                message.kind = 8;
                break;
            case "RequestBadRequest":
            case 9:
                message.kind = 9;
                break;
            case "IdentityCannotAssumeOwnership":
            case 10:
                message.kind = 10;
                break;
            case "IdentityCannotAssumeAccess":
            case 11:
                message.kind = 11;
                break;
            case "IdentitySignatureMismatch":
            case 12:
                message.kind = 12;
                break;
            case "IdentityInvalidLogin":
            case 13:
                message.kind = 13;
                break;
            case "IdentityAlreadyExists":
            case 14:
                message.kind = 14;
                break;
            case "IdentityNotFound":
            case 15:
                message.kind = 15;
                break;
            case "IdentityVersionMismatch":
            case 16:
                message.kind = 16;
                break;
            case "IdentityNotAdmin":
            case 17:
                message.kind = 17;
                break;
            case "IdentityNotAdminDomain":
            case 18:
                message.kind = 18;
                break;
            case "IdentitySharingKindMismatch":
            case 19:
                message.kind = 19;
                break;
            case "ResourceNotFound":
            case 20:
                message.kind = 20;
                break;
            case "RegisterInvalidEmail":
            case 21:
                message.kind = 21;
                break;
            case "RegisterTokenNotFound":
            case 22:
                message.kind = 22;
                break;
            case "ChannelNotFound":
            case 23:
                message.kind = 23;
                break;
            case "DelegatedAccessNotFound":
            case 24:
                message.kind = 24;
                break;
            }
            if (object.payload != null) {
                if (typeof object.payload !== "object")
                    throw TypeError(".errors.ProtoError.payload: object expected");
                message.payload = $root.google.protobuf.Any.fromObject(object.payload);
            }
            return message;
        };

        /**
         * Creates a plain object from a ProtoError message. Also converts values to other types if specified.
         * @function toObject
         * @memberof errors.ProtoError
         * @static
         * @param {errors.ProtoError} message ProtoError
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoError.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.code = 0;
                object.kind = options.enums === String ? "ServerInternalError" : 0;
                object.payload = null;
            }
            if (message.code != null && message.hasOwnProperty("code"))
                object.code = message.code;
            if (message.kind != null && message.hasOwnProperty("kind"))
                object.kind = options.enums === String ? $root.errors.PepsErrorKind[message.kind] : message.kind;
            if (message.payload != null && message.hasOwnProperty("payload"))
                object.payload = $root.google.protobuf.Any.toObject(message.payload, options);
            return object;
        };

        /**
         * Converts this ProtoError to JSON.
         * @function toJSON
         * @memberof errors.ProtoError
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoError.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoError;
    })();

    /**
     * PepsErrorKind enum.
     * @name errors.PepsErrorKind
     * @enum {string}
     * @property {number} ServerInternalError=0 ServerInternalError value
     * @property {number} SessionExpired=1 SessionExpired value
     * @property {number} SessionStale=2 SessionStale value
     * @property {number} SessionInvalidSalt=3 SessionInvalidSalt value
     * @property {number} AssumeStale=4 AssumeStale value
     * @property {number} RequestBadUriParams=6 RequestBadUriParams value
     * @property {number} RequestMissingHeader=7 RequestMissingHeader value
     * @property {number} RequestDecodeHeader=8 RequestDecodeHeader value
     * @property {number} RequestBadRequest=9 RequestBadRequest value
     * @property {number} IdentityCannotAssumeOwnership=10 IdentityCannotAssumeOwnership value
     * @property {number} IdentityCannotAssumeAccess=11 IdentityCannotAssumeAccess value
     * @property {number} IdentitySignatureMismatch=12 IdentitySignatureMismatch value
     * @property {number} IdentityInvalidLogin=13 IdentityInvalidLogin value
     * @property {number} IdentityAlreadyExists=14 IdentityAlreadyExists value
     * @property {number} IdentityNotFound=15 IdentityNotFound value
     * @property {number} IdentityVersionMismatch=16 IdentityVersionMismatch value
     * @property {number} IdentityNotAdmin=17 IdentityNotAdmin value
     * @property {number} IdentityNotAdminDomain=18 IdentityNotAdminDomain value
     * @property {number} IdentitySharingKindMismatch=19 IdentitySharingKindMismatch value
     * @property {number} ResourceNotFound=20 ResourceNotFound value
     * @property {number} RegisterInvalidEmail=21 RegisterInvalidEmail value
     * @property {number} RegisterTokenNotFound=22 RegisterTokenNotFound value
     * @property {number} ChannelNotFound=23 ChannelNotFound value
     * @property {number} DelegatedAccessNotFound=24 DelegatedAccessNotFound value
     */
    errors.PepsErrorKind = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "ServerInternalError"] = 0;
        values[valuesById[1] = "SessionExpired"] = 1;
        values[valuesById[2] = "SessionStale"] = 2;
        values[valuesById[3] = "SessionInvalidSalt"] = 3;
        values[valuesById[4] = "AssumeStale"] = 4;
        values[valuesById[6] = "RequestBadUriParams"] = 6;
        values[valuesById[7] = "RequestMissingHeader"] = 7;
        values[valuesById[8] = "RequestDecodeHeader"] = 8;
        values[valuesById[9] = "RequestBadRequest"] = 9;
        values[valuesById[10] = "IdentityCannotAssumeOwnership"] = 10;
        values[valuesById[11] = "IdentityCannotAssumeAccess"] = 11;
        values[valuesById[12] = "IdentitySignatureMismatch"] = 12;
        values[valuesById[13] = "IdentityInvalidLogin"] = 13;
        values[valuesById[14] = "IdentityAlreadyExists"] = 14;
        values[valuesById[15] = "IdentityNotFound"] = 15;
        values[valuesById[16] = "IdentityVersionMismatch"] = 16;
        values[valuesById[17] = "IdentityNotAdmin"] = 17;
        values[valuesById[18] = "IdentityNotAdminDomain"] = 18;
        values[valuesById[19] = "IdentitySharingKindMismatch"] = 19;
        values[valuesById[20] = "ResourceNotFound"] = 20;
        values[valuesById[21] = "RegisterInvalidEmail"] = 21;
        values[valuesById[22] = "RegisterTokenNotFound"] = 22;
        values[valuesById[23] = "ChannelNotFound"] = 23;
        values[valuesById[24] = "DelegatedAccessNotFound"] = 24;
        return values;
    })();

    errors.PayloadServerInternalError = (function() {

        /**
         * Properties of a PayloadServerInternalError.
         * @memberof errors
         * @interface IPayloadServerInternalError
         * @property {string|null} [reason] PayloadServerInternalError reason
         */

        /**
         * Constructs a new PayloadServerInternalError.
         * @memberof errors
         * @classdesc Represents a PayloadServerInternalError.
         * @implements IPayloadServerInternalError
         * @constructor
         * @param {errors.IPayloadServerInternalError=} [properties] Properties to set
         */
        function PayloadServerInternalError(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PayloadServerInternalError reason.
         * @member {string} reason
         * @memberof errors.PayloadServerInternalError
         * @instance
         */
        PayloadServerInternalError.prototype.reason = "";

        /**
         * Creates a new PayloadServerInternalError instance using the specified properties.
         * @function create
         * @memberof errors.PayloadServerInternalError
         * @static
         * @param {errors.IPayloadServerInternalError=} [properties] Properties to set
         * @returns {errors.PayloadServerInternalError} PayloadServerInternalError instance
         */
        PayloadServerInternalError.create = function create(properties) {
            return new PayloadServerInternalError(properties);
        };

        /**
         * Encodes the specified PayloadServerInternalError message. Does not implicitly {@link errors.PayloadServerInternalError.verify|verify} messages.
         * @function encode
         * @memberof errors.PayloadServerInternalError
         * @static
         * @param {errors.IPayloadServerInternalError} message PayloadServerInternalError message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadServerInternalError.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.reason != null && message.hasOwnProperty("reason"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.reason);
            return writer;
        };

        /**
         * Encodes the specified PayloadServerInternalError message, length delimited. Does not implicitly {@link errors.PayloadServerInternalError.verify|verify} messages.
         * @function encodeDelimited
         * @memberof errors.PayloadServerInternalError
         * @static
         * @param {errors.IPayloadServerInternalError} message PayloadServerInternalError message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadServerInternalError.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PayloadServerInternalError message from the specified reader or buffer.
         * @function decode
         * @memberof errors.PayloadServerInternalError
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {errors.PayloadServerInternalError} PayloadServerInternalError
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadServerInternalError.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.errors.PayloadServerInternalError();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.reason = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PayloadServerInternalError message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof errors.PayloadServerInternalError
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {errors.PayloadServerInternalError} PayloadServerInternalError
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadServerInternalError.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PayloadServerInternalError message.
         * @function verify
         * @memberof errors.PayloadServerInternalError
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PayloadServerInternalError.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.reason != null && message.hasOwnProperty("reason"))
                if (!$util.isString(message.reason))
                    return "reason: string expected";
            return null;
        };

        /**
         * Creates a PayloadServerInternalError message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof errors.PayloadServerInternalError
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {errors.PayloadServerInternalError} PayloadServerInternalError
         */
        PayloadServerInternalError.fromObject = function fromObject(object) {
            if (object instanceof $root.errors.PayloadServerInternalError)
                return object;
            var message = new $root.errors.PayloadServerInternalError();
            if (object.reason != null)
                message.reason = String(object.reason);
            return message;
        };

        /**
         * Creates a plain object from a PayloadServerInternalError message. Also converts values to other types if specified.
         * @function toObject
         * @memberof errors.PayloadServerInternalError
         * @static
         * @param {errors.PayloadServerInternalError} message PayloadServerInternalError
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PayloadServerInternalError.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.reason = "";
            if (message.reason != null && message.hasOwnProperty("reason"))
                object.reason = message.reason;
            return object;
        };

        /**
         * Converts this PayloadServerInternalError to JSON.
         * @function toJSON
         * @memberof errors.PayloadServerInternalError
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PayloadServerInternalError.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PayloadServerInternalError;
    })();

    errors.PayloadRequestBadUriParams = (function() {

        /**
         * Properties of a PayloadRequestBadUriParams.
         * @memberof errors
         * @interface IPayloadRequestBadUriParams
         * @property {string|null} [key] PayloadRequestBadUriParams key
         * @property {string|null} [value] PayloadRequestBadUriParams value
         * @property {string|null} [expected] PayloadRequestBadUriParams expected
         */

        /**
         * Constructs a new PayloadRequestBadUriParams.
         * @memberof errors
         * @classdesc Represents a PayloadRequestBadUriParams.
         * @implements IPayloadRequestBadUriParams
         * @constructor
         * @param {errors.IPayloadRequestBadUriParams=} [properties] Properties to set
         */
        function PayloadRequestBadUriParams(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PayloadRequestBadUriParams key.
         * @member {string} key
         * @memberof errors.PayloadRequestBadUriParams
         * @instance
         */
        PayloadRequestBadUriParams.prototype.key = "";

        /**
         * PayloadRequestBadUriParams value.
         * @member {string} value
         * @memberof errors.PayloadRequestBadUriParams
         * @instance
         */
        PayloadRequestBadUriParams.prototype.value = "";

        /**
         * PayloadRequestBadUriParams expected.
         * @member {string} expected
         * @memberof errors.PayloadRequestBadUriParams
         * @instance
         */
        PayloadRequestBadUriParams.prototype.expected = "";

        /**
         * Creates a new PayloadRequestBadUriParams instance using the specified properties.
         * @function create
         * @memberof errors.PayloadRequestBadUriParams
         * @static
         * @param {errors.IPayloadRequestBadUriParams=} [properties] Properties to set
         * @returns {errors.PayloadRequestBadUriParams} PayloadRequestBadUriParams instance
         */
        PayloadRequestBadUriParams.create = function create(properties) {
            return new PayloadRequestBadUriParams(properties);
        };

        /**
         * Encodes the specified PayloadRequestBadUriParams message. Does not implicitly {@link errors.PayloadRequestBadUriParams.verify|verify} messages.
         * @function encode
         * @memberof errors.PayloadRequestBadUriParams
         * @static
         * @param {errors.IPayloadRequestBadUriParams} message PayloadRequestBadUriParams message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadRequestBadUriParams.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.key != null && message.hasOwnProperty("key"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.key);
            if (message.value != null && message.hasOwnProperty("value"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.value);
            if (message.expected != null && message.hasOwnProperty("expected"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.expected);
            return writer;
        };

        /**
         * Encodes the specified PayloadRequestBadUriParams message, length delimited. Does not implicitly {@link errors.PayloadRequestBadUriParams.verify|verify} messages.
         * @function encodeDelimited
         * @memberof errors.PayloadRequestBadUriParams
         * @static
         * @param {errors.IPayloadRequestBadUriParams} message PayloadRequestBadUriParams message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadRequestBadUriParams.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PayloadRequestBadUriParams message from the specified reader or buffer.
         * @function decode
         * @memberof errors.PayloadRequestBadUriParams
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {errors.PayloadRequestBadUriParams} PayloadRequestBadUriParams
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadRequestBadUriParams.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.errors.PayloadRequestBadUriParams();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = reader.string();
                    break;
                case 3:
                    message.expected = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PayloadRequestBadUriParams message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof errors.PayloadRequestBadUriParams
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {errors.PayloadRequestBadUriParams} PayloadRequestBadUriParams
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadRequestBadUriParams.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PayloadRequestBadUriParams message.
         * @function verify
         * @memberof errors.PayloadRequestBadUriParams
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PayloadRequestBadUriParams.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.key != null && message.hasOwnProperty("key"))
                if (!$util.isString(message.key))
                    return "key: string expected";
            if (message.value != null && message.hasOwnProperty("value"))
                if (!$util.isString(message.value))
                    return "value: string expected";
            if (message.expected != null && message.hasOwnProperty("expected"))
                if (!$util.isString(message.expected))
                    return "expected: string expected";
            return null;
        };

        /**
         * Creates a PayloadRequestBadUriParams message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof errors.PayloadRequestBadUriParams
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {errors.PayloadRequestBadUriParams} PayloadRequestBadUriParams
         */
        PayloadRequestBadUriParams.fromObject = function fromObject(object) {
            if (object instanceof $root.errors.PayloadRequestBadUriParams)
                return object;
            var message = new $root.errors.PayloadRequestBadUriParams();
            if (object.key != null)
                message.key = String(object.key);
            if (object.value != null)
                message.value = String(object.value);
            if (object.expected != null)
                message.expected = String(object.expected);
            return message;
        };

        /**
         * Creates a plain object from a PayloadRequestBadUriParams message. Also converts values to other types if specified.
         * @function toObject
         * @memberof errors.PayloadRequestBadUriParams
         * @static
         * @param {errors.PayloadRequestBadUriParams} message PayloadRequestBadUriParams
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PayloadRequestBadUriParams.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.key = "";
                object.value = "";
                object.expected = "";
            }
            if (message.key != null && message.hasOwnProperty("key"))
                object.key = message.key;
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = message.value;
            if (message.expected != null && message.hasOwnProperty("expected"))
                object.expected = message.expected;
            return object;
        };

        /**
         * Converts this PayloadRequestBadUriParams to JSON.
         * @function toJSON
         * @memberof errors.PayloadRequestBadUriParams
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PayloadRequestBadUriParams.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PayloadRequestBadUriParams;
    })();

    errors.PayloadRequestMissingHeader = (function() {

        /**
         * Properties of a PayloadRequestMissingHeader.
         * @memberof errors
         * @interface IPayloadRequestMissingHeader
         * @property {string|null} [name] PayloadRequestMissingHeader name
         */

        /**
         * Constructs a new PayloadRequestMissingHeader.
         * @memberof errors
         * @classdesc Represents a PayloadRequestMissingHeader.
         * @implements IPayloadRequestMissingHeader
         * @constructor
         * @param {errors.IPayloadRequestMissingHeader=} [properties] Properties to set
         */
        function PayloadRequestMissingHeader(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PayloadRequestMissingHeader name.
         * @member {string} name
         * @memberof errors.PayloadRequestMissingHeader
         * @instance
         */
        PayloadRequestMissingHeader.prototype.name = "";

        /**
         * Creates a new PayloadRequestMissingHeader instance using the specified properties.
         * @function create
         * @memberof errors.PayloadRequestMissingHeader
         * @static
         * @param {errors.IPayloadRequestMissingHeader=} [properties] Properties to set
         * @returns {errors.PayloadRequestMissingHeader} PayloadRequestMissingHeader instance
         */
        PayloadRequestMissingHeader.create = function create(properties) {
            return new PayloadRequestMissingHeader(properties);
        };

        /**
         * Encodes the specified PayloadRequestMissingHeader message. Does not implicitly {@link errors.PayloadRequestMissingHeader.verify|verify} messages.
         * @function encode
         * @memberof errors.PayloadRequestMissingHeader
         * @static
         * @param {errors.IPayloadRequestMissingHeader} message PayloadRequestMissingHeader message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadRequestMissingHeader.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            return writer;
        };

        /**
         * Encodes the specified PayloadRequestMissingHeader message, length delimited. Does not implicitly {@link errors.PayloadRequestMissingHeader.verify|verify} messages.
         * @function encodeDelimited
         * @memberof errors.PayloadRequestMissingHeader
         * @static
         * @param {errors.IPayloadRequestMissingHeader} message PayloadRequestMissingHeader message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadRequestMissingHeader.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PayloadRequestMissingHeader message from the specified reader or buffer.
         * @function decode
         * @memberof errors.PayloadRequestMissingHeader
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {errors.PayloadRequestMissingHeader} PayloadRequestMissingHeader
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadRequestMissingHeader.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.errors.PayloadRequestMissingHeader();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PayloadRequestMissingHeader message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof errors.PayloadRequestMissingHeader
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {errors.PayloadRequestMissingHeader} PayloadRequestMissingHeader
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadRequestMissingHeader.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PayloadRequestMissingHeader message.
         * @function verify
         * @memberof errors.PayloadRequestMissingHeader
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PayloadRequestMissingHeader.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            return null;
        };

        /**
         * Creates a PayloadRequestMissingHeader message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof errors.PayloadRequestMissingHeader
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {errors.PayloadRequestMissingHeader} PayloadRequestMissingHeader
         */
        PayloadRequestMissingHeader.fromObject = function fromObject(object) {
            if (object instanceof $root.errors.PayloadRequestMissingHeader)
                return object;
            var message = new $root.errors.PayloadRequestMissingHeader();
            if (object.name != null)
                message.name = String(object.name);
            return message;
        };

        /**
         * Creates a plain object from a PayloadRequestMissingHeader message. Also converts values to other types if specified.
         * @function toObject
         * @memberof errors.PayloadRequestMissingHeader
         * @static
         * @param {errors.PayloadRequestMissingHeader} message PayloadRequestMissingHeader
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PayloadRequestMissingHeader.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.name = "";
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            return object;
        };

        /**
         * Converts this PayloadRequestMissingHeader to JSON.
         * @function toJSON
         * @memberof errors.PayloadRequestMissingHeader
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PayloadRequestMissingHeader.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PayloadRequestMissingHeader;
    })();

    errors.PayloadRequestDecodeHeader = (function() {

        /**
         * Properties of a PayloadRequestDecodeHeader.
         * @memberof errors
         * @interface IPayloadRequestDecodeHeader
         * @property {string|null} [name] PayloadRequestDecodeHeader name
         * @property {string|null} [value] PayloadRequestDecodeHeader value
         */

        /**
         * Constructs a new PayloadRequestDecodeHeader.
         * @memberof errors
         * @classdesc Represents a PayloadRequestDecodeHeader.
         * @implements IPayloadRequestDecodeHeader
         * @constructor
         * @param {errors.IPayloadRequestDecodeHeader=} [properties] Properties to set
         */
        function PayloadRequestDecodeHeader(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PayloadRequestDecodeHeader name.
         * @member {string} name
         * @memberof errors.PayloadRequestDecodeHeader
         * @instance
         */
        PayloadRequestDecodeHeader.prototype.name = "";

        /**
         * PayloadRequestDecodeHeader value.
         * @member {string} value
         * @memberof errors.PayloadRequestDecodeHeader
         * @instance
         */
        PayloadRequestDecodeHeader.prototype.value = "";

        /**
         * Creates a new PayloadRequestDecodeHeader instance using the specified properties.
         * @function create
         * @memberof errors.PayloadRequestDecodeHeader
         * @static
         * @param {errors.IPayloadRequestDecodeHeader=} [properties] Properties to set
         * @returns {errors.PayloadRequestDecodeHeader} PayloadRequestDecodeHeader instance
         */
        PayloadRequestDecodeHeader.create = function create(properties) {
            return new PayloadRequestDecodeHeader(properties);
        };

        /**
         * Encodes the specified PayloadRequestDecodeHeader message. Does not implicitly {@link errors.PayloadRequestDecodeHeader.verify|verify} messages.
         * @function encode
         * @memberof errors.PayloadRequestDecodeHeader
         * @static
         * @param {errors.IPayloadRequestDecodeHeader} message PayloadRequestDecodeHeader message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadRequestDecodeHeader.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.value != null && message.hasOwnProperty("value"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.value);
            return writer;
        };

        /**
         * Encodes the specified PayloadRequestDecodeHeader message, length delimited. Does not implicitly {@link errors.PayloadRequestDecodeHeader.verify|verify} messages.
         * @function encodeDelimited
         * @memberof errors.PayloadRequestDecodeHeader
         * @static
         * @param {errors.IPayloadRequestDecodeHeader} message PayloadRequestDecodeHeader message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadRequestDecodeHeader.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PayloadRequestDecodeHeader message from the specified reader or buffer.
         * @function decode
         * @memberof errors.PayloadRequestDecodeHeader
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {errors.PayloadRequestDecodeHeader} PayloadRequestDecodeHeader
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadRequestDecodeHeader.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.errors.PayloadRequestDecodeHeader();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.value = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PayloadRequestDecodeHeader message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof errors.PayloadRequestDecodeHeader
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {errors.PayloadRequestDecodeHeader} PayloadRequestDecodeHeader
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadRequestDecodeHeader.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PayloadRequestDecodeHeader message.
         * @function verify
         * @memberof errors.PayloadRequestDecodeHeader
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PayloadRequestDecodeHeader.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.value != null && message.hasOwnProperty("value"))
                if (!$util.isString(message.value))
                    return "value: string expected";
            return null;
        };

        /**
         * Creates a PayloadRequestDecodeHeader message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof errors.PayloadRequestDecodeHeader
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {errors.PayloadRequestDecodeHeader} PayloadRequestDecodeHeader
         */
        PayloadRequestDecodeHeader.fromObject = function fromObject(object) {
            if (object instanceof $root.errors.PayloadRequestDecodeHeader)
                return object;
            var message = new $root.errors.PayloadRequestDecodeHeader();
            if (object.name != null)
                message.name = String(object.name);
            if (object.value != null)
                message.value = String(object.value);
            return message;
        };

        /**
         * Creates a plain object from a PayloadRequestDecodeHeader message. Also converts values to other types if specified.
         * @function toObject
         * @memberof errors.PayloadRequestDecodeHeader
         * @static
         * @param {errors.PayloadRequestDecodeHeader} message PayloadRequestDecodeHeader
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PayloadRequestDecodeHeader.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.name = "";
                object.value = "";
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = message.value;
            return object;
        };

        /**
         * Converts this PayloadRequestDecodeHeader to JSON.
         * @function toJSON
         * @memberof errors.PayloadRequestDecodeHeader
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PayloadRequestDecodeHeader.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PayloadRequestDecodeHeader;
    })();

    errors.PayloadRequestBadRequest = (function() {

        /**
         * Properties of a PayloadRequestBadRequest.
         * @memberof errors
         * @interface IPayloadRequestBadRequest
         * @property {string|null} [hint] PayloadRequestBadRequest hint
         */

        /**
         * Constructs a new PayloadRequestBadRequest.
         * @memberof errors
         * @classdesc Represents a PayloadRequestBadRequest.
         * @implements IPayloadRequestBadRequest
         * @constructor
         * @param {errors.IPayloadRequestBadRequest=} [properties] Properties to set
         */
        function PayloadRequestBadRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PayloadRequestBadRequest hint.
         * @member {string} hint
         * @memberof errors.PayloadRequestBadRequest
         * @instance
         */
        PayloadRequestBadRequest.prototype.hint = "";

        /**
         * Creates a new PayloadRequestBadRequest instance using the specified properties.
         * @function create
         * @memberof errors.PayloadRequestBadRequest
         * @static
         * @param {errors.IPayloadRequestBadRequest=} [properties] Properties to set
         * @returns {errors.PayloadRequestBadRequest} PayloadRequestBadRequest instance
         */
        PayloadRequestBadRequest.create = function create(properties) {
            return new PayloadRequestBadRequest(properties);
        };

        /**
         * Encodes the specified PayloadRequestBadRequest message. Does not implicitly {@link errors.PayloadRequestBadRequest.verify|verify} messages.
         * @function encode
         * @memberof errors.PayloadRequestBadRequest
         * @static
         * @param {errors.IPayloadRequestBadRequest} message PayloadRequestBadRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadRequestBadRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.hint != null && message.hasOwnProperty("hint"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.hint);
            return writer;
        };

        /**
         * Encodes the specified PayloadRequestBadRequest message, length delimited. Does not implicitly {@link errors.PayloadRequestBadRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof errors.PayloadRequestBadRequest
         * @static
         * @param {errors.IPayloadRequestBadRequest} message PayloadRequestBadRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadRequestBadRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PayloadRequestBadRequest message from the specified reader or buffer.
         * @function decode
         * @memberof errors.PayloadRequestBadRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {errors.PayloadRequestBadRequest} PayloadRequestBadRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadRequestBadRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.errors.PayloadRequestBadRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.hint = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PayloadRequestBadRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof errors.PayloadRequestBadRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {errors.PayloadRequestBadRequest} PayloadRequestBadRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadRequestBadRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PayloadRequestBadRequest message.
         * @function verify
         * @memberof errors.PayloadRequestBadRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PayloadRequestBadRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.hint != null && message.hasOwnProperty("hint"))
                if (!$util.isString(message.hint))
                    return "hint: string expected";
            return null;
        };

        /**
         * Creates a PayloadRequestBadRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof errors.PayloadRequestBadRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {errors.PayloadRequestBadRequest} PayloadRequestBadRequest
         */
        PayloadRequestBadRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.errors.PayloadRequestBadRequest)
                return object;
            var message = new $root.errors.PayloadRequestBadRequest();
            if (object.hint != null)
                message.hint = String(object.hint);
            return message;
        };

        /**
         * Creates a plain object from a PayloadRequestBadRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof errors.PayloadRequestBadRequest
         * @static
         * @param {errors.PayloadRequestBadRequest} message PayloadRequestBadRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PayloadRequestBadRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.hint = "";
            if (message.hint != null && message.hasOwnProperty("hint"))
                object.hint = message.hint;
            return object;
        };

        /**
         * Converts this PayloadRequestBadRequest to JSON.
         * @function toJSON
         * @memberof errors.PayloadRequestBadRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PayloadRequestBadRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PayloadRequestBadRequest;
    })();

    errors.PayloadIdentityCannotAssumeOwnership = (function() {

        /**
         * Properties of a PayloadIdentityCannotAssumeOwnership.
         * @memberof errors
         * @interface IPayloadIdentityCannotAssumeOwnership
         * @property {string|null} [owner] PayloadIdentityCannotAssumeOwnership owner
         */

        /**
         * Constructs a new PayloadIdentityCannotAssumeOwnership.
         * @memberof errors
         * @classdesc Represents a PayloadIdentityCannotAssumeOwnership.
         * @implements IPayloadIdentityCannotAssumeOwnership
         * @constructor
         * @param {errors.IPayloadIdentityCannotAssumeOwnership=} [properties] Properties to set
         */
        function PayloadIdentityCannotAssumeOwnership(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PayloadIdentityCannotAssumeOwnership owner.
         * @member {string} owner
         * @memberof errors.PayloadIdentityCannotAssumeOwnership
         * @instance
         */
        PayloadIdentityCannotAssumeOwnership.prototype.owner = "";

        /**
         * Creates a new PayloadIdentityCannotAssumeOwnership instance using the specified properties.
         * @function create
         * @memberof errors.PayloadIdentityCannotAssumeOwnership
         * @static
         * @param {errors.IPayloadIdentityCannotAssumeOwnership=} [properties] Properties to set
         * @returns {errors.PayloadIdentityCannotAssumeOwnership} PayloadIdentityCannotAssumeOwnership instance
         */
        PayloadIdentityCannotAssumeOwnership.create = function create(properties) {
            return new PayloadIdentityCannotAssumeOwnership(properties);
        };

        /**
         * Encodes the specified PayloadIdentityCannotAssumeOwnership message. Does not implicitly {@link errors.PayloadIdentityCannotAssumeOwnership.verify|verify} messages.
         * @function encode
         * @memberof errors.PayloadIdentityCannotAssumeOwnership
         * @static
         * @param {errors.IPayloadIdentityCannotAssumeOwnership} message PayloadIdentityCannotAssumeOwnership message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadIdentityCannotAssumeOwnership.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.owner != null && message.hasOwnProperty("owner"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.owner);
            return writer;
        };

        /**
         * Encodes the specified PayloadIdentityCannotAssumeOwnership message, length delimited. Does not implicitly {@link errors.PayloadIdentityCannotAssumeOwnership.verify|verify} messages.
         * @function encodeDelimited
         * @memberof errors.PayloadIdentityCannotAssumeOwnership
         * @static
         * @param {errors.IPayloadIdentityCannotAssumeOwnership} message PayloadIdentityCannotAssumeOwnership message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadIdentityCannotAssumeOwnership.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PayloadIdentityCannotAssumeOwnership message from the specified reader or buffer.
         * @function decode
         * @memberof errors.PayloadIdentityCannotAssumeOwnership
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {errors.PayloadIdentityCannotAssumeOwnership} PayloadIdentityCannotAssumeOwnership
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadIdentityCannotAssumeOwnership.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.errors.PayloadIdentityCannotAssumeOwnership();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.owner = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PayloadIdentityCannotAssumeOwnership message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof errors.PayloadIdentityCannotAssumeOwnership
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {errors.PayloadIdentityCannotAssumeOwnership} PayloadIdentityCannotAssumeOwnership
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadIdentityCannotAssumeOwnership.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PayloadIdentityCannotAssumeOwnership message.
         * @function verify
         * @memberof errors.PayloadIdentityCannotAssumeOwnership
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PayloadIdentityCannotAssumeOwnership.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.owner != null && message.hasOwnProperty("owner"))
                if (!$util.isString(message.owner))
                    return "owner: string expected";
            return null;
        };

        /**
         * Creates a PayloadIdentityCannotAssumeOwnership message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof errors.PayloadIdentityCannotAssumeOwnership
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {errors.PayloadIdentityCannotAssumeOwnership} PayloadIdentityCannotAssumeOwnership
         */
        PayloadIdentityCannotAssumeOwnership.fromObject = function fromObject(object) {
            if (object instanceof $root.errors.PayloadIdentityCannotAssumeOwnership)
                return object;
            var message = new $root.errors.PayloadIdentityCannotAssumeOwnership();
            if (object.owner != null)
                message.owner = String(object.owner);
            return message;
        };

        /**
         * Creates a plain object from a PayloadIdentityCannotAssumeOwnership message. Also converts values to other types if specified.
         * @function toObject
         * @memberof errors.PayloadIdentityCannotAssumeOwnership
         * @static
         * @param {errors.PayloadIdentityCannotAssumeOwnership} message PayloadIdentityCannotAssumeOwnership
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PayloadIdentityCannotAssumeOwnership.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.owner = "";
            if (message.owner != null && message.hasOwnProperty("owner"))
                object.owner = message.owner;
            return object;
        };

        /**
         * Converts this PayloadIdentityCannotAssumeOwnership to JSON.
         * @function toJSON
         * @memberof errors.PayloadIdentityCannotAssumeOwnership
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PayloadIdentityCannotAssumeOwnership.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PayloadIdentityCannotAssumeOwnership;
    })();

    errors.PayloadIdentityCannotAssumeAccess = (function() {

        /**
         * Properties of a PayloadIdentityCannotAssumeAccess.
         * @memberof errors
         * @interface IPayloadIdentityCannotAssumeAccess
         * @property {types.IdentityAccessKeyKind|null} [kind] PayloadIdentityCannotAssumeAccess kind
         */

        /**
         * Constructs a new PayloadIdentityCannotAssumeAccess.
         * @memberof errors
         * @classdesc Represents a PayloadIdentityCannotAssumeAccess.
         * @implements IPayloadIdentityCannotAssumeAccess
         * @constructor
         * @param {errors.IPayloadIdentityCannotAssumeAccess=} [properties] Properties to set
         */
        function PayloadIdentityCannotAssumeAccess(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PayloadIdentityCannotAssumeAccess kind.
         * @member {types.IdentityAccessKeyKind} kind
         * @memberof errors.PayloadIdentityCannotAssumeAccess
         * @instance
         */
        PayloadIdentityCannotAssumeAccess.prototype.kind = 0;

        /**
         * Creates a new PayloadIdentityCannotAssumeAccess instance using the specified properties.
         * @function create
         * @memberof errors.PayloadIdentityCannotAssumeAccess
         * @static
         * @param {errors.IPayloadIdentityCannotAssumeAccess=} [properties] Properties to set
         * @returns {errors.PayloadIdentityCannotAssumeAccess} PayloadIdentityCannotAssumeAccess instance
         */
        PayloadIdentityCannotAssumeAccess.create = function create(properties) {
            return new PayloadIdentityCannotAssumeAccess(properties);
        };

        /**
         * Encodes the specified PayloadIdentityCannotAssumeAccess message. Does not implicitly {@link errors.PayloadIdentityCannotAssumeAccess.verify|verify} messages.
         * @function encode
         * @memberof errors.PayloadIdentityCannotAssumeAccess
         * @static
         * @param {errors.IPayloadIdentityCannotAssumeAccess} message PayloadIdentityCannotAssumeAccess message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadIdentityCannotAssumeAccess.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.kind != null && message.hasOwnProperty("kind"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.kind);
            return writer;
        };

        /**
         * Encodes the specified PayloadIdentityCannotAssumeAccess message, length delimited. Does not implicitly {@link errors.PayloadIdentityCannotAssumeAccess.verify|verify} messages.
         * @function encodeDelimited
         * @memberof errors.PayloadIdentityCannotAssumeAccess
         * @static
         * @param {errors.IPayloadIdentityCannotAssumeAccess} message PayloadIdentityCannotAssumeAccess message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadIdentityCannotAssumeAccess.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PayloadIdentityCannotAssumeAccess message from the specified reader or buffer.
         * @function decode
         * @memberof errors.PayloadIdentityCannotAssumeAccess
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {errors.PayloadIdentityCannotAssumeAccess} PayloadIdentityCannotAssumeAccess
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadIdentityCannotAssumeAccess.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.errors.PayloadIdentityCannotAssumeAccess();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.kind = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PayloadIdentityCannotAssumeAccess message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof errors.PayloadIdentityCannotAssumeAccess
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {errors.PayloadIdentityCannotAssumeAccess} PayloadIdentityCannotAssumeAccess
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadIdentityCannotAssumeAccess.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PayloadIdentityCannotAssumeAccess message.
         * @function verify
         * @memberof errors.PayloadIdentityCannotAssumeAccess
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PayloadIdentityCannotAssumeAccess.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.kind != null && message.hasOwnProperty("kind"))
                switch (message.kind) {
                default:
                    return "kind: enum value expected";
                case 0:
                case 1:
                    break;
                }
            return null;
        };

        /**
         * Creates a PayloadIdentityCannotAssumeAccess message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof errors.PayloadIdentityCannotAssumeAccess
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {errors.PayloadIdentityCannotAssumeAccess} PayloadIdentityCannotAssumeAccess
         */
        PayloadIdentityCannotAssumeAccess.fromObject = function fromObject(object) {
            if (object instanceof $root.errors.PayloadIdentityCannotAssumeAccess)
                return object;
            var message = new $root.errors.PayloadIdentityCannotAssumeAccess();
            switch (object.kind) {
            case "READ":
            case 0:
                message.kind = 0;
                break;
            case "WRITE":
            case 1:
                message.kind = 1;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a PayloadIdentityCannotAssumeAccess message. Also converts values to other types if specified.
         * @function toObject
         * @memberof errors.PayloadIdentityCannotAssumeAccess
         * @static
         * @param {errors.PayloadIdentityCannotAssumeAccess} message PayloadIdentityCannotAssumeAccess
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PayloadIdentityCannotAssumeAccess.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.kind = options.enums === String ? "READ" : 0;
            if (message.kind != null && message.hasOwnProperty("kind"))
                object.kind = options.enums === String ? $root.types.IdentityAccessKeyKind[message.kind] : message.kind;
            return object;
        };

        /**
         * Converts this PayloadIdentityCannotAssumeAccess to JSON.
         * @function toJSON
         * @memberof errors.PayloadIdentityCannotAssumeAccess
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PayloadIdentityCannotAssumeAccess.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PayloadIdentityCannotAssumeAccess;
    })();

    errors.PayloadIdentitySignatureMismatch = (function() {

        /**
         * Properties of a PayloadIdentitySignatureMismatch.
         * @memberof errors
         * @interface IPayloadIdentitySignatureMismatch
         * @property {types.IIdentityKeyID|null} [key] PayloadIdentitySignatureMismatch key
         */

        /**
         * Constructs a new PayloadIdentitySignatureMismatch.
         * @memberof errors
         * @classdesc Represents a PayloadIdentitySignatureMismatch.
         * @implements IPayloadIdentitySignatureMismatch
         * @constructor
         * @param {errors.IPayloadIdentitySignatureMismatch=} [properties] Properties to set
         */
        function PayloadIdentitySignatureMismatch(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PayloadIdentitySignatureMismatch key.
         * @member {types.IIdentityKeyID|null|undefined} key
         * @memberof errors.PayloadIdentitySignatureMismatch
         * @instance
         */
        PayloadIdentitySignatureMismatch.prototype.key = null;

        /**
         * Creates a new PayloadIdentitySignatureMismatch instance using the specified properties.
         * @function create
         * @memberof errors.PayloadIdentitySignatureMismatch
         * @static
         * @param {errors.IPayloadIdentitySignatureMismatch=} [properties] Properties to set
         * @returns {errors.PayloadIdentitySignatureMismatch} PayloadIdentitySignatureMismatch instance
         */
        PayloadIdentitySignatureMismatch.create = function create(properties) {
            return new PayloadIdentitySignatureMismatch(properties);
        };

        /**
         * Encodes the specified PayloadIdentitySignatureMismatch message. Does not implicitly {@link errors.PayloadIdentitySignatureMismatch.verify|verify} messages.
         * @function encode
         * @memberof errors.PayloadIdentitySignatureMismatch
         * @static
         * @param {errors.IPayloadIdentitySignatureMismatch} message PayloadIdentitySignatureMismatch message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadIdentitySignatureMismatch.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.key != null && message.hasOwnProperty("key"))
                $root.types.IdentityKeyID.encode(message.key, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified PayloadIdentitySignatureMismatch message, length delimited. Does not implicitly {@link errors.PayloadIdentitySignatureMismatch.verify|verify} messages.
         * @function encodeDelimited
         * @memberof errors.PayloadIdentitySignatureMismatch
         * @static
         * @param {errors.IPayloadIdentitySignatureMismatch} message PayloadIdentitySignatureMismatch message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadIdentitySignatureMismatch.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PayloadIdentitySignatureMismatch message from the specified reader or buffer.
         * @function decode
         * @memberof errors.PayloadIdentitySignatureMismatch
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {errors.PayloadIdentitySignatureMismatch} PayloadIdentitySignatureMismatch
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadIdentitySignatureMismatch.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.errors.PayloadIdentitySignatureMismatch();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.key = $root.types.IdentityKeyID.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PayloadIdentitySignatureMismatch message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof errors.PayloadIdentitySignatureMismatch
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {errors.PayloadIdentitySignatureMismatch} PayloadIdentitySignatureMismatch
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadIdentitySignatureMismatch.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PayloadIdentitySignatureMismatch message.
         * @function verify
         * @memberof errors.PayloadIdentitySignatureMismatch
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PayloadIdentitySignatureMismatch.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.key != null && message.hasOwnProperty("key")) {
                var error = $root.types.IdentityKeyID.verify(message.key);
                if (error)
                    return "key." + error;
            }
            return null;
        };

        /**
         * Creates a PayloadIdentitySignatureMismatch message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof errors.PayloadIdentitySignatureMismatch
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {errors.PayloadIdentitySignatureMismatch} PayloadIdentitySignatureMismatch
         */
        PayloadIdentitySignatureMismatch.fromObject = function fromObject(object) {
            if (object instanceof $root.errors.PayloadIdentitySignatureMismatch)
                return object;
            var message = new $root.errors.PayloadIdentitySignatureMismatch();
            if (object.key != null) {
                if (typeof object.key !== "object")
                    throw TypeError(".errors.PayloadIdentitySignatureMismatch.key: object expected");
                message.key = $root.types.IdentityKeyID.fromObject(object.key);
            }
            return message;
        };

        /**
         * Creates a plain object from a PayloadIdentitySignatureMismatch message. Also converts values to other types if specified.
         * @function toObject
         * @memberof errors.PayloadIdentitySignatureMismatch
         * @static
         * @param {errors.PayloadIdentitySignatureMismatch} message PayloadIdentitySignatureMismatch
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PayloadIdentitySignatureMismatch.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.key = null;
            if (message.key != null && message.hasOwnProperty("key"))
                object.key = $root.types.IdentityKeyID.toObject(message.key, options);
            return object;
        };

        /**
         * Converts this PayloadIdentitySignatureMismatch to JSON.
         * @function toJSON
         * @memberof errors.PayloadIdentitySignatureMismatch
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PayloadIdentitySignatureMismatch.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PayloadIdentitySignatureMismatch;
    })();

    errors.PayloadIdentityInvalidLogin = (function() {

        /**
         * Properties of a PayloadIdentityInvalidLogin.
         * @memberof errors
         * @interface IPayloadIdentityInvalidLogin
         * @property {string|null} [login] PayloadIdentityInvalidLogin login
         */

        /**
         * Constructs a new PayloadIdentityInvalidLogin.
         * @memberof errors
         * @classdesc Represents a PayloadIdentityInvalidLogin.
         * @implements IPayloadIdentityInvalidLogin
         * @constructor
         * @param {errors.IPayloadIdentityInvalidLogin=} [properties] Properties to set
         */
        function PayloadIdentityInvalidLogin(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PayloadIdentityInvalidLogin login.
         * @member {string} login
         * @memberof errors.PayloadIdentityInvalidLogin
         * @instance
         */
        PayloadIdentityInvalidLogin.prototype.login = "";

        /**
         * Creates a new PayloadIdentityInvalidLogin instance using the specified properties.
         * @function create
         * @memberof errors.PayloadIdentityInvalidLogin
         * @static
         * @param {errors.IPayloadIdentityInvalidLogin=} [properties] Properties to set
         * @returns {errors.PayloadIdentityInvalidLogin} PayloadIdentityInvalidLogin instance
         */
        PayloadIdentityInvalidLogin.create = function create(properties) {
            return new PayloadIdentityInvalidLogin(properties);
        };

        /**
         * Encodes the specified PayloadIdentityInvalidLogin message. Does not implicitly {@link errors.PayloadIdentityInvalidLogin.verify|verify} messages.
         * @function encode
         * @memberof errors.PayloadIdentityInvalidLogin
         * @static
         * @param {errors.IPayloadIdentityInvalidLogin} message PayloadIdentityInvalidLogin message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadIdentityInvalidLogin.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            return writer;
        };

        /**
         * Encodes the specified PayloadIdentityInvalidLogin message, length delimited. Does not implicitly {@link errors.PayloadIdentityInvalidLogin.verify|verify} messages.
         * @function encodeDelimited
         * @memberof errors.PayloadIdentityInvalidLogin
         * @static
         * @param {errors.IPayloadIdentityInvalidLogin} message PayloadIdentityInvalidLogin message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadIdentityInvalidLogin.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PayloadIdentityInvalidLogin message from the specified reader or buffer.
         * @function decode
         * @memberof errors.PayloadIdentityInvalidLogin
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {errors.PayloadIdentityInvalidLogin} PayloadIdentityInvalidLogin
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadIdentityInvalidLogin.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.errors.PayloadIdentityInvalidLogin();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PayloadIdentityInvalidLogin message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof errors.PayloadIdentityInvalidLogin
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {errors.PayloadIdentityInvalidLogin} PayloadIdentityInvalidLogin
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadIdentityInvalidLogin.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PayloadIdentityInvalidLogin message.
         * @function verify
         * @memberof errors.PayloadIdentityInvalidLogin
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PayloadIdentityInvalidLogin.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            return null;
        };

        /**
         * Creates a PayloadIdentityInvalidLogin message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof errors.PayloadIdentityInvalidLogin
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {errors.PayloadIdentityInvalidLogin} PayloadIdentityInvalidLogin
         */
        PayloadIdentityInvalidLogin.fromObject = function fromObject(object) {
            if (object instanceof $root.errors.PayloadIdentityInvalidLogin)
                return object;
            var message = new $root.errors.PayloadIdentityInvalidLogin();
            if (object.login != null)
                message.login = String(object.login);
            return message;
        };

        /**
         * Creates a plain object from a PayloadIdentityInvalidLogin message. Also converts values to other types if specified.
         * @function toObject
         * @memberof errors.PayloadIdentityInvalidLogin
         * @static
         * @param {errors.PayloadIdentityInvalidLogin} message PayloadIdentityInvalidLogin
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PayloadIdentityInvalidLogin.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.login = "";
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            return object;
        };

        /**
         * Converts this PayloadIdentityInvalidLogin to JSON.
         * @function toJSON
         * @memberof errors.PayloadIdentityInvalidLogin
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PayloadIdentityInvalidLogin.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PayloadIdentityInvalidLogin;
    })();

    errors.PayloadIdentityAlreadyExists = (function() {

        /**
         * Properties of a PayloadIdentityAlreadyExists.
         * @memberof errors
         * @interface IPayloadIdentityAlreadyExists
         * @property {string|null} [login] PayloadIdentityAlreadyExists login
         */

        /**
         * Constructs a new PayloadIdentityAlreadyExists.
         * @memberof errors
         * @classdesc Represents a PayloadIdentityAlreadyExists.
         * @implements IPayloadIdentityAlreadyExists
         * @constructor
         * @param {errors.IPayloadIdentityAlreadyExists=} [properties] Properties to set
         */
        function PayloadIdentityAlreadyExists(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PayloadIdentityAlreadyExists login.
         * @member {string} login
         * @memberof errors.PayloadIdentityAlreadyExists
         * @instance
         */
        PayloadIdentityAlreadyExists.prototype.login = "";

        /**
         * Creates a new PayloadIdentityAlreadyExists instance using the specified properties.
         * @function create
         * @memberof errors.PayloadIdentityAlreadyExists
         * @static
         * @param {errors.IPayloadIdentityAlreadyExists=} [properties] Properties to set
         * @returns {errors.PayloadIdentityAlreadyExists} PayloadIdentityAlreadyExists instance
         */
        PayloadIdentityAlreadyExists.create = function create(properties) {
            return new PayloadIdentityAlreadyExists(properties);
        };

        /**
         * Encodes the specified PayloadIdentityAlreadyExists message. Does not implicitly {@link errors.PayloadIdentityAlreadyExists.verify|verify} messages.
         * @function encode
         * @memberof errors.PayloadIdentityAlreadyExists
         * @static
         * @param {errors.IPayloadIdentityAlreadyExists} message PayloadIdentityAlreadyExists message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadIdentityAlreadyExists.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            return writer;
        };

        /**
         * Encodes the specified PayloadIdentityAlreadyExists message, length delimited. Does not implicitly {@link errors.PayloadIdentityAlreadyExists.verify|verify} messages.
         * @function encodeDelimited
         * @memberof errors.PayloadIdentityAlreadyExists
         * @static
         * @param {errors.IPayloadIdentityAlreadyExists} message PayloadIdentityAlreadyExists message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadIdentityAlreadyExists.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PayloadIdentityAlreadyExists message from the specified reader or buffer.
         * @function decode
         * @memberof errors.PayloadIdentityAlreadyExists
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {errors.PayloadIdentityAlreadyExists} PayloadIdentityAlreadyExists
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadIdentityAlreadyExists.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.errors.PayloadIdentityAlreadyExists();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PayloadIdentityAlreadyExists message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof errors.PayloadIdentityAlreadyExists
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {errors.PayloadIdentityAlreadyExists} PayloadIdentityAlreadyExists
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadIdentityAlreadyExists.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PayloadIdentityAlreadyExists message.
         * @function verify
         * @memberof errors.PayloadIdentityAlreadyExists
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PayloadIdentityAlreadyExists.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            return null;
        };

        /**
         * Creates a PayloadIdentityAlreadyExists message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof errors.PayloadIdentityAlreadyExists
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {errors.PayloadIdentityAlreadyExists} PayloadIdentityAlreadyExists
         */
        PayloadIdentityAlreadyExists.fromObject = function fromObject(object) {
            if (object instanceof $root.errors.PayloadIdentityAlreadyExists)
                return object;
            var message = new $root.errors.PayloadIdentityAlreadyExists();
            if (object.login != null)
                message.login = String(object.login);
            return message;
        };

        /**
         * Creates a plain object from a PayloadIdentityAlreadyExists message. Also converts values to other types if specified.
         * @function toObject
         * @memberof errors.PayloadIdentityAlreadyExists
         * @static
         * @param {errors.PayloadIdentityAlreadyExists} message PayloadIdentityAlreadyExists
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PayloadIdentityAlreadyExists.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.login = "";
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            return object;
        };

        /**
         * Converts this PayloadIdentityAlreadyExists to JSON.
         * @function toJSON
         * @memberof errors.PayloadIdentityAlreadyExists
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PayloadIdentityAlreadyExists.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PayloadIdentityAlreadyExists;
    })();

    errors.PayloadIdentityNotFound = (function() {

        /**
         * Properties of a PayloadIdentityNotFound.
         * @memberof errors
         * @interface IPayloadIdentityNotFound
         * @property {string|null} [login] PayloadIdentityNotFound login
         */

        /**
         * Constructs a new PayloadIdentityNotFound.
         * @memberof errors
         * @classdesc Represents a PayloadIdentityNotFound.
         * @implements IPayloadIdentityNotFound
         * @constructor
         * @param {errors.IPayloadIdentityNotFound=} [properties] Properties to set
         */
        function PayloadIdentityNotFound(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PayloadIdentityNotFound login.
         * @member {string} login
         * @memberof errors.PayloadIdentityNotFound
         * @instance
         */
        PayloadIdentityNotFound.prototype.login = "";

        /**
         * Creates a new PayloadIdentityNotFound instance using the specified properties.
         * @function create
         * @memberof errors.PayloadIdentityNotFound
         * @static
         * @param {errors.IPayloadIdentityNotFound=} [properties] Properties to set
         * @returns {errors.PayloadIdentityNotFound} PayloadIdentityNotFound instance
         */
        PayloadIdentityNotFound.create = function create(properties) {
            return new PayloadIdentityNotFound(properties);
        };

        /**
         * Encodes the specified PayloadIdentityNotFound message. Does not implicitly {@link errors.PayloadIdentityNotFound.verify|verify} messages.
         * @function encode
         * @memberof errors.PayloadIdentityNotFound
         * @static
         * @param {errors.IPayloadIdentityNotFound} message PayloadIdentityNotFound message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadIdentityNotFound.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            return writer;
        };

        /**
         * Encodes the specified PayloadIdentityNotFound message, length delimited. Does not implicitly {@link errors.PayloadIdentityNotFound.verify|verify} messages.
         * @function encodeDelimited
         * @memberof errors.PayloadIdentityNotFound
         * @static
         * @param {errors.IPayloadIdentityNotFound} message PayloadIdentityNotFound message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadIdentityNotFound.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PayloadIdentityNotFound message from the specified reader or buffer.
         * @function decode
         * @memberof errors.PayloadIdentityNotFound
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {errors.PayloadIdentityNotFound} PayloadIdentityNotFound
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadIdentityNotFound.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.errors.PayloadIdentityNotFound();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PayloadIdentityNotFound message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof errors.PayloadIdentityNotFound
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {errors.PayloadIdentityNotFound} PayloadIdentityNotFound
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadIdentityNotFound.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PayloadIdentityNotFound message.
         * @function verify
         * @memberof errors.PayloadIdentityNotFound
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PayloadIdentityNotFound.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            return null;
        };

        /**
         * Creates a PayloadIdentityNotFound message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof errors.PayloadIdentityNotFound
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {errors.PayloadIdentityNotFound} PayloadIdentityNotFound
         */
        PayloadIdentityNotFound.fromObject = function fromObject(object) {
            if (object instanceof $root.errors.PayloadIdentityNotFound)
                return object;
            var message = new $root.errors.PayloadIdentityNotFound();
            if (object.login != null)
                message.login = String(object.login);
            return message;
        };

        /**
         * Creates a plain object from a PayloadIdentityNotFound message. Also converts values to other types if specified.
         * @function toObject
         * @memberof errors.PayloadIdentityNotFound
         * @static
         * @param {errors.PayloadIdentityNotFound} message PayloadIdentityNotFound
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PayloadIdentityNotFound.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.login = "";
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            return object;
        };

        /**
         * Converts this PayloadIdentityNotFound to JSON.
         * @function toJSON
         * @memberof errors.PayloadIdentityNotFound
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PayloadIdentityNotFound.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PayloadIdentityNotFound;
    })();

    errors.PayloadIdentityVersionMismatch = (function() {

        /**
         * Properties of a PayloadIdentityVersionMismatch.
         * @memberof errors
         * @interface IPayloadIdentityVersionMismatch
         * @property {types.IIdentityKeyID|null} [key] PayloadIdentityVersionMismatch key
         * @property {number|null} [expected] PayloadIdentityVersionMismatch expected
         */

        /**
         * Constructs a new PayloadIdentityVersionMismatch.
         * @memberof errors
         * @classdesc Represents a PayloadIdentityVersionMismatch.
         * @implements IPayloadIdentityVersionMismatch
         * @constructor
         * @param {errors.IPayloadIdentityVersionMismatch=} [properties] Properties to set
         */
        function PayloadIdentityVersionMismatch(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PayloadIdentityVersionMismatch key.
         * @member {types.IIdentityKeyID|null|undefined} key
         * @memberof errors.PayloadIdentityVersionMismatch
         * @instance
         */
        PayloadIdentityVersionMismatch.prototype.key = null;

        /**
         * PayloadIdentityVersionMismatch expected.
         * @member {number} expected
         * @memberof errors.PayloadIdentityVersionMismatch
         * @instance
         */
        PayloadIdentityVersionMismatch.prototype.expected = 0;

        /**
         * Creates a new PayloadIdentityVersionMismatch instance using the specified properties.
         * @function create
         * @memberof errors.PayloadIdentityVersionMismatch
         * @static
         * @param {errors.IPayloadIdentityVersionMismatch=} [properties] Properties to set
         * @returns {errors.PayloadIdentityVersionMismatch} PayloadIdentityVersionMismatch instance
         */
        PayloadIdentityVersionMismatch.create = function create(properties) {
            return new PayloadIdentityVersionMismatch(properties);
        };

        /**
         * Encodes the specified PayloadIdentityVersionMismatch message. Does not implicitly {@link errors.PayloadIdentityVersionMismatch.verify|verify} messages.
         * @function encode
         * @memberof errors.PayloadIdentityVersionMismatch
         * @static
         * @param {errors.IPayloadIdentityVersionMismatch} message PayloadIdentityVersionMismatch message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadIdentityVersionMismatch.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.key != null && message.hasOwnProperty("key"))
                $root.types.IdentityKeyID.encode(message.key, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.expected != null && message.hasOwnProperty("expected"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.expected);
            return writer;
        };

        /**
         * Encodes the specified PayloadIdentityVersionMismatch message, length delimited. Does not implicitly {@link errors.PayloadIdentityVersionMismatch.verify|verify} messages.
         * @function encodeDelimited
         * @memberof errors.PayloadIdentityVersionMismatch
         * @static
         * @param {errors.IPayloadIdentityVersionMismatch} message PayloadIdentityVersionMismatch message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadIdentityVersionMismatch.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PayloadIdentityVersionMismatch message from the specified reader or buffer.
         * @function decode
         * @memberof errors.PayloadIdentityVersionMismatch
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {errors.PayloadIdentityVersionMismatch} PayloadIdentityVersionMismatch
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadIdentityVersionMismatch.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.errors.PayloadIdentityVersionMismatch();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.key = $root.types.IdentityKeyID.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.expected = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PayloadIdentityVersionMismatch message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof errors.PayloadIdentityVersionMismatch
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {errors.PayloadIdentityVersionMismatch} PayloadIdentityVersionMismatch
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadIdentityVersionMismatch.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PayloadIdentityVersionMismatch message.
         * @function verify
         * @memberof errors.PayloadIdentityVersionMismatch
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PayloadIdentityVersionMismatch.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.key != null && message.hasOwnProperty("key")) {
                var error = $root.types.IdentityKeyID.verify(message.key);
                if (error)
                    return "key." + error;
            }
            if (message.expected != null && message.hasOwnProperty("expected"))
                if (!$util.isInteger(message.expected))
                    return "expected: integer expected";
            return null;
        };

        /**
         * Creates a PayloadIdentityVersionMismatch message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof errors.PayloadIdentityVersionMismatch
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {errors.PayloadIdentityVersionMismatch} PayloadIdentityVersionMismatch
         */
        PayloadIdentityVersionMismatch.fromObject = function fromObject(object) {
            if (object instanceof $root.errors.PayloadIdentityVersionMismatch)
                return object;
            var message = new $root.errors.PayloadIdentityVersionMismatch();
            if (object.key != null) {
                if (typeof object.key !== "object")
                    throw TypeError(".errors.PayloadIdentityVersionMismatch.key: object expected");
                message.key = $root.types.IdentityKeyID.fromObject(object.key);
            }
            if (object.expected != null)
                message.expected = object.expected >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a PayloadIdentityVersionMismatch message. Also converts values to other types if specified.
         * @function toObject
         * @memberof errors.PayloadIdentityVersionMismatch
         * @static
         * @param {errors.PayloadIdentityVersionMismatch} message PayloadIdentityVersionMismatch
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PayloadIdentityVersionMismatch.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.key = null;
                object.expected = 0;
            }
            if (message.key != null && message.hasOwnProperty("key"))
                object.key = $root.types.IdentityKeyID.toObject(message.key, options);
            if (message.expected != null && message.hasOwnProperty("expected"))
                object.expected = message.expected;
            return object;
        };

        /**
         * Converts this PayloadIdentityVersionMismatch to JSON.
         * @function toJSON
         * @memberof errors.PayloadIdentityVersionMismatch
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PayloadIdentityVersionMismatch.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PayloadIdentityVersionMismatch;
    })();

    errors.PayloadIdentityNotAdmin = (function() {

        /**
         * Properties of a PayloadIdentityNotAdmin.
         * @memberof errors
         * @interface IPayloadIdentityNotAdmin
         * @property {string|null} [login] PayloadIdentityNotAdmin login
         */

        /**
         * Constructs a new PayloadIdentityNotAdmin.
         * @memberof errors
         * @classdesc Represents a PayloadIdentityNotAdmin.
         * @implements IPayloadIdentityNotAdmin
         * @constructor
         * @param {errors.IPayloadIdentityNotAdmin=} [properties] Properties to set
         */
        function PayloadIdentityNotAdmin(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PayloadIdentityNotAdmin login.
         * @member {string} login
         * @memberof errors.PayloadIdentityNotAdmin
         * @instance
         */
        PayloadIdentityNotAdmin.prototype.login = "";

        /**
         * Creates a new PayloadIdentityNotAdmin instance using the specified properties.
         * @function create
         * @memberof errors.PayloadIdentityNotAdmin
         * @static
         * @param {errors.IPayloadIdentityNotAdmin=} [properties] Properties to set
         * @returns {errors.PayloadIdentityNotAdmin} PayloadIdentityNotAdmin instance
         */
        PayloadIdentityNotAdmin.create = function create(properties) {
            return new PayloadIdentityNotAdmin(properties);
        };

        /**
         * Encodes the specified PayloadIdentityNotAdmin message. Does not implicitly {@link errors.PayloadIdentityNotAdmin.verify|verify} messages.
         * @function encode
         * @memberof errors.PayloadIdentityNotAdmin
         * @static
         * @param {errors.IPayloadIdentityNotAdmin} message PayloadIdentityNotAdmin message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadIdentityNotAdmin.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            return writer;
        };

        /**
         * Encodes the specified PayloadIdentityNotAdmin message, length delimited. Does not implicitly {@link errors.PayloadIdentityNotAdmin.verify|verify} messages.
         * @function encodeDelimited
         * @memberof errors.PayloadIdentityNotAdmin
         * @static
         * @param {errors.IPayloadIdentityNotAdmin} message PayloadIdentityNotAdmin message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadIdentityNotAdmin.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PayloadIdentityNotAdmin message from the specified reader or buffer.
         * @function decode
         * @memberof errors.PayloadIdentityNotAdmin
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {errors.PayloadIdentityNotAdmin} PayloadIdentityNotAdmin
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadIdentityNotAdmin.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.errors.PayloadIdentityNotAdmin();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PayloadIdentityNotAdmin message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof errors.PayloadIdentityNotAdmin
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {errors.PayloadIdentityNotAdmin} PayloadIdentityNotAdmin
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadIdentityNotAdmin.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PayloadIdentityNotAdmin message.
         * @function verify
         * @memberof errors.PayloadIdentityNotAdmin
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PayloadIdentityNotAdmin.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            return null;
        };

        /**
         * Creates a PayloadIdentityNotAdmin message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof errors.PayloadIdentityNotAdmin
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {errors.PayloadIdentityNotAdmin} PayloadIdentityNotAdmin
         */
        PayloadIdentityNotAdmin.fromObject = function fromObject(object) {
            if (object instanceof $root.errors.PayloadIdentityNotAdmin)
                return object;
            var message = new $root.errors.PayloadIdentityNotAdmin();
            if (object.login != null)
                message.login = String(object.login);
            return message;
        };

        /**
         * Creates a plain object from a PayloadIdentityNotAdmin message. Also converts values to other types if specified.
         * @function toObject
         * @memberof errors.PayloadIdentityNotAdmin
         * @static
         * @param {errors.PayloadIdentityNotAdmin} message PayloadIdentityNotAdmin
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PayloadIdentityNotAdmin.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.login = "";
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            return object;
        };

        /**
         * Converts this PayloadIdentityNotAdmin to JSON.
         * @function toJSON
         * @memberof errors.PayloadIdentityNotAdmin
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PayloadIdentityNotAdmin.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PayloadIdentityNotAdmin;
    })();

    errors.PayloadIdentityNotAdminDomain = (function() {

        /**
         * Properties of a PayloadIdentityNotAdminDomain.
         * @memberof errors
         * @interface IPayloadIdentityNotAdminDomain
         * @property {string|null} [login] PayloadIdentityNotAdminDomain login
         * @property {string|null} [domain] PayloadIdentityNotAdminDomain domain
         */

        /**
         * Constructs a new PayloadIdentityNotAdminDomain.
         * @memberof errors
         * @classdesc Represents a PayloadIdentityNotAdminDomain.
         * @implements IPayloadIdentityNotAdminDomain
         * @constructor
         * @param {errors.IPayloadIdentityNotAdminDomain=} [properties] Properties to set
         */
        function PayloadIdentityNotAdminDomain(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PayloadIdentityNotAdminDomain login.
         * @member {string} login
         * @memberof errors.PayloadIdentityNotAdminDomain
         * @instance
         */
        PayloadIdentityNotAdminDomain.prototype.login = "";

        /**
         * PayloadIdentityNotAdminDomain domain.
         * @member {string} domain
         * @memberof errors.PayloadIdentityNotAdminDomain
         * @instance
         */
        PayloadIdentityNotAdminDomain.prototype.domain = "";

        /**
         * Creates a new PayloadIdentityNotAdminDomain instance using the specified properties.
         * @function create
         * @memberof errors.PayloadIdentityNotAdminDomain
         * @static
         * @param {errors.IPayloadIdentityNotAdminDomain=} [properties] Properties to set
         * @returns {errors.PayloadIdentityNotAdminDomain} PayloadIdentityNotAdminDomain instance
         */
        PayloadIdentityNotAdminDomain.create = function create(properties) {
            return new PayloadIdentityNotAdminDomain(properties);
        };

        /**
         * Encodes the specified PayloadIdentityNotAdminDomain message. Does not implicitly {@link errors.PayloadIdentityNotAdminDomain.verify|verify} messages.
         * @function encode
         * @memberof errors.PayloadIdentityNotAdminDomain
         * @static
         * @param {errors.IPayloadIdentityNotAdminDomain} message PayloadIdentityNotAdminDomain message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadIdentityNotAdminDomain.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            if (message.domain != null && message.hasOwnProperty("domain"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.domain);
            return writer;
        };

        /**
         * Encodes the specified PayloadIdentityNotAdminDomain message, length delimited. Does not implicitly {@link errors.PayloadIdentityNotAdminDomain.verify|verify} messages.
         * @function encodeDelimited
         * @memberof errors.PayloadIdentityNotAdminDomain
         * @static
         * @param {errors.IPayloadIdentityNotAdminDomain} message PayloadIdentityNotAdminDomain message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadIdentityNotAdminDomain.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PayloadIdentityNotAdminDomain message from the specified reader or buffer.
         * @function decode
         * @memberof errors.PayloadIdentityNotAdminDomain
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {errors.PayloadIdentityNotAdminDomain} PayloadIdentityNotAdminDomain
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadIdentityNotAdminDomain.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.errors.PayloadIdentityNotAdminDomain();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                case 2:
                    message.domain = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PayloadIdentityNotAdminDomain message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof errors.PayloadIdentityNotAdminDomain
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {errors.PayloadIdentityNotAdminDomain} PayloadIdentityNotAdminDomain
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadIdentityNotAdminDomain.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PayloadIdentityNotAdminDomain message.
         * @function verify
         * @memberof errors.PayloadIdentityNotAdminDomain
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PayloadIdentityNotAdminDomain.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            if (message.domain != null && message.hasOwnProperty("domain"))
                if (!$util.isString(message.domain))
                    return "domain: string expected";
            return null;
        };

        /**
         * Creates a PayloadIdentityNotAdminDomain message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof errors.PayloadIdentityNotAdminDomain
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {errors.PayloadIdentityNotAdminDomain} PayloadIdentityNotAdminDomain
         */
        PayloadIdentityNotAdminDomain.fromObject = function fromObject(object) {
            if (object instanceof $root.errors.PayloadIdentityNotAdminDomain)
                return object;
            var message = new $root.errors.PayloadIdentityNotAdminDomain();
            if (object.login != null)
                message.login = String(object.login);
            if (object.domain != null)
                message.domain = String(object.domain);
            return message;
        };

        /**
         * Creates a plain object from a PayloadIdentityNotAdminDomain message. Also converts values to other types if specified.
         * @function toObject
         * @memberof errors.PayloadIdentityNotAdminDomain
         * @static
         * @param {errors.PayloadIdentityNotAdminDomain} message PayloadIdentityNotAdminDomain
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PayloadIdentityNotAdminDomain.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.login = "";
                object.domain = "";
            }
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            if (message.domain != null && message.hasOwnProperty("domain"))
                object.domain = message.domain;
            return object;
        };

        /**
         * Converts this PayloadIdentityNotAdminDomain to JSON.
         * @function toJSON
         * @memberof errors.PayloadIdentityNotAdminDomain
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PayloadIdentityNotAdminDomain.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PayloadIdentityNotAdminDomain;
    })();

    errors.PayloadResourceNotFound = (function() {

        /**
         * Properties of a PayloadResourceNotFound.
         * @memberof errors
         * @interface IPayloadResourceNotFound
         * @property {number|Long|null} [id] PayloadResourceNotFound id
         */

        /**
         * Constructs a new PayloadResourceNotFound.
         * @memberof errors
         * @classdesc Represents a PayloadResourceNotFound.
         * @implements IPayloadResourceNotFound
         * @constructor
         * @param {errors.IPayloadResourceNotFound=} [properties] Properties to set
         */
        function PayloadResourceNotFound(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PayloadResourceNotFound id.
         * @member {number|Long} id
         * @memberof errors.PayloadResourceNotFound
         * @instance
         */
        PayloadResourceNotFound.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new PayloadResourceNotFound instance using the specified properties.
         * @function create
         * @memberof errors.PayloadResourceNotFound
         * @static
         * @param {errors.IPayloadResourceNotFound=} [properties] Properties to set
         * @returns {errors.PayloadResourceNotFound} PayloadResourceNotFound instance
         */
        PayloadResourceNotFound.create = function create(properties) {
            return new PayloadResourceNotFound(properties);
        };

        /**
         * Encodes the specified PayloadResourceNotFound message. Does not implicitly {@link errors.PayloadResourceNotFound.verify|verify} messages.
         * @function encode
         * @memberof errors.PayloadResourceNotFound
         * @static
         * @param {errors.IPayloadResourceNotFound} message PayloadResourceNotFound message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadResourceNotFound.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
            return writer;
        };

        /**
         * Encodes the specified PayloadResourceNotFound message, length delimited. Does not implicitly {@link errors.PayloadResourceNotFound.verify|verify} messages.
         * @function encodeDelimited
         * @memberof errors.PayloadResourceNotFound
         * @static
         * @param {errors.IPayloadResourceNotFound} message PayloadResourceNotFound message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadResourceNotFound.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PayloadResourceNotFound message from the specified reader or buffer.
         * @function decode
         * @memberof errors.PayloadResourceNotFound
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {errors.PayloadResourceNotFound} PayloadResourceNotFound
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadResourceNotFound.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.errors.PayloadResourceNotFound();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PayloadResourceNotFound message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof errors.PayloadResourceNotFound
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {errors.PayloadResourceNotFound} PayloadResourceNotFound
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadResourceNotFound.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PayloadResourceNotFound message.
         * @function verify
         * @memberof errors.PayloadResourceNotFound
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PayloadResourceNotFound.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                    return "id: integer|Long expected";
            return null;
        };

        /**
         * Creates a PayloadResourceNotFound message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof errors.PayloadResourceNotFound
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {errors.PayloadResourceNotFound} PayloadResourceNotFound
         */
        PayloadResourceNotFound.fromObject = function fromObject(object) {
            if (object instanceof $root.errors.PayloadResourceNotFound)
                return object;
            var message = new $root.errors.PayloadResourceNotFound();
            if (object.id != null)
                if ($util.Long)
                    (message.id = $util.Long.fromValue(object.id)).unsigned = true;
                else if (typeof object.id === "string")
                    message.id = parseInt(object.id, 10);
                else if (typeof object.id === "number")
                    message.id = object.id;
                else if (typeof object.id === "object")
                    message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a PayloadResourceNotFound message. Also converts values to other types if specified.
         * @function toObject
         * @memberof errors.PayloadResourceNotFound
         * @static
         * @param {errors.PayloadResourceNotFound} message PayloadResourceNotFound
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PayloadResourceNotFound.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.id = options.longs === String ? "0" : 0;
            if (message.id != null && message.hasOwnProperty("id"))
                if (typeof message.id === "number")
                    object.id = options.longs === String ? String(message.id) : message.id;
                else
                    object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
            return object;
        };

        /**
         * Converts this PayloadResourceNotFound to JSON.
         * @function toJSON
         * @memberof errors.PayloadResourceNotFound
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PayloadResourceNotFound.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PayloadResourceNotFound;
    })();

    errors.PayloadRegisterInvalidEmail = (function() {

        /**
         * Properties of a PayloadRegisterInvalidEmail.
         * @memberof errors
         * @interface IPayloadRegisterInvalidEmail
         * @property {string|null} [email] PayloadRegisterInvalidEmail email
         */

        /**
         * Constructs a new PayloadRegisterInvalidEmail.
         * @memberof errors
         * @classdesc Represents a PayloadRegisterInvalidEmail.
         * @implements IPayloadRegisterInvalidEmail
         * @constructor
         * @param {errors.IPayloadRegisterInvalidEmail=} [properties] Properties to set
         */
        function PayloadRegisterInvalidEmail(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PayloadRegisterInvalidEmail email.
         * @member {string} email
         * @memberof errors.PayloadRegisterInvalidEmail
         * @instance
         */
        PayloadRegisterInvalidEmail.prototype.email = "";

        /**
         * Creates a new PayloadRegisterInvalidEmail instance using the specified properties.
         * @function create
         * @memberof errors.PayloadRegisterInvalidEmail
         * @static
         * @param {errors.IPayloadRegisterInvalidEmail=} [properties] Properties to set
         * @returns {errors.PayloadRegisterInvalidEmail} PayloadRegisterInvalidEmail instance
         */
        PayloadRegisterInvalidEmail.create = function create(properties) {
            return new PayloadRegisterInvalidEmail(properties);
        };

        /**
         * Encodes the specified PayloadRegisterInvalidEmail message. Does not implicitly {@link errors.PayloadRegisterInvalidEmail.verify|verify} messages.
         * @function encode
         * @memberof errors.PayloadRegisterInvalidEmail
         * @static
         * @param {errors.IPayloadRegisterInvalidEmail} message PayloadRegisterInvalidEmail message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadRegisterInvalidEmail.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.email != null && message.hasOwnProperty("email"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.email);
            return writer;
        };

        /**
         * Encodes the specified PayloadRegisterInvalidEmail message, length delimited. Does not implicitly {@link errors.PayloadRegisterInvalidEmail.verify|verify} messages.
         * @function encodeDelimited
         * @memberof errors.PayloadRegisterInvalidEmail
         * @static
         * @param {errors.IPayloadRegisterInvalidEmail} message PayloadRegisterInvalidEmail message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadRegisterInvalidEmail.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PayloadRegisterInvalidEmail message from the specified reader or buffer.
         * @function decode
         * @memberof errors.PayloadRegisterInvalidEmail
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {errors.PayloadRegisterInvalidEmail} PayloadRegisterInvalidEmail
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadRegisterInvalidEmail.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.errors.PayloadRegisterInvalidEmail();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.email = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PayloadRegisterInvalidEmail message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof errors.PayloadRegisterInvalidEmail
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {errors.PayloadRegisterInvalidEmail} PayloadRegisterInvalidEmail
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadRegisterInvalidEmail.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PayloadRegisterInvalidEmail message.
         * @function verify
         * @memberof errors.PayloadRegisterInvalidEmail
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PayloadRegisterInvalidEmail.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.email != null && message.hasOwnProperty("email"))
                if (!$util.isString(message.email))
                    return "email: string expected";
            return null;
        };

        /**
         * Creates a PayloadRegisterInvalidEmail message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof errors.PayloadRegisterInvalidEmail
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {errors.PayloadRegisterInvalidEmail} PayloadRegisterInvalidEmail
         */
        PayloadRegisterInvalidEmail.fromObject = function fromObject(object) {
            if (object instanceof $root.errors.PayloadRegisterInvalidEmail)
                return object;
            var message = new $root.errors.PayloadRegisterInvalidEmail();
            if (object.email != null)
                message.email = String(object.email);
            return message;
        };

        /**
         * Creates a plain object from a PayloadRegisterInvalidEmail message. Also converts values to other types if specified.
         * @function toObject
         * @memberof errors.PayloadRegisterInvalidEmail
         * @static
         * @param {errors.PayloadRegisterInvalidEmail} message PayloadRegisterInvalidEmail
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PayloadRegisterInvalidEmail.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.email = "";
            if (message.email != null && message.hasOwnProperty("email"))
                object.email = message.email;
            return object;
        };

        /**
         * Converts this PayloadRegisterInvalidEmail to JSON.
         * @function toJSON
         * @memberof errors.PayloadRegisterInvalidEmail
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PayloadRegisterInvalidEmail.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PayloadRegisterInvalidEmail;
    })();

    errors.PayloadRegisterTokenNotFound = (function() {

        /**
         * Properties of a PayloadRegisterTokenNotFound.
         * @memberof errors
         * @interface IPayloadRegisterTokenNotFound
         * @property {Uint8Array|null} [token] PayloadRegisterTokenNotFound token
         */

        /**
         * Constructs a new PayloadRegisterTokenNotFound.
         * @memberof errors
         * @classdesc Represents a PayloadRegisterTokenNotFound.
         * @implements IPayloadRegisterTokenNotFound
         * @constructor
         * @param {errors.IPayloadRegisterTokenNotFound=} [properties] Properties to set
         */
        function PayloadRegisterTokenNotFound(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PayloadRegisterTokenNotFound token.
         * @member {Uint8Array} token
         * @memberof errors.PayloadRegisterTokenNotFound
         * @instance
         */
        PayloadRegisterTokenNotFound.prototype.token = $util.newBuffer([]);

        /**
         * Creates a new PayloadRegisterTokenNotFound instance using the specified properties.
         * @function create
         * @memberof errors.PayloadRegisterTokenNotFound
         * @static
         * @param {errors.IPayloadRegisterTokenNotFound=} [properties] Properties to set
         * @returns {errors.PayloadRegisterTokenNotFound} PayloadRegisterTokenNotFound instance
         */
        PayloadRegisterTokenNotFound.create = function create(properties) {
            return new PayloadRegisterTokenNotFound(properties);
        };

        /**
         * Encodes the specified PayloadRegisterTokenNotFound message. Does not implicitly {@link errors.PayloadRegisterTokenNotFound.verify|verify} messages.
         * @function encode
         * @memberof errors.PayloadRegisterTokenNotFound
         * @static
         * @param {errors.IPayloadRegisterTokenNotFound} message PayloadRegisterTokenNotFound message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadRegisterTokenNotFound.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.token != null && message.hasOwnProperty("token"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.token);
            return writer;
        };

        /**
         * Encodes the specified PayloadRegisterTokenNotFound message, length delimited. Does not implicitly {@link errors.PayloadRegisterTokenNotFound.verify|verify} messages.
         * @function encodeDelimited
         * @memberof errors.PayloadRegisterTokenNotFound
         * @static
         * @param {errors.IPayloadRegisterTokenNotFound} message PayloadRegisterTokenNotFound message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadRegisterTokenNotFound.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PayloadRegisterTokenNotFound message from the specified reader or buffer.
         * @function decode
         * @memberof errors.PayloadRegisterTokenNotFound
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {errors.PayloadRegisterTokenNotFound} PayloadRegisterTokenNotFound
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadRegisterTokenNotFound.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.errors.PayloadRegisterTokenNotFound();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.token = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PayloadRegisterTokenNotFound message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof errors.PayloadRegisterTokenNotFound
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {errors.PayloadRegisterTokenNotFound} PayloadRegisterTokenNotFound
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadRegisterTokenNotFound.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PayloadRegisterTokenNotFound message.
         * @function verify
         * @memberof errors.PayloadRegisterTokenNotFound
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PayloadRegisterTokenNotFound.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.token != null && message.hasOwnProperty("token"))
                if (!(message.token && typeof message.token.length === "number" || $util.isString(message.token)))
                    return "token: buffer expected";
            return null;
        };

        /**
         * Creates a PayloadRegisterTokenNotFound message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof errors.PayloadRegisterTokenNotFound
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {errors.PayloadRegisterTokenNotFound} PayloadRegisterTokenNotFound
         */
        PayloadRegisterTokenNotFound.fromObject = function fromObject(object) {
            if (object instanceof $root.errors.PayloadRegisterTokenNotFound)
                return object;
            var message = new $root.errors.PayloadRegisterTokenNotFound();
            if (object.token != null)
                if (typeof object.token === "string")
                    $util.base64.decode(object.token, message.token = $util.newBuffer($util.base64.length(object.token)), 0);
                else if (object.token.length)
                    message.token = object.token;
            return message;
        };

        /**
         * Creates a plain object from a PayloadRegisterTokenNotFound message. Also converts values to other types if specified.
         * @function toObject
         * @memberof errors.PayloadRegisterTokenNotFound
         * @static
         * @param {errors.PayloadRegisterTokenNotFound} message PayloadRegisterTokenNotFound
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PayloadRegisterTokenNotFound.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.token = options.bytes === String ? "" : [];
            if (message.token != null && message.hasOwnProperty("token"))
                object.token = options.bytes === String ? $util.base64.encode(message.token, 0, message.token.length) : options.bytes === Array ? Array.prototype.slice.call(message.token) : message.token;
            return object;
        };

        /**
         * Converts this PayloadRegisterTokenNotFound to JSON.
         * @function toJSON
         * @memberof errors.PayloadRegisterTokenNotFound
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PayloadRegisterTokenNotFound.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PayloadRegisterTokenNotFound;
    })();

    errors.PayloadChannelNotFound = (function() {

        /**
         * Properties of a PayloadChannelNotFound.
         * @memberof errors
         * @interface IPayloadChannelNotFound
         * @property {number|Long|null} [id] PayloadChannelNotFound id
         */

        /**
         * Constructs a new PayloadChannelNotFound.
         * @memberof errors
         * @classdesc Represents a PayloadChannelNotFound.
         * @implements IPayloadChannelNotFound
         * @constructor
         * @param {errors.IPayloadChannelNotFound=} [properties] Properties to set
         */
        function PayloadChannelNotFound(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PayloadChannelNotFound id.
         * @member {number|Long} id
         * @memberof errors.PayloadChannelNotFound
         * @instance
         */
        PayloadChannelNotFound.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new PayloadChannelNotFound instance using the specified properties.
         * @function create
         * @memberof errors.PayloadChannelNotFound
         * @static
         * @param {errors.IPayloadChannelNotFound=} [properties] Properties to set
         * @returns {errors.PayloadChannelNotFound} PayloadChannelNotFound instance
         */
        PayloadChannelNotFound.create = function create(properties) {
            return new PayloadChannelNotFound(properties);
        };

        /**
         * Encodes the specified PayloadChannelNotFound message. Does not implicitly {@link errors.PayloadChannelNotFound.verify|verify} messages.
         * @function encode
         * @memberof errors.PayloadChannelNotFound
         * @static
         * @param {errors.IPayloadChannelNotFound} message PayloadChannelNotFound message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadChannelNotFound.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
            return writer;
        };

        /**
         * Encodes the specified PayloadChannelNotFound message, length delimited. Does not implicitly {@link errors.PayloadChannelNotFound.verify|verify} messages.
         * @function encodeDelimited
         * @memberof errors.PayloadChannelNotFound
         * @static
         * @param {errors.IPayloadChannelNotFound} message PayloadChannelNotFound message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadChannelNotFound.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PayloadChannelNotFound message from the specified reader or buffer.
         * @function decode
         * @memberof errors.PayloadChannelNotFound
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {errors.PayloadChannelNotFound} PayloadChannelNotFound
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadChannelNotFound.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.errors.PayloadChannelNotFound();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PayloadChannelNotFound message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof errors.PayloadChannelNotFound
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {errors.PayloadChannelNotFound} PayloadChannelNotFound
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadChannelNotFound.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PayloadChannelNotFound message.
         * @function verify
         * @memberof errors.PayloadChannelNotFound
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PayloadChannelNotFound.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                    return "id: integer|Long expected";
            return null;
        };

        /**
         * Creates a PayloadChannelNotFound message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof errors.PayloadChannelNotFound
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {errors.PayloadChannelNotFound} PayloadChannelNotFound
         */
        PayloadChannelNotFound.fromObject = function fromObject(object) {
            if (object instanceof $root.errors.PayloadChannelNotFound)
                return object;
            var message = new $root.errors.PayloadChannelNotFound();
            if (object.id != null)
                if ($util.Long)
                    (message.id = $util.Long.fromValue(object.id)).unsigned = true;
                else if (typeof object.id === "string")
                    message.id = parseInt(object.id, 10);
                else if (typeof object.id === "number")
                    message.id = object.id;
                else if (typeof object.id === "object")
                    message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a PayloadChannelNotFound message. Also converts values to other types if specified.
         * @function toObject
         * @memberof errors.PayloadChannelNotFound
         * @static
         * @param {errors.PayloadChannelNotFound} message PayloadChannelNotFound
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PayloadChannelNotFound.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.id = options.longs === String ? "0" : 0;
            if (message.id != null && message.hasOwnProperty("id"))
                if (typeof message.id === "number")
                    object.id = options.longs === String ? String(message.id) : message.id;
                else
                    object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
            return object;
        };

        /**
         * Converts this PayloadChannelNotFound to JSON.
         * @function toJSON
         * @memberof errors.PayloadChannelNotFound
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PayloadChannelNotFound.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PayloadChannelNotFound;
    })();

    errors.PayloadDelegatedAccessNotFound = (function() {

        /**
         * Properties of a PayloadDelegatedAccessNotFound.
         * @memberof errors
         * @interface IPayloadDelegatedAccessNotFound
         * @property {number|Long|null} [id] PayloadDelegatedAccessNotFound id
         */

        /**
         * Constructs a new PayloadDelegatedAccessNotFound.
         * @memberof errors
         * @classdesc Represents a PayloadDelegatedAccessNotFound.
         * @implements IPayloadDelegatedAccessNotFound
         * @constructor
         * @param {errors.IPayloadDelegatedAccessNotFound=} [properties] Properties to set
         */
        function PayloadDelegatedAccessNotFound(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PayloadDelegatedAccessNotFound id.
         * @member {number|Long} id
         * @memberof errors.PayloadDelegatedAccessNotFound
         * @instance
         */
        PayloadDelegatedAccessNotFound.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new PayloadDelegatedAccessNotFound instance using the specified properties.
         * @function create
         * @memberof errors.PayloadDelegatedAccessNotFound
         * @static
         * @param {errors.IPayloadDelegatedAccessNotFound=} [properties] Properties to set
         * @returns {errors.PayloadDelegatedAccessNotFound} PayloadDelegatedAccessNotFound instance
         */
        PayloadDelegatedAccessNotFound.create = function create(properties) {
            return new PayloadDelegatedAccessNotFound(properties);
        };

        /**
         * Encodes the specified PayloadDelegatedAccessNotFound message. Does not implicitly {@link errors.PayloadDelegatedAccessNotFound.verify|verify} messages.
         * @function encode
         * @memberof errors.PayloadDelegatedAccessNotFound
         * @static
         * @param {errors.IPayloadDelegatedAccessNotFound} message PayloadDelegatedAccessNotFound message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadDelegatedAccessNotFound.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
            return writer;
        };

        /**
         * Encodes the specified PayloadDelegatedAccessNotFound message, length delimited. Does not implicitly {@link errors.PayloadDelegatedAccessNotFound.verify|verify} messages.
         * @function encodeDelimited
         * @memberof errors.PayloadDelegatedAccessNotFound
         * @static
         * @param {errors.IPayloadDelegatedAccessNotFound} message PayloadDelegatedAccessNotFound message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadDelegatedAccessNotFound.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PayloadDelegatedAccessNotFound message from the specified reader or buffer.
         * @function decode
         * @memberof errors.PayloadDelegatedAccessNotFound
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {errors.PayloadDelegatedAccessNotFound} PayloadDelegatedAccessNotFound
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadDelegatedAccessNotFound.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.errors.PayloadDelegatedAccessNotFound();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PayloadDelegatedAccessNotFound message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof errors.PayloadDelegatedAccessNotFound
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {errors.PayloadDelegatedAccessNotFound} PayloadDelegatedAccessNotFound
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadDelegatedAccessNotFound.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PayloadDelegatedAccessNotFound message.
         * @function verify
         * @memberof errors.PayloadDelegatedAccessNotFound
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PayloadDelegatedAccessNotFound.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                    return "id: integer|Long expected";
            return null;
        };

        /**
         * Creates a PayloadDelegatedAccessNotFound message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof errors.PayloadDelegatedAccessNotFound
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {errors.PayloadDelegatedAccessNotFound} PayloadDelegatedAccessNotFound
         */
        PayloadDelegatedAccessNotFound.fromObject = function fromObject(object) {
            if (object instanceof $root.errors.PayloadDelegatedAccessNotFound)
                return object;
            var message = new $root.errors.PayloadDelegatedAccessNotFound();
            if (object.id != null)
                if ($util.Long)
                    (message.id = $util.Long.fromValue(object.id)).unsigned = true;
                else if (typeof object.id === "string")
                    message.id = parseInt(object.id, 10);
                else if (typeof object.id === "number")
                    message.id = object.id;
                else if (typeof object.id === "object")
                    message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a PayloadDelegatedAccessNotFound message. Also converts values to other types if specified.
         * @function toObject
         * @memberof errors.PayloadDelegatedAccessNotFound
         * @static
         * @param {errors.PayloadDelegatedAccessNotFound} message PayloadDelegatedAccessNotFound
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PayloadDelegatedAccessNotFound.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.id = options.longs === String ? "0" : 0;
            if (message.id != null && message.hasOwnProperty("id"))
                if (typeof message.id === "number")
                    object.id = options.longs === String ? String(message.id) : message.id;
                else
                    object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
            return object;
        };

        /**
         * Converts this PayloadDelegatedAccessNotFound to JSON.
         * @function toJSON
         * @memberof errors.PayloadDelegatedAccessNotFound
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PayloadDelegatedAccessNotFound.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PayloadDelegatedAccessNotFound;
    })();

    return errors;
})();

$root.google = (function() {

    /**
     * Namespace google.
     * @exports google
     * @namespace
     */
    var google = {};

    google.protobuf = (function() {

        /**
         * Namespace protobuf.
         * @memberof google
         * @namespace
         */
        var protobuf = {};

        protobuf.Any = (function() {

            /**
             * Properties of an Any.
             * @memberof google.protobuf
             * @interface IAny
             * @property {string|null} [type_url] Any type_url
             * @property {Uint8Array|null} [value] Any value
             */

            /**
             * Constructs a new Any.
             * @memberof google.protobuf
             * @classdesc Represents an Any.
             * @implements IAny
             * @constructor
             * @param {google.protobuf.IAny=} [properties] Properties to set
             */
            function Any(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Any type_url.
             * @member {string} type_url
             * @memberof google.protobuf.Any
             * @instance
             */
            Any.prototype.type_url = "";

            /**
             * Any value.
             * @member {Uint8Array} value
             * @memberof google.protobuf.Any
             * @instance
             */
            Any.prototype.value = $util.newBuffer([]);

            /**
             * Creates a new Any instance using the specified properties.
             * @function create
             * @memberof google.protobuf.Any
             * @static
             * @param {google.protobuf.IAny=} [properties] Properties to set
             * @returns {google.protobuf.Any} Any instance
             */
            Any.create = function create(properties) {
                return new Any(properties);
            };

            /**
             * Encodes the specified Any message. Does not implicitly {@link google.protobuf.Any.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.Any
             * @static
             * @param {google.protobuf.IAny} message Any message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Any.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type_url != null && message.hasOwnProperty("type_url"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.type_url);
                if (message.value != null && message.hasOwnProperty("value"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.value);
                return writer;
            };

            /**
             * Encodes the specified Any message, length delimited. Does not implicitly {@link google.protobuf.Any.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.Any
             * @static
             * @param {google.protobuf.IAny} message Any message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Any.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Any message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.Any
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.Any} Any
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Any.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Any();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type_url = reader.string();
                        break;
                    case 2:
                        message.value = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Any message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.Any
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.Any} Any
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Any.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Any message.
             * @function verify
             * @memberof google.protobuf.Any
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Any.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type_url != null && message.hasOwnProperty("type_url"))
                    if (!$util.isString(message.type_url))
                        return "type_url: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                return null;
            };

            /**
             * Creates an Any message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.Any
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Any} Any
             */
            Any.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Any)
                    return object;
                var message = new $root.google.protobuf.Any();
                if (object.type_url != null)
                    message.type_url = String(object.type_url);
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                return message;
            };

            /**
             * Creates a plain object from an Any message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.Any
             * @static
             * @param {google.protobuf.Any} message Any
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Any.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.type_url = "";
                    object.value = options.bytes === String ? "" : [];
                }
                if (message.type_url != null && message.hasOwnProperty("type_url"))
                    object.type_url = message.type_url;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                return object;
            };

            /**
             * Converts this Any to JSON.
             * @function toJSON
             * @memberof google.protobuf.Any
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Any.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Any;
        })();

        return protobuf;
    })();

    return google;
})();

$root.types = (function() {

    /**
     * Namespace types.
     * @exports types
     * @namespace
     */
    var types = {};

    types.Cipher = (function() {

        /**
         * Properties of a Cipher.
         * @memberof types
         * @interface ICipher
         * @property {Uint8Array|null} [nonce] Cipher nonce
         * @property {Uint8Array|null} [message] Cipher message
         * @property {types.IIdentityKeyID|null} [sign] Cipher sign
         */

        /**
         * Constructs a new Cipher.
         * @memberof types
         * @classdesc Represents a Cipher.
         * @implements ICipher
         * @constructor
         * @param {types.ICipher=} [properties] Properties to set
         */
        function Cipher(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Cipher nonce.
         * @member {Uint8Array} nonce
         * @memberof types.Cipher
         * @instance
         */
        Cipher.prototype.nonce = $util.newBuffer([]);

        /**
         * Cipher message.
         * @member {Uint8Array} message
         * @memberof types.Cipher
         * @instance
         */
        Cipher.prototype.message = $util.newBuffer([]);

        /**
         * Cipher sign.
         * @member {types.IIdentityKeyID|null|undefined} sign
         * @memberof types.Cipher
         * @instance
         */
        Cipher.prototype.sign = null;

        /**
         * Creates a new Cipher instance using the specified properties.
         * @function create
         * @memberof types.Cipher
         * @static
         * @param {types.ICipher=} [properties] Properties to set
         * @returns {types.Cipher} Cipher instance
         */
        Cipher.create = function create(properties) {
            return new Cipher(properties);
        };

        /**
         * Encodes the specified Cipher message. Does not implicitly {@link types.Cipher.verify|verify} messages.
         * @function encode
         * @memberof types.Cipher
         * @static
         * @param {types.ICipher} message Cipher message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Cipher.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.nonce);
            if (message.message != null && message.hasOwnProperty("message"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.message);
            if (message.sign != null && message.hasOwnProperty("sign"))
                $root.types.IdentityKeyID.encode(message.sign, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Cipher message, length delimited. Does not implicitly {@link types.Cipher.verify|verify} messages.
         * @function encodeDelimited
         * @memberof types.Cipher
         * @static
         * @param {types.ICipher} message Cipher message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Cipher.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Cipher message from the specified reader or buffer.
         * @function decode
         * @memberof types.Cipher
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {types.Cipher} Cipher
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Cipher.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.types.Cipher();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.nonce = reader.bytes();
                    break;
                case 2:
                    message.message = reader.bytes();
                    break;
                case 3:
                    message.sign = $root.types.IdentityKeyID.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Cipher message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof types.Cipher
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {types.Cipher} Cipher
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Cipher.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Cipher message.
         * @function verify
         * @memberof types.Cipher
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Cipher.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                if (!(message.nonce && typeof message.nonce.length === "number" || $util.isString(message.nonce)))
                    return "nonce: buffer expected";
            if (message.message != null && message.hasOwnProperty("message"))
                if (!(message.message && typeof message.message.length === "number" || $util.isString(message.message)))
                    return "message: buffer expected";
            if (message.sign != null && message.hasOwnProperty("sign")) {
                var error = $root.types.IdentityKeyID.verify(message.sign);
                if (error)
                    return "sign." + error;
            }
            return null;
        };

        /**
         * Creates a Cipher message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof types.Cipher
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {types.Cipher} Cipher
         */
        Cipher.fromObject = function fromObject(object) {
            if (object instanceof $root.types.Cipher)
                return object;
            var message = new $root.types.Cipher();
            if (object.nonce != null)
                if (typeof object.nonce === "string")
                    $util.base64.decode(object.nonce, message.nonce = $util.newBuffer($util.base64.length(object.nonce)), 0);
                else if (object.nonce.length)
                    message.nonce = object.nonce;
            if (object.message != null)
                if (typeof object.message === "string")
                    $util.base64.decode(object.message, message.message = $util.newBuffer($util.base64.length(object.message)), 0);
                else if (object.message.length)
                    message.message = object.message;
            if (object.sign != null) {
                if (typeof object.sign !== "object")
                    throw TypeError(".types.Cipher.sign: object expected");
                message.sign = $root.types.IdentityKeyID.fromObject(object.sign);
            }
            return message;
        };

        /**
         * Creates a plain object from a Cipher message. Also converts values to other types if specified.
         * @function toObject
         * @memberof types.Cipher
         * @static
         * @param {types.Cipher} message Cipher
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Cipher.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.nonce = options.bytes === String ? "" : [];
                object.message = options.bytes === String ? "" : [];
                object.sign = null;
            }
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                object.nonce = options.bytes === String ? $util.base64.encode(message.nonce, 0, message.nonce.length) : options.bytes === Array ? Array.prototype.slice.call(message.nonce) : message.nonce;
            if (message.message != null && message.hasOwnProperty("message"))
                object.message = options.bytes === String ? $util.base64.encode(message.message, 0, message.message.length) : options.bytes === Array ? Array.prototype.slice.call(message.message) : message.message;
            if (message.sign != null && message.hasOwnProperty("sign"))
                object.sign = $root.types.IdentityKeyID.toObject(message.sign, options);
            return object;
        };

        /**
         * Converts this Cipher to JSON.
         * @function toJSON
         * @memberof types.Cipher
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Cipher.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Cipher;
    })();

    types.IdentityFields = (function() {

        /**
         * Properties of an IdentityFields.
         * @memberof types
         * @interface IIdentityFields
         * @property {string|null} [login] IdentityFields login
         * @property {string|null} [name] IdentityFields name
         * @property {string|null} [kind] IdentityFields kind
         * @property {Uint8Array|null} [payload] IdentityFields payload
         */

        /**
         * Constructs a new IdentityFields.
         * @memberof types
         * @classdesc Represents an IdentityFields.
         * @implements IIdentityFields
         * @constructor
         * @param {types.IIdentityFields=} [properties] Properties to set
         */
        function IdentityFields(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityFields login.
         * @member {string} login
         * @memberof types.IdentityFields
         * @instance
         */
        IdentityFields.prototype.login = "";

        /**
         * IdentityFields name.
         * @member {string} name
         * @memberof types.IdentityFields
         * @instance
         */
        IdentityFields.prototype.name = "";

        /**
         * IdentityFields kind.
         * @member {string} kind
         * @memberof types.IdentityFields
         * @instance
         */
        IdentityFields.prototype.kind = "";

        /**
         * IdentityFields payload.
         * @member {Uint8Array} payload
         * @memberof types.IdentityFields
         * @instance
         */
        IdentityFields.prototype.payload = $util.newBuffer([]);

        /**
         * Creates a new IdentityFields instance using the specified properties.
         * @function create
         * @memberof types.IdentityFields
         * @static
         * @param {types.IIdentityFields=} [properties] Properties to set
         * @returns {types.IdentityFields} IdentityFields instance
         */
        IdentityFields.create = function create(properties) {
            return new IdentityFields(properties);
        };

        /**
         * Encodes the specified IdentityFields message. Does not implicitly {@link types.IdentityFields.verify|verify} messages.
         * @function encode
         * @memberof types.IdentityFields
         * @static
         * @param {types.IIdentityFields} message IdentityFields message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityFields.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.kind != null && message.hasOwnProperty("kind"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.kind);
            if (message.payload != null && message.hasOwnProperty("payload"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.payload);
            return writer;
        };

        /**
         * Encodes the specified IdentityFields message, length delimited. Does not implicitly {@link types.IdentityFields.verify|verify} messages.
         * @function encodeDelimited
         * @memberof types.IdentityFields
         * @static
         * @param {types.IIdentityFields} message IdentityFields message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityFields.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityFields message from the specified reader or buffer.
         * @function decode
         * @memberof types.IdentityFields
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {types.IdentityFields} IdentityFields
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityFields.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.types.IdentityFields();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 3:
                    message.kind = reader.string();
                    break;
                case 4:
                    message.payload = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityFields message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof types.IdentityFields
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {types.IdentityFields} IdentityFields
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityFields.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityFields message.
         * @function verify
         * @memberof types.IdentityFields
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityFields.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.kind != null && message.hasOwnProperty("kind"))
                if (!$util.isString(message.kind))
                    return "kind: string expected";
            if (message.payload != null && message.hasOwnProperty("payload"))
                if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                    return "payload: buffer expected";
            return null;
        };

        /**
         * Creates an IdentityFields message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof types.IdentityFields
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {types.IdentityFields} IdentityFields
         */
        IdentityFields.fromObject = function fromObject(object) {
            if (object instanceof $root.types.IdentityFields)
                return object;
            var message = new $root.types.IdentityFields();
            if (object.login != null)
                message.login = String(object.login);
            if (object.name != null)
                message.name = String(object.name);
            if (object.kind != null)
                message.kind = String(object.kind);
            if (object.payload != null)
                if (typeof object.payload === "string")
                    $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                else if (object.payload.length)
                    message.payload = object.payload;
            return message;
        };

        /**
         * Creates a plain object from an IdentityFields message. Also converts values to other types if specified.
         * @function toObject
         * @memberof types.IdentityFields
         * @static
         * @param {types.IdentityFields} message IdentityFields
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityFields.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.login = "";
                object.name = "";
                object.kind = "";
                object.payload = options.bytes === String ? "" : [];
            }
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.kind != null && message.hasOwnProperty("kind"))
                object.kind = message.kind;
            if (message.payload != null && message.hasOwnProperty("payload"))
                object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
            return object;
        };

        /**
         * Converts this IdentityFields to JSON.
         * @function toJSON
         * @memberof types.IdentityFields
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityFields.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityFields;
    })();

    types.Identity = (function() {

        /**
         * Properties of an Identity.
         * @memberof types
         * @interface IIdentity
         * @property {string|null} [login] Identity login
         * @property {string|null} [name] Identity name
         * @property {string|null} [kind] Identity kind
         * @property {number|Long|null} [created] Identity created
         * @property {boolean|null} [admin] Identity admin
         * @property {boolean|null} [active] Identity active
         * @property {Uint8Array|null} [payload] Identity payload
         */

        /**
         * Constructs a new Identity.
         * @memberof types
         * @classdesc Represents an Identity.
         * @implements IIdentity
         * @constructor
         * @param {types.IIdentity=} [properties] Properties to set
         */
        function Identity(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Identity login.
         * @member {string} login
         * @memberof types.Identity
         * @instance
         */
        Identity.prototype.login = "";

        /**
         * Identity name.
         * @member {string} name
         * @memberof types.Identity
         * @instance
         */
        Identity.prototype.name = "";

        /**
         * Identity kind.
         * @member {string} kind
         * @memberof types.Identity
         * @instance
         */
        Identity.prototype.kind = "";

        /**
         * Identity created.
         * @member {number|Long} created
         * @memberof types.Identity
         * @instance
         */
        Identity.prototype.created = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Identity admin.
         * @member {boolean} admin
         * @memberof types.Identity
         * @instance
         */
        Identity.prototype.admin = false;

        /**
         * Identity active.
         * @member {boolean} active
         * @memberof types.Identity
         * @instance
         */
        Identity.prototype.active = false;

        /**
         * Identity payload.
         * @member {Uint8Array} payload
         * @memberof types.Identity
         * @instance
         */
        Identity.prototype.payload = $util.newBuffer([]);

        /**
         * Creates a new Identity instance using the specified properties.
         * @function create
         * @memberof types.Identity
         * @static
         * @param {types.IIdentity=} [properties] Properties to set
         * @returns {types.Identity} Identity instance
         */
        Identity.create = function create(properties) {
            return new Identity(properties);
        };

        /**
         * Encodes the specified Identity message. Does not implicitly {@link types.Identity.verify|verify} messages.
         * @function encode
         * @memberof types.Identity
         * @static
         * @param {types.IIdentity} message Identity message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Identity.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.kind != null && message.hasOwnProperty("kind"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.kind);
            if (message.created != null && message.hasOwnProperty("created"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.created);
            if (message.admin != null && message.hasOwnProperty("admin"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.admin);
            if (message.active != null && message.hasOwnProperty("active"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.active);
            if (message.payload != null && message.hasOwnProperty("payload"))
                writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.payload);
            return writer;
        };

        /**
         * Encodes the specified Identity message, length delimited. Does not implicitly {@link types.Identity.verify|verify} messages.
         * @function encodeDelimited
         * @memberof types.Identity
         * @static
         * @param {types.IIdentity} message Identity message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Identity.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Identity message from the specified reader or buffer.
         * @function decode
         * @memberof types.Identity
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {types.Identity} Identity
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Identity.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.types.Identity();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 3:
                    message.kind = reader.string();
                    break;
                case 4:
                    message.created = reader.int64();
                    break;
                case 5:
                    message.admin = reader.bool();
                    break;
                case 6:
                    message.active = reader.bool();
                    break;
                case 7:
                    message.payload = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Identity message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof types.Identity
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {types.Identity} Identity
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Identity.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Identity message.
         * @function verify
         * @memberof types.Identity
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Identity.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.kind != null && message.hasOwnProperty("kind"))
                if (!$util.isString(message.kind))
                    return "kind: string expected";
            if (message.created != null && message.hasOwnProperty("created"))
                if (!$util.isInteger(message.created) && !(message.created && $util.isInteger(message.created.low) && $util.isInteger(message.created.high)))
                    return "created: integer|Long expected";
            if (message.admin != null && message.hasOwnProperty("admin"))
                if (typeof message.admin !== "boolean")
                    return "admin: boolean expected";
            if (message.active != null && message.hasOwnProperty("active"))
                if (typeof message.active !== "boolean")
                    return "active: boolean expected";
            if (message.payload != null && message.hasOwnProperty("payload"))
                if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                    return "payload: buffer expected";
            return null;
        };

        /**
         * Creates an Identity message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof types.Identity
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {types.Identity} Identity
         */
        Identity.fromObject = function fromObject(object) {
            if (object instanceof $root.types.Identity)
                return object;
            var message = new $root.types.Identity();
            if (object.login != null)
                message.login = String(object.login);
            if (object.name != null)
                message.name = String(object.name);
            if (object.kind != null)
                message.kind = String(object.kind);
            if (object.created != null)
                if ($util.Long)
                    (message.created = $util.Long.fromValue(object.created)).unsigned = false;
                else if (typeof object.created === "string")
                    message.created = parseInt(object.created, 10);
                else if (typeof object.created === "number")
                    message.created = object.created;
                else if (typeof object.created === "object")
                    message.created = new $util.LongBits(object.created.low >>> 0, object.created.high >>> 0).toNumber();
            if (object.admin != null)
                message.admin = Boolean(object.admin);
            if (object.active != null)
                message.active = Boolean(object.active);
            if (object.payload != null)
                if (typeof object.payload === "string")
                    $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                else if (object.payload.length)
                    message.payload = object.payload;
            return message;
        };

        /**
         * Creates a plain object from an Identity message. Also converts values to other types if specified.
         * @function toObject
         * @memberof types.Identity
         * @static
         * @param {types.Identity} message Identity
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Identity.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.login = "";
                object.name = "";
                object.kind = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.created = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.created = options.longs === String ? "0" : 0;
                object.admin = false;
                object.active = false;
                object.payload = options.bytes === String ? "" : [];
            }
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.kind != null && message.hasOwnProperty("kind"))
                object.kind = message.kind;
            if (message.created != null && message.hasOwnProperty("created"))
                if (typeof message.created === "number")
                    object.created = options.longs === String ? String(message.created) : message.created;
                else
                    object.created = options.longs === String ? $util.Long.prototype.toString.call(message.created) : options.longs === Number ? new $util.LongBits(message.created.low >>> 0, message.created.high >>> 0).toNumber() : message.created;
            if (message.admin != null && message.hasOwnProperty("admin"))
                object.admin = message.admin;
            if (message.active != null && message.hasOwnProperty("active"))
                object.active = message.active;
            if (message.payload != null && message.hasOwnProperty("payload"))
                object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
            return object;
        };

        /**
         * Converts this Identity to JSON.
         * @function toJSON
         * @memberof types.Identity
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Identity.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Identity;
    })();

    types.IdentityKeyID = (function() {

        /**
         * Properties of an IdentityKeyID.
         * @memberof types
         * @interface IIdentityKeyID
         * @property {string|null} [login] IdentityKeyID login
         * @property {number|null} [version] IdentityKeyID version
         */

        /**
         * Constructs a new IdentityKeyID.
         * @memberof types
         * @classdesc Represents an IdentityKeyID.
         * @implements IIdentityKeyID
         * @constructor
         * @param {types.IIdentityKeyID=} [properties] Properties to set
         */
        function IdentityKeyID(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityKeyID login.
         * @member {string} login
         * @memberof types.IdentityKeyID
         * @instance
         */
        IdentityKeyID.prototype.login = "";

        /**
         * IdentityKeyID version.
         * @member {number} version
         * @memberof types.IdentityKeyID
         * @instance
         */
        IdentityKeyID.prototype.version = 0;

        /**
         * Creates a new IdentityKeyID instance using the specified properties.
         * @function create
         * @memberof types.IdentityKeyID
         * @static
         * @param {types.IIdentityKeyID=} [properties] Properties to set
         * @returns {types.IdentityKeyID} IdentityKeyID instance
         */
        IdentityKeyID.create = function create(properties) {
            return new IdentityKeyID(properties);
        };

        /**
         * Encodes the specified IdentityKeyID message. Does not implicitly {@link types.IdentityKeyID.verify|verify} messages.
         * @function encode
         * @memberof types.IdentityKeyID
         * @static
         * @param {types.IIdentityKeyID} message IdentityKeyID message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityKeyID.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            if (message.version != null && message.hasOwnProperty("version"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.version);
            return writer;
        };

        /**
         * Encodes the specified IdentityKeyID message, length delimited. Does not implicitly {@link types.IdentityKeyID.verify|verify} messages.
         * @function encodeDelimited
         * @memberof types.IdentityKeyID
         * @static
         * @param {types.IIdentityKeyID} message IdentityKeyID message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityKeyID.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityKeyID message from the specified reader or buffer.
         * @function decode
         * @memberof types.IdentityKeyID
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {types.IdentityKeyID} IdentityKeyID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityKeyID.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.types.IdentityKeyID();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                case 2:
                    message.version = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityKeyID message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof types.IdentityKeyID
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {types.IdentityKeyID} IdentityKeyID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityKeyID.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityKeyID message.
         * @function verify
         * @memberof types.IdentityKeyID
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityKeyID.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isInteger(message.version))
                    return "version: integer expected";
            return null;
        };

        /**
         * Creates an IdentityKeyID message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof types.IdentityKeyID
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {types.IdentityKeyID} IdentityKeyID
         */
        IdentityKeyID.fromObject = function fromObject(object) {
            if (object instanceof $root.types.IdentityKeyID)
                return object;
            var message = new $root.types.IdentityKeyID();
            if (object.login != null)
                message.login = String(object.login);
            if (object.version != null)
                message.version = object.version >>> 0;
            return message;
        };

        /**
         * Creates a plain object from an IdentityKeyID message. Also converts values to other types if specified.
         * @function toObject
         * @memberof types.IdentityKeyID
         * @static
         * @param {types.IdentityKeyID} message IdentityKeyID
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityKeyID.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.login = "";
                object.version = 0;
            }
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            return object;
        };

        /**
         * Converts this IdentityKeyID to JSON.
         * @function toJSON
         * @memberof types.IdentityKeyID
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityKeyID.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityKeyID;
    })();

    types.IdentityPublicKey = (function() {

        /**
         * Properties of an IdentityPublicKey.
         * @memberof types
         * @interface IIdentityPublicKey
         * @property {Uint8Array|null} [sign] IdentityPublicKey sign
         * @property {Uint8Array|null} [box] IdentityPublicKey box
         * @property {string|null} [login] IdentityPublicKey login
         * @property {number|null} [version] IdentityPublicKey version
         */

        /**
         * Constructs a new IdentityPublicKey.
         * @memberof types
         * @classdesc Represents an IdentityPublicKey.
         * @implements IIdentityPublicKey
         * @constructor
         * @param {types.IIdentityPublicKey=} [properties] Properties to set
         */
        function IdentityPublicKey(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityPublicKey sign.
         * @member {Uint8Array} sign
         * @memberof types.IdentityPublicKey
         * @instance
         */
        IdentityPublicKey.prototype.sign = $util.newBuffer([]);

        /**
         * IdentityPublicKey box.
         * @member {Uint8Array} box
         * @memberof types.IdentityPublicKey
         * @instance
         */
        IdentityPublicKey.prototype.box = $util.newBuffer([]);

        /**
         * IdentityPublicKey login.
         * @member {string} login
         * @memberof types.IdentityPublicKey
         * @instance
         */
        IdentityPublicKey.prototype.login = "";

        /**
         * IdentityPublicKey version.
         * @member {number} version
         * @memberof types.IdentityPublicKey
         * @instance
         */
        IdentityPublicKey.prototype.version = 0;

        /**
         * Creates a new IdentityPublicKey instance using the specified properties.
         * @function create
         * @memberof types.IdentityPublicKey
         * @static
         * @param {types.IIdentityPublicKey=} [properties] Properties to set
         * @returns {types.IdentityPublicKey} IdentityPublicKey instance
         */
        IdentityPublicKey.create = function create(properties) {
            return new IdentityPublicKey(properties);
        };

        /**
         * Encodes the specified IdentityPublicKey message. Does not implicitly {@link types.IdentityPublicKey.verify|verify} messages.
         * @function encode
         * @memberof types.IdentityPublicKey
         * @static
         * @param {types.IIdentityPublicKey} message IdentityPublicKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityPublicKey.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.sign != null && message.hasOwnProperty("sign"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.sign);
            if (message.box != null && message.hasOwnProperty("box"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.box);
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.login);
            if (message.version != null && message.hasOwnProperty("version"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.version);
            return writer;
        };

        /**
         * Encodes the specified IdentityPublicKey message, length delimited. Does not implicitly {@link types.IdentityPublicKey.verify|verify} messages.
         * @function encodeDelimited
         * @memberof types.IdentityPublicKey
         * @static
         * @param {types.IIdentityPublicKey} message IdentityPublicKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityPublicKey.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityPublicKey message from the specified reader or buffer.
         * @function decode
         * @memberof types.IdentityPublicKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {types.IdentityPublicKey} IdentityPublicKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityPublicKey.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.types.IdentityPublicKey();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.sign = reader.bytes();
                    break;
                case 2:
                    message.box = reader.bytes();
                    break;
                case 3:
                    message.login = reader.string();
                    break;
                case 4:
                    message.version = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityPublicKey message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof types.IdentityPublicKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {types.IdentityPublicKey} IdentityPublicKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityPublicKey.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityPublicKey message.
         * @function verify
         * @memberof types.IdentityPublicKey
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityPublicKey.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.sign != null && message.hasOwnProperty("sign"))
                if (!(message.sign && typeof message.sign.length === "number" || $util.isString(message.sign)))
                    return "sign: buffer expected";
            if (message.box != null && message.hasOwnProperty("box"))
                if (!(message.box && typeof message.box.length === "number" || $util.isString(message.box)))
                    return "box: buffer expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isInteger(message.version))
                    return "version: integer expected";
            return null;
        };

        /**
         * Creates an IdentityPublicKey message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof types.IdentityPublicKey
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {types.IdentityPublicKey} IdentityPublicKey
         */
        IdentityPublicKey.fromObject = function fromObject(object) {
            if (object instanceof $root.types.IdentityPublicKey)
                return object;
            var message = new $root.types.IdentityPublicKey();
            if (object.sign != null)
                if (typeof object.sign === "string")
                    $util.base64.decode(object.sign, message.sign = $util.newBuffer($util.base64.length(object.sign)), 0);
                else if (object.sign.length)
                    message.sign = object.sign;
            if (object.box != null)
                if (typeof object.box === "string")
                    $util.base64.decode(object.box, message.box = $util.newBuffer($util.base64.length(object.box)), 0);
                else if (object.box.length)
                    message.box = object.box;
            if (object.login != null)
                message.login = String(object.login);
            if (object.version != null)
                message.version = object.version >>> 0;
            return message;
        };

        /**
         * Creates a plain object from an IdentityPublicKey message. Also converts values to other types if specified.
         * @function toObject
         * @memberof types.IdentityPublicKey
         * @static
         * @param {types.IdentityPublicKey} message IdentityPublicKey
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityPublicKey.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.sign = options.bytes === String ? "" : [];
                object.box = options.bytes === String ? "" : [];
                object.login = "";
                object.version = 0;
            }
            if (message.sign != null && message.hasOwnProperty("sign"))
                object.sign = options.bytes === String ? $util.base64.encode(message.sign, 0, message.sign.length) : options.bytes === Array ? Array.prototype.slice.call(message.sign) : message.sign;
            if (message.box != null && message.hasOwnProperty("box"))
                object.box = options.bytes === String ? $util.base64.encode(message.box, 0, message.box.length) : options.bytes === Array ? Array.prototype.slice.call(message.box) : message.box;
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            return object;
        };

        /**
         * Converts this IdentityPublicKey to JSON.
         * @function toJSON
         * @memberof types.IdentityPublicKey
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityPublicKey.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityPublicKey;
    })();

    types.IdentityPublicChain = (function() {

        /**
         * Properties of an IdentityPublicChain.
         * @memberof types
         * @interface IIdentityPublicChain
         * @property {string|null} [login] IdentityPublicChain login
         * @property {number|null} [version] IdentityPublicChain version
         * @property {Array.<types.IdentityPublicChain.IElt>|null} [chains] IdentityPublicChain chains
         */

        /**
         * Constructs a new IdentityPublicChain.
         * @memberof types
         * @classdesc Represents an IdentityPublicChain.
         * @implements IIdentityPublicChain
         * @constructor
         * @param {types.IIdentityPublicChain=} [properties] Properties to set
         */
        function IdentityPublicChain(properties) {
            this.chains = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityPublicChain login.
         * @member {string} login
         * @memberof types.IdentityPublicChain
         * @instance
         */
        IdentityPublicChain.prototype.login = "";

        /**
         * IdentityPublicChain version.
         * @member {number} version
         * @memberof types.IdentityPublicChain
         * @instance
         */
        IdentityPublicChain.prototype.version = 0;

        /**
         * IdentityPublicChain chains.
         * @member {Array.<types.IdentityPublicChain.IElt>} chains
         * @memberof types.IdentityPublicChain
         * @instance
         */
        IdentityPublicChain.prototype.chains = $util.emptyArray;

        /**
         * Creates a new IdentityPublicChain instance using the specified properties.
         * @function create
         * @memberof types.IdentityPublicChain
         * @static
         * @param {types.IIdentityPublicChain=} [properties] Properties to set
         * @returns {types.IdentityPublicChain} IdentityPublicChain instance
         */
        IdentityPublicChain.create = function create(properties) {
            return new IdentityPublicChain(properties);
        };

        /**
         * Encodes the specified IdentityPublicChain message. Does not implicitly {@link types.IdentityPublicChain.verify|verify} messages.
         * @function encode
         * @memberof types.IdentityPublicChain
         * @static
         * @param {types.IIdentityPublicChain} message IdentityPublicChain message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityPublicChain.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            if (message.version != null && message.hasOwnProperty("version"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.version);
            if (message.chains != null && message.chains.length)
                for (var i = 0; i < message.chains.length; ++i)
                    $root.types.IdentityPublicChain.Elt.encode(message.chains[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IdentityPublicChain message, length delimited. Does not implicitly {@link types.IdentityPublicChain.verify|verify} messages.
         * @function encodeDelimited
         * @memberof types.IdentityPublicChain
         * @static
         * @param {types.IIdentityPublicChain} message IdentityPublicChain message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityPublicChain.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityPublicChain message from the specified reader or buffer.
         * @function decode
         * @memberof types.IdentityPublicChain
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {types.IdentityPublicChain} IdentityPublicChain
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityPublicChain.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.types.IdentityPublicChain();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                case 2:
                    message.version = reader.uint32();
                    break;
                case 3:
                    if (!(message.chains && message.chains.length))
                        message.chains = [];
                    message.chains.push($root.types.IdentityPublicChain.Elt.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityPublicChain message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof types.IdentityPublicChain
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {types.IdentityPublicChain} IdentityPublicChain
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityPublicChain.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityPublicChain message.
         * @function verify
         * @memberof types.IdentityPublicChain
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityPublicChain.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isInteger(message.version))
                    return "version: integer expected";
            if (message.chains != null && message.hasOwnProperty("chains")) {
                if (!Array.isArray(message.chains))
                    return "chains: array expected";
                for (var i = 0; i < message.chains.length; ++i) {
                    var error = $root.types.IdentityPublicChain.Elt.verify(message.chains[i]);
                    if (error)
                        return "chains." + error;
                }
            }
            return null;
        };

        /**
         * Creates an IdentityPublicChain message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof types.IdentityPublicChain
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {types.IdentityPublicChain} IdentityPublicChain
         */
        IdentityPublicChain.fromObject = function fromObject(object) {
            if (object instanceof $root.types.IdentityPublicChain)
                return object;
            var message = new $root.types.IdentityPublicChain();
            if (object.login != null)
                message.login = String(object.login);
            if (object.version != null)
                message.version = object.version >>> 0;
            if (object.chains) {
                if (!Array.isArray(object.chains))
                    throw TypeError(".types.IdentityPublicChain.chains: array expected");
                message.chains = [];
                for (var i = 0; i < object.chains.length; ++i) {
                    if (typeof object.chains[i] !== "object")
                        throw TypeError(".types.IdentityPublicChain.chains: object expected");
                    message.chains[i] = $root.types.IdentityPublicChain.Elt.fromObject(object.chains[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an IdentityPublicChain message. Also converts values to other types if specified.
         * @function toObject
         * @memberof types.IdentityPublicChain
         * @static
         * @param {types.IdentityPublicChain} message IdentityPublicChain
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityPublicChain.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.chains = [];
            if (options.defaults) {
                object.login = "";
                object.version = 0;
            }
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            if (message.chains && message.chains.length) {
                object.chains = [];
                for (var j = 0; j < message.chains.length; ++j)
                    object.chains[j] = $root.types.IdentityPublicChain.Elt.toObject(message.chains[j], options);
            }
            return object;
        };

        /**
         * Converts this IdentityPublicChain to JSON.
         * @function toJSON
         * @memberof types.IdentityPublicChain
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityPublicChain.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        IdentityPublicChain.Elt = (function() {

            /**
             * Properties of an Elt.
             * @memberof types.IdentityPublicChain
             * @interface IElt
             * @property {Uint8Array|null} [sign] Elt sign
             * @property {Uint8Array|null} [box] Elt box
             * @property {Uint8Array|null} [chain] Elt chain
             * @property {types.IIdentityKeyID|null} [mandate] Elt mandate
             */

            /**
             * Constructs a new Elt.
             * @memberof types.IdentityPublicChain
             * @classdesc Represents an Elt.
             * @implements IElt
             * @constructor
             * @param {types.IdentityPublicChain.IElt=} [properties] Properties to set
             */
            function Elt(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Elt sign.
             * @member {Uint8Array} sign
             * @memberof types.IdentityPublicChain.Elt
             * @instance
             */
            Elt.prototype.sign = $util.newBuffer([]);

            /**
             * Elt box.
             * @member {Uint8Array} box
             * @memberof types.IdentityPublicChain.Elt
             * @instance
             */
            Elt.prototype.box = $util.newBuffer([]);

            /**
             * Elt chain.
             * @member {Uint8Array} chain
             * @memberof types.IdentityPublicChain.Elt
             * @instance
             */
            Elt.prototype.chain = $util.newBuffer([]);

            /**
             * Elt mandate.
             * @member {types.IIdentityKeyID|null|undefined} mandate
             * @memberof types.IdentityPublicChain.Elt
             * @instance
             */
            Elt.prototype.mandate = null;

            /**
             * Creates a new Elt instance using the specified properties.
             * @function create
             * @memberof types.IdentityPublicChain.Elt
             * @static
             * @param {types.IdentityPublicChain.IElt=} [properties] Properties to set
             * @returns {types.IdentityPublicChain.Elt} Elt instance
             */
            Elt.create = function create(properties) {
                return new Elt(properties);
            };

            /**
             * Encodes the specified Elt message. Does not implicitly {@link types.IdentityPublicChain.Elt.verify|verify} messages.
             * @function encode
             * @memberof types.IdentityPublicChain.Elt
             * @static
             * @param {types.IdentityPublicChain.IElt} message Elt message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Elt.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sign != null && message.hasOwnProperty("sign"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.sign);
                if (message.box != null && message.hasOwnProperty("box"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.box);
                if (message.chain != null && message.hasOwnProperty("chain"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.chain);
                if (message.mandate != null && message.hasOwnProperty("mandate"))
                    $root.types.IdentityKeyID.encode(message.mandate, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Elt message, length delimited. Does not implicitly {@link types.IdentityPublicChain.Elt.verify|verify} messages.
             * @function encodeDelimited
             * @memberof types.IdentityPublicChain.Elt
             * @static
             * @param {types.IdentityPublicChain.IElt} message Elt message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Elt.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Elt message from the specified reader or buffer.
             * @function decode
             * @memberof types.IdentityPublicChain.Elt
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {types.IdentityPublicChain.Elt} Elt
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Elt.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.types.IdentityPublicChain.Elt();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.sign = reader.bytes();
                        break;
                    case 2:
                        message.box = reader.bytes();
                        break;
                    case 3:
                        message.chain = reader.bytes();
                        break;
                    case 4:
                        message.mandate = $root.types.IdentityKeyID.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Elt message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof types.IdentityPublicChain.Elt
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {types.IdentityPublicChain.Elt} Elt
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Elt.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Elt message.
             * @function verify
             * @memberof types.IdentityPublicChain.Elt
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Elt.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.sign != null && message.hasOwnProperty("sign"))
                    if (!(message.sign && typeof message.sign.length === "number" || $util.isString(message.sign)))
                        return "sign: buffer expected";
                if (message.box != null && message.hasOwnProperty("box"))
                    if (!(message.box && typeof message.box.length === "number" || $util.isString(message.box)))
                        return "box: buffer expected";
                if (message.chain != null && message.hasOwnProperty("chain"))
                    if (!(message.chain && typeof message.chain.length === "number" || $util.isString(message.chain)))
                        return "chain: buffer expected";
                if (message.mandate != null && message.hasOwnProperty("mandate")) {
                    var error = $root.types.IdentityKeyID.verify(message.mandate);
                    if (error)
                        return "mandate." + error;
                }
                return null;
            };

            /**
             * Creates an Elt message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof types.IdentityPublicChain.Elt
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {types.IdentityPublicChain.Elt} Elt
             */
            Elt.fromObject = function fromObject(object) {
                if (object instanceof $root.types.IdentityPublicChain.Elt)
                    return object;
                var message = new $root.types.IdentityPublicChain.Elt();
                if (object.sign != null)
                    if (typeof object.sign === "string")
                        $util.base64.decode(object.sign, message.sign = $util.newBuffer($util.base64.length(object.sign)), 0);
                    else if (object.sign.length)
                        message.sign = object.sign;
                if (object.box != null)
                    if (typeof object.box === "string")
                        $util.base64.decode(object.box, message.box = $util.newBuffer($util.base64.length(object.box)), 0);
                    else if (object.box.length)
                        message.box = object.box;
                if (object.chain != null)
                    if (typeof object.chain === "string")
                        $util.base64.decode(object.chain, message.chain = $util.newBuffer($util.base64.length(object.chain)), 0);
                    else if (object.chain.length)
                        message.chain = object.chain;
                if (object.mandate != null) {
                    if (typeof object.mandate !== "object")
                        throw TypeError(".types.IdentityPublicChain.Elt.mandate: object expected");
                    message.mandate = $root.types.IdentityKeyID.fromObject(object.mandate);
                }
                return message;
            };

            /**
             * Creates a plain object from an Elt message. Also converts values to other types if specified.
             * @function toObject
             * @memberof types.IdentityPublicChain.Elt
             * @static
             * @param {types.IdentityPublicChain.Elt} message Elt
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Elt.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.sign = options.bytes === String ? "" : [];
                    object.box = options.bytes === String ? "" : [];
                    object.chain = options.bytes === String ? "" : [];
                    object.mandate = null;
                }
                if (message.sign != null && message.hasOwnProperty("sign"))
                    object.sign = options.bytes === String ? $util.base64.encode(message.sign, 0, message.sign.length) : options.bytes === Array ? Array.prototype.slice.call(message.sign) : message.sign;
                if (message.box != null && message.hasOwnProperty("box"))
                    object.box = options.bytes === String ? $util.base64.encode(message.box, 0, message.box.length) : options.bytes === Array ? Array.prototype.slice.call(message.box) : message.box;
                if (message.chain != null && message.hasOwnProperty("chain"))
                    object.chain = options.bytes === String ? $util.base64.encode(message.chain, 0, message.chain.length) : options.bytes === Array ? Array.prototype.slice.call(message.chain) : message.chain;
                if (message.mandate != null && message.hasOwnProperty("mandate"))
                    object.mandate = $root.types.IdentityKeyID.toObject(message.mandate, options);
                return object;
            };

            /**
             * Converts this Elt to JSON.
             * @function toJSON
             * @memberof types.IdentityPublicChain.Elt
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Elt.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Elt;
        })();

        return IdentityPublicChain;
    })();

    types.IdentityEncryptedKey = (function() {

        /**
         * Properties of an IdentityEncryptedKey.
         * @memberof types
         * @interface IIdentityEncryptedKey
         * @property {Uint8Array|null} [nonce] IdentityEncryptedKey nonce
         * @property {Uint8Array|null} [publicKey] IdentityEncryptedKey publicKey
         * @property {Uint8Array|null} [encryptedKey] IdentityEncryptedKey encryptedKey
         */

        /**
         * Constructs a new IdentityEncryptedKey.
         * @memberof types
         * @classdesc Represents an IdentityEncryptedKey.
         * @implements IIdentityEncryptedKey
         * @constructor
         * @param {types.IIdentityEncryptedKey=} [properties] Properties to set
         */
        function IdentityEncryptedKey(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityEncryptedKey nonce.
         * @member {Uint8Array} nonce
         * @memberof types.IdentityEncryptedKey
         * @instance
         */
        IdentityEncryptedKey.prototype.nonce = $util.newBuffer([]);

        /**
         * IdentityEncryptedKey publicKey.
         * @member {Uint8Array} publicKey
         * @memberof types.IdentityEncryptedKey
         * @instance
         */
        IdentityEncryptedKey.prototype.publicKey = $util.newBuffer([]);

        /**
         * IdentityEncryptedKey encryptedKey.
         * @member {Uint8Array} encryptedKey
         * @memberof types.IdentityEncryptedKey
         * @instance
         */
        IdentityEncryptedKey.prototype.encryptedKey = $util.newBuffer([]);

        /**
         * Creates a new IdentityEncryptedKey instance using the specified properties.
         * @function create
         * @memberof types.IdentityEncryptedKey
         * @static
         * @param {types.IIdentityEncryptedKey=} [properties] Properties to set
         * @returns {types.IdentityEncryptedKey} IdentityEncryptedKey instance
         */
        IdentityEncryptedKey.create = function create(properties) {
            return new IdentityEncryptedKey(properties);
        };

        /**
         * Encodes the specified IdentityEncryptedKey message. Does not implicitly {@link types.IdentityEncryptedKey.verify|verify} messages.
         * @function encode
         * @memberof types.IdentityEncryptedKey
         * @static
         * @param {types.IIdentityEncryptedKey} message IdentityEncryptedKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityEncryptedKey.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.nonce);
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.publicKey);
            if (message.encryptedKey != null && message.hasOwnProperty("encryptedKey"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.encryptedKey);
            return writer;
        };

        /**
         * Encodes the specified IdentityEncryptedKey message, length delimited. Does not implicitly {@link types.IdentityEncryptedKey.verify|verify} messages.
         * @function encodeDelimited
         * @memberof types.IdentityEncryptedKey
         * @static
         * @param {types.IIdentityEncryptedKey} message IdentityEncryptedKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityEncryptedKey.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityEncryptedKey message from the specified reader or buffer.
         * @function decode
         * @memberof types.IdentityEncryptedKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {types.IdentityEncryptedKey} IdentityEncryptedKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityEncryptedKey.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.types.IdentityEncryptedKey();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.nonce = reader.bytes();
                    break;
                case 2:
                    message.publicKey = reader.bytes();
                    break;
                case 3:
                    message.encryptedKey = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityEncryptedKey message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof types.IdentityEncryptedKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {types.IdentityEncryptedKey} IdentityEncryptedKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityEncryptedKey.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityEncryptedKey message.
         * @function verify
         * @memberof types.IdentityEncryptedKey
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityEncryptedKey.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                if (!(message.nonce && typeof message.nonce.length === "number" || $util.isString(message.nonce)))
                    return "nonce: buffer expected";
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                if (!(message.publicKey && typeof message.publicKey.length === "number" || $util.isString(message.publicKey)))
                    return "publicKey: buffer expected";
            if (message.encryptedKey != null && message.hasOwnProperty("encryptedKey"))
                if (!(message.encryptedKey && typeof message.encryptedKey.length === "number" || $util.isString(message.encryptedKey)))
                    return "encryptedKey: buffer expected";
            return null;
        };

        /**
         * Creates an IdentityEncryptedKey message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof types.IdentityEncryptedKey
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {types.IdentityEncryptedKey} IdentityEncryptedKey
         */
        IdentityEncryptedKey.fromObject = function fromObject(object) {
            if (object instanceof $root.types.IdentityEncryptedKey)
                return object;
            var message = new $root.types.IdentityEncryptedKey();
            if (object.nonce != null)
                if (typeof object.nonce === "string")
                    $util.base64.decode(object.nonce, message.nonce = $util.newBuffer($util.base64.length(object.nonce)), 0);
                else if (object.nonce.length)
                    message.nonce = object.nonce;
            if (object.publicKey != null)
                if (typeof object.publicKey === "string")
                    $util.base64.decode(object.publicKey, message.publicKey = $util.newBuffer($util.base64.length(object.publicKey)), 0);
                else if (object.publicKey.length)
                    message.publicKey = object.publicKey;
            if (object.encryptedKey != null)
                if (typeof object.encryptedKey === "string")
                    $util.base64.decode(object.encryptedKey, message.encryptedKey = $util.newBuffer($util.base64.length(object.encryptedKey)), 0);
                else if (object.encryptedKey.length)
                    message.encryptedKey = object.encryptedKey;
            return message;
        };

        /**
         * Creates a plain object from an IdentityEncryptedKey message. Also converts values to other types if specified.
         * @function toObject
         * @memberof types.IdentityEncryptedKey
         * @static
         * @param {types.IdentityEncryptedKey} message IdentityEncryptedKey
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityEncryptedKey.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.nonce = options.bytes === String ? "" : [];
                object.publicKey = options.bytes === String ? "" : [];
                object.encryptedKey = options.bytes === String ? "" : [];
            }
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                object.nonce = options.bytes === String ? $util.base64.encode(message.nonce, 0, message.nonce.length) : options.bytes === Array ? Array.prototype.slice.call(message.nonce) : message.nonce;
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                object.publicKey = options.bytes === String ? $util.base64.encode(message.publicKey, 0, message.publicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.publicKey) : message.publicKey;
            if (message.encryptedKey != null && message.hasOwnProperty("encryptedKey"))
                object.encryptedKey = options.bytes === String ? $util.base64.encode(message.encryptedKey, 0, message.encryptedKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedKey) : message.encryptedKey;
            return object;
        };

        /**
         * Converts this IdentityEncryptedKey to JSON.
         * @function toJSON
         * @memberof types.IdentityEncryptedKey
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityEncryptedKey.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityEncryptedKey;
    })();

    types.IdentityEncryption = (function() {

        /**
         * Properties of an IdentityEncryption.
         * @memberof types
         * @interface IIdentityEncryption
         * @property {number|null} [version] IdentityEncryption version
         * @property {Uint8Array|null} [masterSalt] IdentityEncryption masterSalt
         * @property {Uint8Array|null} [masterPublicKey] IdentityEncryption masterPublicKey
         * @property {types.IIdentityEncryptedKey|null} [sharingEncrypted] IdentityEncryption sharingEncrypted
         * @property {types.IIdentityEncryptedKey|null} [boxEncrypted] IdentityEncryption boxEncrypted
         * @property {types.IIdentityEncryptedKey|null} [signEncrypted] IdentityEncryption signEncrypted
         * @property {types.IIdentityEncryptedKey|null} [readEncrypted] IdentityEncryption readEncrypted
         */

        /**
         * Constructs a new IdentityEncryption.
         * @memberof types
         * @classdesc Represents an IdentityEncryption.
         * @implements IIdentityEncryption
         * @constructor
         * @param {types.IIdentityEncryption=} [properties] Properties to set
         */
        function IdentityEncryption(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityEncryption version.
         * @member {number} version
         * @memberof types.IdentityEncryption
         * @instance
         */
        IdentityEncryption.prototype.version = 0;

        /**
         * IdentityEncryption masterSalt.
         * @member {Uint8Array} masterSalt
         * @memberof types.IdentityEncryption
         * @instance
         */
        IdentityEncryption.prototype.masterSalt = $util.newBuffer([]);

        /**
         * IdentityEncryption masterPublicKey.
         * @member {Uint8Array} masterPublicKey
         * @memberof types.IdentityEncryption
         * @instance
         */
        IdentityEncryption.prototype.masterPublicKey = $util.newBuffer([]);

        /**
         * IdentityEncryption sharingEncrypted.
         * @member {types.IIdentityEncryptedKey|null|undefined} sharingEncrypted
         * @memberof types.IdentityEncryption
         * @instance
         */
        IdentityEncryption.prototype.sharingEncrypted = null;

        /**
         * IdentityEncryption boxEncrypted.
         * @member {types.IIdentityEncryptedKey|null|undefined} boxEncrypted
         * @memberof types.IdentityEncryption
         * @instance
         */
        IdentityEncryption.prototype.boxEncrypted = null;

        /**
         * IdentityEncryption signEncrypted.
         * @member {types.IIdentityEncryptedKey|null|undefined} signEncrypted
         * @memberof types.IdentityEncryption
         * @instance
         */
        IdentityEncryption.prototype.signEncrypted = null;

        /**
         * IdentityEncryption readEncrypted.
         * @member {types.IIdentityEncryptedKey|null|undefined} readEncrypted
         * @memberof types.IdentityEncryption
         * @instance
         */
        IdentityEncryption.prototype.readEncrypted = null;

        /**
         * Creates a new IdentityEncryption instance using the specified properties.
         * @function create
         * @memberof types.IdentityEncryption
         * @static
         * @param {types.IIdentityEncryption=} [properties] Properties to set
         * @returns {types.IdentityEncryption} IdentityEncryption instance
         */
        IdentityEncryption.create = function create(properties) {
            return new IdentityEncryption(properties);
        };

        /**
         * Encodes the specified IdentityEncryption message. Does not implicitly {@link types.IdentityEncryption.verify|verify} messages.
         * @function encode
         * @memberof types.IdentityEncryption
         * @static
         * @param {types.IIdentityEncryption} message IdentityEncryption message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityEncryption.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.version != null && message.hasOwnProperty("version"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.version);
            if (message.masterSalt != null && message.hasOwnProperty("masterSalt"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.masterSalt);
            if (message.masterPublicKey != null && message.hasOwnProperty("masterPublicKey"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.masterPublicKey);
            if (message.sharingEncrypted != null && message.hasOwnProperty("sharingEncrypted"))
                $root.types.IdentityEncryptedKey.encode(message.sharingEncrypted, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.boxEncrypted != null && message.hasOwnProperty("boxEncrypted"))
                $root.types.IdentityEncryptedKey.encode(message.boxEncrypted, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.signEncrypted != null && message.hasOwnProperty("signEncrypted"))
                $root.types.IdentityEncryptedKey.encode(message.signEncrypted, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.readEncrypted != null && message.hasOwnProperty("readEncrypted"))
                $root.types.IdentityEncryptedKey.encode(message.readEncrypted, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IdentityEncryption message, length delimited. Does not implicitly {@link types.IdentityEncryption.verify|verify} messages.
         * @function encodeDelimited
         * @memberof types.IdentityEncryption
         * @static
         * @param {types.IIdentityEncryption} message IdentityEncryption message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityEncryption.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityEncryption message from the specified reader or buffer.
         * @function decode
         * @memberof types.IdentityEncryption
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {types.IdentityEncryption} IdentityEncryption
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityEncryption.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.types.IdentityEncryption();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.version = reader.uint32();
                    break;
                case 2:
                    message.masterSalt = reader.bytes();
                    break;
                case 3:
                    message.masterPublicKey = reader.bytes();
                    break;
                case 4:
                    message.sharingEncrypted = $root.types.IdentityEncryptedKey.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.boxEncrypted = $root.types.IdentityEncryptedKey.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.signEncrypted = $root.types.IdentityEncryptedKey.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.readEncrypted = $root.types.IdentityEncryptedKey.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityEncryption message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof types.IdentityEncryption
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {types.IdentityEncryption} IdentityEncryption
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityEncryption.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityEncryption message.
         * @function verify
         * @memberof types.IdentityEncryption
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityEncryption.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isInteger(message.version))
                    return "version: integer expected";
            if (message.masterSalt != null && message.hasOwnProperty("masterSalt"))
                if (!(message.masterSalt && typeof message.masterSalt.length === "number" || $util.isString(message.masterSalt)))
                    return "masterSalt: buffer expected";
            if (message.masterPublicKey != null && message.hasOwnProperty("masterPublicKey"))
                if (!(message.masterPublicKey && typeof message.masterPublicKey.length === "number" || $util.isString(message.masterPublicKey)))
                    return "masterPublicKey: buffer expected";
            if (message.sharingEncrypted != null && message.hasOwnProperty("sharingEncrypted")) {
                var error = $root.types.IdentityEncryptedKey.verify(message.sharingEncrypted);
                if (error)
                    return "sharingEncrypted." + error;
            }
            if (message.boxEncrypted != null && message.hasOwnProperty("boxEncrypted")) {
                var error = $root.types.IdentityEncryptedKey.verify(message.boxEncrypted);
                if (error)
                    return "boxEncrypted." + error;
            }
            if (message.signEncrypted != null && message.hasOwnProperty("signEncrypted")) {
                var error = $root.types.IdentityEncryptedKey.verify(message.signEncrypted);
                if (error)
                    return "signEncrypted." + error;
            }
            if (message.readEncrypted != null && message.hasOwnProperty("readEncrypted")) {
                var error = $root.types.IdentityEncryptedKey.verify(message.readEncrypted);
                if (error)
                    return "readEncrypted." + error;
            }
            return null;
        };

        /**
         * Creates an IdentityEncryption message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof types.IdentityEncryption
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {types.IdentityEncryption} IdentityEncryption
         */
        IdentityEncryption.fromObject = function fromObject(object) {
            if (object instanceof $root.types.IdentityEncryption)
                return object;
            var message = new $root.types.IdentityEncryption();
            if (object.version != null)
                message.version = object.version >>> 0;
            if (object.masterSalt != null)
                if (typeof object.masterSalt === "string")
                    $util.base64.decode(object.masterSalt, message.masterSalt = $util.newBuffer($util.base64.length(object.masterSalt)), 0);
                else if (object.masterSalt.length)
                    message.masterSalt = object.masterSalt;
            if (object.masterPublicKey != null)
                if (typeof object.masterPublicKey === "string")
                    $util.base64.decode(object.masterPublicKey, message.masterPublicKey = $util.newBuffer($util.base64.length(object.masterPublicKey)), 0);
                else if (object.masterPublicKey.length)
                    message.masterPublicKey = object.masterPublicKey;
            if (object.sharingEncrypted != null) {
                if (typeof object.sharingEncrypted !== "object")
                    throw TypeError(".types.IdentityEncryption.sharingEncrypted: object expected");
                message.sharingEncrypted = $root.types.IdentityEncryptedKey.fromObject(object.sharingEncrypted);
            }
            if (object.boxEncrypted != null) {
                if (typeof object.boxEncrypted !== "object")
                    throw TypeError(".types.IdentityEncryption.boxEncrypted: object expected");
                message.boxEncrypted = $root.types.IdentityEncryptedKey.fromObject(object.boxEncrypted);
            }
            if (object.signEncrypted != null) {
                if (typeof object.signEncrypted !== "object")
                    throw TypeError(".types.IdentityEncryption.signEncrypted: object expected");
                message.signEncrypted = $root.types.IdentityEncryptedKey.fromObject(object.signEncrypted);
            }
            if (object.readEncrypted != null) {
                if (typeof object.readEncrypted !== "object")
                    throw TypeError(".types.IdentityEncryption.readEncrypted: object expected");
                message.readEncrypted = $root.types.IdentityEncryptedKey.fromObject(object.readEncrypted);
            }
            return message;
        };

        /**
         * Creates a plain object from an IdentityEncryption message. Also converts values to other types if specified.
         * @function toObject
         * @memberof types.IdentityEncryption
         * @static
         * @param {types.IdentityEncryption} message IdentityEncryption
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityEncryption.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.version = 0;
                object.masterSalt = options.bytes === String ? "" : [];
                object.masterPublicKey = options.bytes === String ? "" : [];
                object.sharingEncrypted = null;
                object.boxEncrypted = null;
                object.signEncrypted = null;
                object.readEncrypted = null;
            }
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            if (message.masterSalt != null && message.hasOwnProperty("masterSalt"))
                object.masterSalt = options.bytes === String ? $util.base64.encode(message.masterSalt, 0, message.masterSalt.length) : options.bytes === Array ? Array.prototype.slice.call(message.masterSalt) : message.masterSalt;
            if (message.masterPublicKey != null && message.hasOwnProperty("masterPublicKey"))
                object.masterPublicKey = options.bytes === String ? $util.base64.encode(message.masterPublicKey, 0, message.masterPublicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.masterPublicKey) : message.masterPublicKey;
            if (message.sharingEncrypted != null && message.hasOwnProperty("sharingEncrypted"))
                object.sharingEncrypted = $root.types.IdentityEncryptedKey.toObject(message.sharingEncrypted, options);
            if (message.boxEncrypted != null && message.hasOwnProperty("boxEncrypted"))
                object.boxEncrypted = $root.types.IdentityEncryptedKey.toObject(message.boxEncrypted, options);
            if (message.signEncrypted != null && message.hasOwnProperty("signEncrypted"))
                object.signEncrypted = $root.types.IdentityEncryptedKey.toObject(message.signEncrypted, options);
            if (message.readEncrypted != null && message.hasOwnProperty("readEncrypted"))
                object.readEncrypted = $root.types.IdentityEncryptedKey.toObject(message.readEncrypted, options);
            return object;
        };

        /**
         * Converts this IdentityEncryption to JSON.
         * @function toJSON
         * @memberof types.IdentityEncryption
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityEncryption.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityEncryption;
    })();

    /**
     * IdentityShareKind enum.
     * @name types.IdentityShareKind
     * @enum {string}
     * @property {number} BOX=0 BOX value
     * @property {number} SHARING=1 SHARING value
     */
    types.IdentityShareKind = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "BOX"] = 0;
        values[valuesById[1] = "SHARING"] = 1;
        return values;
    })();

    /**
     * IdentityAccessKeyKind enum.
     * @name types.IdentityAccessKeyKind
     * @enum {string}
     * @property {number} READ=0 READ value
     * @property {number} WRITE=1 WRITE value
     */
    types.IdentityAccessKeyKind = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "READ"] = 0;
        values[valuesById[1] = "WRITE"] = 1;
        return values;
    })();

    types.IdentityRegisterRequest = (function() {

        /**
         * Properties of an IdentityRegisterRequest.
         * @memberof types
         * @interface IIdentityRegisterRequest
         * @property {types.IIdentityFields|null} [identity] IdentityRegisterRequest identity
         * @property {types.IIdentityEncryption|null} [encryption] IdentityRegisterRequest encryption
         */

        /**
         * Constructs a new IdentityRegisterRequest.
         * @memberof types
         * @classdesc Represents an IdentityRegisterRequest.
         * @implements IIdentityRegisterRequest
         * @constructor
         * @param {types.IIdentityRegisterRequest=} [properties] Properties to set
         */
        function IdentityRegisterRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityRegisterRequest identity.
         * @member {types.IIdentityFields|null|undefined} identity
         * @memberof types.IdentityRegisterRequest
         * @instance
         */
        IdentityRegisterRequest.prototype.identity = null;

        /**
         * IdentityRegisterRequest encryption.
         * @member {types.IIdentityEncryption|null|undefined} encryption
         * @memberof types.IdentityRegisterRequest
         * @instance
         */
        IdentityRegisterRequest.prototype.encryption = null;

        /**
         * Creates a new IdentityRegisterRequest instance using the specified properties.
         * @function create
         * @memberof types.IdentityRegisterRequest
         * @static
         * @param {types.IIdentityRegisterRequest=} [properties] Properties to set
         * @returns {types.IdentityRegisterRequest} IdentityRegisterRequest instance
         */
        IdentityRegisterRequest.create = function create(properties) {
            return new IdentityRegisterRequest(properties);
        };

        /**
         * Encodes the specified IdentityRegisterRequest message. Does not implicitly {@link types.IdentityRegisterRequest.verify|verify} messages.
         * @function encode
         * @memberof types.IdentityRegisterRequest
         * @static
         * @param {types.IIdentityRegisterRequest} message IdentityRegisterRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityRegisterRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.identity != null && message.hasOwnProperty("identity"))
                $root.types.IdentityFields.encode(message.identity, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.encryption != null && message.hasOwnProperty("encryption"))
                $root.types.IdentityEncryption.encode(message.encryption, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IdentityRegisterRequest message, length delimited. Does not implicitly {@link types.IdentityRegisterRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof types.IdentityRegisterRequest
         * @static
         * @param {types.IIdentityRegisterRequest} message IdentityRegisterRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityRegisterRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityRegisterRequest message from the specified reader or buffer.
         * @function decode
         * @memberof types.IdentityRegisterRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {types.IdentityRegisterRequest} IdentityRegisterRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityRegisterRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.types.IdentityRegisterRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.identity = $root.types.IdentityFields.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.encryption = $root.types.IdentityEncryption.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityRegisterRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof types.IdentityRegisterRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {types.IdentityRegisterRequest} IdentityRegisterRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityRegisterRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityRegisterRequest message.
         * @function verify
         * @memberof types.IdentityRegisterRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityRegisterRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.identity != null && message.hasOwnProperty("identity")) {
                var error = $root.types.IdentityFields.verify(message.identity);
                if (error)
                    return "identity." + error;
            }
            if (message.encryption != null && message.hasOwnProperty("encryption")) {
                var error = $root.types.IdentityEncryption.verify(message.encryption);
                if (error)
                    return "encryption." + error;
            }
            return null;
        };

        /**
         * Creates an IdentityRegisterRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof types.IdentityRegisterRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {types.IdentityRegisterRequest} IdentityRegisterRequest
         */
        IdentityRegisterRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.types.IdentityRegisterRequest)
                return object;
            var message = new $root.types.IdentityRegisterRequest();
            if (object.identity != null) {
                if (typeof object.identity !== "object")
                    throw TypeError(".types.IdentityRegisterRequest.identity: object expected");
                message.identity = $root.types.IdentityFields.fromObject(object.identity);
            }
            if (object.encryption != null) {
                if (typeof object.encryption !== "object")
                    throw TypeError(".types.IdentityRegisterRequest.encryption: object expected");
                message.encryption = $root.types.IdentityEncryption.fromObject(object.encryption);
            }
            return message;
        };

        /**
         * Creates a plain object from an IdentityRegisterRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof types.IdentityRegisterRequest
         * @static
         * @param {types.IdentityRegisterRequest} message IdentityRegisterRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityRegisterRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.identity = null;
                object.encryption = null;
            }
            if (message.identity != null && message.hasOwnProperty("identity"))
                object.identity = $root.types.IdentityFields.toObject(message.identity, options);
            if (message.encryption != null && message.hasOwnProperty("encryption"))
                object.encryption = $root.types.IdentityEncryption.toObject(message.encryption, options);
            return object;
        };

        /**
         * Converts this IdentityRegisterRequest to JSON.
         * @function toJSON
         * @memberof types.IdentityRegisterRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityRegisterRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityRegisterRequest;
    })();

    types.IdentityCreateRequest = (function() {

        /**
         * Properties of an IdentityCreateRequest.
         * @memberof types
         * @interface IIdentityCreateRequest
         * @property {types.IIdentityFields|null} [identity] IdentityCreateRequest identity
         * @property {types.IIdentityEncryption|null} [encryption] IdentityCreateRequest encryption
         * @property {Uint8Array|null} [signChain] IdentityCreateRequest signChain
         * @property {Array.<types.IIdentityShareEntry>|null} [sharingGroup] IdentityCreateRequest sharingGroup
         */

        /**
         * Constructs a new IdentityCreateRequest.
         * @memberof types
         * @classdesc Represents an IdentityCreateRequest.
         * @implements IIdentityCreateRequest
         * @constructor
         * @param {types.IIdentityCreateRequest=} [properties] Properties to set
         */
        function IdentityCreateRequest(properties) {
            this.sharingGroup = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityCreateRequest identity.
         * @member {types.IIdentityFields|null|undefined} identity
         * @memberof types.IdentityCreateRequest
         * @instance
         */
        IdentityCreateRequest.prototype.identity = null;

        /**
         * IdentityCreateRequest encryption.
         * @member {types.IIdentityEncryption|null|undefined} encryption
         * @memberof types.IdentityCreateRequest
         * @instance
         */
        IdentityCreateRequest.prototype.encryption = null;

        /**
         * IdentityCreateRequest signChain.
         * @member {Uint8Array} signChain
         * @memberof types.IdentityCreateRequest
         * @instance
         */
        IdentityCreateRequest.prototype.signChain = $util.newBuffer([]);

        /**
         * IdentityCreateRequest sharingGroup.
         * @member {Array.<types.IIdentityShareEntry>} sharingGroup
         * @memberof types.IdentityCreateRequest
         * @instance
         */
        IdentityCreateRequest.prototype.sharingGroup = $util.emptyArray;

        /**
         * Creates a new IdentityCreateRequest instance using the specified properties.
         * @function create
         * @memberof types.IdentityCreateRequest
         * @static
         * @param {types.IIdentityCreateRequest=} [properties] Properties to set
         * @returns {types.IdentityCreateRequest} IdentityCreateRequest instance
         */
        IdentityCreateRequest.create = function create(properties) {
            return new IdentityCreateRequest(properties);
        };

        /**
         * Encodes the specified IdentityCreateRequest message. Does not implicitly {@link types.IdentityCreateRequest.verify|verify} messages.
         * @function encode
         * @memberof types.IdentityCreateRequest
         * @static
         * @param {types.IIdentityCreateRequest} message IdentityCreateRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityCreateRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.identity != null && message.hasOwnProperty("identity"))
                $root.types.IdentityFields.encode(message.identity, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.encryption != null && message.hasOwnProperty("encryption"))
                $root.types.IdentityEncryption.encode(message.encryption, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.signChain != null && message.hasOwnProperty("signChain"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.signChain);
            if (message.sharingGroup != null && message.sharingGroup.length)
                for (var i = 0; i < message.sharingGroup.length; ++i)
                    $root.types.IdentityShareEntry.encode(message.sharingGroup[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IdentityCreateRequest message, length delimited. Does not implicitly {@link types.IdentityCreateRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof types.IdentityCreateRequest
         * @static
         * @param {types.IIdentityCreateRequest} message IdentityCreateRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityCreateRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityCreateRequest message from the specified reader or buffer.
         * @function decode
         * @memberof types.IdentityCreateRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {types.IdentityCreateRequest} IdentityCreateRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityCreateRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.types.IdentityCreateRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.identity = $root.types.IdentityFields.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.encryption = $root.types.IdentityEncryption.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.signChain = reader.bytes();
                    break;
                case 4:
                    if (!(message.sharingGroup && message.sharingGroup.length))
                        message.sharingGroup = [];
                    message.sharingGroup.push($root.types.IdentityShareEntry.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityCreateRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof types.IdentityCreateRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {types.IdentityCreateRequest} IdentityCreateRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityCreateRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityCreateRequest message.
         * @function verify
         * @memberof types.IdentityCreateRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityCreateRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.identity != null && message.hasOwnProperty("identity")) {
                var error = $root.types.IdentityFields.verify(message.identity);
                if (error)
                    return "identity." + error;
            }
            if (message.encryption != null && message.hasOwnProperty("encryption")) {
                var error = $root.types.IdentityEncryption.verify(message.encryption);
                if (error)
                    return "encryption." + error;
            }
            if (message.signChain != null && message.hasOwnProperty("signChain"))
                if (!(message.signChain && typeof message.signChain.length === "number" || $util.isString(message.signChain)))
                    return "signChain: buffer expected";
            if (message.sharingGroup != null && message.hasOwnProperty("sharingGroup")) {
                if (!Array.isArray(message.sharingGroup))
                    return "sharingGroup: array expected";
                for (var i = 0; i < message.sharingGroup.length; ++i) {
                    var error = $root.types.IdentityShareEntry.verify(message.sharingGroup[i]);
                    if (error)
                        return "sharingGroup." + error;
                }
            }
            return null;
        };

        /**
         * Creates an IdentityCreateRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof types.IdentityCreateRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {types.IdentityCreateRequest} IdentityCreateRequest
         */
        IdentityCreateRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.types.IdentityCreateRequest)
                return object;
            var message = new $root.types.IdentityCreateRequest();
            if (object.identity != null) {
                if (typeof object.identity !== "object")
                    throw TypeError(".types.IdentityCreateRequest.identity: object expected");
                message.identity = $root.types.IdentityFields.fromObject(object.identity);
            }
            if (object.encryption != null) {
                if (typeof object.encryption !== "object")
                    throw TypeError(".types.IdentityCreateRequest.encryption: object expected");
                message.encryption = $root.types.IdentityEncryption.fromObject(object.encryption);
            }
            if (object.signChain != null)
                if (typeof object.signChain === "string")
                    $util.base64.decode(object.signChain, message.signChain = $util.newBuffer($util.base64.length(object.signChain)), 0);
                else if (object.signChain.length)
                    message.signChain = object.signChain;
            if (object.sharingGroup) {
                if (!Array.isArray(object.sharingGroup))
                    throw TypeError(".types.IdentityCreateRequest.sharingGroup: array expected");
                message.sharingGroup = [];
                for (var i = 0; i < object.sharingGroup.length; ++i) {
                    if (typeof object.sharingGroup[i] !== "object")
                        throw TypeError(".types.IdentityCreateRequest.sharingGroup: object expected");
                    message.sharingGroup[i] = $root.types.IdentityShareEntry.fromObject(object.sharingGroup[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an IdentityCreateRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof types.IdentityCreateRequest
         * @static
         * @param {types.IdentityCreateRequest} message IdentityCreateRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityCreateRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.sharingGroup = [];
            if (options.defaults) {
                object.identity = null;
                object.encryption = null;
                object.signChain = options.bytes === String ? "" : [];
            }
            if (message.identity != null && message.hasOwnProperty("identity"))
                object.identity = $root.types.IdentityFields.toObject(message.identity, options);
            if (message.encryption != null && message.hasOwnProperty("encryption"))
                object.encryption = $root.types.IdentityEncryption.toObject(message.encryption, options);
            if (message.signChain != null && message.hasOwnProperty("signChain"))
                object.signChain = options.bytes === String ? $util.base64.encode(message.signChain, 0, message.signChain.length) : options.bytes === Array ? Array.prototype.slice.call(message.signChain) : message.signChain;
            if (message.sharingGroup && message.sharingGroup.length) {
                object.sharingGroup = [];
                for (var j = 0; j < message.sharingGroup.length; ++j)
                    object.sharingGroup[j] = $root.types.IdentityShareEntry.toObject(message.sharingGroup[j], options);
            }
            return object;
        };

        /**
         * Converts this IdentityCreateRequest to JSON.
         * @function toJSON
         * @memberof types.IdentityCreateRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityCreateRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityCreateRequest;
    })();

    types.IdentityKeysToReplaceRequest = (function() {

        /**
         * Properties of an IdentityKeysToReplaceRequest.
         * @memberof types
         * @interface IIdentityKeysToReplaceRequest
         * @property {string|null} [login] IdentityKeysToReplaceRequest login
         * @property {types.IIdentityEncryption|null} [encryption] IdentityKeysToReplaceRequest encryption
         * @property {Uint8Array|null} [signChain] IdentityKeysToReplaceRequest signChain
         * @property {Array.<types.IIdentityShareEntry>|null} [sharingGroup] IdentityKeysToReplaceRequest sharingGroup
         */

        /**
         * Constructs a new IdentityKeysToReplaceRequest.
         * @memberof types
         * @classdesc Represents an IdentityKeysToReplaceRequest.
         * @implements IIdentityKeysToReplaceRequest
         * @constructor
         * @param {types.IIdentityKeysToReplaceRequest=} [properties] Properties to set
         */
        function IdentityKeysToReplaceRequest(properties) {
            this.sharingGroup = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityKeysToReplaceRequest login.
         * @member {string} login
         * @memberof types.IdentityKeysToReplaceRequest
         * @instance
         */
        IdentityKeysToReplaceRequest.prototype.login = "";

        /**
         * IdentityKeysToReplaceRequest encryption.
         * @member {types.IIdentityEncryption|null|undefined} encryption
         * @memberof types.IdentityKeysToReplaceRequest
         * @instance
         */
        IdentityKeysToReplaceRequest.prototype.encryption = null;

        /**
         * IdentityKeysToReplaceRequest signChain.
         * @member {Uint8Array} signChain
         * @memberof types.IdentityKeysToReplaceRequest
         * @instance
         */
        IdentityKeysToReplaceRequest.prototype.signChain = $util.newBuffer([]);

        /**
         * IdentityKeysToReplaceRequest sharingGroup.
         * @member {Array.<types.IIdentityShareEntry>} sharingGroup
         * @memberof types.IdentityKeysToReplaceRequest
         * @instance
         */
        IdentityKeysToReplaceRequest.prototype.sharingGroup = $util.emptyArray;

        /**
         * Creates a new IdentityKeysToReplaceRequest instance using the specified properties.
         * @function create
         * @memberof types.IdentityKeysToReplaceRequest
         * @static
         * @param {types.IIdentityKeysToReplaceRequest=} [properties] Properties to set
         * @returns {types.IdentityKeysToReplaceRequest} IdentityKeysToReplaceRequest instance
         */
        IdentityKeysToReplaceRequest.create = function create(properties) {
            return new IdentityKeysToReplaceRequest(properties);
        };

        /**
         * Encodes the specified IdentityKeysToReplaceRequest message. Does not implicitly {@link types.IdentityKeysToReplaceRequest.verify|verify} messages.
         * @function encode
         * @memberof types.IdentityKeysToReplaceRequest
         * @static
         * @param {types.IIdentityKeysToReplaceRequest} message IdentityKeysToReplaceRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityKeysToReplaceRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            if (message.encryption != null && message.hasOwnProperty("encryption"))
                $root.types.IdentityEncryption.encode(message.encryption, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.signChain != null && message.hasOwnProperty("signChain"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.signChain);
            if (message.sharingGroup != null && message.sharingGroup.length)
                for (var i = 0; i < message.sharingGroup.length; ++i)
                    $root.types.IdentityShareEntry.encode(message.sharingGroup[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IdentityKeysToReplaceRequest message, length delimited. Does not implicitly {@link types.IdentityKeysToReplaceRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof types.IdentityKeysToReplaceRequest
         * @static
         * @param {types.IIdentityKeysToReplaceRequest} message IdentityKeysToReplaceRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityKeysToReplaceRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityKeysToReplaceRequest message from the specified reader or buffer.
         * @function decode
         * @memberof types.IdentityKeysToReplaceRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {types.IdentityKeysToReplaceRequest} IdentityKeysToReplaceRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityKeysToReplaceRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.types.IdentityKeysToReplaceRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                case 2:
                    message.encryption = $root.types.IdentityEncryption.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.signChain = reader.bytes();
                    break;
                case 4:
                    if (!(message.sharingGroup && message.sharingGroup.length))
                        message.sharingGroup = [];
                    message.sharingGroup.push($root.types.IdentityShareEntry.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityKeysToReplaceRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof types.IdentityKeysToReplaceRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {types.IdentityKeysToReplaceRequest} IdentityKeysToReplaceRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityKeysToReplaceRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityKeysToReplaceRequest message.
         * @function verify
         * @memberof types.IdentityKeysToReplaceRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityKeysToReplaceRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            if (message.encryption != null && message.hasOwnProperty("encryption")) {
                var error = $root.types.IdentityEncryption.verify(message.encryption);
                if (error)
                    return "encryption." + error;
            }
            if (message.signChain != null && message.hasOwnProperty("signChain"))
                if (!(message.signChain && typeof message.signChain.length === "number" || $util.isString(message.signChain)))
                    return "signChain: buffer expected";
            if (message.sharingGroup != null && message.hasOwnProperty("sharingGroup")) {
                if (!Array.isArray(message.sharingGroup))
                    return "sharingGroup: array expected";
                for (var i = 0; i < message.sharingGroup.length; ++i) {
                    var error = $root.types.IdentityShareEntry.verify(message.sharingGroup[i]);
                    if (error)
                        return "sharingGroup." + error;
                }
            }
            return null;
        };

        /**
         * Creates an IdentityKeysToReplaceRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof types.IdentityKeysToReplaceRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {types.IdentityKeysToReplaceRequest} IdentityKeysToReplaceRequest
         */
        IdentityKeysToReplaceRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.types.IdentityKeysToReplaceRequest)
                return object;
            var message = new $root.types.IdentityKeysToReplaceRequest();
            if (object.login != null)
                message.login = String(object.login);
            if (object.encryption != null) {
                if (typeof object.encryption !== "object")
                    throw TypeError(".types.IdentityKeysToReplaceRequest.encryption: object expected");
                message.encryption = $root.types.IdentityEncryption.fromObject(object.encryption);
            }
            if (object.signChain != null)
                if (typeof object.signChain === "string")
                    $util.base64.decode(object.signChain, message.signChain = $util.newBuffer($util.base64.length(object.signChain)), 0);
                else if (object.signChain.length)
                    message.signChain = object.signChain;
            if (object.sharingGroup) {
                if (!Array.isArray(object.sharingGroup))
                    throw TypeError(".types.IdentityKeysToReplaceRequest.sharingGroup: array expected");
                message.sharingGroup = [];
                for (var i = 0; i < object.sharingGroup.length; ++i) {
                    if (typeof object.sharingGroup[i] !== "object")
                        throw TypeError(".types.IdentityKeysToReplaceRequest.sharingGroup: object expected");
                    message.sharingGroup[i] = $root.types.IdentityShareEntry.fromObject(object.sharingGroup[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an IdentityKeysToReplaceRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof types.IdentityKeysToReplaceRequest
         * @static
         * @param {types.IdentityKeysToReplaceRequest} message IdentityKeysToReplaceRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityKeysToReplaceRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.sharingGroup = [];
            if (options.defaults) {
                object.login = "";
                object.encryption = null;
                object.signChain = options.bytes === String ? "" : [];
            }
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            if (message.encryption != null && message.hasOwnProperty("encryption"))
                object.encryption = $root.types.IdentityEncryption.toObject(message.encryption, options);
            if (message.signChain != null && message.hasOwnProperty("signChain"))
                object.signChain = options.bytes === String ? $util.base64.encode(message.signChain, 0, message.signChain.length) : options.bytes === Array ? Array.prototype.slice.call(message.signChain) : message.signChain;
            if (message.sharingGroup && message.sharingGroup.length) {
                object.sharingGroup = [];
                for (var j = 0; j < message.sharingGroup.length; ++j)
                    object.sharingGroup[j] = $root.types.IdentityShareEntry.toObject(message.sharingGroup[j], options);
            }
            return object;
        };

        /**
         * Converts this IdentityKeysToReplaceRequest to JSON.
         * @function toJSON
         * @memberof types.IdentityKeysToReplaceRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityKeysToReplaceRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityKeysToReplaceRequest;
    })();

    types.IdentityListResponse = (function() {

        /**
         * Properties of an IdentityListResponse.
         * @memberof types
         * @interface IIdentityListResponse
         * @property {Array.<types.IIdentity>|null} [identities] IdentityListResponse identities
         */

        /**
         * Constructs a new IdentityListResponse.
         * @memberof types
         * @classdesc Represents an IdentityListResponse.
         * @implements IIdentityListResponse
         * @constructor
         * @param {types.IIdentityListResponse=} [properties] Properties to set
         */
        function IdentityListResponse(properties) {
            this.identities = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityListResponse identities.
         * @member {Array.<types.IIdentity>} identities
         * @memberof types.IdentityListResponse
         * @instance
         */
        IdentityListResponse.prototype.identities = $util.emptyArray;

        /**
         * Creates a new IdentityListResponse instance using the specified properties.
         * @function create
         * @memberof types.IdentityListResponse
         * @static
         * @param {types.IIdentityListResponse=} [properties] Properties to set
         * @returns {types.IdentityListResponse} IdentityListResponse instance
         */
        IdentityListResponse.create = function create(properties) {
            return new IdentityListResponse(properties);
        };

        /**
         * Encodes the specified IdentityListResponse message. Does not implicitly {@link types.IdentityListResponse.verify|verify} messages.
         * @function encode
         * @memberof types.IdentityListResponse
         * @static
         * @param {types.IIdentityListResponse} message IdentityListResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityListResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.identities != null && message.identities.length)
                for (var i = 0; i < message.identities.length; ++i)
                    $root.types.Identity.encode(message.identities[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IdentityListResponse message, length delimited. Does not implicitly {@link types.IdentityListResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof types.IdentityListResponse
         * @static
         * @param {types.IIdentityListResponse} message IdentityListResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityListResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityListResponse message from the specified reader or buffer.
         * @function decode
         * @memberof types.IdentityListResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {types.IdentityListResponse} IdentityListResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityListResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.types.IdentityListResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.identities && message.identities.length))
                        message.identities = [];
                    message.identities.push($root.types.Identity.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityListResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof types.IdentityListResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {types.IdentityListResponse} IdentityListResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityListResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityListResponse message.
         * @function verify
         * @memberof types.IdentityListResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityListResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.identities != null && message.hasOwnProperty("identities")) {
                if (!Array.isArray(message.identities))
                    return "identities: array expected";
                for (var i = 0; i < message.identities.length; ++i) {
                    var error = $root.types.Identity.verify(message.identities[i]);
                    if (error)
                        return "identities." + error;
                }
            }
            return null;
        };

        /**
         * Creates an IdentityListResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof types.IdentityListResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {types.IdentityListResponse} IdentityListResponse
         */
        IdentityListResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.types.IdentityListResponse)
                return object;
            var message = new $root.types.IdentityListResponse();
            if (object.identities) {
                if (!Array.isArray(object.identities))
                    throw TypeError(".types.IdentityListResponse.identities: array expected");
                message.identities = [];
                for (var i = 0; i < object.identities.length; ++i) {
                    if (typeof object.identities[i] !== "object")
                        throw TypeError(".types.IdentityListResponse.identities: object expected");
                    message.identities[i] = $root.types.Identity.fromObject(object.identities[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an IdentityListResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof types.IdentityListResponse
         * @static
         * @param {types.IdentityListResponse} message IdentityListResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityListResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.identities = [];
            if (message.identities && message.identities.length) {
                object.identities = [];
                for (var j = 0; j < message.identities.length; ++j)
                    object.identities[j] = $root.types.Identity.toObject(message.identities[j], options);
            }
            return object;
        };

        /**
         * Converts this IdentityListResponse to JSON.
         * @function toJSON
         * @memberof types.IdentityListResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityListResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityListResponse;
    })();

    types.IdentityPromoteRequest = (function() {

        /**
         * Properties of an IdentityPromoteRequest.
         * @memberof types
         * @interface IIdentityPromoteRequest
         * @property {string|null} [login] IdentityPromoteRequest login
         * @property {boolean|null} [admin] IdentityPromoteRequest admin
         */

        /**
         * Constructs a new IdentityPromoteRequest.
         * @memberof types
         * @classdesc Represents an IdentityPromoteRequest.
         * @implements IIdentityPromoteRequest
         * @constructor
         * @param {types.IIdentityPromoteRequest=} [properties] Properties to set
         */
        function IdentityPromoteRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityPromoteRequest login.
         * @member {string} login
         * @memberof types.IdentityPromoteRequest
         * @instance
         */
        IdentityPromoteRequest.prototype.login = "";

        /**
         * IdentityPromoteRequest admin.
         * @member {boolean} admin
         * @memberof types.IdentityPromoteRequest
         * @instance
         */
        IdentityPromoteRequest.prototype.admin = false;

        /**
         * Creates a new IdentityPromoteRequest instance using the specified properties.
         * @function create
         * @memberof types.IdentityPromoteRequest
         * @static
         * @param {types.IIdentityPromoteRequest=} [properties] Properties to set
         * @returns {types.IdentityPromoteRequest} IdentityPromoteRequest instance
         */
        IdentityPromoteRequest.create = function create(properties) {
            return new IdentityPromoteRequest(properties);
        };

        /**
         * Encodes the specified IdentityPromoteRequest message. Does not implicitly {@link types.IdentityPromoteRequest.verify|verify} messages.
         * @function encode
         * @memberof types.IdentityPromoteRequest
         * @static
         * @param {types.IIdentityPromoteRequest} message IdentityPromoteRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityPromoteRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            if (message.admin != null && message.hasOwnProperty("admin"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.admin);
            return writer;
        };

        /**
         * Encodes the specified IdentityPromoteRequest message, length delimited. Does not implicitly {@link types.IdentityPromoteRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof types.IdentityPromoteRequest
         * @static
         * @param {types.IIdentityPromoteRequest} message IdentityPromoteRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityPromoteRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityPromoteRequest message from the specified reader or buffer.
         * @function decode
         * @memberof types.IdentityPromoteRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {types.IdentityPromoteRequest} IdentityPromoteRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityPromoteRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.types.IdentityPromoteRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                case 2:
                    message.admin = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityPromoteRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof types.IdentityPromoteRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {types.IdentityPromoteRequest} IdentityPromoteRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityPromoteRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityPromoteRequest message.
         * @function verify
         * @memberof types.IdentityPromoteRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityPromoteRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            if (message.admin != null && message.hasOwnProperty("admin"))
                if (typeof message.admin !== "boolean")
                    return "admin: boolean expected";
            return null;
        };

        /**
         * Creates an IdentityPromoteRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof types.IdentityPromoteRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {types.IdentityPromoteRequest} IdentityPromoteRequest
         */
        IdentityPromoteRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.types.IdentityPromoteRequest)
                return object;
            var message = new $root.types.IdentityPromoteRequest();
            if (object.login != null)
                message.login = String(object.login);
            if (object.admin != null)
                message.admin = Boolean(object.admin);
            return message;
        };

        /**
         * Creates a plain object from an IdentityPromoteRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof types.IdentityPromoteRequest
         * @static
         * @param {types.IdentityPromoteRequest} message IdentityPromoteRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityPromoteRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.login = "";
                object.admin = false;
            }
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            if (message.admin != null && message.hasOwnProperty("admin"))
                object.admin = message.admin;
            return object;
        };

        /**
         * Converts this IdentityPromoteRequest to JSON.
         * @function toJSON
         * @memberof types.IdentityPromoteRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityPromoteRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityPromoteRequest;
    })();

    types.IdentityGetKeysResponse = (function() {

        /**
         * Properties of an IdentityGetKeysResponse.
         * @memberof types
         * @interface IIdentityGetKeysResponse
         * @property {Array.<types.ICipher>|null} [sharingKey] IdentityGetKeysResponse sharingKey
         * @property {types.ICipher|null} [signKey] IdentityGetKeysResponse signKey
         * @property {types.ICipher|null} [boxKey] IdentityGetKeysResponse boxKey
         * @property {types.ICipher|null} [readKey] IdentityGetKeysResponse readKey
         * @property {number|null} [version] IdentityGetKeysResponse version
         */

        /**
         * Constructs a new IdentityGetKeysResponse.
         * @memberof types
         * @classdesc Represents an IdentityGetKeysResponse.
         * @implements IIdentityGetKeysResponse
         * @constructor
         * @param {types.IIdentityGetKeysResponse=} [properties] Properties to set
         */
        function IdentityGetKeysResponse(properties) {
            this.sharingKey = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityGetKeysResponse sharingKey.
         * @member {Array.<types.ICipher>} sharingKey
         * @memberof types.IdentityGetKeysResponse
         * @instance
         */
        IdentityGetKeysResponse.prototype.sharingKey = $util.emptyArray;

        /**
         * IdentityGetKeysResponse signKey.
         * @member {types.ICipher|null|undefined} signKey
         * @memberof types.IdentityGetKeysResponse
         * @instance
         */
        IdentityGetKeysResponse.prototype.signKey = null;

        /**
         * IdentityGetKeysResponse boxKey.
         * @member {types.ICipher|null|undefined} boxKey
         * @memberof types.IdentityGetKeysResponse
         * @instance
         */
        IdentityGetKeysResponse.prototype.boxKey = null;

        /**
         * IdentityGetKeysResponse readKey.
         * @member {types.ICipher|null|undefined} readKey
         * @memberof types.IdentityGetKeysResponse
         * @instance
         */
        IdentityGetKeysResponse.prototype.readKey = null;

        /**
         * IdentityGetKeysResponse version.
         * @member {number} version
         * @memberof types.IdentityGetKeysResponse
         * @instance
         */
        IdentityGetKeysResponse.prototype.version = 0;

        /**
         * Creates a new IdentityGetKeysResponse instance using the specified properties.
         * @function create
         * @memberof types.IdentityGetKeysResponse
         * @static
         * @param {types.IIdentityGetKeysResponse=} [properties] Properties to set
         * @returns {types.IdentityGetKeysResponse} IdentityGetKeysResponse instance
         */
        IdentityGetKeysResponse.create = function create(properties) {
            return new IdentityGetKeysResponse(properties);
        };

        /**
         * Encodes the specified IdentityGetKeysResponse message. Does not implicitly {@link types.IdentityGetKeysResponse.verify|verify} messages.
         * @function encode
         * @memberof types.IdentityGetKeysResponse
         * @static
         * @param {types.IIdentityGetKeysResponse} message IdentityGetKeysResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetKeysResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.sharingKey != null && message.sharingKey.length)
                for (var i = 0; i < message.sharingKey.length; ++i)
                    $root.types.Cipher.encode(message.sharingKey[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.signKey != null && message.hasOwnProperty("signKey"))
                $root.types.Cipher.encode(message.signKey, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.boxKey != null && message.hasOwnProperty("boxKey"))
                $root.types.Cipher.encode(message.boxKey, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.readKey != null && message.hasOwnProperty("readKey"))
                $root.types.Cipher.encode(message.readKey, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.version != null && message.hasOwnProperty("version"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.version);
            return writer;
        };

        /**
         * Encodes the specified IdentityGetKeysResponse message, length delimited. Does not implicitly {@link types.IdentityGetKeysResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof types.IdentityGetKeysResponse
         * @static
         * @param {types.IIdentityGetKeysResponse} message IdentityGetKeysResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetKeysResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityGetKeysResponse message from the specified reader or buffer.
         * @function decode
         * @memberof types.IdentityGetKeysResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {types.IdentityGetKeysResponse} IdentityGetKeysResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetKeysResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.types.IdentityGetKeysResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.sharingKey && message.sharingKey.length))
                        message.sharingKey = [];
                    message.sharingKey.push($root.types.Cipher.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.signKey = $root.types.Cipher.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.boxKey = $root.types.Cipher.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.readKey = $root.types.Cipher.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.version = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityGetKeysResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof types.IdentityGetKeysResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {types.IdentityGetKeysResponse} IdentityGetKeysResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetKeysResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityGetKeysResponse message.
         * @function verify
         * @memberof types.IdentityGetKeysResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityGetKeysResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.sharingKey != null && message.hasOwnProperty("sharingKey")) {
                if (!Array.isArray(message.sharingKey))
                    return "sharingKey: array expected";
                for (var i = 0; i < message.sharingKey.length; ++i) {
                    var error = $root.types.Cipher.verify(message.sharingKey[i]);
                    if (error)
                        return "sharingKey." + error;
                }
            }
            if (message.signKey != null && message.hasOwnProperty("signKey")) {
                var error = $root.types.Cipher.verify(message.signKey);
                if (error)
                    return "signKey." + error;
            }
            if (message.boxKey != null && message.hasOwnProperty("boxKey")) {
                var error = $root.types.Cipher.verify(message.boxKey);
                if (error)
                    return "boxKey." + error;
            }
            if (message.readKey != null && message.hasOwnProperty("readKey")) {
                var error = $root.types.Cipher.verify(message.readKey);
                if (error)
                    return "readKey." + error;
            }
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isInteger(message.version))
                    return "version: integer expected";
            return null;
        };

        /**
         * Creates an IdentityGetKeysResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof types.IdentityGetKeysResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {types.IdentityGetKeysResponse} IdentityGetKeysResponse
         */
        IdentityGetKeysResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.types.IdentityGetKeysResponse)
                return object;
            var message = new $root.types.IdentityGetKeysResponse();
            if (object.sharingKey) {
                if (!Array.isArray(object.sharingKey))
                    throw TypeError(".types.IdentityGetKeysResponse.sharingKey: array expected");
                message.sharingKey = [];
                for (var i = 0; i < object.sharingKey.length; ++i) {
                    if (typeof object.sharingKey[i] !== "object")
                        throw TypeError(".types.IdentityGetKeysResponse.sharingKey: object expected");
                    message.sharingKey[i] = $root.types.Cipher.fromObject(object.sharingKey[i]);
                }
            }
            if (object.signKey != null) {
                if (typeof object.signKey !== "object")
                    throw TypeError(".types.IdentityGetKeysResponse.signKey: object expected");
                message.signKey = $root.types.Cipher.fromObject(object.signKey);
            }
            if (object.boxKey != null) {
                if (typeof object.boxKey !== "object")
                    throw TypeError(".types.IdentityGetKeysResponse.boxKey: object expected");
                message.boxKey = $root.types.Cipher.fromObject(object.boxKey);
            }
            if (object.readKey != null) {
                if (typeof object.readKey !== "object")
                    throw TypeError(".types.IdentityGetKeysResponse.readKey: object expected");
                message.readKey = $root.types.Cipher.fromObject(object.readKey);
            }
            if (object.version != null)
                message.version = object.version >>> 0;
            return message;
        };

        /**
         * Creates a plain object from an IdentityGetKeysResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof types.IdentityGetKeysResponse
         * @static
         * @param {types.IdentityGetKeysResponse} message IdentityGetKeysResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityGetKeysResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.sharingKey = [];
            if (options.defaults) {
                object.signKey = null;
                object.boxKey = null;
                object.readKey = null;
                object.version = 0;
            }
            if (message.sharingKey && message.sharingKey.length) {
                object.sharingKey = [];
                for (var j = 0; j < message.sharingKey.length; ++j)
                    object.sharingKey[j] = $root.types.Cipher.toObject(message.sharingKey[j], options);
            }
            if (message.signKey != null && message.hasOwnProperty("signKey"))
                object.signKey = $root.types.Cipher.toObject(message.signKey, options);
            if (message.boxKey != null && message.hasOwnProperty("boxKey"))
                object.boxKey = $root.types.Cipher.toObject(message.boxKey, options);
            if (message.readKey != null && message.hasOwnProperty("readKey"))
                object.readKey = $root.types.Cipher.toObject(message.readKey, options);
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            return object;
        };

        /**
         * Converts this IdentityGetKeysResponse to JSON.
         * @function toJSON
         * @memberof types.IdentityGetKeysResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityGetKeysResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityGetKeysResponse;
    })();

    types.IdentityGetPublicKeysRequest = (function() {

        /**
         * Properties of an IdentityGetPublicKeysRequest.
         * @memberof types
         * @interface IIdentityGetPublicKeysRequest
         * @property {Array.<types.IIdentityKeyID>|null} [ids] IdentityGetPublicKeysRequest ids
         */

        /**
         * Constructs a new IdentityGetPublicKeysRequest.
         * @memberof types
         * @classdesc Represents an IdentityGetPublicKeysRequest.
         * @implements IIdentityGetPublicKeysRequest
         * @constructor
         * @param {types.IIdentityGetPublicKeysRequest=} [properties] Properties to set
         */
        function IdentityGetPublicKeysRequest(properties) {
            this.ids = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityGetPublicKeysRequest ids.
         * @member {Array.<types.IIdentityKeyID>} ids
         * @memberof types.IdentityGetPublicKeysRequest
         * @instance
         */
        IdentityGetPublicKeysRequest.prototype.ids = $util.emptyArray;

        /**
         * Creates a new IdentityGetPublicKeysRequest instance using the specified properties.
         * @function create
         * @memberof types.IdentityGetPublicKeysRequest
         * @static
         * @param {types.IIdentityGetPublicKeysRequest=} [properties] Properties to set
         * @returns {types.IdentityGetPublicKeysRequest} IdentityGetPublicKeysRequest instance
         */
        IdentityGetPublicKeysRequest.create = function create(properties) {
            return new IdentityGetPublicKeysRequest(properties);
        };

        /**
         * Encodes the specified IdentityGetPublicKeysRequest message. Does not implicitly {@link types.IdentityGetPublicKeysRequest.verify|verify} messages.
         * @function encode
         * @memberof types.IdentityGetPublicKeysRequest
         * @static
         * @param {types.IIdentityGetPublicKeysRequest} message IdentityGetPublicKeysRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetPublicKeysRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ids != null && message.ids.length)
                for (var i = 0; i < message.ids.length; ++i)
                    $root.types.IdentityKeyID.encode(message.ids[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IdentityGetPublicKeysRequest message, length delimited. Does not implicitly {@link types.IdentityGetPublicKeysRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof types.IdentityGetPublicKeysRequest
         * @static
         * @param {types.IIdentityGetPublicKeysRequest} message IdentityGetPublicKeysRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetPublicKeysRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityGetPublicKeysRequest message from the specified reader or buffer.
         * @function decode
         * @memberof types.IdentityGetPublicKeysRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {types.IdentityGetPublicKeysRequest} IdentityGetPublicKeysRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetPublicKeysRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.types.IdentityGetPublicKeysRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.ids && message.ids.length))
                        message.ids = [];
                    message.ids.push($root.types.IdentityKeyID.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityGetPublicKeysRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof types.IdentityGetPublicKeysRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {types.IdentityGetPublicKeysRequest} IdentityGetPublicKeysRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetPublicKeysRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityGetPublicKeysRequest message.
         * @function verify
         * @memberof types.IdentityGetPublicKeysRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityGetPublicKeysRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ids != null && message.hasOwnProperty("ids")) {
                if (!Array.isArray(message.ids))
                    return "ids: array expected";
                for (var i = 0; i < message.ids.length; ++i) {
                    var error = $root.types.IdentityKeyID.verify(message.ids[i]);
                    if (error)
                        return "ids." + error;
                }
            }
            return null;
        };

        /**
         * Creates an IdentityGetPublicKeysRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof types.IdentityGetPublicKeysRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {types.IdentityGetPublicKeysRequest} IdentityGetPublicKeysRequest
         */
        IdentityGetPublicKeysRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.types.IdentityGetPublicKeysRequest)
                return object;
            var message = new $root.types.IdentityGetPublicKeysRequest();
            if (object.ids) {
                if (!Array.isArray(object.ids))
                    throw TypeError(".types.IdentityGetPublicKeysRequest.ids: array expected");
                message.ids = [];
                for (var i = 0; i < object.ids.length; ++i) {
                    if (typeof object.ids[i] !== "object")
                        throw TypeError(".types.IdentityGetPublicKeysRequest.ids: object expected");
                    message.ids[i] = $root.types.IdentityKeyID.fromObject(object.ids[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an IdentityGetPublicKeysRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof types.IdentityGetPublicKeysRequest
         * @static
         * @param {types.IdentityGetPublicKeysRequest} message IdentityGetPublicKeysRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityGetPublicKeysRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.ids = [];
            if (message.ids && message.ids.length) {
                object.ids = [];
                for (var j = 0; j < message.ids.length; ++j)
                    object.ids[j] = $root.types.IdentityKeyID.toObject(message.ids[j], options);
            }
            return object;
        };

        /**
         * Converts this IdentityGetPublicKeysRequest to JSON.
         * @function toJSON
         * @memberof types.IdentityGetPublicKeysRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityGetPublicKeysRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityGetPublicKeysRequest;
    })();

    types.IdentityGetPublicKeysResponse = (function() {

        /**
         * Properties of an IdentityGetPublicKeysResponse.
         * @memberof types
         * @interface IIdentityGetPublicKeysResponse
         * @property {Array.<types.IIdentityPublicKey>|null} [publicKeys] IdentityGetPublicKeysResponse publicKeys
         */

        /**
         * Constructs a new IdentityGetPublicKeysResponse.
         * @memberof types
         * @classdesc Represents an IdentityGetPublicKeysResponse.
         * @implements IIdentityGetPublicKeysResponse
         * @constructor
         * @param {types.IIdentityGetPublicKeysResponse=} [properties] Properties to set
         */
        function IdentityGetPublicKeysResponse(properties) {
            this.publicKeys = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityGetPublicKeysResponse publicKeys.
         * @member {Array.<types.IIdentityPublicKey>} publicKeys
         * @memberof types.IdentityGetPublicKeysResponse
         * @instance
         */
        IdentityGetPublicKeysResponse.prototype.publicKeys = $util.emptyArray;

        /**
         * Creates a new IdentityGetPublicKeysResponse instance using the specified properties.
         * @function create
         * @memberof types.IdentityGetPublicKeysResponse
         * @static
         * @param {types.IIdentityGetPublicKeysResponse=} [properties] Properties to set
         * @returns {types.IdentityGetPublicKeysResponse} IdentityGetPublicKeysResponse instance
         */
        IdentityGetPublicKeysResponse.create = function create(properties) {
            return new IdentityGetPublicKeysResponse(properties);
        };

        /**
         * Encodes the specified IdentityGetPublicKeysResponse message. Does not implicitly {@link types.IdentityGetPublicKeysResponse.verify|verify} messages.
         * @function encode
         * @memberof types.IdentityGetPublicKeysResponse
         * @static
         * @param {types.IIdentityGetPublicKeysResponse} message IdentityGetPublicKeysResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetPublicKeysResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.publicKeys != null && message.publicKeys.length)
                for (var i = 0; i < message.publicKeys.length; ++i)
                    $root.types.IdentityPublicKey.encode(message.publicKeys[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IdentityGetPublicKeysResponse message, length delimited. Does not implicitly {@link types.IdentityGetPublicKeysResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof types.IdentityGetPublicKeysResponse
         * @static
         * @param {types.IIdentityGetPublicKeysResponse} message IdentityGetPublicKeysResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetPublicKeysResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityGetPublicKeysResponse message from the specified reader or buffer.
         * @function decode
         * @memberof types.IdentityGetPublicKeysResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {types.IdentityGetPublicKeysResponse} IdentityGetPublicKeysResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetPublicKeysResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.types.IdentityGetPublicKeysResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.publicKeys && message.publicKeys.length))
                        message.publicKeys = [];
                    message.publicKeys.push($root.types.IdentityPublicKey.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityGetPublicKeysResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof types.IdentityGetPublicKeysResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {types.IdentityGetPublicKeysResponse} IdentityGetPublicKeysResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetPublicKeysResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityGetPublicKeysResponse message.
         * @function verify
         * @memberof types.IdentityGetPublicKeysResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityGetPublicKeysResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.publicKeys != null && message.hasOwnProperty("publicKeys")) {
                if (!Array.isArray(message.publicKeys))
                    return "publicKeys: array expected";
                for (var i = 0; i < message.publicKeys.length; ++i) {
                    var error = $root.types.IdentityPublicKey.verify(message.publicKeys[i]);
                    if (error)
                        return "publicKeys." + error;
                }
            }
            return null;
        };

        /**
         * Creates an IdentityGetPublicKeysResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof types.IdentityGetPublicKeysResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {types.IdentityGetPublicKeysResponse} IdentityGetPublicKeysResponse
         */
        IdentityGetPublicKeysResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.types.IdentityGetPublicKeysResponse)
                return object;
            var message = new $root.types.IdentityGetPublicKeysResponse();
            if (object.publicKeys) {
                if (!Array.isArray(object.publicKeys))
                    throw TypeError(".types.IdentityGetPublicKeysResponse.publicKeys: array expected");
                message.publicKeys = [];
                for (var i = 0; i < object.publicKeys.length; ++i) {
                    if (typeof object.publicKeys[i] !== "object")
                        throw TypeError(".types.IdentityGetPublicKeysResponse.publicKeys: object expected");
                    message.publicKeys[i] = $root.types.IdentityPublicKey.fromObject(object.publicKeys[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an IdentityGetPublicKeysResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof types.IdentityGetPublicKeysResponse
         * @static
         * @param {types.IdentityGetPublicKeysResponse} message IdentityGetPublicKeysResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityGetPublicKeysResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.publicKeys = [];
            if (message.publicKeys && message.publicKeys.length) {
                object.publicKeys = [];
                for (var j = 0; j < message.publicKeys.length; ++j)
                    object.publicKeys[j] = $root.types.IdentityPublicKey.toObject(message.publicKeys[j], options);
            }
            return object;
        };

        /**
         * Converts this IdentityGetPublicKeysResponse to JSON.
         * @function toJSON
         * @memberof types.IdentityGetPublicKeysResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityGetPublicKeysResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityGetPublicKeysResponse;
    })();

    types.IdentityGetLatestPublicKeysRequest = (function() {

        /**
         * Properties of an IdentityGetLatestPublicKeysRequest.
         * @memberof types
         * @interface IIdentityGetLatestPublicKeysRequest
         * @property {Array.<string>|null} [logins] IdentityGetLatestPublicKeysRequest logins
         */

        /**
         * Constructs a new IdentityGetLatestPublicKeysRequest.
         * @memberof types
         * @classdesc Represents an IdentityGetLatestPublicKeysRequest.
         * @implements IIdentityGetLatestPublicKeysRequest
         * @constructor
         * @param {types.IIdentityGetLatestPublicKeysRequest=} [properties] Properties to set
         */
        function IdentityGetLatestPublicKeysRequest(properties) {
            this.logins = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityGetLatestPublicKeysRequest logins.
         * @member {Array.<string>} logins
         * @memberof types.IdentityGetLatestPublicKeysRequest
         * @instance
         */
        IdentityGetLatestPublicKeysRequest.prototype.logins = $util.emptyArray;

        /**
         * Creates a new IdentityGetLatestPublicKeysRequest instance using the specified properties.
         * @function create
         * @memberof types.IdentityGetLatestPublicKeysRequest
         * @static
         * @param {types.IIdentityGetLatestPublicKeysRequest=} [properties] Properties to set
         * @returns {types.IdentityGetLatestPublicKeysRequest} IdentityGetLatestPublicKeysRequest instance
         */
        IdentityGetLatestPublicKeysRequest.create = function create(properties) {
            return new IdentityGetLatestPublicKeysRequest(properties);
        };

        /**
         * Encodes the specified IdentityGetLatestPublicKeysRequest message. Does not implicitly {@link types.IdentityGetLatestPublicKeysRequest.verify|verify} messages.
         * @function encode
         * @memberof types.IdentityGetLatestPublicKeysRequest
         * @static
         * @param {types.IIdentityGetLatestPublicKeysRequest} message IdentityGetLatestPublicKeysRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetLatestPublicKeysRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.logins != null && message.logins.length)
                for (var i = 0; i < message.logins.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.logins[i]);
            return writer;
        };

        /**
         * Encodes the specified IdentityGetLatestPublicKeysRequest message, length delimited. Does not implicitly {@link types.IdentityGetLatestPublicKeysRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof types.IdentityGetLatestPublicKeysRequest
         * @static
         * @param {types.IIdentityGetLatestPublicKeysRequest} message IdentityGetLatestPublicKeysRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetLatestPublicKeysRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityGetLatestPublicKeysRequest message from the specified reader or buffer.
         * @function decode
         * @memberof types.IdentityGetLatestPublicKeysRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {types.IdentityGetLatestPublicKeysRequest} IdentityGetLatestPublicKeysRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetLatestPublicKeysRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.types.IdentityGetLatestPublicKeysRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.logins && message.logins.length))
                        message.logins = [];
                    message.logins.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityGetLatestPublicKeysRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof types.IdentityGetLatestPublicKeysRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {types.IdentityGetLatestPublicKeysRequest} IdentityGetLatestPublicKeysRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetLatestPublicKeysRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityGetLatestPublicKeysRequest message.
         * @function verify
         * @memberof types.IdentityGetLatestPublicKeysRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityGetLatestPublicKeysRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.logins != null && message.hasOwnProperty("logins")) {
                if (!Array.isArray(message.logins))
                    return "logins: array expected";
                for (var i = 0; i < message.logins.length; ++i)
                    if (!$util.isString(message.logins[i]))
                        return "logins: string[] expected";
            }
            return null;
        };

        /**
         * Creates an IdentityGetLatestPublicKeysRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof types.IdentityGetLatestPublicKeysRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {types.IdentityGetLatestPublicKeysRequest} IdentityGetLatestPublicKeysRequest
         */
        IdentityGetLatestPublicKeysRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.types.IdentityGetLatestPublicKeysRequest)
                return object;
            var message = new $root.types.IdentityGetLatestPublicKeysRequest();
            if (object.logins) {
                if (!Array.isArray(object.logins))
                    throw TypeError(".types.IdentityGetLatestPublicKeysRequest.logins: array expected");
                message.logins = [];
                for (var i = 0; i < object.logins.length; ++i)
                    message.logins[i] = String(object.logins[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from an IdentityGetLatestPublicKeysRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof types.IdentityGetLatestPublicKeysRequest
         * @static
         * @param {types.IdentityGetLatestPublicKeysRequest} message IdentityGetLatestPublicKeysRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityGetLatestPublicKeysRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.logins = [];
            if (message.logins && message.logins.length) {
                object.logins = [];
                for (var j = 0; j < message.logins.length; ++j)
                    object.logins[j] = message.logins[j];
            }
            return object;
        };

        /**
         * Converts this IdentityGetLatestPublicKeysRequest to JSON.
         * @function toJSON
         * @memberof types.IdentityGetLatestPublicKeysRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityGetLatestPublicKeysRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityGetLatestPublicKeysRequest;
    })();

    types.IdentityGetLatestPublicKeysResponse = (function() {

        /**
         * Properties of an IdentityGetLatestPublicKeysResponse.
         * @memberof types
         * @interface IIdentityGetLatestPublicKeysResponse
         * @property {Array.<types.IIdentityPublicKey>|null} [publicKeys] IdentityGetLatestPublicKeysResponse publicKeys
         */

        /**
         * Constructs a new IdentityGetLatestPublicKeysResponse.
         * @memberof types
         * @classdesc Represents an IdentityGetLatestPublicKeysResponse.
         * @implements IIdentityGetLatestPublicKeysResponse
         * @constructor
         * @param {types.IIdentityGetLatestPublicKeysResponse=} [properties] Properties to set
         */
        function IdentityGetLatestPublicKeysResponse(properties) {
            this.publicKeys = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityGetLatestPublicKeysResponse publicKeys.
         * @member {Array.<types.IIdentityPublicKey>} publicKeys
         * @memberof types.IdentityGetLatestPublicKeysResponse
         * @instance
         */
        IdentityGetLatestPublicKeysResponse.prototype.publicKeys = $util.emptyArray;

        /**
         * Creates a new IdentityGetLatestPublicKeysResponse instance using the specified properties.
         * @function create
         * @memberof types.IdentityGetLatestPublicKeysResponse
         * @static
         * @param {types.IIdentityGetLatestPublicKeysResponse=} [properties] Properties to set
         * @returns {types.IdentityGetLatestPublicKeysResponse} IdentityGetLatestPublicKeysResponse instance
         */
        IdentityGetLatestPublicKeysResponse.create = function create(properties) {
            return new IdentityGetLatestPublicKeysResponse(properties);
        };

        /**
         * Encodes the specified IdentityGetLatestPublicKeysResponse message. Does not implicitly {@link types.IdentityGetLatestPublicKeysResponse.verify|verify} messages.
         * @function encode
         * @memberof types.IdentityGetLatestPublicKeysResponse
         * @static
         * @param {types.IIdentityGetLatestPublicKeysResponse} message IdentityGetLatestPublicKeysResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetLatestPublicKeysResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.publicKeys != null && message.publicKeys.length)
                for (var i = 0; i < message.publicKeys.length; ++i)
                    $root.types.IdentityPublicKey.encode(message.publicKeys[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IdentityGetLatestPublicKeysResponse message, length delimited. Does not implicitly {@link types.IdentityGetLatestPublicKeysResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof types.IdentityGetLatestPublicKeysResponse
         * @static
         * @param {types.IIdentityGetLatestPublicKeysResponse} message IdentityGetLatestPublicKeysResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetLatestPublicKeysResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityGetLatestPublicKeysResponse message from the specified reader or buffer.
         * @function decode
         * @memberof types.IdentityGetLatestPublicKeysResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {types.IdentityGetLatestPublicKeysResponse} IdentityGetLatestPublicKeysResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetLatestPublicKeysResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.types.IdentityGetLatestPublicKeysResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.publicKeys && message.publicKeys.length))
                        message.publicKeys = [];
                    message.publicKeys.push($root.types.IdentityPublicKey.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityGetLatestPublicKeysResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof types.IdentityGetLatestPublicKeysResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {types.IdentityGetLatestPublicKeysResponse} IdentityGetLatestPublicKeysResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetLatestPublicKeysResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityGetLatestPublicKeysResponse message.
         * @function verify
         * @memberof types.IdentityGetLatestPublicKeysResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityGetLatestPublicKeysResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.publicKeys != null && message.hasOwnProperty("publicKeys")) {
                if (!Array.isArray(message.publicKeys))
                    return "publicKeys: array expected";
                for (var i = 0; i < message.publicKeys.length; ++i) {
                    var error = $root.types.IdentityPublicKey.verify(message.publicKeys[i]);
                    if (error)
                        return "publicKeys." + error;
                }
            }
            return null;
        };

        /**
         * Creates an IdentityGetLatestPublicKeysResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof types.IdentityGetLatestPublicKeysResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {types.IdentityGetLatestPublicKeysResponse} IdentityGetLatestPublicKeysResponse
         */
        IdentityGetLatestPublicKeysResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.types.IdentityGetLatestPublicKeysResponse)
                return object;
            var message = new $root.types.IdentityGetLatestPublicKeysResponse();
            if (object.publicKeys) {
                if (!Array.isArray(object.publicKeys))
                    throw TypeError(".types.IdentityGetLatestPublicKeysResponse.publicKeys: array expected");
                message.publicKeys = [];
                for (var i = 0; i < object.publicKeys.length; ++i) {
                    if (typeof object.publicKeys[i] !== "object")
                        throw TypeError(".types.IdentityGetLatestPublicKeysResponse.publicKeys: object expected");
                    message.publicKeys[i] = $root.types.IdentityPublicKey.fromObject(object.publicKeys[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an IdentityGetLatestPublicKeysResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof types.IdentityGetLatestPublicKeysResponse
         * @static
         * @param {types.IdentityGetLatestPublicKeysResponse} message IdentityGetLatestPublicKeysResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityGetLatestPublicKeysResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.publicKeys = [];
            if (message.publicKeys && message.publicKeys.length) {
                object.publicKeys = [];
                for (var j = 0; j < message.publicKeys.length; ++j)
                    object.publicKeys[j] = $root.types.IdentityPublicKey.toObject(message.publicKeys[j], options);
            }
            return object;
        };

        /**
         * Converts this IdentityGetLatestPublicKeysResponse to JSON.
         * @function toJSON
         * @memberof types.IdentityGetLatestPublicKeysResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityGetLatestPublicKeysResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityGetLatestPublicKeysResponse;
    })();

    types.IdentityGetPublicChainsRequest = (function() {

        /**
         * Properties of an IdentityGetPublicChainsRequest.
         * @memberof types
         * @interface IIdentityGetPublicChainsRequest
         * @property {Array.<types.IdentityGetPublicChainsRequest.IE>|null} [ids] IdentityGetPublicChainsRequest ids
         */

        /**
         * Constructs a new IdentityGetPublicChainsRequest.
         * @memberof types
         * @classdesc Represents an IdentityGetPublicChainsRequest.
         * @implements IIdentityGetPublicChainsRequest
         * @constructor
         * @param {types.IIdentityGetPublicChainsRequest=} [properties] Properties to set
         */
        function IdentityGetPublicChainsRequest(properties) {
            this.ids = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityGetPublicChainsRequest ids.
         * @member {Array.<types.IdentityGetPublicChainsRequest.IE>} ids
         * @memberof types.IdentityGetPublicChainsRequest
         * @instance
         */
        IdentityGetPublicChainsRequest.prototype.ids = $util.emptyArray;

        /**
         * Creates a new IdentityGetPublicChainsRequest instance using the specified properties.
         * @function create
         * @memberof types.IdentityGetPublicChainsRequest
         * @static
         * @param {types.IIdentityGetPublicChainsRequest=} [properties] Properties to set
         * @returns {types.IdentityGetPublicChainsRequest} IdentityGetPublicChainsRequest instance
         */
        IdentityGetPublicChainsRequest.create = function create(properties) {
            return new IdentityGetPublicChainsRequest(properties);
        };

        /**
         * Encodes the specified IdentityGetPublicChainsRequest message. Does not implicitly {@link types.IdentityGetPublicChainsRequest.verify|verify} messages.
         * @function encode
         * @memberof types.IdentityGetPublicChainsRequest
         * @static
         * @param {types.IIdentityGetPublicChainsRequest} message IdentityGetPublicChainsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetPublicChainsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ids != null && message.ids.length)
                for (var i = 0; i < message.ids.length; ++i)
                    $root.types.IdentityGetPublicChainsRequest.E.encode(message.ids[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IdentityGetPublicChainsRequest message, length delimited. Does not implicitly {@link types.IdentityGetPublicChainsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof types.IdentityGetPublicChainsRequest
         * @static
         * @param {types.IIdentityGetPublicChainsRequest} message IdentityGetPublicChainsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetPublicChainsRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityGetPublicChainsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof types.IdentityGetPublicChainsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {types.IdentityGetPublicChainsRequest} IdentityGetPublicChainsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetPublicChainsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.types.IdentityGetPublicChainsRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.ids && message.ids.length))
                        message.ids = [];
                    message.ids.push($root.types.IdentityGetPublicChainsRequest.E.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityGetPublicChainsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof types.IdentityGetPublicChainsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {types.IdentityGetPublicChainsRequest} IdentityGetPublicChainsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetPublicChainsRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityGetPublicChainsRequest message.
         * @function verify
         * @memberof types.IdentityGetPublicChainsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityGetPublicChainsRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ids != null && message.hasOwnProperty("ids")) {
                if (!Array.isArray(message.ids))
                    return "ids: array expected";
                for (var i = 0; i < message.ids.length; ++i) {
                    var error = $root.types.IdentityGetPublicChainsRequest.E.verify(message.ids[i]);
                    if (error)
                        return "ids." + error;
                }
            }
            return null;
        };

        /**
         * Creates an IdentityGetPublicChainsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof types.IdentityGetPublicChainsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {types.IdentityGetPublicChainsRequest} IdentityGetPublicChainsRequest
         */
        IdentityGetPublicChainsRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.types.IdentityGetPublicChainsRequest)
                return object;
            var message = new $root.types.IdentityGetPublicChainsRequest();
            if (object.ids) {
                if (!Array.isArray(object.ids))
                    throw TypeError(".types.IdentityGetPublicChainsRequest.ids: array expected");
                message.ids = [];
                for (var i = 0; i < object.ids.length; ++i) {
                    if (typeof object.ids[i] !== "object")
                        throw TypeError(".types.IdentityGetPublicChainsRequest.ids: object expected");
                    message.ids[i] = $root.types.IdentityGetPublicChainsRequest.E.fromObject(object.ids[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an IdentityGetPublicChainsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof types.IdentityGetPublicChainsRequest
         * @static
         * @param {types.IdentityGetPublicChainsRequest} message IdentityGetPublicChainsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityGetPublicChainsRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.ids = [];
            if (message.ids && message.ids.length) {
                object.ids = [];
                for (var j = 0; j < message.ids.length; ++j)
                    object.ids[j] = $root.types.IdentityGetPublicChainsRequest.E.toObject(message.ids[j], options);
            }
            return object;
        };

        /**
         * Converts this IdentityGetPublicChainsRequest to JSON.
         * @function toJSON
         * @memberof types.IdentityGetPublicChainsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityGetPublicChainsRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        IdentityGetPublicChainsRequest.E = (function() {

            /**
             * Properties of a E.
             * @memberof types.IdentityGetPublicChainsRequest
             * @interface IE
             * @property {types.IIdentityKeyID|null} [id] E id
             * @property {number|null} [since] E since
             */

            /**
             * Constructs a new E.
             * @memberof types.IdentityGetPublicChainsRequest
             * @classdesc Represents a E.
             * @implements IE
             * @constructor
             * @param {types.IdentityGetPublicChainsRequest.IE=} [properties] Properties to set
             */
            function E(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * E id.
             * @member {types.IIdentityKeyID|null|undefined} id
             * @memberof types.IdentityGetPublicChainsRequest.E
             * @instance
             */
            E.prototype.id = null;

            /**
             * E since.
             * @member {number} since
             * @memberof types.IdentityGetPublicChainsRequest.E
             * @instance
             */
            E.prototype.since = 0;

            /**
             * Creates a new E instance using the specified properties.
             * @function create
             * @memberof types.IdentityGetPublicChainsRequest.E
             * @static
             * @param {types.IdentityGetPublicChainsRequest.IE=} [properties] Properties to set
             * @returns {types.IdentityGetPublicChainsRequest.E} E instance
             */
            E.create = function create(properties) {
                return new E(properties);
            };

            /**
             * Encodes the specified E message. Does not implicitly {@link types.IdentityGetPublicChainsRequest.E.verify|verify} messages.
             * @function encode
             * @memberof types.IdentityGetPublicChainsRequest.E
             * @static
             * @param {types.IdentityGetPublicChainsRequest.IE} message E message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            E.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && message.hasOwnProperty("id"))
                    $root.types.IdentityKeyID.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.since != null && message.hasOwnProperty("since"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.since);
                return writer;
            };

            /**
             * Encodes the specified E message, length delimited. Does not implicitly {@link types.IdentityGetPublicChainsRequest.E.verify|verify} messages.
             * @function encodeDelimited
             * @memberof types.IdentityGetPublicChainsRequest.E
             * @static
             * @param {types.IdentityGetPublicChainsRequest.IE} message E message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            E.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a E message from the specified reader or buffer.
             * @function decode
             * @memberof types.IdentityGetPublicChainsRequest.E
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {types.IdentityGetPublicChainsRequest.E} E
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            E.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.types.IdentityGetPublicChainsRequest.E();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = $root.types.IdentityKeyID.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.since = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a E message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof types.IdentityGetPublicChainsRequest.E
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {types.IdentityGetPublicChainsRequest.E} E
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            E.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a E message.
             * @function verify
             * @memberof types.IdentityGetPublicChainsRequest.E
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            E.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id")) {
                    var error = $root.types.IdentityKeyID.verify(message.id);
                    if (error)
                        return "id." + error;
                }
                if (message.since != null && message.hasOwnProperty("since"))
                    if (!$util.isInteger(message.since))
                        return "since: integer expected";
                return null;
            };

            /**
             * Creates a E message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof types.IdentityGetPublicChainsRequest.E
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {types.IdentityGetPublicChainsRequest.E} E
             */
            E.fromObject = function fromObject(object) {
                if (object instanceof $root.types.IdentityGetPublicChainsRequest.E)
                    return object;
                var message = new $root.types.IdentityGetPublicChainsRequest.E();
                if (object.id != null) {
                    if (typeof object.id !== "object")
                        throw TypeError(".types.IdentityGetPublicChainsRequest.E.id: object expected");
                    message.id = $root.types.IdentityKeyID.fromObject(object.id);
                }
                if (object.since != null)
                    message.since = object.since >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a E message. Also converts values to other types if specified.
             * @function toObject
             * @memberof types.IdentityGetPublicChainsRequest.E
             * @static
             * @param {types.IdentityGetPublicChainsRequest.E} message E
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            E.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.id = null;
                    object.since = 0;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = $root.types.IdentityKeyID.toObject(message.id, options);
                if (message.since != null && message.hasOwnProperty("since"))
                    object.since = message.since;
                return object;
            };

            /**
             * Converts this E to JSON.
             * @function toJSON
             * @memberof types.IdentityGetPublicChainsRequest.E
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            E.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return E;
        })();

        return IdentityGetPublicChainsRequest;
    })();

    types.IdentityGetPublicChainsResponse = (function() {

        /**
         * Properties of an IdentityGetPublicChainsResponse.
         * @memberof types
         * @interface IIdentityGetPublicChainsResponse
         * @property {Array.<types.IIdentityPublicChain>|null} [chains] IdentityGetPublicChainsResponse chains
         */

        /**
         * Constructs a new IdentityGetPublicChainsResponse.
         * @memberof types
         * @classdesc Represents an IdentityGetPublicChainsResponse.
         * @implements IIdentityGetPublicChainsResponse
         * @constructor
         * @param {types.IIdentityGetPublicChainsResponse=} [properties] Properties to set
         */
        function IdentityGetPublicChainsResponse(properties) {
            this.chains = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityGetPublicChainsResponse chains.
         * @member {Array.<types.IIdentityPublicChain>} chains
         * @memberof types.IdentityGetPublicChainsResponse
         * @instance
         */
        IdentityGetPublicChainsResponse.prototype.chains = $util.emptyArray;

        /**
         * Creates a new IdentityGetPublicChainsResponse instance using the specified properties.
         * @function create
         * @memberof types.IdentityGetPublicChainsResponse
         * @static
         * @param {types.IIdentityGetPublicChainsResponse=} [properties] Properties to set
         * @returns {types.IdentityGetPublicChainsResponse} IdentityGetPublicChainsResponse instance
         */
        IdentityGetPublicChainsResponse.create = function create(properties) {
            return new IdentityGetPublicChainsResponse(properties);
        };

        /**
         * Encodes the specified IdentityGetPublicChainsResponse message. Does not implicitly {@link types.IdentityGetPublicChainsResponse.verify|verify} messages.
         * @function encode
         * @memberof types.IdentityGetPublicChainsResponse
         * @static
         * @param {types.IIdentityGetPublicChainsResponse} message IdentityGetPublicChainsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetPublicChainsResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.chains != null && message.chains.length)
                for (var i = 0; i < message.chains.length; ++i)
                    $root.types.IdentityPublicChain.encode(message.chains[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IdentityGetPublicChainsResponse message, length delimited. Does not implicitly {@link types.IdentityGetPublicChainsResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof types.IdentityGetPublicChainsResponse
         * @static
         * @param {types.IIdentityGetPublicChainsResponse} message IdentityGetPublicChainsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetPublicChainsResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityGetPublicChainsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof types.IdentityGetPublicChainsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {types.IdentityGetPublicChainsResponse} IdentityGetPublicChainsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetPublicChainsResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.types.IdentityGetPublicChainsResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.chains && message.chains.length))
                        message.chains = [];
                    message.chains.push($root.types.IdentityPublicChain.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityGetPublicChainsResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof types.IdentityGetPublicChainsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {types.IdentityGetPublicChainsResponse} IdentityGetPublicChainsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetPublicChainsResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityGetPublicChainsResponse message.
         * @function verify
         * @memberof types.IdentityGetPublicChainsResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityGetPublicChainsResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.chains != null && message.hasOwnProperty("chains")) {
                if (!Array.isArray(message.chains))
                    return "chains: array expected";
                for (var i = 0; i < message.chains.length; ++i) {
                    var error = $root.types.IdentityPublicChain.verify(message.chains[i]);
                    if (error)
                        return "chains." + error;
                }
            }
            return null;
        };

        /**
         * Creates an IdentityGetPublicChainsResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof types.IdentityGetPublicChainsResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {types.IdentityGetPublicChainsResponse} IdentityGetPublicChainsResponse
         */
        IdentityGetPublicChainsResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.types.IdentityGetPublicChainsResponse)
                return object;
            var message = new $root.types.IdentityGetPublicChainsResponse();
            if (object.chains) {
                if (!Array.isArray(object.chains))
                    throw TypeError(".types.IdentityGetPublicChainsResponse.chains: array expected");
                message.chains = [];
                for (var i = 0; i < object.chains.length; ++i) {
                    if (typeof object.chains[i] !== "object")
                        throw TypeError(".types.IdentityGetPublicChainsResponse.chains: object expected");
                    message.chains[i] = $root.types.IdentityPublicChain.fromObject(object.chains[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an IdentityGetPublicChainsResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof types.IdentityGetPublicChainsResponse
         * @static
         * @param {types.IdentityGetPublicChainsResponse} message IdentityGetPublicChainsResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityGetPublicChainsResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.chains = [];
            if (message.chains && message.chains.length) {
                object.chains = [];
                for (var j = 0; j < message.chains.length; ++j)
                    object.chains[j] = $root.types.IdentityPublicChain.toObject(message.chains[j], options);
            }
            return object;
        };

        /**
         * Converts this IdentityGetPublicChainsResponse to JSON.
         * @function toJSON
         * @memberof types.IdentityGetPublicChainsResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityGetPublicChainsResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityGetPublicChainsResponse;
    })();

    types.IdentityGetLatestPublicChainsRequest = (function() {

        /**
         * Properties of an IdentityGetLatestPublicChainsRequest.
         * @memberof types
         * @interface IIdentityGetLatestPublicChainsRequest
         * @property {Array.<types.IdentityGetLatestPublicChainsRequest.IE>|null} [ids] IdentityGetLatestPublicChainsRequest ids
         */

        /**
         * Constructs a new IdentityGetLatestPublicChainsRequest.
         * @memberof types
         * @classdesc Represents an IdentityGetLatestPublicChainsRequest.
         * @implements IIdentityGetLatestPublicChainsRequest
         * @constructor
         * @param {types.IIdentityGetLatestPublicChainsRequest=} [properties] Properties to set
         */
        function IdentityGetLatestPublicChainsRequest(properties) {
            this.ids = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityGetLatestPublicChainsRequest ids.
         * @member {Array.<types.IdentityGetLatestPublicChainsRequest.IE>} ids
         * @memberof types.IdentityGetLatestPublicChainsRequest
         * @instance
         */
        IdentityGetLatestPublicChainsRequest.prototype.ids = $util.emptyArray;

        /**
         * Creates a new IdentityGetLatestPublicChainsRequest instance using the specified properties.
         * @function create
         * @memberof types.IdentityGetLatestPublicChainsRequest
         * @static
         * @param {types.IIdentityGetLatestPublicChainsRequest=} [properties] Properties to set
         * @returns {types.IdentityGetLatestPublicChainsRequest} IdentityGetLatestPublicChainsRequest instance
         */
        IdentityGetLatestPublicChainsRequest.create = function create(properties) {
            return new IdentityGetLatestPublicChainsRequest(properties);
        };

        /**
         * Encodes the specified IdentityGetLatestPublicChainsRequest message. Does not implicitly {@link types.IdentityGetLatestPublicChainsRequest.verify|verify} messages.
         * @function encode
         * @memberof types.IdentityGetLatestPublicChainsRequest
         * @static
         * @param {types.IIdentityGetLatestPublicChainsRequest} message IdentityGetLatestPublicChainsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetLatestPublicChainsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ids != null && message.ids.length)
                for (var i = 0; i < message.ids.length; ++i)
                    $root.types.IdentityGetLatestPublicChainsRequest.E.encode(message.ids[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IdentityGetLatestPublicChainsRequest message, length delimited. Does not implicitly {@link types.IdentityGetLatestPublicChainsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof types.IdentityGetLatestPublicChainsRequest
         * @static
         * @param {types.IIdentityGetLatestPublicChainsRequest} message IdentityGetLatestPublicChainsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetLatestPublicChainsRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityGetLatestPublicChainsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof types.IdentityGetLatestPublicChainsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {types.IdentityGetLatestPublicChainsRequest} IdentityGetLatestPublicChainsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetLatestPublicChainsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.types.IdentityGetLatestPublicChainsRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.ids && message.ids.length))
                        message.ids = [];
                    message.ids.push($root.types.IdentityGetLatestPublicChainsRequest.E.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityGetLatestPublicChainsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof types.IdentityGetLatestPublicChainsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {types.IdentityGetLatestPublicChainsRequest} IdentityGetLatestPublicChainsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetLatestPublicChainsRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityGetLatestPublicChainsRequest message.
         * @function verify
         * @memberof types.IdentityGetLatestPublicChainsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityGetLatestPublicChainsRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ids != null && message.hasOwnProperty("ids")) {
                if (!Array.isArray(message.ids))
                    return "ids: array expected";
                for (var i = 0; i < message.ids.length; ++i) {
                    var error = $root.types.IdentityGetLatestPublicChainsRequest.E.verify(message.ids[i]);
                    if (error)
                        return "ids." + error;
                }
            }
            return null;
        };

        /**
         * Creates an IdentityGetLatestPublicChainsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof types.IdentityGetLatestPublicChainsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {types.IdentityGetLatestPublicChainsRequest} IdentityGetLatestPublicChainsRequest
         */
        IdentityGetLatestPublicChainsRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.types.IdentityGetLatestPublicChainsRequest)
                return object;
            var message = new $root.types.IdentityGetLatestPublicChainsRequest();
            if (object.ids) {
                if (!Array.isArray(object.ids))
                    throw TypeError(".types.IdentityGetLatestPublicChainsRequest.ids: array expected");
                message.ids = [];
                for (var i = 0; i < object.ids.length; ++i) {
                    if (typeof object.ids[i] !== "object")
                        throw TypeError(".types.IdentityGetLatestPublicChainsRequest.ids: object expected");
                    message.ids[i] = $root.types.IdentityGetLatestPublicChainsRequest.E.fromObject(object.ids[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an IdentityGetLatestPublicChainsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof types.IdentityGetLatestPublicChainsRequest
         * @static
         * @param {types.IdentityGetLatestPublicChainsRequest} message IdentityGetLatestPublicChainsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityGetLatestPublicChainsRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.ids = [];
            if (message.ids && message.ids.length) {
                object.ids = [];
                for (var j = 0; j < message.ids.length; ++j)
                    object.ids[j] = $root.types.IdentityGetLatestPublicChainsRequest.E.toObject(message.ids[j], options);
            }
            return object;
        };

        /**
         * Converts this IdentityGetLatestPublicChainsRequest to JSON.
         * @function toJSON
         * @memberof types.IdentityGetLatestPublicChainsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityGetLatestPublicChainsRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        IdentityGetLatestPublicChainsRequest.E = (function() {

            /**
             * Properties of a E.
             * @memberof types.IdentityGetLatestPublicChainsRequest
             * @interface IE
             * @property {string|null} [login] E login
             * @property {number|null} [since] E since
             */

            /**
             * Constructs a new E.
             * @memberof types.IdentityGetLatestPublicChainsRequest
             * @classdesc Represents a E.
             * @implements IE
             * @constructor
             * @param {types.IdentityGetLatestPublicChainsRequest.IE=} [properties] Properties to set
             */
            function E(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * E login.
             * @member {string} login
             * @memberof types.IdentityGetLatestPublicChainsRequest.E
             * @instance
             */
            E.prototype.login = "";

            /**
             * E since.
             * @member {number} since
             * @memberof types.IdentityGetLatestPublicChainsRequest.E
             * @instance
             */
            E.prototype.since = 0;

            /**
             * Creates a new E instance using the specified properties.
             * @function create
             * @memberof types.IdentityGetLatestPublicChainsRequest.E
             * @static
             * @param {types.IdentityGetLatestPublicChainsRequest.IE=} [properties] Properties to set
             * @returns {types.IdentityGetLatestPublicChainsRequest.E} E instance
             */
            E.create = function create(properties) {
                return new E(properties);
            };

            /**
             * Encodes the specified E message. Does not implicitly {@link types.IdentityGetLatestPublicChainsRequest.E.verify|verify} messages.
             * @function encode
             * @memberof types.IdentityGetLatestPublicChainsRequest.E
             * @static
             * @param {types.IdentityGetLatestPublicChainsRequest.IE} message E message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            E.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.login != null && message.hasOwnProperty("login"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
                if (message.since != null && message.hasOwnProperty("since"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.since);
                return writer;
            };

            /**
             * Encodes the specified E message, length delimited. Does not implicitly {@link types.IdentityGetLatestPublicChainsRequest.E.verify|verify} messages.
             * @function encodeDelimited
             * @memberof types.IdentityGetLatestPublicChainsRequest.E
             * @static
             * @param {types.IdentityGetLatestPublicChainsRequest.IE} message E message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            E.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a E message from the specified reader or buffer.
             * @function decode
             * @memberof types.IdentityGetLatestPublicChainsRequest.E
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {types.IdentityGetLatestPublicChainsRequest.E} E
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            E.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.types.IdentityGetLatestPublicChainsRequest.E();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.login = reader.string();
                        break;
                    case 2:
                        message.since = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a E message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof types.IdentityGetLatestPublicChainsRequest.E
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {types.IdentityGetLatestPublicChainsRequest.E} E
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            E.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a E message.
             * @function verify
             * @memberof types.IdentityGetLatestPublicChainsRequest.E
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            E.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.login != null && message.hasOwnProperty("login"))
                    if (!$util.isString(message.login))
                        return "login: string expected";
                if (message.since != null && message.hasOwnProperty("since"))
                    if (!$util.isInteger(message.since))
                        return "since: integer expected";
                return null;
            };

            /**
             * Creates a E message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof types.IdentityGetLatestPublicChainsRequest.E
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {types.IdentityGetLatestPublicChainsRequest.E} E
             */
            E.fromObject = function fromObject(object) {
                if (object instanceof $root.types.IdentityGetLatestPublicChainsRequest.E)
                    return object;
                var message = new $root.types.IdentityGetLatestPublicChainsRequest.E();
                if (object.login != null)
                    message.login = String(object.login);
                if (object.since != null)
                    message.since = object.since >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a E message. Also converts values to other types if specified.
             * @function toObject
             * @memberof types.IdentityGetLatestPublicChainsRequest.E
             * @static
             * @param {types.IdentityGetLatestPublicChainsRequest.E} message E
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            E.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.login = "";
                    object.since = 0;
                }
                if (message.login != null && message.hasOwnProperty("login"))
                    object.login = message.login;
                if (message.since != null && message.hasOwnProperty("since"))
                    object.since = message.since;
                return object;
            };

            /**
             * Converts this E to JSON.
             * @function toJSON
             * @memberof types.IdentityGetLatestPublicChainsRequest.E
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            E.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return E;
        })();

        return IdentityGetLatestPublicChainsRequest;
    })();

    types.IdentityGetLatestPublicChainsResponse = (function() {

        /**
         * Properties of an IdentityGetLatestPublicChainsResponse.
         * @memberof types
         * @interface IIdentityGetLatestPublicChainsResponse
         * @property {Array.<types.IIdentityPublicChain>|null} [chains] IdentityGetLatestPublicChainsResponse chains
         */

        /**
         * Constructs a new IdentityGetLatestPublicChainsResponse.
         * @memberof types
         * @classdesc Represents an IdentityGetLatestPublicChainsResponse.
         * @implements IIdentityGetLatestPublicChainsResponse
         * @constructor
         * @param {types.IIdentityGetLatestPublicChainsResponse=} [properties] Properties to set
         */
        function IdentityGetLatestPublicChainsResponse(properties) {
            this.chains = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityGetLatestPublicChainsResponse chains.
         * @member {Array.<types.IIdentityPublicChain>} chains
         * @memberof types.IdentityGetLatestPublicChainsResponse
         * @instance
         */
        IdentityGetLatestPublicChainsResponse.prototype.chains = $util.emptyArray;

        /**
         * Creates a new IdentityGetLatestPublicChainsResponse instance using the specified properties.
         * @function create
         * @memberof types.IdentityGetLatestPublicChainsResponse
         * @static
         * @param {types.IIdentityGetLatestPublicChainsResponse=} [properties] Properties to set
         * @returns {types.IdentityGetLatestPublicChainsResponse} IdentityGetLatestPublicChainsResponse instance
         */
        IdentityGetLatestPublicChainsResponse.create = function create(properties) {
            return new IdentityGetLatestPublicChainsResponse(properties);
        };

        /**
         * Encodes the specified IdentityGetLatestPublicChainsResponse message. Does not implicitly {@link types.IdentityGetLatestPublicChainsResponse.verify|verify} messages.
         * @function encode
         * @memberof types.IdentityGetLatestPublicChainsResponse
         * @static
         * @param {types.IIdentityGetLatestPublicChainsResponse} message IdentityGetLatestPublicChainsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetLatestPublicChainsResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.chains != null && message.chains.length)
                for (var i = 0; i < message.chains.length; ++i)
                    $root.types.IdentityPublicChain.encode(message.chains[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IdentityGetLatestPublicChainsResponse message, length delimited. Does not implicitly {@link types.IdentityGetLatestPublicChainsResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof types.IdentityGetLatestPublicChainsResponse
         * @static
         * @param {types.IIdentityGetLatestPublicChainsResponse} message IdentityGetLatestPublicChainsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetLatestPublicChainsResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityGetLatestPublicChainsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof types.IdentityGetLatestPublicChainsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {types.IdentityGetLatestPublicChainsResponse} IdentityGetLatestPublicChainsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetLatestPublicChainsResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.types.IdentityGetLatestPublicChainsResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.chains && message.chains.length))
                        message.chains = [];
                    message.chains.push($root.types.IdentityPublicChain.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityGetLatestPublicChainsResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof types.IdentityGetLatestPublicChainsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {types.IdentityGetLatestPublicChainsResponse} IdentityGetLatestPublicChainsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetLatestPublicChainsResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityGetLatestPublicChainsResponse message.
         * @function verify
         * @memberof types.IdentityGetLatestPublicChainsResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityGetLatestPublicChainsResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.chains != null && message.hasOwnProperty("chains")) {
                if (!Array.isArray(message.chains))
                    return "chains: array expected";
                for (var i = 0; i < message.chains.length; ++i) {
                    var error = $root.types.IdentityPublicChain.verify(message.chains[i]);
                    if (error)
                        return "chains." + error;
                }
            }
            return null;
        };

        /**
         * Creates an IdentityGetLatestPublicChainsResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof types.IdentityGetLatestPublicChainsResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {types.IdentityGetLatestPublicChainsResponse} IdentityGetLatestPublicChainsResponse
         */
        IdentityGetLatestPublicChainsResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.types.IdentityGetLatestPublicChainsResponse)
                return object;
            var message = new $root.types.IdentityGetLatestPublicChainsResponse();
            if (object.chains) {
                if (!Array.isArray(object.chains))
                    throw TypeError(".types.IdentityGetLatestPublicChainsResponse.chains: array expected");
                message.chains = [];
                for (var i = 0; i < object.chains.length; ++i) {
                    if (typeof object.chains[i] !== "object")
                        throw TypeError(".types.IdentityGetLatestPublicChainsResponse.chains: object expected");
                    message.chains[i] = $root.types.IdentityPublicChain.fromObject(object.chains[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an IdentityGetLatestPublicChainsResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof types.IdentityGetLatestPublicChainsResponse
         * @static
         * @param {types.IdentityGetLatestPublicChainsResponse} message IdentityGetLatestPublicChainsResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityGetLatestPublicChainsResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.chains = [];
            if (message.chains && message.chains.length) {
                object.chains = [];
                for (var j = 0; j < message.chains.length; ++j)
                    object.chains[j] = $root.types.IdentityPublicChain.toObject(message.chains[j], options);
            }
            return object;
        };

        /**
         * Converts this IdentityGetLatestPublicChainsResponse to JSON.
         * @function toJSON
         * @memberof types.IdentityGetLatestPublicChainsResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityGetLatestPublicChainsResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityGetLatestPublicChainsResponse;
    })();

    types.IdentityShareLink = (function() {

        /**
         * Properties of an IdentityShareLink.
         * @memberof types
         * @interface IIdentityShareLink
         * @property {types.IIdentityKeyID|null} [id] IdentityShareLink id
         * @property {types.IdentityShareKind|null} [kind] IdentityShareLink kind
         */

        /**
         * Constructs a new IdentityShareLink.
         * @memberof types
         * @classdesc Represents an IdentityShareLink.
         * @implements IIdentityShareLink
         * @constructor
         * @param {types.IIdentityShareLink=} [properties] Properties to set
         */
        function IdentityShareLink(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityShareLink id.
         * @member {types.IIdentityKeyID|null|undefined} id
         * @memberof types.IdentityShareLink
         * @instance
         */
        IdentityShareLink.prototype.id = null;

        /**
         * IdentityShareLink kind.
         * @member {types.IdentityShareKind} kind
         * @memberof types.IdentityShareLink
         * @instance
         */
        IdentityShareLink.prototype.kind = 0;

        /**
         * Creates a new IdentityShareLink instance using the specified properties.
         * @function create
         * @memberof types.IdentityShareLink
         * @static
         * @param {types.IIdentityShareLink=} [properties] Properties to set
         * @returns {types.IdentityShareLink} IdentityShareLink instance
         */
        IdentityShareLink.create = function create(properties) {
            return new IdentityShareLink(properties);
        };

        /**
         * Encodes the specified IdentityShareLink message. Does not implicitly {@link types.IdentityShareLink.verify|verify} messages.
         * @function encode
         * @memberof types.IdentityShareLink
         * @static
         * @param {types.IIdentityShareLink} message IdentityShareLink message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityShareLink.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                $root.types.IdentityKeyID.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.kind != null && message.hasOwnProperty("kind"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.kind);
            return writer;
        };

        /**
         * Encodes the specified IdentityShareLink message, length delimited. Does not implicitly {@link types.IdentityShareLink.verify|verify} messages.
         * @function encodeDelimited
         * @memberof types.IdentityShareLink
         * @static
         * @param {types.IIdentityShareLink} message IdentityShareLink message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityShareLink.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityShareLink message from the specified reader or buffer.
         * @function decode
         * @memberof types.IdentityShareLink
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {types.IdentityShareLink} IdentityShareLink
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityShareLink.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.types.IdentityShareLink();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = $root.types.IdentityKeyID.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.kind = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityShareLink message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof types.IdentityShareLink
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {types.IdentityShareLink} IdentityShareLink
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityShareLink.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityShareLink message.
         * @function verify
         * @memberof types.IdentityShareLink
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityShareLink.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id")) {
                var error = $root.types.IdentityKeyID.verify(message.id);
                if (error)
                    return "id." + error;
            }
            if (message.kind != null && message.hasOwnProperty("kind"))
                switch (message.kind) {
                default:
                    return "kind: enum value expected";
                case 0:
                case 1:
                    break;
                }
            return null;
        };

        /**
         * Creates an IdentityShareLink message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof types.IdentityShareLink
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {types.IdentityShareLink} IdentityShareLink
         */
        IdentityShareLink.fromObject = function fromObject(object) {
            if (object instanceof $root.types.IdentityShareLink)
                return object;
            var message = new $root.types.IdentityShareLink();
            if (object.id != null) {
                if (typeof object.id !== "object")
                    throw TypeError(".types.IdentityShareLink.id: object expected");
                message.id = $root.types.IdentityKeyID.fromObject(object.id);
            }
            switch (object.kind) {
            case "BOX":
            case 0:
                message.kind = 0;
                break;
            case "SHARING":
            case 1:
                message.kind = 1;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from an IdentityShareLink message. Also converts values to other types if specified.
         * @function toObject
         * @memberof types.IdentityShareLink
         * @static
         * @param {types.IdentityShareLink} message IdentityShareLink
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityShareLink.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = null;
                object.kind = options.enums === String ? "BOX" : 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = $root.types.IdentityKeyID.toObject(message.id, options);
            if (message.kind != null && message.hasOwnProperty("kind"))
                object.kind = options.enums === String ? $root.types.IdentityShareKind[message.kind] : message.kind;
            return object;
        };

        /**
         * Converts this IdentityShareLink to JSON.
         * @function toJSON
         * @memberof types.IdentityShareLink
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityShareLink.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityShareLink;
    })();

    types.IdentityGetSharingGroupResponse = (function() {

        /**
         * Properties of an IdentityGetSharingGroupResponse.
         * @memberof types
         * @interface IIdentityGetSharingGroupResponse
         * @property {Array.<types.IIdentityShareLink>|null} [sharingGroup] IdentityGetSharingGroupResponse sharingGroup
         */

        /**
         * Constructs a new IdentityGetSharingGroupResponse.
         * @memberof types
         * @classdesc Represents an IdentityGetSharingGroupResponse.
         * @implements IIdentityGetSharingGroupResponse
         * @constructor
         * @param {types.IIdentityGetSharingGroupResponse=} [properties] Properties to set
         */
        function IdentityGetSharingGroupResponse(properties) {
            this.sharingGroup = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityGetSharingGroupResponse sharingGroup.
         * @member {Array.<types.IIdentityShareLink>} sharingGroup
         * @memberof types.IdentityGetSharingGroupResponse
         * @instance
         */
        IdentityGetSharingGroupResponse.prototype.sharingGroup = $util.emptyArray;

        /**
         * Creates a new IdentityGetSharingGroupResponse instance using the specified properties.
         * @function create
         * @memberof types.IdentityGetSharingGroupResponse
         * @static
         * @param {types.IIdentityGetSharingGroupResponse=} [properties] Properties to set
         * @returns {types.IdentityGetSharingGroupResponse} IdentityGetSharingGroupResponse instance
         */
        IdentityGetSharingGroupResponse.create = function create(properties) {
            return new IdentityGetSharingGroupResponse(properties);
        };

        /**
         * Encodes the specified IdentityGetSharingGroupResponse message. Does not implicitly {@link types.IdentityGetSharingGroupResponse.verify|verify} messages.
         * @function encode
         * @memberof types.IdentityGetSharingGroupResponse
         * @static
         * @param {types.IIdentityGetSharingGroupResponse} message IdentityGetSharingGroupResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetSharingGroupResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.sharingGroup != null && message.sharingGroup.length)
                for (var i = 0; i < message.sharingGroup.length; ++i)
                    $root.types.IdentityShareLink.encode(message.sharingGroup[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IdentityGetSharingGroupResponse message, length delimited. Does not implicitly {@link types.IdentityGetSharingGroupResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof types.IdentityGetSharingGroupResponse
         * @static
         * @param {types.IIdentityGetSharingGroupResponse} message IdentityGetSharingGroupResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetSharingGroupResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityGetSharingGroupResponse message from the specified reader or buffer.
         * @function decode
         * @memberof types.IdentityGetSharingGroupResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {types.IdentityGetSharingGroupResponse} IdentityGetSharingGroupResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetSharingGroupResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.types.IdentityGetSharingGroupResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.sharingGroup && message.sharingGroup.length))
                        message.sharingGroup = [];
                    message.sharingGroup.push($root.types.IdentityShareLink.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityGetSharingGroupResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof types.IdentityGetSharingGroupResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {types.IdentityGetSharingGroupResponse} IdentityGetSharingGroupResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetSharingGroupResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityGetSharingGroupResponse message.
         * @function verify
         * @memberof types.IdentityGetSharingGroupResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityGetSharingGroupResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.sharingGroup != null && message.hasOwnProperty("sharingGroup")) {
                if (!Array.isArray(message.sharingGroup))
                    return "sharingGroup: array expected";
                for (var i = 0; i < message.sharingGroup.length; ++i) {
                    var error = $root.types.IdentityShareLink.verify(message.sharingGroup[i]);
                    if (error)
                        return "sharingGroup." + error;
                }
            }
            return null;
        };

        /**
         * Creates an IdentityGetSharingGroupResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof types.IdentityGetSharingGroupResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {types.IdentityGetSharingGroupResponse} IdentityGetSharingGroupResponse
         */
        IdentityGetSharingGroupResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.types.IdentityGetSharingGroupResponse)
                return object;
            var message = new $root.types.IdentityGetSharingGroupResponse();
            if (object.sharingGroup) {
                if (!Array.isArray(object.sharingGroup))
                    throw TypeError(".types.IdentityGetSharingGroupResponse.sharingGroup: array expected");
                message.sharingGroup = [];
                for (var i = 0; i < object.sharingGroup.length; ++i) {
                    if (typeof object.sharingGroup[i] !== "object")
                        throw TypeError(".types.IdentityGetSharingGroupResponse.sharingGroup: object expected");
                    message.sharingGroup[i] = $root.types.IdentityShareLink.fromObject(object.sharingGroup[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an IdentityGetSharingGroupResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof types.IdentityGetSharingGroupResponse
         * @static
         * @param {types.IdentityGetSharingGroupResponse} message IdentityGetSharingGroupResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityGetSharingGroupResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.sharingGroup = [];
            if (message.sharingGroup && message.sharingGroup.length) {
                object.sharingGroup = [];
                for (var j = 0; j < message.sharingGroup.length; ++j)
                    object.sharingGroup[j] = $root.types.IdentityShareLink.toObject(message.sharingGroup[j], options);
            }
            return object;
        };

        /**
         * Converts this IdentityGetSharingGroupResponse to JSON.
         * @function toJSON
         * @memberof types.IdentityGetSharingGroupResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityGetSharingGroupResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityGetSharingGroupResponse;
    })();

    types.IdentityGetAccessGroupResponse = (function() {

        /**
         * Properties of an IdentityGetAccessGroupResponse.
         * @memberof types
         * @interface IIdentityGetAccessGroupResponse
         * @property {Array.<types.IIdentityShareLink>|null} [accessGroup] IdentityGetAccessGroupResponse accessGroup
         */

        /**
         * Constructs a new IdentityGetAccessGroupResponse.
         * @memberof types
         * @classdesc Represents an IdentityGetAccessGroupResponse.
         * @implements IIdentityGetAccessGroupResponse
         * @constructor
         * @param {types.IIdentityGetAccessGroupResponse=} [properties] Properties to set
         */
        function IdentityGetAccessGroupResponse(properties) {
            this.accessGroup = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityGetAccessGroupResponse accessGroup.
         * @member {Array.<types.IIdentityShareLink>} accessGroup
         * @memberof types.IdentityGetAccessGroupResponse
         * @instance
         */
        IdentityGetAccessGroupResponse.prototype.accessGroup = $util.emptyArray;

        /**
         * Creates a new IdentityGetAccessGroupResponse instance using the specified properties.
         * @function create
         * @memberof types.IdentityGetAccessGroupResponse
         * @static
         * @param {types.IIdentityGetAccessGroupResponse=} [properties] Properties to set
         * @returns {types.IdentityGetAccessGroupResponse} IdentityGetAccessGroupResponse instance
         */
        IdentityGetAccessGroupResponse.create = function create(properties) {
            return new IdentityGetAccessGroupResponse(properties);
        };

        /**
         * Encodes the specified IdentityGetAccessGroupResponse message. Does not implicitly {@link types.IdentityGetAccessGroupResponse.verify|verify} messages.
         * @function encode
         * @memberof types.IdentityGetAccessGroupResponse
         * @static
         * @param {types.IIdentityGetAccessGroupResponse} message IdentityGetAccessGroupResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetAccessGroupResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.accessGroup != null && message.accessGroup.length)
                for (var i = 0; i < message.accessGroup.length; ++i)
                    $root.types.IdentityShareLink.encode(message.accessGroup[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IdentityGetAccessGroupResponse message, length delimited. Does not implicitly {@link types.IdentityGetAccessGroupResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof types.IdentityGetAccessGroupResponse
         * @static
         * @param {types.IIdentityGetAccessGroupResponse} message IdentityGetAccessGroupResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetAccessGroupResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityGetAccessGroupResponse message from the specified reader or buffer.
         * @function decode
         * @memberof types.IdentityGetAccessGroupResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {types.IdentityGetAccessGroupResponse} IdentityGetAccessGroupResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetAccessGroupResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.types.IdentityGetAccessGroupResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.accessGroup && message.accessGroup.length))
                        message.accessGroup = [];
                    message.accessGroup.push($root.types.IdentityShareLink.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityGetAccessGroupResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof types.IdentityGetAccessGroupResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {types.IdentityGetAccessGroupResponse} IdentityGetAccessGroupResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetAccessGroupResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityGetAccessGroupResponse message.
         * @function verify
         * @memberof types.IdentityGetAccessGroupResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityGetAccessGroupResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.accessGroup != null && message.hasOwnProperty("accessGroup")) {
                if (!Array.isArray(message.accessGroup))
                    return "accessGroup: array expected";
                for (var i = 0; i < message.accessGroup.length; ++i) {
                    var error = $root.types.IdentityShareLink.verify(message.accessGroup[i]);
                    if (error)
                        return "accessGroup." + error;
                }
            }
            return null;
        };

        /**
         * Creates an IdentityGetAccessGroupResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof types.IdentityGetAccessGroupResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {types.IdentityGetAccessGroupResponse} IdentityGetAccessGroupResponse
         */
        IdentityGetAccessGroupResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.types.IdentityGetAccessGroupResponse)
                return object;
            var message = new $root.types.IdentityGetAccessGroupResponse();
            if (object.accessGroup) {
                if (!Array.isArray(object.accessGroup))
                    throw TypeError(".types.IdentityGetAccessGroupResponse.accessGroup: array expected");
                message.accessGroup = [];
                for (var i = 0; i < object.accessGroup.length; ++i) {
                    if (typeof object.accessGroup[i] !== "object")
                        throw TypeError(".types.IdentityGetAccessGroupResponse.accessGroup: object expected");
                    message.accessGroup[i] = $root.types.IdentityShareLink.fromObject(object.accessGroup[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an IdentityGetAccessGroupResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof types.IdentityGetAccessGroupResponse
         * @static
         * @param {types.IdentityGetAccessGroupResponse} message IdentityGetAccessGroupResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityGetAccessGroupResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.accessGroup = [];
            if (message.accessGroup && message.accessGroup.length) {
                object.accessGroup = [];
                for (var j = 0; j < message.accessGroup.length; ++j)
                    object.accessGroup[j] = $root.types.IdentityShareLink.toObject(message.accessGroup[j], options);
            }
            return object;
        };

        /**
         * Converts this IdentityGetAccessGroupResponse to JSON.
         * @function toJSON
         * @memberof types.IdentityGetAccessGroupResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityGetAccessGroupResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityGetAccessGroupResponse;
    })();

    types.IdentityShareEntry = (function() {

        /**
         * Properties of an IdentityShareEntry.
         * @memberof types
         * @interface IIdentityShareEntry
         * @property {string|null} [login] IdentityShareEntry login
         * @property {number|null} [version] IdentityShareEntry version
         * @property {Uint8Array|null} [nonce] IdentityShareEntry nonce
         * @property {Uint8Array|null} [encryptedKey] IdentityShareEntry encryptedKey
         * @property {types.IdentityShareKind|null} [kind] IdentityShareEntry kind
         */

        /**
         * Constructs a new IdentityShareEntry.
         * @memberof types
         * @classdesc Represents an IdentityShareEntry.
         * @implements IIdentityShareEntry
         * @constructor
         * @param {types.IIdentityShareEntry=} [properties] Properties to set
         */
        function IdentityShareEntry(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityShareEntry login.
         * @member {string} login
         * @memberof types.IdentityShareEntry
         * @instance
         */
        IdentityShareEntry.prototype.login = "";

        /**
         * IdentityShareEntry version.
         * @member {number} version
         * @memberof types.IdentityShareEntry
         * @instance
         */
        IdentityShareEntry.prototype.version = 0;

        /**
         * IdentityShareEntry nonce.
         * @member {Uint8Array} nonce
         * @memberof types.IdentityShareEntry
         * @instance
         */
        IdentityShareEntry.prototype.nonce = $util.newBuffer([]);

        /**
         * IdentityShareEntry encryptedKey.
         * @member {Uint8Array} encryptedKey
         * @memberof types.IdentityShareEntry
         * @instance
         */
        IdentityShareEntry.prototype.encryptedKey = $util.newBuffer([]);

        /**
         * IdentityShareEntry kind.
         * @member {types.IdentityShareKind} kind
         * @memberof types.IdentityShareEntry
         * @instance
         */
        IdentityShareEntry.prototype.kind = 0;

        /**
         * Creates a new IdentityShareEntry instance using the specified properties.
         * @function create
         * @memberof types.IdentityShareEntry
         * @static
         * @param {types.IIdentityShareEntry=} [properties] Properties to set
         * @returns {types.IdentityShareEntry} IdentityShareEntry instance
         */
        IdentityShareEntry.create = function create(properties) {
            return new IdentityShareEntry(properties);
        };

        /**
         * Encodes the specified IdentityShareEntry message. Does not implicitly {@link types.IdentityShareEntry.verify|verify} messages.
         * @function encode
         * @memberof types.IdentityShareEntry
         * @static
         * @param {types.IIdentityShareEntry} message IdentityShareEntry message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityShareEntry.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            if (message.version != null && message.hasOwnProperty("version"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.version);
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.nonce);
            if (message.encryptedKey != null && message.hasOwnProperty("encryptedKey"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.encryptedKey);
            if (message.kind != null && message.hasOwnProperty("kind"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.kind);
            return writer;
        };

        /**
         * Encodes the specified IdentityShareEntry message, length delimited. Does not implicitly {@link types.IdentityShareEntry.verify|verify} messages.
         * @function encodeDelimited
         * @memberof types.IdentityShareEntry
         * @static
         * @param {types.IIdentityShareEntry} message IdentityShareEntry message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityShareEntry.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityShareEntry message from the specified reader or buffer.
         * @function decode
         * @memberof types.IdentityShareEntry
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {types.IdentityShareEntry} IdentityShareEntry
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityShareEntry.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.types.IdentityShareEntry();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                case 2:
                    message.version = reader.uint32();
                    break;
                case 3:
                    message.nonce = reader.bytes();
                    break;
                case 4:
                    message.encryptedKey = reader.bytes();
                    break;
                case 5:
                    message.kind = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityShareEntry message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof types.IdentityShareEntry
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {types.IdentityShareEntry} IdentityShareEntry
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityShareEntry.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityShareEntry message.
         * @function verify
         * @memberof types.IdentityShareEntry
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityShareEntry.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isInteger(message.version))
                    return "version: integer expected";
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                if (!(message.nonce && typeof message.nonce.length === "number" || $util.isString(message.nonce)))
                    return "nonce: buffer expected";
            if (message.encryptedKey != null && message.hasOwnProperty("encryptedKey"))
                if (!(message.encryptedKey && typeof message.encryptedKey.length === "number" || $util.isString(message.encryptedKey)))
                    return "encryptedKey: buffer expected";
            if (message.kind != null && message.hasOwnProperty("kind"))
                switch (message.kind) {
                default:
                    return "kind: enum value expected";
                case 0:
                case 1:
                    break;
                }
            return null;
        };

        /**
         * Creates an IdentityShareEntry message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof types.IdentityShareEntry
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {types.IdentityShareEntry} IdentityShareEntry
         */
        IdentityShareEntry.fromObject = function fromObject(object) {
            if (object instanceof $root.types.IdentityShareEntry)
                return object;
            var message = new $root.types.IdentityShareEntry();
            if (object.login != null)
                message.login = String(object.login);
            if (object.version != null)
                message.version = object.version >>> 0;
            if (object.nonce != null)
                if (typeof object.nonce === "string")
                    $util.base64.decode(object.nonce, message.nonce = $util.newBuffer($util.base64.length(object.nonce)), 0);
                else if (object.nonce.length)
                    message.nonce = object.nonce;
            if (object.encryptedKey != null)
                if (typeof object.encryptedKey === "string")
                    $util.base64.decode(object.encryptedKey, message.encryptedKey = $util.newBuffer($util.base64.length(object.encryptedKey)), 0);
                else if (object.encryptedKey.length)
                    message.encryptedKey = object.encryptedKey;
            switch (object.kind) {
            case "BOX":
            case 0:
                message.kind = 0;
                break;
            case "SHARING":
            case 1:
                message.kind = 1;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from an IdentityShareEntry message. Also converts values to other types if specified.
         * @function toObject
         * @memberof types.IdentityShareEntry
         * @static
         * @param {types.IdentityShareEntry} message IdentityShareEntry
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityShareEntry.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.login = "";
                object.version = 0;
                object.nonce = options.bytes === String ? "" : [];
                object.encryptedKey = options.bytes === String ? "" : [];
                object.kind = options.enums === String ? "BOX" : 0;
            }
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                object.nonce = options.bytes === String ? $util.base64.encode(message.nonce, 0, message.nonce.length) : options.bytes === Array ? Array.prototype.slice.call(message.nonce) : message.nonce;
            if (message.encryptedKey != null && message.hasOwnProperty("encryptedKey"))
                object.encryptedKey = options.bytes === String ? $util.base64.encode(message.encryptedKey, 0, message.encryptedKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedKey) : message.encryptedKey;
            if (message.kind != null && message.hasOwnProperty("kind"))
                object.kind = options.enums === String ? $root.types.IdentityShareKind[message.kind] : message.kind;
            return object;
        };

        /**
         * Converts this IdentityShareEntry to JSON.
         * @function toJSON
         * @memberof types.IdentityShareEntry
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityShareEntry.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityShareEntry;
    })();

    types.IdentityShareRequest = (function() {

        /**
         * Properties of an IdentityShareRequest.
         * @memberof types
         * @interface IIdentityShareRequest
         * @property {string|null} [login] IdentityShareRequest login
         * @property {number|null} [version] IdentityShareRequest version
         * @property {Array.<types.IIdentityShareEntry>|null} [sharingGroup] IdentityShareRequest sharingGroup
         */

        /**
         * Constructs a new IdentityShareRequest.
         * @memberof types
         * @classdesc Represents an IdentityShareRequest.
         * @implements IIdentityShareRequest
         * @constructor
         * @param {types.IIdentityShareRequest=} [properties] Properties to set
         */
        function IdentityShareRequest(properties) {
            this.sharingGroup = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityShareRequest login.
         * @member {string} login
         * @memberof types.IdentityShareRequest
         * @instance
         */
        IdentityShareRequest.prototype.login = "";

        /**
         * IdentityShareRequest version.
         * @member {number} version
         * @memberof types.IdentityShareRequest
         * @instance
         */
        IdentityShareRequest.prototype.version = 0;

        /**
         * IdentityShareRequest sharingGroup.
         * @member {Array.<types.IIdentityShareEntry>} sharingGroup
         * @memberof types.IdentityShareRequest
         * @instance
         */
        IdentityShareRequest.prototype.sharingGroup = $util.emptyArray;

        /**
         * Creates a new IdentityShareRequest instance using the specified properties.
         * @function create
         * @memberof types.IdentityShareRequest
         * @static
         * @param {types.IIdentityShareRequest=} [properties] Properties to set
         * @returns {types.IdentityShareRequest} IdentityShareRequest instance
         */
        IdentityShareRequest.create = function create(properties) {
            return new IdentityShareRequest(properties);
        };

        /**
         * Encodes the specified IdentityShareRequest message. Does not implicitly {@link types.IdentityShareRequest.verify|verify} messages.
         * @function encode
         * @memberof types.IdentityShareRequest
         * @static
         * @param {types.IIdentityShareRequest} message IdentityShareRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityShareRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            if (message.version != null && message.hasOwnProperty("version"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.version);
            if (message.sharingGroup != null && message.sharingGroup.length)
                for (var i = 0; i < message.sharingGroup.length; ++i)
                    $root.types.IdentityShareEntry.encode(message.sharingGroup[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IdentityShareRequest message, length delimited. Does not implicitly {@link types.IdentityShareRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof types.IdentityShareRequest
         * @static
         * @param {types.IIdentityShareRequest} message IdentityShareRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityShareRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityShareRequest message from the specified reader or buffer.
         * @function decode
         * @memberof types.IdentityShareRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {types.IdentityShareRequest} IdentityShareRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityShareRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.types.IdentityShareRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                case 2:
                    message.version = reader.uint32();
                    break;
                case 3:
                    if (!(message.sharingGroup && message.sharingGroup.length))
                        message.sharingGroup = [];
                    message.sharingGroup.push($root.types.IdentityShareEntry.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityShareRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof types.IdentityShareRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {types.IdentityShareRequest} IdentityShareRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityShareRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityShareRequest message.
         * @function verify
         * @memberof types.IdentityShareRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityShareRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isInteger(message.version))
                    return "version: integer expected";
            if (message.sharingGroup != null && message.hasOwnProperty("sharingGroup")) {
                if (!Array.isArray(message.sharingGroup))
                    return "sharingGroup: array expected";
                for (var i = 0; i < message.sharingGroup.length; ++i) {
                    var error = $root.types.IdentityShareEntry.verify(message.sharingGroup[i]);
                    if (error)
                        return "sharingGroup." + error;
                }
            }
            return null;
        };

        /**
         * Creates an IdentityShareRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof types.IdentityShareRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {types.IdentityShareRequest} IdentityShareRequest
         */
        IdentityShareRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.types.IdentityShareRequest)
                return object;
            var message = new $root.types.IdentityShareRequest();
            if (object.login != null)
                message.login = String(object.login);
            if (object.version != null)
                message.version = object.version >>> 0;
            if (object.sharingGroup) {
                if (!Array.isArray(object.sharingGroup))
                    throw TypeError(".types.IdentityShareRequest.sharingGroup: array expected");
                message.sharingGroup = [];
                for (var i = 0; i < object.sharingGroup.length; ++i) {
                    if (typeof object.sharingGroup[i] !== "object")
                        throw TypeError(".types.IdentityShareRequest.sharingGroup: object expected");
                    message.sharingGroup[i] = $root.types.IdentityShareEntry.fromObject(object.sharingGroup[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an IdentityShareRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof types.IdentityShareRequest
         * @static
         * @param {types.IdentityShareRequest} message IdentityShareRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityShareRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.sharingGroup = [];
            if (options.defaults) {
                object.login = "";
                object.version = 0;
            }
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            if (message.sharingGroup && message.sharingGroup.length) {
                object.sharingGroup = [];
                for (var j = 0; j < message.sharingGroup.length; ++j)
                    object.sharingGroup[j] = $root.types.IdentityShareEntry.toObject(message.sharingGroup[j], options);
            }
            return object;
        };

        /**
         * Converts this IdentityShareRequest to JSON.
         * @function toJSON
         * @memberof types.IdentityShareRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityShareRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityShareRequest;
    })();

    types.IdentityGetEncryptionResponse = (function() {

        /**
         * Properties of an IdentityGetEncryptionResponse.
         * @memberof types
         * @interface IIdentityGetEncryptionResponse
         * @property {types.IIdentityEncryption|null} [encryption] IdentityGetEncryptionResponse encryption
         * @property {types.IIdentityPublicKey|null} [creator] IdentityGetEncryptionResponse creator
         */

        /**
         * Constructs a new IdentityGetEncryptionResponse.
         * @memberof types
         * @classdesc Represents an IdentityGetEncryptionResponse.
         * @implements IIdentityGetEncryptionResponse
         * @constructor
         * @param {types.IIdentityGetEncryptionResponse=} [properties] Properties to set
         */
        function IdentityGetEncryptionResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityGetEncryptionResponse encryption.
         * @member {types.IIdentityEncryption|null|undefined} encryption
         * @memberof types.IdentityGetEncryptionResponse
         * @instance
         */
        IdentityGetEncryptionResponse.prototype.encryption = null;

        /**
         * IdentityGetEncryptionResponse creator.
         * @member {types.IIdentityPublicKey|null|undefined} creator
         * @memberof types.IdentityGetEncryptionResponse
         * @instance
         */
        IdentityGetEncryptionResponse.prototype.creator = null;

        /**
         * Creates a new IdentityGetEncryptionResponse instance using the specified properties.
         * @function create
         * @memberof types.IdentityGetEncryptionResponse
         * @static
         * @param {types.IIdentityGetEncryptionResponse=} [properties] Properties to set
         * @returns {types.IdentityGetEncryptionResponse} IdentityGetEncryptionResponse instance
         */
        IdentityGetEncryptionResponse.create = function create(properties) {
            return new IdentityGetEncryptionResponse(properties);
        };

        /**
         * Encodes the specified IdentityGetEncryptionResponse message. Does not implicitly {@link types.IdentityGetEncryptionResponse.verify|verify} messages.
         * @function encode
         * @memberof types.IdentityGetEncryptionResponse
         * @static
         * @param {types.IIdentityGetEncryptionResponse} message IdentityGetEncryptionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetEncryptionResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.encryption != null && message.hasOwnProperty("encryption"))
                $root.types.IdentityEncryption.encode(message.encryption, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.creator != null && message.hasOwnProperty("creator"))
                $root.types.IdentityPublicKey.encode(message.creator, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IdentityGetEncryptionResponse message, length delimited. Does not implicitly {@link types.IdentityGetEncryptionResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof types.IdentityGetEncryptionResponse
         * @static
         * @param {types.IIdentityGetEncryptionResponse} message IdentityGetEncryptionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetEncryptionResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityGetEncryptionResponse message from the specified reader or buffer.
         * @function decode
         * @memberof types.IdentityGetEncryptionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {types.IdentityGetEncryptionResponse} IdentityGetEncryptionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetEncryptionResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.types.IdentityGetEncryptionResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.encryption = $root.types.IdentityEncryption.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.creator = $root.types.IdentityPublicKey.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityGetEncryptionResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof types.IdentityGetEncryptionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {types.IdentityGetEncryptionResponse} IdentityGetEncryptionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetEncryptionResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityGetEncryptionResponse message.
         * @function verify
         * @memberof types.IdentityGetEncryptionResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityGetEncryptionResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.encryption != null && message.hasOwnProperty("encryption")) {
                var error = $root.types.IdentityEncryption.verify(message.encryption);
                if (error)
                    return "encryption." + error;
            }
            if (message.creator != null && message.hasOwnProperty("creator")) {
                var error = $root.types.IdentityPublicKey.verify(message.creator);
                if (error)
                    return "creator." + error;
            }
            return null;
        };

        /**
         * Creates an IdentityGetEncryptionResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof types.IdentityGetEncryptionResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {types.IdentityGetEncryptionResponse} IdentityGetEncryptionResponse
         */
        IdentityGetEncryptionResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.types.IdentityGetEncryptionResponse)
                return object;
            var message = new $root.types.IdentityGetEncryptionResponse();
            if (object.encryption != null) {
                if (typeof object.encryption !== "object")
                    throw TypeError(".types.IdentityGetEncryptionResponse.encryption: object expected");
                message.encryption = $root.types.IdentityEncryption.fromObject(object.encryption);
            }
            if (object.creator != null) {
                if (typeof object.creator !== "object")
                    throw TypeError(".types.IdentityGetEncryptionResponse.creator: object expected");
                message.creator = $root.types.IdentityPublicKey.fromObject(object.creator);
            }
            return message;
        };

        /**
         * Creates a plain object from an IdentityGetEncryptionResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof types.IdentityGetEncryptionResponse
         * @static
         * @param {types.IdentityGetEncryptionResponse} message IdentityGetEncryptionResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityGetEncryptionResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.encryption = null;
                object.creator = null;
            }
            if (message.encryption != null && message.hasOwnProperty("encryption"))
                object.encryption = $root.types.IdentityEncryption.toObject(message.encryption, options);
            if (message.creator != null && message.hasOwnProperty("creator"))
                object.creator = $root.types.IdentityPublicKey.toObject(message.creator, options);
            return object;
        };

        /**
         * Converts this IdentityGetEncryptionResponse to JSON.
         * @function toJSON
         * @memberof types.IdentityGetEncryptionResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityGetEncryptionResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityGetEncryptionResponse;
    })();

    types.IdentityGetKeysToRenewResponse = (function() {

        /**
         * Properties of an IdentityGetKeysToRenewResponse.
         * @memberof types
         * @interface IIdentityGetKeysToRenewResponse
         * @property {types.IIdentityEncryption|null} [encryption] IdentityGetKeysToRenewResponse encryption
         * @property {types.IIdentityPublicKey|null} [creator] IdentityGetKeysToRenewResponse creator
         * @property {Array.<types.IIdentityPublicKey>|null} [sharingGroup] IdentityGetKeysToRenewResponse sharingGroup
         */

        /**
         * Constructs a new IdentityGetKeysToRenewResponse.
         * @memberof types
         * @classdesc Represents an IdentityGetKeysToRenewResponse.
         * @implements IIdentityGetKeysToRenewResponse
         * @constructor
         * @param {types.IIdentityGetKeysToRenewResponse=} [properties] Properties to set
         */
        function IdentityGetKeysToRenewResponse(properties) {
            this.sharingGroup = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityGetKeysToRenewResponse encryption.
         * @member {types.IIdentityEncryption|null|undefined} encryption
         * @memberof types.IdentityGetKeysToRenewResponse
         * @instance
         */
        IdentityGetKeysToRenewResponse.prototype.encryption = null;

        /**
         * IdentityGetKeysToRenewResponse creator.
         * @member {types.IIdentityPublicKey|null|undefined} creator
         * @memberof types.IdentityGetKeysToRenewResponse
         * @instance
         */
        IdentityGetKeysToRenewResponse.prototype.creator = null;

        /**
         * IdentityGetKeysToRenewResponse sharingGroup.
         * @member {Array.<types.IIdentityPublicKey>} sharingGroup
         * @memberof types.IdentityGetKeysToRenewResponse
         * @instance
         */
        IdentityGetKeysToRenewResponse.prototype.sharingGroup = $util.emptyArray;

        /**
         * Creates a new IdentityGetKeysToRenewResponse instance using the specified properties.
         * @function create
         * @memberof types.IdentityGetKeysToRenewResponse
         * @static
         * @param {types.IIdentityGetKeysToRenewResponse=} [properties] Properties to set
         * @returns {types.IdentityGetKeysToRenewResponse} IdentityGetKeysToRenewResponse instance
         */
        IdentityGetKeysToRenewResponse.create = function create(properties) {
            return new IdentityGetKeysToRenewResponse(properties);
        };

        /**
         * Encodes the specified IdentityGetKeysToRenewResponse message. Does not implicitly {@link types.IdentityGetKeysToRenewResponse.verify|verify} messages.
         * @function encode
         * @memberof types.IdentityGetKeysToRenewResponse
         * @static
         * @param {types.IIdentityGetKeysToRenewResponse} message IdentityGetKeysToRenewResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetKeysToRenewResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.encryption != null && message.hasOwnProperty("encryption"))
                $root.types.IdentityEncryption.encode(message.encryption, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.creator != null && message.hasOwnProperty("creator"))
                $root.types.IdentityPublicKey.encode(message.creator, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.sharingGroup != null && message.sharingGroup.length)
                for (var i = 0; i < message.sharingGroup.length; ++i)
                    $root.types.IdentityPublicKey.encode(message.sharingGroup[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IdentityGetKeysToRenewResponse message, length delimited. Does not implicitly {@link types.IdentityGetKeysToRenewResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof types.IdentityGetKeysToRenewResponse
         * @static
         * @param {types.IIdentityGetKeysToRenewResponse} message IdentityGetKeysToRenewResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetKeysToRenewResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityGetKeysToRenewResponse message from the specified reader or buffer.
         * @function decode
         * @memberof types.IdentityGetKeysToRenewResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {types.IdentityGetKeysToRenewResponse} IdentityGetKeysToRenewResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetKeysToRenewResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.types.IdentityGetKeysToRenewResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.encryption = $root.types.IdentityEncryption.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.creator = $root.types.IdentityPublicKey.decode(reader, reader.uint32());
                    break;
                case 3:
                    if (!(message.sharingGroup && message.sharingGroup.length))
                        message.sharingGroup = [];
                    message.sharingGroup.push($root.types.IdentityPublicKey.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityGetKeysToRenewResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof types.IdentityGetKeysToRenewResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {types.IdentityGetKeysToRenewResponse} IdentityGetKeysToRenewResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetKeysToRenewResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityGetKeysToRenewResponse message.
         * @function verify
         * @memberof types.IdentityGetKeysToRenewResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityGetKeysToRenewResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.encryption != null && message.hasOwnProperty("encryption")) {
                var error = $root.types.IdentityEncryption.verify(message.encryption);
                if (error)
                    return "encryption." + error;
            }
            if (message.creator != null && message.hasOwnProperty("creator")) {
                var error = $root.types.IdentityPublicKey.verify(message.creator);
                if (error)
                    return "creator." + error;
            }
            if (message.sharingGroup != null && message.hasOwnProperty("sharingGroup")) {
                if (!Array.isArray(message.sharingGroup))
                    return "sharingGroup: array expected";
                for (var i = 0; i < message.sharingGroup.length; ++i) {
                    var error = $root.types.IdentityPublicKey.verify(message.sharingGroup[i]);
                    if (error)
                        return "sharingGroup." + error;
                }
            }
            return null;
        };

        /**
         * Creates an IdentityGetKeysToRenewResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof types.IdentityGetKeysToRenewResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {types.IdentityGetKeysToRenewResponse} IdentityGetKeysToRenewResponse
         */
        IdentityGetKeysToRenewResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.types.IdentityGetKeysToRenewResponse)
                return object;
            var message = new $root.types.IdentityGetKeysToRenewResponse();
            if (object.encryption != null) {
                if (typeof object.encryption !== "object")
                    throw TypeError(".types.IdentityGetKeysToRenewResponse.encryption: object expected");
                message.encryption = $root.types.IdentityEncryption.fromObject(object.encryption);
            }
            if (object.creator != null) {
                if (typeof object.creator !== "object")
                    throw TypeError(".types.IdentityGetKeysToRenewResponse.creator: object expected");
                message.creator = $root.types.IdentityPublicKey.fromObject(object.creator);
            }
            if (object.sharingGroup) {
                if (!Array.isArray(object.sharingGroup))
                    throw TypeError(".types.IdentityGetKeysToRenewResponse.sharingGroup: array expected");
                message.sharingGroup = [];
                for (var i = 0; i < object.sharingGroup.length; ++i) {
                    if (typeof object.sharingGroup[i] !== "object")
                        throw TypeError(".types.IdentityGetKeysToRenewResponse.sharingGroup: object expected");
                    message.sharingGroup[i] = $root.types.IdentityPublicKey.fromObject(object.sharingGroup[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an IdentityGetKeysToRenewResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof types.IdentityGetKeysToRenewResponse
         * @static
         * @param {types.IdentityGetKeysToRenewResponse} message IdentityGetKeysToRenewResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityGetKeysToRenewResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.sharingGroup = [];
            if (options.defaults) {
                object.encryption = null;
                object.creator = null;
            }
            if (message.encryption != null && message.hasOwnProperty("encryption"))
                object.encryption = $root.types.IdentityEncryption.toObject(message.encryption, options);
            if (message.creator != null && message.hasOwnProperty("creator"))
                object.creator = $root.types.IdentityPublicKey.toObject(message.creator, options);
            if (message.sharingGroup && message.sharingGroup.length) {
                object.sharingGroup = [];
                for (var j = 0; j < message.sharingGroup.length; ++j)
                    object.sharingGroup[j] = $root.types.IdentityPublicKey.toObject(message.sharingGroup[j], options);
            }
            return object;
        };

        /**
         * Converts this IdentityGetKeysToRenewResponse to JSON.
         * @function toJSON
         * @memberof types.IdentityGetKeysToRenewResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityGetKeysToRenewResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityGetKeysToRenewResponse;
    })();

    types.IdentityBackwardKey = (function() {

        /**
         * Properties of an IdentityBackwardKey.
         * @memberof types
         * @interface IIdentityBackwardKey
         * @property {Uint8Array|null} [nonce] IdentityBackwardKey nonce
         * @property {Uint8Array|null} [encryptedKey] IdentityBackwardKey encryptedKey
         */

        /**
         * Constructs a new IdentityBackwardKey.
         * @memberof types
         * @classdesc Represents an IdentityBackwardKey.
         * @implements IIdentityBackwardKey
         * @constructor
         * @param {types.IIdentityBackwardKey=} [properties] Properties to set
         */
        function IdentityBackwardKey(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityBackwardKey nonce.
         * @member {Uint8Array} nonce
         * @memberof types.IdentityBackwardKey
         * @instance
         */
        IdentityBackwardKey.prototype.nonce = $util.newBuffer([]);

        /**
         * IdentityBackwardKey encryptedKey.
         * @member {Uint8Array} encryptedKey
         * @memberof types.IdentityBackwardKey
         * @instance
         */
        IdentityBackwardKey.prototype.encryptedKey = $util.newBuffer([]);

        /**
         * Creates a new IdentityBackwardKey instance using the specified properties.
         * @function create
         * @memberof types.IdentityBackwardKey
         * @static
         * @param {types.IIdentityBackwardKey=} [properties] Properties to set
         * @returns {types.IdentityBackwardKey} IdentityBackwardKey instance
         */
        IdentityBackwardKey.create = function create(properties) {
            return new IdentityBackwardKey(properties);
        };

        /**
         * Encodes the specified IdentityBackwardKey message. Does not implicitly {@link types.IdentityBackwardKey.verify|verify} messages.
         * @function encode
         * @memberof types.IdentityBackwardKey
         * @static
         * @param {types.IIdentityBackwardKey} message IdentityBackwardKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityBackwardKey.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.nonce);
            if (message.encryptedKey != null && message.hasOwnProperty("encryptedKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.encryptedKey);
            return writer;
        };

        /**
         * Encodes the specified IdentityBackwardKey message, length delimited. Does not implicitly {@link types.IdentityBackwardKey.verify|verify} messages.
         * @function encodeDelimited
         * @memberof types.IdentityBackwardKey
         * @static
         * @param {types.IIdentityBackwardKey} message IdentityBackwardKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityBackwardKey.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityBackwardKey message from the specified reader or buffer.
         * @function decode
         * @memberof types.IdentityBackwardKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {types.IdentityBackwardKey} IdentityBackwardKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityBackwardKey.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.types.IdentityBackwardKey();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.nonce = reader.bytes();
                    break;
                case 2:
                    message.encryptedKey = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityBackwardKey message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof types.IdentityBackwardKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {types.IdentityBackwardKey} IdentityBackwardKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityBackwardKey.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityBackwardKey message.
         * @function verify
         * @memberof types.IdentityBackwardKey
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityBackwardKey.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                if (!(message.nonce && typeof message.nonce.length === "number" || $util.isString(message.nonce)))
                    return "nonce: buffer expected";
            if (message.encryptedKey != null && message.hasOwnProperty("encryptedKey"))
                if (!(message.encryptedKey && typeof message.encryptedKey.length === "number" || $util.isString(message.encryptedKey)))
                    return "encryptedKey: buffer expected";
            return null;
        };

        /**
         * Creates an IdentityBackwardKey message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof types.IdentityBackwardKey
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {types.IdentityBackwardKey} IdentityBackwardKey
         */
        IdentityBackwardKey.fromObject = function fromObject(object) {
            if (object instanceof $root.types.IdentityBackwardKey)
                return object;
            var message = new $root.types.IdentityBackwardKey();
            if (object.nonce != null)
                if (typeof object.nonce === "string")
                    $util.base64.decode(object.nonce, message.nonce = $util.newBuffer($util.base64.length(object.nonce)), 0);
                else if (object.nonce.length)
                    message.nonce = object.nonce;
            if (object.encryptedKey != null)
                if (typeof object.encryptedKey === "string")
                    $util.base64.decode(object.encryptedKey, message.encryptedKey = $util.newBuffer($util.base64.length(object.encryptedKey)), 0);
                else if (object.encryptedKey.length)
                    message.encryptedKey = object.encryptedKey;
            return message;
        };

        /**
         * Creates a plain object from an IdentityBackwardKey message. Also converts values to other types if specified.
         * @function toObject
         * @memberof types.IdentityBackwardKey
         * @static
         * @param {types.IdentityBackwardKey} message IdentityBackwardKey
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityBackwardKey.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.nonce = options.bytes === String ? "" : [];
                object.encryptedKey = options.bytes === String ? "" : [];
            }
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                object.nonce = options.bytes === String ? $util.base64.encode(message.nonce, 0, message.nonce.length) : options.bytes === Array ? Array.prototype.slice.call(message.nonce) : message.nonce;
            if (message.encryptedKey != null && message.hasOwnProperty("encryptedKey"))
                object.encryptedKey = options.bytes === String ? $util.base64.encode(message.encryptedKey, 0, message.encryptedKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedKey) : message.encryptedKey;
            return object;
        };

        /**
         * Converts this IdentityBackwardKey to JSON.
         * @function toJSON
         * @memberof types.IdentityBackwardKey
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityBackwardKey.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityBackwardKey;
    })();

    types.IdentityPostKeysToRenewRequest = (function() {

        /**
         * Properties of an IdentityPostKeysToRenewRequest.
         * @memberof types
         * @interface IIdentityPostKeysToRenewRequest
         * @property {string|null} [login] IdentityPostKeysToRenewRequest login
         * @property {types.IIdentityEncryption|null} [encryption] IdentityPostKeysToRenewRequest encryption
         * @property {Uint8Array|null} [signChain] IdentityPostKeysToRenewRequest signChain
         * @property {Array.<types.IIdentityShareEntry>|null} [sharingGroup] IdentityPostKeysToRenewRequest sharingGroup
         * @property {types.IIdentityBackwardKey|null} [backward] IdentityPostKeysToRenewRequest backward
         */

        /**
         * Constructs a new IdentityPostKeysToRenewRequest.
         * @memberof types
         * @classdesc Represents an IdentityPostKeysToRenewRequest.
         * @implements IIdentityPostKeysToRenewRequest
         * @constructor
         * @param {types.IIdentityPostKeysToRenewRequest=} [properties] Properties to set
         */
        function IdentityPostKeysToRenewRequest(properties) {
            this.sharingGroup = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityPostKeysToRenewRequest login.
         * @member {string} login
         * @memberof types.IdentityPostKeysToRenewRequest
         * @instance
         */
        IdentityPostKeysToRenewRequest.prototype.login = "";

        /**
         * IdentityPostKeysToRenewRequest encryption.
         * @member {types.IIdentityEncryption|null|undefined} encryption
         * @memberof types.IdentityPostKeysToRenewRequest
         * @instance
         */
        IdentityPostKeysToRenewRequest.prototype.encryption = null;

        /**
         * IdentityPostKeysToRenewRequest signChain.
         * @member {Uint8Array} signChain
         * @memberof types.IdentityPostKeysToRenewRequest
         * @instance
         */
        IdentityPostKeysToRenewRequest.prototype.signChain = $util.newBuffer([]);

        /**
         * IdentityPostKeysToRenewRequest sharingGroup.
         * @member {Array.<types.IIdentityShareEntry>} sharingGroup
         * @memberof types.IdentityPostKeysToRenewRequest
         * @instance
         */
        IdentityPostKeysToRenewRequest.prototype.sharingGroup = $util.emptyArray;

        /**
         * IdentityPostKeysToRenewRequest backward.
         * @member {types.IIdentityBackwardKey|null|undefined} backward
         * @memberof types.IdentityPostKeysToRenewRequest
         * @instance
         */
        IdentityPostKeysToRenewRequest.prototype.backward = null;

        /**
         * Creates a new IdentityPostKeysToRenewRequest instance using the specified properties.
         * @function create
         * @memberof types.IdentityPostKeysToRenewRequest
         * @static
         * @param {types.IIdentityPostKeysToRenewRequest=} [properties] Properties to set
         * @returns {types.IdentityPostKeysToRenewRequest} IdentityPostKeysToRenewRequest instance
         */
        IdentityPostKeysToRenewRequest.create = function create(properties) {
            return new IdentityPostKeysToRenewRequest(properties);
        };

        /**
         * Encodes the specified IdentityPostKeysToRenewRequest message. Does not implicitly {@link types.IdentityPostKeysToRenewRequest.verify|verify} messages.
         * @function encode
         * @memberof types.IdentityPostKeysToRenewRequest
         * @static
         * @param {types.IIdentityPostKeysToRenewRequest} message IdentityPostKeysToRenewRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityPostKeysToRenewRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            if (message.encryption != null && message.hasOwnProperty("encryption"))
                $root.types.IdentityEncryption.encode(message.encryption, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.signChain != null && message.hasOwnProperty("signChain"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.signChain);
            if (message.sharingGroup != null && message.sharingGroup.length)
                for (var i = 0; i < message.sharingGroup.length; ++i)
                    $root.types.IdentityShareEntry.encode(message.sharingGroup[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.backward != null && message.hasOwnProperty("backward"))
                $root.types.IdentityBackwardKey.encode(message.backward, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IdentityPostKeysToRenewRequest message, length delimited. Does not implicitly {@link types.IdentityPostKeysToRenewRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof types.IdentityPostKeysToRenewRequest
         * @static
         * @param {types.IIdentityPostKeysToRenewRequest} message IdentityPostKeysToRenewRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityPostKeysToRenewRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityPostKeysToRenewRequest message from the specified reader or buffer.
         * @function decode
         * @memberof types.IdentityPostKeysToRenewRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {types.IdentityPostKeysToRenewRequest} IdentityPostKeysToRenewRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityPostKeysToRenewRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.types.IdentityPostKeysToRenewRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                case 2:
                    message.encryption = $root.types.IdentityEncryption.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.signChain = reader.bytes();
                    break;
                case 4:
                    if (!(message.sharingGroup && message.sharingGroup.length))
                        message.sharingGroup = [];
                    message.sharingGroup.push($root.types.IdentityShareEntry.decode(reader, reader.uint32()));
                    break;
                case 5:
                    message.backward = $root.types.IdentityBackwardKey.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityPostKeysToRenewRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof types.IdentityPostKeysToRenewRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {types.IdentityPostKeysToRenewRequest} IdentityPostKeysToRenewRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityPostKeysToRenewRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityPostKeysToRenewRequest message.
         * @function verify
         * @memberof types.IdentityPostKeysToRenewRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityPostKeysToRenewRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            if (message.encryption != null && message.hasOwnProperty("encryption")) {
                var error = $root.types.IdentityEncryption.verify(message.encryption);
                if (error)
                    return "encryption." + error;
            }
            if (message.signChain != null && message.hasOwnProperty("signChain"))
                if (!(message.signChain && typeof message.signChain.length === "number" || $util.isString(message.signChain)))
                    return "signChain: buffer expected";
            if (message.sharingGroup != null && message.hasOwnProperty("sharingGroup")) {
                if (!Array.isArray(message.sharingGroup))
                    return "sharingGroup: array expected";
                for (var i = 0; i < message.sharingGroup.length; ++i) {
                    var error = $root.types.IdentityShareEntry.verify(message.sharingGroup[i]);
                    if (error)
                        return "sharingGroup." + error;
                }
            }
            if (message.backward != null && message.hasOwnProperty("backward")) {
                var error = $root.types.IdentityBackwardKey.verify(message.backward);
                if (error)
                    return "backward." + error;
            }
            return null;
        };

        /**
         * Creates an IdentityPostKeysToRenewRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof types.IdentityPostKeysToRenewRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {types.IdentityPostKeysToRenewRequest} IdentityPostKeysToRenewRequest
         */
        IdentityPostKeysToRenewRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.types.IdentityPostKeysToRenewRequest)
                return object;
            var message = new $root.types.IdentityPostKeysToRenewRequest();
            if (object.login != null)
                message.login = String(object.login);
            if (object.encryption != null) {
                if (typeof object.encryption !== "object")
                    throw TypeError(".types.IdentityPostKeysToRenewRequest.encryption: object expected");
                message.encryption = $root.types.IdentityEncryption.fromObject(object.encryption);
            }
            if (object.signChain != null)
                if (typeof object.signChain === "string")
                    $util.base64.decode(object.signChain, message.signChain = $util.newBuffer($util.base64.length(object.signChain)), 0);
                else if (object.signChain.length)
                    message.signChain = object.signChain;
            if (object.sharingGroup) {
                if (!Array.isArray(object.sharingGroup))
                    throw TypeError(".types.IdentityPostKeysToRenewRequest.sharingGroup: array expected");
                message.sharingGroup = [];
                for (var i = 0; i < object.sharingGroup.length; ++i) {
                    if (typeof object.sharingGroup[i] !== "object")
                        throw TypeError(".types.IdentityPostKeysToRenewRequest.sharingGroup: object expected");
                    message.sharingGroup[i] = $root.types.IdentityShareEntry.fromObject(object.sharingGroup[i]);
                }
            }
            if (object.backward != null) {
                if (typeof object.backward !== "object")
                    throw TypeError(".types.IdentityPostKeysToRenewRequest.backward: object expected");
                message.backward = $root.types.IdentityBackwardKey.fromObject(object.backward);
            }
            return message;
        };

        /**
         * Creates a plain object from an IdentityPostKeysToRenewRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof types.IdentityPostKeysToRenewRequest
         * @static
         * @param {types.IdentityPostKeysToRenewRequest} message IdentityPostKeysToRenewRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityPostKeysToRenewRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.sharingGroup = [];
            if (options.defaults) {
                object.login = "";
                object.encryption = null;
                object.signChain = options.bytes === String ? "" : [];
                object.backward = null;
            }
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            if (message.encryption != null && message.hasOwnProperty("encryption"))
                object.encryption = $root.types.IdentityEncryption.toObject(message.encryption, options);
            if (message.signChain != null && message.hasOwnProperty("signChain"))
                object.signChain = options.bytes === String ? $util.base64.encode(message.signChain, 0, message.signChain.length) : options.bytes === Array ? Array.prototype.slice.call(message.signChain) : message.signChain;
            if (message.sharingGroup && message.sharingGroup.length) {
                object.sharingGroup = [];
                for (var j = 0; j < message.sharingGroup.length; ++j)
                    object.sharingGroup[j] = $root.types.IdentityShareEntry.toObject(message.sharingGroup[j], options);
            }
            if (message.backward != null && message.hasOwnProperty("backward"))
                object.backward = $root.types.IdentityBackwardKey.toObject(message.backward, options);
            return object;
        };

        /**
         * Converts this IdentityPostKeysToRenewRequest to JSON.
         * @function toJSON
         * @memberof types.IdentityPostKeysToRenewRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityPostKeysToRenewRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityPostKeysToRenewRequest;
    })();

    types.IdentityGetSharingGraphElement = (function() {

        /**
         * Properties of an IdentityGetSharingGraphElement.
         * @memberof types
         * @interface IIdentityGetSharingGraphElement
         * @property {string|null} [login] IdentityGetSharingGraphElement login
         * @property {number|null} [version] IdentityGetSharingGraphElement version
         * @property {Uint8Array|null} [masterPublicKey] IdentityGetSharingGraphElement masterPublicKey
         * @property {types.ICipher|null} [sharingKey] IdentityGetSharingGraphElement sharingKey
         * @property {types.ICipher|null} [boxKey] IdentityGetSharingGraphElement boxKey
         * @property {types.ICipher|null} [signKey] IdentityGetSharingGraphElement signKey
         * @property {Array.<types.IIdentityPublicKey>|null} [sharingGroup] IdentityGetSharingGraphElement sharingGroup
         * @property {types.IIdentityKeyID|null} [sharedFrom] IdentityGetSharingGraphElement sharedFrom
         * @property {boolean|null} [latest] IdentityGetSharingGraphElement latest
         */

        /**
         * Constructs a new IdentityGetSharingGraphElement.
         * @memberof types
         * @classdesc Represents an IdentityGetSharingGraphElement.
         * @implements IIdentityGetSharingGraphElement
         * @constructor
         * @param {types.IIdentityGetSharingGraphElement=} [properties] Properties to set
         */
        function IdentityGetSharingGraphElement(properties) {
            this.sharingGroup = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityGetSharingGraphElement login.
         * @member {string} login
         * @memberof types.IdentityGetSharingGraphElement
         * @instance
         */
        IdentityGetSharingGraphElement.prototype.login = "";

        /**
         * IdentityGetSharingGraphElement version.
         * @member {number} version
         * @memberof types.IdentityGetSharingGraphElement
         * @instance
         */
        IdentityGetSharingGraphElement.prototype.version = 0;

        /**
         * IdentityGetSharingGraphElement masterPublicKey.
         * @member {Uint8Array} masterPublicKey
         * @memberof types.IdentityGetSharingGraphElement
         * @instance
         */
        IdentityGetSharingGraphElement.prototype.masterPublicKey = $util.newBuffer([]);

        /**
         * IdentityGetSharingGraphElement sharingKey.
         * @member {types.ICipher|null|undefined} sharingKey
         * @memberof types.IdentityGetSharingGraphElement
         * @instance
         */
        IdentityGetSharingGraphElement.prototype.sharingKey = null;

        /**
         * IdentityGetSharingGraphElement boxKey.
         * @member {types.ICipher|null|undefined} boxKey
         * @memberof types.IdentityGetSharingGraphElement
         * @instance
         */
        IdentityGetSharingGraphElement.prototype.boxKey = null;

        /**
         * IdentityGetSharingGraphElement signKey.
         * @member {types.ICipher|null|undefined} signKey
         * @memberof types.IdentityGetSharingGraphElement
         * @instance
         */
        IdentityGetSharingGraphElement.prototype.signKey = null;

        /**
         * IdentityGetSharingGraphElement sharingGroup.
         * @member {Array.<types.IIdentityPublicKey>} sharingGroup
         * @memberof types.IdentityGetSharingGraphElement
         * @instance
         */
        IdentityGetSharingGraphElement.prototype.sharingGroup = $util.emptyArray;

        /**
         * IdentityGetSharingGraphElement sharedFrom.
         * @member {types.IIdentityKeyID|null|undefined} sharedFrom
         * @memberof types.IdentityGetSharingGraphElement
         * @instance
         */
        IdentityGetSharingGraphElement.prototype.sharedFrom = null;

        /**
         * IdentityGetSharingGraphElement latest.
         * @member {boolean} latest
         * @memberof types.IdentityGetSharingGraphElement
         * @instance
         */
        IdentityGetSharingGraphElement.prototype.latest = false;

        /**
         * Creates a new IdentityGetSharingGraphElement instance using the specified properties.
         * @function create
         * @memberof types.IdentityGetSharingGraphElement
         * @static
         * @param {types.IIdentityGetSharingGraphElement=} [properties] Properties to set
         * @returns {types.IdentityGetSharingGraphElement} IdentityGetSharingGraphElement instance
         */
        IdentityGetSharingGraphElement.create = function create(properties) {
            return new IdentityGetSharingGraphElement(properties);
        };

        /**
         * Encodes the specified IdentityGetSharingGraphElement message. Does not implicitly {@link types.IdentityGetSharingGraphElement.verify|verify} messages.
         * @function encode
         * @memberof types.IdentityGetSharingGraphElement
         * @static
         * @param {types.IIdentityGetSharingGraphElement} message IdentityGetSharingGraphElement message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetSharingGraphElement.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            if (message.version != null && message.hasOwnProperty("version"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.version);
            if (message.masterPublicKey != null && message.hasOwnProperty("masterPublicKey"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.masterPublicKey);
            if (message.sharingKey != null && message.hasOwnProperty("sharingKey"))
                $root.types.Cipher.encode(message.sharingKey, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.boxKey != null && message.hasOwnProperty("boxKey"))
                $root.types.Cipher.encode(message.boxKey, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.signKey != null && message.hasOwnProperty("signKey"))
                $root.types.Cipher.encode(message.signKey, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.sharingGroup != null && message.sharingGroup.length)
                for (var i = 0; i < message.sharingGroup.length; ++i)
                    $root.types.IdentityPublicKey.encode(message.sharingGroup[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.sharedFrom != null && message.hasOwnProperty("sharedFrom"))
                $root.types.IdentityKeyID.encode(message.sharedFrom, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.latest != null && message.hasOwnProperty("latest"))
                writer.uint32(/* id 10, wireType 0 =*/80).bool(message.latest);
            return writer;
        };

        /**
         * Encodes the specified IdentityGetSharingGraphElement message, length delimited. Does not implicitly {@link types.IdentityGetSharingGraphElement.verify|verify} messages.
         * @function encodeDelimited
         * @memberof types.IdentityGetSharingGraphElement
         * @static
         * @param {types.IIdentityGetSharingGraphElement} message IdentityGetSharingGraphElement message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetSharingGraphElement.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityGetSharingGraphElement message from the specified reader or buffer.
         * @function decode
         * @memberof types.IdentityGetSharingGraphElement
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {types.IdentityGetSharingGraphElement} IdentityGetSharingGraphElement
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetSharingGraphElement.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.types.IdentityGetSharingGraphElement();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                case 2:
                    message.version = reader.uint32();
                    break;
                case 3:
                    message.masterPublicKey = reader.bytes();
                    break;
                case 4:
                    message.sharingKey = $root.types.Cipher.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.boxKey = $root.types.Cipher.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.signKey = $root.types.Cipher.decode(reader, reader.uint32());
                    break;
                case 8:
                    if (!(message.sharingGroup && message.sharingGroup.length))
                        message.sharingGroup = [];
                    message.sharingGroup.push($root.types.IdentityPublicKey.decode(reader, reader.uint32()));
                    break;
                case 9:
                    message.sharedFrom = $root.types.IdentityKeyID.decode(reader, reader.uint32());
                    break;
                case 10:
                    message.latest = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityGetSharingGraphElement message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof types.IdentityGetSharingGraphElement
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {types.IdentityGetSharingGraphElement} IdentityGetSharingGraphElement
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetSharingGraphElement.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityGetSharingGraphElement message.
         * @function verify
         * @memberof types.IdentityGetSharingGraphElement
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityGetSharingGraphElement.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isInteger(message.version))
                    return "version: integer expected";
            if (message.masterPublicKey != null && message.hasOwnProperty("masterPublicKey"))
                if (!(message.masterPublicKey && typeof message.masterPublicKey.length === "number" || $util.isString(message.masterPublicKey)))
                    return "masterPublicKey: buffer expected";
            if (message.sharingKey != null && message.hasOwnProperty("sharingKey")) {
                var error = $root.types.Cipher.verify(message.sharingKey);
                if (error)
                    return "sharingKey." + error;
            }
            if (message.boxKey != null && message.hasOwnProperty("boxKey")) {
                var error = $root.types.Cipher.verify(message.boxKey);
                if (error)
                    return "boxKey." + error;
            }
            if (message.signKey != null && message.hasOwnProperty("signKey")) {
                var error = $root.types.Cipher.verify(message.signKey);
                if (error)
                    return "signKey." + error;
            }
            if (message.sharingGroup != null && message.hasOwnProperty("sharingGroup")) {
                if (!Array.isArray(message.sharingGroup))
                    return "sharingGroup: array expected";
                for (var i = 0; i < message.sharingGroup.length; ++i) {
                    var error = $root.types.IdentityPublicKey.verify(message.sharingGroup[i]);
                    if (error)
                        return "sharingGroup." + error;
                }
            }
            if (message.sharedFrom != null && message.hasOwnProperty("sharedFrom")) {
                var error = $root.types.IdentityKeyID.verify(message.sharedFrom);
                if (error)
                    return "sharedFrom." + error;
            }
            if (message.latest != null && message.hasOwnProperty("latest"))
                if (typeof message.latest !== "boolean")
                    return "latest: boolean expected";
            return null;
        };

        /**
         * Creates an IdentityGetSharingGraphElement message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof types.IdentityGetSharingGraphElement
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {types.IdentityGetSharingGraphElement} IdentityGetSharingGraphElement
         */
        IdentityGetSharingGraphElement.fromObject = function fromObject(object) {
            if (object instanceof $root.types.IdentityGetSharingGraphElement)
                return object;
            var message = new $root.types.IdentityGetSharingGraphElement();
            if (object.login != null)
                message.login = String(object.login);
            if (object.version != null)
                message.version = object.version >>> 0;
            if (object.masterPublicKey != null)
                if (typeof object.masterPublicKey === "string")
                    $util.base64.decode(object.masterPublicKey, message.masterPublicKey = $util.newBuffer($util.base64.length(object.masterPublicKey)), 0);
                else if (object.masterPublicKey.length)
                    message.masterPublicKey = object.masterPublicKey;
            if (object.sharingKey != null) {
                if (typeof object.sharingKey !== "object")
                    throw TypeError(".types.IdentityGetSharingGraphElement.sharingKey: object expected");
                message.sharingKey = $root.types.Cipher.fromObject(object.sharingKey);
            }
            if (object.boxKey != null) {
                if (typeof object.boxKey !== "object")
                    throw TypeError(".types.IdentityGetSharingGraphElement.boxKey: object expected");
                message.boxKey = $root.types.Cipher.fromObject(object.boxKey);
            }
            if (object.signKey != null) {
                if (typeof object.signKey !== "object")
                    throw TypeError(".types.IdentityGetSharingGraphElement.signKey: object expected");
                message.signKey = $root.types.Cipher.fromObject(object.signKey);
            }
            if (object.sharingGroup) {
                if (!Array.isArray(object.sharingGroup))
                    throw TypeError(".types.IdentityGetSharingGraphElement.sharingGroup: array expected");
                message.sharingGroup = [];
                for (var i = 0; i < object.sharingGroup.length; ++i) {
                    if (typeof object.sharingGroup[i] !== "object")
                        throw TypeError(".types.IdentityGetSharingGraphElement.sharingGroup: object expected");
                    message.sharingGroup[i] = $root.types.IdentityPublicKey.fromObject(object.sharingGroup[i]);
                }
            }
            if (object.sharedFrom != null) {
                if (typeof object.sharedFrom !== "object")
                    throw TypeError(".types.IdentityGetSharingGraphElement.sharedFrom: object expected");
                message.sharedFrom = $root.types.IdentityKeyID.fromObject(object.sharedFrom);
            }
            if (object.latest != null)
                message.latest = Boolean(object.latest);
            return message;
        };

        /**
         * Creates a plain object from an IdentityGetSharingGraphElement message. Also converts values to other types if specified.
         * @function toObject
         * @memberof types.IdentityGetSharingGraphElement
         * @static
         * @param {types.IdentityGetSharingGraphElement} message IdentityGetSharingGraphElement
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityGetSharingGraphElement.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.sharingGroup = [];
            if (options.defaults) {
                object.login = "";
                object.version = 0;
                object.masterPublicKey = options.bytes === String ? "" : [];
                object.sharingKey = null;
                object.boxKey = null;
                object.signKey = null;
                object.sharedFrom = null;
                object.latest = false;
            }
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            if (message.masterPublicKey != null && message.hasOwnProperty("masterPublicKey"))
                object.masterPublicKey = options.bytes === String ? $util.base64.encode(message.masterPublicKey, 0, message.masterPublicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.masterPublicKey) : message.masterPublicKey;
            if (message.sharingKey != null && message.hasOwnProperty("sharingKey"))
                object.sharingKey = $root.types.Cipher.toObject(message.sharingKey, options);
            if (message.boxKey != null && message.hasOwnProperty("boxKey"))
                object.boxKey = $root.types.Cipher.toObject(message.boxKey, options);
            if (message.signKey != null && message.hasOwnProperty("signKey"))
                object.signKey = $root.types.Cipher.toObject(message.signKey, options);
            if (message.sharingGroup && message.sharingGroup.length) {
                object.sharingGroup = [];
                for (var j = 0; j < message.sharingGroup.length; ++j)
                    object.sharingGroup[j] = $root.types.IdentityPublicKey.toObject(message.sharingGroup[j], options);
            }
            if (message.sharedFrom != null && message.hasOwnProperty("sharedFrom"))
                object.sharedFrom = $root.types.IdentityKeyID.toObject(message.sharedFrom, options);
            if (message.latest != null && message.hasOwnProperty("latest"))
                object.latest = message.latest;
            return object;
        };

        /**
         * Converts this IdentityGetSharingGraphElement to JSON.
         * @function toJSON
         * @memberof types.IdentityGetSharingGraphElement
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityGetSharingGraphElement.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityGetSharingGraphElement;
    })();

    types.IdentityGetSharingGraphResponse = (function() {

        /**
         * Properties of an IdentityGetSharingGraphResponse.
         * @memberof types
         * @interface IIdentityGetSharingGraphResponse
         * @property {Array.<types.IIdentityGetSharingGraphElement>|null} [graph] IdentityGetSharingGraphResponse graph
         */

        /**
         * Constructs a new IdentityGetSharingGraphResponse.
         * @memberof types
         * @classdesc Represents an IdentityGetSharingGraphResponse.
         * @implements IIdentityGetSharingGraphResponse
         * @constructor
         * @param {types.IIdentityGetSharingGraphResponse=} [properties] Properties to set
         */
        function IdentityGetSharingGraphResponse(properties) {
            this.graph = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityGetSharingGraphResponse graph.
         * @member {Array.<types.IIdentityGetSharingGraphElement>} graph
         * @memberof types.IdentityGetSharingGraphResponse
         * @instance
         */
        IdentityGetSharingGraphResponse.prototype.graph = $util.emptyArray;

        /**
         * Creates a new IdentityGetSharingGraphResponse instance using the specified properties.
         * @function create
         * @memberof types.IdentityGetSharingGraphResponse
         * @static
         * @param {types.IIdentityGetSharingGraphResponse=} [properties] Properties to set
         * @returns {types.IdentityGetSharingGraphResponse} IdentityGetSharingGraphResponse instance
         */
        IdentityGetSharingGraphResponse.create = function create(properties) {
            return new IdentityGetSharingGraphResponse(properties);
        };

        /**
         * Encodes the specified IdentityGetSharingGraphResponse message. Does not implicitly {@link types.IdentityGetSharingGraphResponse.verify|verify} messages.
         * @function encode
         * @memberof types.IdentityGetSharingGraphResponse
         * @static
         * @param {types.IIdentityGetSharingGraphResponse} message IdentityGetSharingGraphResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetSharingGraphResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.graph != null && message.graph.length)
                for (var i = 0; i < message.graph.length; ++i)
                    $root.types.IdentityGetSharingGraphElement.encode(message.graph[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IdentityGetSharingGraphResponse message, length delimited. Does not implicitly {@link types.IdentityGetSharingGraphResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof types.IdentityGetSharingGraphResponse
         * @static
         * @param {types.IIdentityGetSharingGraphResponse} message IdentityGetSharingGraphResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetSharingGraphResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityGetSharingGraphResponse message from the specified reader or buffer.
         * @function decode
         * @memberof types.IdentityGetSharingGraphResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {types.IdentityGetSharingGraphResponse} IdentityGetSharingGraphResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetSharingGraphResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.types.IdentityGetSharingGraphResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.graph && message.graph.length))
                        message.graph = [];
                    message.graph.push($root.types.IdentityGetSharingGraphElement.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityGetSharingGraphResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof types.IdentityGetSharingGraphResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {types.IdentityGetSharingGraphResponse} IdentityGetSharingGraphResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetSharingGraphResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityGetSharingGraphResponse message.
         * @function verify
         * @memberof types.IdentityGetSharingGraphResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityGetSharingGraphResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.graph != null && message.hasOwnProperty("graph")) {
                if (!Array.isArray(message.graph))
                    return "graph: array expected";
                for (var i = 0; i < message.graph.length; ++i) {
                    var error = $root.types.IdentityGetSharingGraphElement.verify(message.graph[i]);
                    if (error)
                        return "graph." + error;
                }
            }
            return null;
        };

        /**
         * Creates an IdentityGetSharingGraphResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof types.IdentityGetSharingGraphResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {types.IdentityGetSharingGraphResponse} IdentityGetSharingGraphResponse
         */
        IdentityGetSharingGraphResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.types.IdentityGetSharingGraphResponse)
                return object;
            var message = new $root.types.IdentityGetSharingGraphResponse();
            if (object.graph) {
                if (!Array.isArray(object.graph))
                    throw TypeError(".types.IdentityGetSharingGraphResponse.graph: array expected");
                message.graph = [];
                for (var i = 0; i < object.graph.length; ++i) {
                    if (typeof object.graph[i] !== "object")
                        throw TypeError(".types.IdentityGetSharingGraphResponse.graph: object expected");
                    message.graph[i] = $root.types.IdentityGetSharingGraphElement.fromObject(object.graph[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an IdentityGetSharingGraphResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof types.IdentityGetSharingGraphResponse
         * @static
         * @param {types.IdentityGetSharingGraphResponse} message IdentityGetSharingGraphResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityGetSharingGraphResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.graph = [];
            if (message.graph && message.graph.length) {
                object.graph = [];
                for (var j = 0; j < message.graph.length; ++j)
                    object.graph[j] = $root.types.IdentityGetSharingGraphElement.toObject(message.graph[j], options);
            }
            return object;
        };

        /**
         * Converts this IdentityGetSharingGraphResponse to JSON.
         * @function toJSON
         * @memberof types.IdentityGetSharingGraphResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityGetSharingGraphResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityGetSharingGraphResponse;
    })();

    types.IdentityPostSharingGraphElement = (function() {

        /**
         * Properties of an IdentityPostSharingGraphElement.
         * @memberof types
         * @interface IIdentityPostSharingGraphElement
         * @property {string|null} [login] IdentityPostSharingGraphElement login
         * @property {number|null} [version] IdentityPostSharingGraphElement version
         * @property {types.IIdentityEncryptedKey|null} [sharingEncrypted] IdentityPostSharingGraphElement sharingEncrypted
         * @property {types.IIdentityEncryptedKey|null} [boxEncrypted] IdentityPostSharingGraphElement boxEncrypted
         * @property {types.IIdentityEncryptedKey|null} [signEncrypted] IdentityPostSharingGraphElement signEncrypted
         * @property {types.IIdentityEncryptedKey|null} [readEncrypted] IdentityPostSharingGraphElement readEncrypted
         * @property {Uint8Array|null} [signChain] IdentityPostSharingGraphElement signChain
         * @property {Array.<types.IIdentityShareEntry>|null} [sharingGroup] IdentityPostSharingGraphElement sharingGroup
         * @property {types.IIdentityBackwardKey|null} [backward] IdentityPostSharingGraphElement backward
         */

        /**
         * Constructs a new IdentityPostSharingGraphElement.
         * @memberof types
         * @classdesc Represents an IdentityPostSharingGraphElement.
         * @implements IIdentityPostSharingGraphElement
         * @constructor
         * @param {types.IIdentityPostSharingGraphElement=} [properties] Properties to set
         */
        function IdentityPostSharingGraphElement(properties) {
            this.sharingGroup = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityPostSharingGraphElement login.
         * @member {string} login
         * @memberof types.IdentityPostSharingGraphElement
         * @instance
         */
        IdentityPostSharingGraphElement.prototype.login = "";

        /**
         * IdentityPostSharingGraphElement version.
         * @member {number} version
         * @memberof types.IdentityPostSharingGraphElement
         * @instance
         */
        IdentityPostSharingGraphElement.prototype.version = 0;

        /**
         * IdentityPostSharingGraphElement sharingEncrypted.
         * @member {types.IIdentityEncryptedKey|null|undefined} sharingEncrypted
         * @memberof types.IdentityPostSharingGraphElement
         * @instance
         */
        IdentityPostSharingGraphElement.prototype.sharingEncrypted = null;

        /**
         * IdentityPostSharingGraphElement boxEncrypted.
         * @member {types.IIdentityEncryptedKey|null|undefined} boxEncrypted
         * @memberof types.IdentityPostSharingGraphElement
         * @instance
         */
        IdentityPostSharingGraphElement.prototype.boxEncrypted = null;

        /**
         * IdentityPostSharingGraphElement signEncrypted.
         * @member {types.IIdentityEncryptedKey|null|undefined} signEncrypted
         * @memberof types.IdentityPostSharingGraphElement
         * @instance
         */
        IdentityPostSharingGraphElement.prototype.signEncrypted = null;

        /**
         * IdentityPostSharingGraphElement readEncrypted.
         * @member {types.IIdentityEncryptedKey|null|undefined} readEncrypted
         * @memberof types.IdentityPostSharingGraphElement
         * @instance
         */
        IdentityPostSharingGraphElement.prototype.readEncrypted = null;

        /**
         * IdentityPostSharingGraphElement signChain.
         * @member {Uint8Array} signChain
         * @memberof types.IdentityPostSharingGraphElement
         * @instance
         */
        IdentityPostSharingGraphElement.prototype.signChain = $util.newBuffer([]);

        /**
         * IdentityPostSharingGraphElement sharingGroup.
         * @member {Array.<types.IIdentityShareEntry>} sharingGroup
         * @memberof types.IdentityPostSharingGraphElement
         * @instance
         */
        IdentityPostSharingGraphElement.prototype.sharingGroup = $util.emptyArray;

        /**
         * IdentityPostSharingGraphElement backward.
         * @member {types.IIdentityBackwardKey|null|undefined} backward
         * @memberof types.IdentityPostSharingGraphElement
         * @instance
         */
        IdentityPostSharingGraphElement.prototype.backward = null;

        /**
         * Creates a new IdentityPostSharingGraphElement instance using the specified properties.
         * @function create
         * @memberof types.IdentityPostSharingGraphElement
         * @static
         * @param {types.IIdentityPostSharingGraphElement=} [properties] Properties to set
         * @returns {types.IdentityPostSharingGraphElement} IdentityPostSharingGraphElement instance
         */
        IdentityPostSharingGraphElement.create = function create(properties) {
            return new IdentityPostSharingGraphElement(properties);
        };

        /**
         * Encodes the specified IdentityPostSharingGraphElement message. Does not implicitly {@link types.IdentityPostSharingGraphElement.verify|verify} messages.
         * @function encode
         * @memberof types.IdentityPostSharingGraphElement
         * @static
         * @param {types.IIdentityPostSharingGraphElement} message IdentityPostSharingGraphElement message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityPostSharingGraphElement.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            if (message.version != null && message.hasOwnProperty("version"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.version);
            if (message.sharingEncrypted != null && message.hasOwnProperty("sharingEncrypted"))
                $root.types.IdentityEncryptedKey.encode(message.sharingEncrypted, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.boxEncrypted != null && message.hasOwnProperty("boxEncrypted"))
                $root.types.IdentityEncryptedKey.encode(message.boxEncrypted, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.signEncrypted != null && message.hasOwnProperty("signEncrypted"))
                $root.types.IdentityEncryptedKey.encode(message.signEncrypted, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.readEncrypted != null && message.hasOwnProperty("readEncrypted"))
                $root.types.IdentityEncryptedKey.encode(message.readEncrypted, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.signChain != null && message.hasOwnProperty("signChain"))
                writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.signChain);
            if (message.sharingGroup != null && message.sharingGroup.length)
                for (var i = 0; i < message.sharingGroup.length; ++i)
                    $root.types.IdentityShareEntry.encode(message.sharingGroup[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.backward != null && message.hasOwnProperty("backward"))
                $root.types.IdentityBackwardKey.encode(message.backward, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IdentityPostSharingGraphElement message, length delimited. Does not implicitly {@link types.IdentityPostSharingGraphElement.verify|verify} messages.
         * @function encodeDelimited
         * @memberof types.IdentityPostSharingGraphElement
         * @static
         * @param {types.IIdentityPostSharingGraphElement} message IdentityPostSharingGraphElement message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityPostSharingGraphElement.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityPostSharingGraphElement message from the specified reader or buffer.
         * @function decode
         * @memberof types.IdentityPostSharingGraphElement
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {types.IdentityPostSharingGraphElement} IdentityPostSharingGraphElement
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityPostSharingGraphElement.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.types.IdentityPostSharingGraphElement();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                case 2:
                    message.version = reader.uint32();
                    break;
                case 3:
                    message.sharingEncrypted = $root.types.IdentityEncryptedKey.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.boxEncrypted = $root.types.IdentityEncryptedKey.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.signEncrypted = $root.types.IdentityEncryptedKey.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.readEncrypted = $root.types.IdentityEncryptedKey.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.signChain = reader.bytes();
                    break;
                case 8:
                    if (!(message.sharingGroup && message.sharingGroup.length))
                        message.sharingGroup = [];
                    message.sharingGroup.push($root.types.IdentityShareEntry.decode(reader, reader.uint32()));
                    break;
                case 9:
                    message.backward = $root.types.IdentityBackwardKey.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityPostSharingGraphElement message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof types.IdentityPostSharingGraphElement
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {types.IdentityPostSharingGraphElement} IdentityPostSharingGraphElement
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityPostSharingGraphElement.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityPostSharingGraphElement message.
         * @function verify
         * @memberof types.IdentityPostSharingGraphElement
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityPostSharingGraphElement.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isInteger(message.version))
                    return "version: integer expected";
            if (message.sharingEncrypted != null && message.hasOwnProperty("sharingEncrypted")) {
                var error = $root.types.IdentityEncryptedKey.verify(message.sharingEncrypted);
                if (error)
                    return "sharingEncrypted." + error;
            }
            if (message.boxEncrypted != null && message.hasOwnProperty("boxEncrypted")) {
                var error = $root.types.IdentityEncryptedKey.verify(message.boxEncrypted);
                if (error)
                    return "boxEncrypted." + error;
            }
            if (message.signEncrypted != null && message.hasOwnProperty("signEncrypted")) {
                var error = $root.types.IdentityEncryptedKey.verify(message.signEncrypted);
                if (error)
                    return "signEncrypted." + error;
            }
            if (message.readEncrypted != null && message.hasOwnProperty("readEncrypted")) {
                var error = $root.types.IdentityEncryptedKey.verify(message.readEncrypted);
                if (error)
                    return "readEncrypted." + error;
            }
            if (message.signChain != null && message.hasOwnProperty("signChain"))
                if (!(message.signChain && typeof message.signChain.length === "number" || $util.isString(message.signChain)))
                    return "signChain: buffer expected";
            if (message.sharingGroup != null && message.hasOwnProperty("sharingGroup")) {
                if (!Array.isArray(message.sharingGroup))
                    return "sharingGroup: array expected";
                for (var i = 0; i < message.sharingGroup.length; ++i) {
                    var error = $root.types.IdentityShareEntry.verify(message.sharingGroup[i]);
                    if (error)
                        return "sharingGroup." + error;
                }
            }
            if (message.backward != null && message.hasOwnProperty("backward")) {
                var error = $root.types.IdentityBackwardKey.verify(message.backward);
                if (error)
                    return "backward." + error;
            }
            return null;
        };

        /**
         * Creates an IdentityPostSharingGraphElement message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof types.IdentityPostSharingGraphElement
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {types.IdentityPostSharingGraphElement} IdentityPostSharingGraphElement
         */
        IdentityPostSharingGraphElement.fromObject = function fromObject(object) {
            if (object instanceof $root.types.IdentityPostSharingGraphElement)
                return object;
            var message = new $root.types.IdentityPostSharingGraphElement();
            if (object.login != null)
                message.login = String(object.login);
            if (object.version != null)
                message.version = object.version >>> 0;
            if (object.sharingEncrypted != null) {
                if (typeof object.sharingEncrypted !== "object")
                    throw TypeError(".types.IdentityPostSharingGraphElement.sharingEncrypted: object expected");
                message.sharingEncrypted = $root.types.IdentityEncryptedKey.fromObject(object.sharingEncrypted);
            }
            if (object.boxEncrypted != null) {
                if (typeof object.boxEncrypted !== "object")
                    throw TypeError(".types.IdentityPostSharingGraphElement.boxEncrypted: object expected");
                message.boxEncrypted = $root.types.IdentityEncryptedKey.fromObject(object.boxEncrypted);
            }
            if (object.signEncrypted != null) {
                if (typeof object.signEncrypted !== "object")
                    throw TypeError(".types.IdentityPostSharingGraphElement.signEncrypted: object expected");
                message.signEncrypted = $root.types.IdentityEncryptedKey.fromObject(object.signEncrypted);
            }
            if (object.readEncrypted != null) {
                if (typeof object.readEncrypted !== "object")
                    throw TypeError(".types.IdentityPostSharingGraphElement.readEncrypted: object expected");
                message.readEncrypted = $root.types.IdentityEncryptedKey.fromObject(object.readEncrypted);
            }
            if (object.signChain != null)
                if (typeof object.signChain === "string")
                    $util.base64.decode(object.signChain, message.signChain = $util.newBuffer($util.base64.length(object.signChain)), 0);
                else if (object.signChain.length)
                    message.signChain = object.signChain;
            if (object.sharingGroup) {
                if (!Array.isArray(object.sharingGroup))
                    throw TypeError(".types.IdentityPostSharingGraphElement.sharingGroup: array expected");
                message.sharingGroup = [];
                for (var i = 0; i < object.sharingGroup.length; ++i) {
                    if (typeof object.sharingGroup[i] !== "object")
                        throw TypeError(".types.IdentityPostSharingGraphElement.sharingGroup: object expected");
                    message.sharingGroup[i] = $root.types.IdentityShareEntry.fromObject(object.sharingGroup[i]);
                }
            }
            if (object.backward != null) {
                if (typeof object.backward !== "object")
                    throw TypeError(".types.IdentityPostSharingGraphElement.backward: object expected");
                message.backward = $root.types.IdentityBackwardKey.fromObject(object.backward);
            }
            return message;
        };

        /**
         * Creates a plain object from an IdentityPostSharingGraphElement message. Also converts values to other types if specified.
         * @function toObject
         * @memberof types.IdentityPostSharingGraphElement
         * @static
         * @param {types.IdentityPostSharingGraphElement} message IdentityPostSharingGraphElement
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityPostSharingGraphElement.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.sharingGroup = [];
            if (options.defaults) {
                object.login = "";
                object.version = 0;
                object.sharingEncrypted = null;
                object.boxEncrypted = null;
                object.signEncrypted = null;
                object.readEncrypted = null;
                object.signChain = options.bytes === String ? "" : [];
                object.backward = null;
            }
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            if (message.sharingEncrypted != null && message.hasOwnProperty("sharingEncrypted"))
                object.sharingEncrypted = $root.types.IdentityEncryptedKey.toObject(message.sharingEncrypted, options);
            if (message.boxEncrypted != null && message.hasOwnProperty("boxEncrypted"))
                object.boxEncrypted = $root.types.IdentityEncryptedKey.toObject(message.boxEncrypted, options);
            if (message.signEncrypted != null && message.hasOwnProperty("signEncrypted"))
                object.signEncrypted = $root.types.IdentityEncryptedKey.toObject(message.signEncrypted, options);
            if (message.readEncrypted != null && message.hasOwnProperty("readEncrypted"))
                object.readEncrypted = $root.types.IdentityEncryptedKey.toObject(message.readEncrypted, options);
            if (message.signChain != null && message.hasOwnProperty("signChain"))
                object.signChain = options.bytes === String ? $util.base64.encode(message.signChain, 0, message.signChain.length) : options.bytes === Array ? Array.prototype.slice.call(message.signChain) : message.signChain;
            if (message.sharingGroup && message.sharingGroup.length) {
                object.sharingGroup = [];
                for (var j = 0; j < message.sharingGroup.length; ++j)
                    object.sharingGroup[j] = $root.types.IdentityShareEntry.toObject(message.sharingGroup[j], options);
            }
            if (message.backward != null && message.hasOwnProperty("backward"))
                object.backward = $root.types.IdentityBackwardKey.toObject(message.backward, options);
            return object;
        };

        /**
         * Converts this IdentityPostSharingGraphElement to JSON.
         * @function toJSON
         * @memberof types.IdentityPostSharingGraphElement
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityPostSharingGraphElement.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityPostSharingGraphElement;
    })();

    types.IdentityPostSharingGraphRequest = (function() {

        /**
         * Properties of an IdentityPostSharingGraphRequest.
         * @memberof types
         * @interface IIdentityPostSharingGraphRequest
         * @property {string|null} [login] IdentityPostSharingGraphRequest login
         * @property {Array.<types.IIdentityPostSharingGraphElement>|null} [graph] IdentityPostSharingGraphRequest graph
         */

        /**
         * Constructs a new IdentityPostSharingGraphRequest.
         * @memberof types
         * @classdesc Represents an IdentityPostSharingGraphRequest.
         * @implements IIdentityPostSharingGraphRequest
         * @constructor
         * @param {types.IIdentityPostSharingGraphRequest=} [properties] Properties to set
         */
        function IdentityPostSharingGraphRequest(properties) {
            this.graph = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityPostSharingGraphRequest login.
         * @member {string} login
         * @memberof types.IdentityPostSharingGraphRequest
         * @instance
         */
        IdentityPostSharingGraphRequest.prototype.login = "";

        /**
         * IdentityPostSharingGraphRequest graph.
         * @member {Array.<types.IIdentityPostSharingGraphElement>} graph
         * @memberof types.IdentityPostSharingGraphRequest
         * @instance
         */
        IdentityPostSharingGraphRequest.prototype.graph = $util.emptyArray;

        /**
         * Creates a new IdentityPostSharingGraphRequest instance using the specified properties.
         * @function create
         * @memberof types.IdentityPostSharingGraphRequest
         * @static
         * @param {types.IIdentityPostSharingGraphRequest=} [properties] Properties to set
         * @returns {types.IdentityPostSharingGraphRequest} IdentityPostSharingGraphRequest instance
         */
        IdentityPostSharingGraphRequest.create = function create(properties) {
            return new IdentityPostSharingGraphRequest(properties);
        };

        /**
         * Encodes the specified IdentityPostSharingGraphRequest message. Does not implicitly {@link types.IdentityPostSharingGraphRequest.verify|verify} messages.
         * @function encode
         * @memberof types.IdentityPostSharingGraphRequest
         * @static
         * @param {types.IIdentityPostSharingGraphRequest} message IdentityPostSharingGraphRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityPostSharingGraphRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            if (message.graph != null && message.graph.length)
                for (var i = 0; i < message.graph.length; ++i)
                    $root.types.IdentityPostSharingGraphElement.encode(message.graph[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IdentityPostSharingGraphRequest message, length delimited. Does not implicitly {@link types.IdentityPostSharingGraphRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof types.IdentityPostSharingGraphRequest
         * @static
         * @param {types.IIdentityPostSharingGraphRequest} message IdentityPostSharingGraphRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityPostSharingGraphRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityPostSharingGraphRequest message from the specified reader or buffer.
         * @function decode
         * @memberof types.IdentityPostSharingGraphRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {types.IdentityPostSharingGraphRequest} IdentityPostSharingGraphRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityPostSharingGraphRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.types.IdentityPostSharingGraphRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                case 2:
                    if (!(message.graph && message.graph.length))
                        message.graph = [];
                    message.graph.push($root.types.IdentityPostSharingGraphElement.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityPostSharingGraphRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof types.IdentityPostSharingGraphRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {types.IdentityPostSharingGraphRequest} IdentityPostSharingGraphRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityPostSharingGraphRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityPostSharingGraphRequest message.
         * @function verify
         * @memberof types.IdentityPostSharingGraphRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityPostSharingGraphRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            if (message.graph != null && message.hasOwnProperty("graph")) {
                if (!Array.isArray(message.graph))
                    return "graph: array expected";
                for (var i = 0; i < message.graph.length; ++i) {
                    var error = $root.types.IdentityPostSharingGraphElement.verify(message.graph[i]);
                    if (error)
                        return "graph." + error;
                }
            }
            return null;
        };

        /**
         * Creates an IdentityPostSharingGraphRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof types.IdentityPostSharingGraphRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {types.IdentityPostSharingGraphRequest} IdentityPostSharingGraphRequest
         */
        IdentityPostSharingGraphRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.types.IdentityPostSharingGraphRequest)
                return object;
            var message = new $root.types.IdentityPostSharingGraphRequest();
            if (object.login != null)
                message.login = String(object.login);
            if (object.graph) {
                if (!Array.isArray(object.graph))
                    throw TypeError(".types.IdentityPostSharingGraphRequest.graph: array expected");
                message.graph = [];
                for (var i = 0; i < object.graph.length; ++i) {
                    if (typeof object.graph[i] !== "object")
                        throw TypeError(".types.IdentityPostSharingGraphRequest.graph: object expected");
                    message.graph[i] = $root.types.IdentityPostSharingGraphElement.fromObject(object.graph[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an IdentityPostSharingGraphRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof types.IdentityPostSharingGraphRequest
         * @static
         * @param {types.IdentityPostSharingGraphRequest} message IdentityPostSharingGraphRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityPostSharingGraphRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.graph = [];
            if (options.defaults)
                object.login = "";
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            if (message.graph && message.graph.length) {
                object.graph = [];
                for (var j = 0; j < message.graph.length; ++j)
                    object.graph[j] = $root.types.IdentityPostSharingGraphElement.toObject(message.graph[j], options);
            }
            return object;
        };

        /**
         * Converts this IdentityPostSharingGraphRequest to JSON.
         * @function toJSON
         * @memberof types.IdentityPostSharingGraphRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityPostSharingGraphRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityPostSharingGraphRequest;
    })();

    types.IdentityToggleActiveStatusRequest = (function() {

        /**
         * Properties of an IdentityToggleActiveStatusRequest.
         * @memberof types
         * @interface IIdentityToggleActiveStatusRequest
         * @property {string|null} [login] IdentityToggleActiveStatusRequest login
         * @property {boolean|null} [active] IdentityToggleActiveStatusRequest active
         */

        /**
         * Constructs a new IdentityToggleActiveStatusRequest.
         * @memberof types
         * @classdesc Represents an IdentityToggleActiveStatusRequest.
         * @implements IIdentityToggleActiveStatusRequest
         * @constructor
         * @param {types.IIdentityToggleActiveStatusRequest=} [properties] Properties to set
         */
        function IdentityToggleActiveStatusRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityToggleActiveStatusRequest login.
         * @member {string} login
         * @memberof types.IdentityToggleActiveStatusRequest
         * @instance
         */
        IdentityToggleActiveStatusRequest.prototype.login = "";

        /**
         * IdentityToggleActiveStatusRequest active.
         * @member {boolean} active
         * @memberof types.IdentityToggleActiveStatusRequest
         * @instance
         */
        IdentityToggleActiveStatusRequest.prototype.active = false;

        /**
         * Creates a new IdentityToggleActiveStatusRequest instance using the specified properties.
         * @function create
         * @memberof types.IdentityToggleActiveStatusRequest
         * @static
         * @param {types.IIdentityToggleActiveStatusRequest=} [properties] Properties to set
         * @returns {types.IdentityToggleActiveStatusRequest} IdentityToggleActiveStatusRequest instance
         */
        IdentityToggleActiveStatusRequest.create = function create(properties) {
            return new IdentityToggleActiveStatusRequest(properties);
        };

        /**
         * Encodes the specified IdentityToggleActiveStatusRequest message. Does not implicitly {@link types.IdentityToggleActiveStatusRequest.verify|verify} messages.
         * @function encode
         * @memberof types.IdentityToggleActiveStatusRequest
         * @static
         * @param {types.IIdentityToggleActiveStatusRequest} message IdentityToggleActiveStatusRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityToggleActiveStatusRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            if (message.active != null && message.hasOwnProperty("active"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.active);
            return writer;
        };

        /**
         * Encodes the specified IdentityToggleActiveStatusRequest message, length delimited. Does not implicitly {@link types.IdentityToggleActiveStatusRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof types.IdentityToggleActiveStatusRequest
         * @static
         * @param {types.IIdentityToggleActiveStatusRequest} message IdentityToggleActiveStatusRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityToggleActiveStatusRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityToggleActiveStatusRequest message from the specified reader or buffer.
         * @function decode
         * @memberof types.IdentityToggleActiveStatusRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {types.IdentityToggleActiveStatusRequest} IdentityToggleActiveStatusRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityToggleActiveStatusRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.types.IdentityToggleActiveStatusRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                case 2:
                    message.active = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityToggleActiveStatusRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof types.IdentityToggleActiveStatusRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {types.IdentityToggleActiveStatusRequest} IdentityToggleActiveStatusRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityToggleActiveStatusRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityToggleActiveStatusRequest message.
         * @function verify
         * @memberof types.IdentityToggleActiveStatusRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityToggleActiveStatusRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            if (message.active != null && message.hasOwnProperty("active"))
                if (typeof message.active !== "boolean")
                    return "active: boolean expected";
            return null;
        };

        /**
         * Creates an IdentityToggleActiveStatusRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof types.IdentityToggleActiveStatusRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {types.IdentityToggleActiveStatusRequest} IdentityToggleActiveStatusRequest
         */
        IdentityToggleActiveStatusRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.types.IdentityToggleActiveStatusRequest)
                return object;
            var message = new $root.types.IdentityToggleActiveStatusRequest();
            if (object.login != null)
                message.login = String(object.login);
            if (object.active != null)
                message.active = Boolean(object.active);
            return message;
        };

        /**
         * Creates a plain object from an IdentityToggleActiveStatusRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof types.IdentityToggleActiveStatusRequest
         * @static
         * @param {types.IdentityToggleActiveStatusRequest} message IdentityToggleActiveStatusRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityToggleActiveStatusRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.login = "";
                object.active = false;
            }
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            if (message.active != null && message.hasOwnProperty("active"))
                object.active = message.active;
            return object;
        };

        /**
         * Converts this IdentityToggleActiveStatusRequest to JSON.
         * @function toJSON
         * @memberof types.IdentityToggleActiveStatusRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityToggleActiveStatusRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityToggleActiveStatusRequest;
    })();

    /**
     * SessionSaltKind enum.
     * @name types.SessionSaltKind
     * @enum {string}
     * @property {number} TIME=0 TIME value
     * @property {number} RAND=1 RAND value
     */
    types.SessionSaltKind = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "TIME"] = 0;
        values[valuesById[1] = "RAND"] = 1;
        return values;
    })();

    types.SessionCreateChallengeRequest = (function() {

        /**
         * Properties of a SessionCreateChallengeRequest.
         * @memberof types
         * @interface ISessionCreateChallengeRequest
         * @property {string|null} [login] SessionCreateChallengeRequest login
         * @property {types.SessionSaltKind|null} [saltKind] SessionCreateChallengeRequest saltKind
         */

        /**
         * Constructs a new SessionCreateChallengeRequest.
         * @memberof types
         * @classdesc Represents a SessionCreateChallengeRequest.
         * @implements ISessionCreateChallengeRequest
         * @constructor
         * @param {types.ISessionCreateChallengeRequest=} [properties] Properties to set
         */
        function SessionCreateChallengeRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SessionCreateChallengeRequest login.
         * @member {string} login
         * @memberof types.SessionCreateChallengeRequest
         * @instance
         */
        SessionCreateChallengeRequest.prototype.login = "";

        /**
         * SessionCreateChallengeRequest saltKind.
         * @member {types.SessionSaltKind} saltKind
         * @memberof types.SessionCreateChallengeRequest
         * @instance
         */
        SessionCreateChallengeRequest.prototype.saltKind = 0;

        /**
         * Creates a new SessionCreateChallengeRequest instance using the specified properties.
         * @function create
         * @memberof types.SessionCreateChallengeRequest
         * @static
         * @param {types.ISessionCreateChallengeRequest=} [properties] Properties to set
         * @returns {types.SessionCreateChallengeRequest} SessionCreateChallengeRequest instance
         */
        SessionCreateChallengeRequest.create = function create(properties) {
            return new SessionCreateChallengeRequest(properties);
        };

        /**
         * Encodes the specified SessionCreateChallengeRequest message. Does not implicitly {@link types.SessionCreateChallengeRequest.verify|verify} messages.
         * @function encode
         * @memberof types.SessionCreateChallengeRequest
         * @static
         * @param {types.ISessionCreateChallengeRequest} message SessionCreateChallengeRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SessionCreateChallengeRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            if (message.saltKind != null && message.hasOwnProperty("saltKind"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.saltKind);
            return writer;
        };

        /**
         * Encodes the specified SessionCreateChallengeRequest message, length delimited. Does not implicitly {@link types.SessionCreateChallengeRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof types.SessionCreateChallengeRequest
         * @static
         * @param {types.ISessionCreateChallengeRequest} message SessionCreateChallengeRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SessionCreateChallengeRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SessionCreateChallengeRequest message from the specified reader or buffer.
         * @function decode
         * @memberof types.SessionCreateChallengeRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {types.SessionCreateChallengeRequest} SessionCreateChallengeRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SessionCreateChallengeRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.types.SessionCreateChallengeRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                case 2:
                    message.saltKind = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SessionCreateChallengeRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof types.SessionCreateChallengeRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {types.SessionCreateChallengeRequest} SessionCreateChallengeRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SessionCreateChallengeRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SessionCreateChallengeRequest message.
         * @function verify
         * @memberof types.SessionCreateChallengeRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SessionCreateChallengeRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            if (message.saltKind != null && message.hasOwnProperty("saltKind"))
                switch (message.saltKind) {
                default:
                    return "saltKind: enum value expected";
                case 0:
                case 1:
                    break;
                }
            return null;
        };

        /**
         * Creates a SessionCreateChallengeRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof types.SessionCreateChallengeRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {types.SessionCreateChallengeRequest} SessionCreateChallengeRequest
         */
        SessionCreateChallengeRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.types.SessionCreateChallengeRequest)
                return object;
            var message = new $root.types.SessionCreateChallengeRequest();
            if (object.login != null)
                message.login = String(object.login);
            switch (object.saltKind) {
            case "TIME":
            case 0:
                message.saltKind = 0;
                break;
            case "RAND":
            case 1:
                message.saltKind = 1;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a SessionCreateChallengeRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof types.SessionCreateChallengeRequest
         * @static
         * @param {types.SessionCreateChallengeRequest} message SessionCreateChallengeRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SessionCreateChallengeRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.login = "";
                object.saltKind = options.enums === String ? "TIME" : 0;
            }
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            if (message.saltKind != null && message.hasOwnProperty("saltKind"))
                object.saltKind = options.enums === String ? $root.types.SessionSaltKind[message.saltKind] : message.saltKind;
            return object;
        };

        /**
         * Converts this SessionCreateChallengeRequest to JSON.
         * @function toJSON
         * @memberof types.SessionCreateChallengeRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SessionCreateChallengeRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SessionCreateChallengeRequest;
    })();

    types.SessionCreateChallengeResponse = (function() {

        /**
         * Properties of a SessionCreateChallengeResponse.
         * @memberof types
         * @interface ISessionCreateChallengeResponse
         * @property {Uint8Array|null} [salt] SessionCreateChallengeResponse salt
         * @property {Uint8Array|null} [token] SessionCreateChallengeResponse token
         * @property {types.IIdentityEncryption|null} [encryption] SessionCreateChallengeResponse encryption
         * @property {types.IIdentityPublicKey|null} [creator] SessionCreateChallengeResponse creator
         * @property {types.SessionSaltKind|null} [saltKind] SessionCreateChallengeResponse saltKind
         */

        /**
         * Constructs a new SessionCreateChallengeResponse.
         * @memberof types
         * @classdesc Represents a SessionCreateChallengeResponse.
         * @implements ISessionCreateChallengeResponse
         * @constructor
         * @param {types.ISessionCreateChallengeResponse=} [properties] Properties to set
         */
        function SessionCreateChallengeResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SessionCreateChallengeResponse salt.
         * @member {Uint8Array} salt
         * @memberof types.SessionCreateChallengeResponse
         * @instance
         */
        SessionCreateChallengeResponse.prototype.salt = $util.newBuffer([]);

        /**
         * SessionCreateChallengeResponse token.
         * @member {Uint8Array} token
         * @memberof types.SessionCreateChallengeResponse
         * @instance
         */
        SessionCreateChallengeResponse.prototype.token = $util.newBuffer([]);

        /**
         * SessionCreateChallengeResponse encryption.
         * @member {types.IIdentityEncryption|null|undefined} encryption
         * @memberof types.SessionCreateChallengeResponse
         * @instance
         */
        SessionCreateChallengeResponse.prototype.encryption = null;

        /**
         * SessionCreateChallengeResponse creator.
         * @member {types.IIdentityPublicKey|null|undefined} creator
         * @memberof types.SessionCreateChallengeResponse
         * @instance
         */
        SessionCreateChallengeResponse.prototype.creator = null;

        /**
         * SessionCreateChallengeResponse saltKind.
         * @member {types.SessionSaltKind} saltKind
         * @memberof types.SessionCreateChallengeResponse
         * @instance
         */
        SessionCreateChallengeResponse.prototype.saltKind = 0;

        /**
         * Creates a new SessionCreateChallengeResponse instance using the specified properties.
         * @function create
         * @memberof types.SessionCreateChallengeResponse
         * @static
         * @param {types.ISessionCreateChallengeResponse=} [properties] Properties to set
         * @returns {types.SessionCreateChallengeResponse} SessionCreateChallengeResponse instance
         */
        SessionCreateChallengeResponse.create = function create(properties) {
            return new SessionCreateChallengeResponse(properties);
        };

        /**
         * Encodes the specified SessionCreateChallengeResponse message. Does not implicitly {@link types.SessionCreateChallengeResponse.verify|verify} messages.
         * @function encode
         * @memberof types.SessionCreateChallengeResponse
         * @static
         * @param {types.ISessionCreateChallengeResponse} message SessionCreateChallengeResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SessionCreateChallengeResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.salt != null && message.hasOwnProperty("salt"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.salt);
            if (message.token != null && message.hasOwnProperty("token"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.token);
            if (message.encryption != null && message.hasOwnProperty("encryption"))
                $root.types.IdentityEncryption.encode(message.encryption, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.creator != null && message.hasOwnProperty("creator"))
                $root.types.IdentityPublicKey.encode(message.creator, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.saltKind != null && message.hasOwnProperty("saltKind"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.saltKind);
            return writer;
        };

        /**
         * Encodes the specified SessionCreateChallengeResponse message, length delimited. Does not implicitly {@link types.SessionCreateChallengeResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof types.SessionCreateChallengeResponse
         * @static
         * @param {types.ISessionCreateChallengeResponse} message SessionCreateChallengeResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SessionCreateChallengeResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SessionCreateChallengeResponse message from the specified reader or buffer.
         * @function decode
         * @memberof types.SessionCreateChallengeResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {types.SessionCreateChallengeResponse} SessionCreateChallengeResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SessionCreateChallengeResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.types.SessionCreateChallengeResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.salt = reader.bytes();
                    break;
                case 2:
                    message.token = reader.bytes();
                    break;
                case 3:
                    message.encryption = $root.types.IdentityEncryption.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.creator = $root.types.IdentityPublicKey.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.saltKind = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SessionCreateChallengeResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof types.SessionCreateChallengeResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {types.SessionCreateChallengeResponse} SessionCreateChallengeResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SessionCreateChallengeResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SessionCreateChallengeResponse message.
         * @function verify
         * @memberof types.SessionCreateChallengeResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SessionCreateChallengeResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.salt != null && message.hasOwnProperty("salt"))
                if (!(message.salt && typeof message.salt.length === "number" || $util.isString(message.salt)))
                    return "salt: buffer expected";
            if (message.token != null && message.hasOwnProperty("token"))
                if (!(message.token && typeof message.token.length === "number" || $util.isString(message.token)))
                    return "token: buffer expected";
            if (message.encryption != null && message.hasOwnProperty("encryption")) {
                var error = $root.types.IdentityEncryption.verify(message.encryption);
                if (error)
                    return "encryption." + error;
            }
            if (message.creator != null && message.hasOwnProperty("creator")) {
                var error = $root.types.IdentityPublicKey.verify(message.creator);
                if (error)
                    return "creator." + error;
            }
            if (message.saltKind != null && message.hasOwnProperty("saltKind"))
                switch (message.saltKind) {
                default:
                    return "saltKind: enum value expected";
                case 0:
                case 1:
                    break;
                }
            return null;
        };

        /**
         * Creates a SessionCreateChallengeResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof types.SessionCreateChallengeResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {types.SessionCreateChallengeResponse} SessionCreateChallengeResponse
         */
        SessionCreateChallengeResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.types.SessionCreateChallengeResponse)
                return object;
            var message = new $root.types.SessionCreateChallengeResponse();
            if (object.salt != null)
                if (typeof object.salt === "string")
                    $util.base64.decode(object.salt, message.salt = $util.newBuffer($util.base64.length(object.salt)), 0);
                else if (object.salt.length)
                    message.salt = object.salt;
            if (object.token != null)
                if (typeof object.token === "string")
                    $util.base64.decode(object.token, message.token = $util.newBuffer($util.base64.length(object.token)), 0);
                else if (object.token.length)
                    message.token = object.token;
            if (object.encryption != null) {
                if (typeof object.encryption !== "object")
                    throw TypeError(".types.SessionCreateChallengeResponse.encryption: object expected");
                message.encryption = $root.types.IdentityEncryption.fromObject(object.encryption);
            }
            if (object.creator != null) {
                if (typeof object.creator !== "object")
                    throw TypeError(".types.SessionCreateChallengeResponse.creator: object expected");
                message.creator = $root.types.IdentityPublicKey.fromObject(object.creator);
            }
            switch (object.saltKind) {
            case "TIME":
            case 0:
                message.saltKind = 0;
                break;
            case "RAND":
            case 1:
                message.saltKind = 1;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a SessionCreateChallengeResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof types.SessionCreateChallengeResponse
         * @static
         * @param {types.SessionCreateChallengeResponse} message SessionCreateChallengeResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SessionCreateChallengeResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.salt = options.bytes === String ? "" : [];
                object.token = options.bytes === String ? "" : [];
                object.encryption = null;
                object.creator = null;
                object.saltKind = options.enums === String ? "TIME" : 0;
            }
            if (message.salt != null && message.hasOwnProperty("salt"))
                object.salt = options.bytes === String ? $util.base64.encode(message.salt, 0, message.salt.length) : options.bytes === Array ? Array.prototype.slice.call(message.salt) : message.salt;
            if (message.token != null && message.hasOwnProperty("token"))
                object.token = options.bytes === String ? $util.base64.encode(message.token, 0, message.token.length) : options.bytes === Array ? Array.prototype.slice.call(message.token) : message.token;
            if (message.encryption != null && message.hasOwnProperty("encryption"))
                object.encryption = $root.types.IdentityEncryption.toObject(message.encryption, options);
            if (message.creator != null && message.hasOwnProperty("creator"))
                object.creator = $root.types.IdentityPublicKey.toObject(message.creator, options);
            if (message.saltKind != null && message.hasOwnProperty("saltKind"))
                object.saltKind = options.enums === String ? $root.types.SessionSaltKind[message.saltKind] : message.saltKind;
            return object;
        };

        /**
         * Converts this SessionCreateChallengeResponse to JSON.
         * @function toJSON
         * @memberof types.SessionCreateChallengeResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SessionCreateChallengeResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SessionCreateChallengeResponse;
    })();

    types.SessionResolveChallengeRequest = (function() {

        /**
         * Properties of a SessionResolveChallengeRequest.
         * @memberof types
         * @interface ISessionResolveChallengeRequest
         * @property {Uint8Array|null} [token] SessionResolveChallengeRequest token
         * @property {Uint8Array|null} [signature] SessionResolveChallengeRequest signature
         * @property {Uint8Array|null} [salt] SessionResolveChallengeRequest salt
         */

        /**
         * Constructs a new SessionResolveChallengeRequest.
         * @memberof types
         * @classdesc Represents a SessionResolveChallengeRequest.
         * @implements ISessionResolveChallengeRequest
         * @constructor
         * @param {types.ISessionResolveChallengeRequest=} [properties] Properties to set
         */
        function SessionResolveChallengeRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SessionResolveChallengeRequest token.
         * @member {Uint8Array} token
         * @memberof types.SessionResolveChallengeRequest
         * @instance
         */
        SessionResolveChallengeRequest.prototype.token = $util.newBuffer([]);

        /**
         * SessionResolveChallengeRequest signature.
         * @member {Uint8Array} signature
         * @memberof types.SessionResolveChallengeRequest
         * @instance
         */
        SessionResolveChallengeRequest.prototype.signature = $util.newBuffer([]);

        /**
         * SessionResolveChallengeRequest salt.
         * @member {Uint8Array} salt
         * @memberof types.SessionResolveChallengeRequest
         * @instance
         */
        SessionResolveChallengeRequest.prototype.salt = $util.newBuffer([]);

        /**
         * Creates a new SessionResolveChallengeRequest instance using the specified properties.
         * @function create
         * @memberof types.SessionResolveChallengeRequest
         * @static
         * @param {types.ISessionResolveChallengeRequest=} [properties] Properties to set
         * @returns {types.SessionResolveChallengeRequest} SessionResolveChallengeRequest instance
         */
        SessionResolveChallengeRequest.create = function create(properties) {
            return new SessionResolveChallengeRequest(properties);
        };

        /**
         * Encodes the specified SessionResolveChallengeRequest message. Does not implicitly {@link types.SessionResolveChallengeRequest.verify|verify} messages.
         * @function encode
         * @memberof types.SessionResolveChallengeRequest
         * @static
         * @param {types.ISessionResolveChallengeRequest} message SessionResolveChallengeRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SessionResolveChallengeRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.token != null && message.hasOwnProperty("token"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.token);
            if (message.signature != null && message.hasOwnProperty("signature"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.signature);
            if (message.salt != null && message.hasOwnProperty("salt"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.salt);
            return writer;
        };

        /**
         * Encodes the specified SessionResolveChallengeRequest message, length delimited. Does not implicitly {@link types.SessionResolveChallengeRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof types.SessionResolveChallengeRequest
         * @static
         * @param {types.ISessionResolveChallengeRequest} message SessionResolveChallengeRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SessionResolveChallengeRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SessionResolveChallengeRequest message from the specified reader or buffer.
         * @function decode
         * @memberof types.SessionResolveChallengeRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {types.SessionResolveChallengeRequest} SessionResolveChallengeRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SessionResolveChallengeRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.types.SessionResolveChallengeRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.token = reader.bytes();
                    break;
                case 2:
                    message.signature = reader.bytes();
                    break;
                case 3:
                    message.salt = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SessionResolveChallengeRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof types.SessionResolveChallengeRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {types.SessionResolveChallengeRequest} SessionResolveChallengeRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SessionResolveChallengeRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SessionResolveChallengeRequest message.
         * @function verify
         * @memberof types.SessionResolveChallengeRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SessionResolveChallengeRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.token != null && message.hasOwnProperty("token"))
                if (!(message.token && typeof message.token.length === "number" || $util.isString(message.token)))
                    return "token: buffer expected";
            if (message.signature != null && message.hasOwnProperty("signature"))
                if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                    return "signature: buffer expected";
            if (message.salt != null && message.hasOwnProperty("salt"))
                if (!(message.salt && typeof message.salt.length === "number" || $util.isString(message.salt)))
                    return "salt: buffer expected";
            return null;
        };

        /**
         * Creates a SessionResolveChallengeRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof types.SessionResolveChallengeRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {types.SessionResolveChallengeRequest} SessionResolveChallengeRequest
         */
        SessionResolveChallengeRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.types.SessionResolveChallengeRequest)
                return object;
            var message = new $root.types.SessionResolveChallengeRequest();
            if (object.token != null)
                if (typeof object.token === "string")
                    $util.base64.decode(object.token, message.token = $util.newBuffer($util.base64.length(object.token)), 0);
                else if (object.token.length)
                    message.token = object.token;
            if (object.signature != null)
                if (typeof object.signature === "string")
                    $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                else if (object.signature.length)
                    message.signature = object.signature;
            if (object.salt != null)
                if (typeof object.salt === "string")
                    $util.base64.decode(object.salt, message.salt = $util.newBuffer($util.base64.length(object.salt)), 0);
                else if (object.salt.length)
                    message.salt = object.salt;
            return message;
        };

        /**
         * Creates a plain object from a SessionResolveChallengeRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof types.SessionResolveChallengeRequest
         * @static
         * @param {types.SessionResolveChallengeRequest} message SessionResolveChallengeRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SessionResolveChallengeRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.token = options.bytes === String ? "" : [];
                object.signature = options.bytes === String ? "" : [];
                object.salt = options.bytes === String ? "" : [];
            }
            if (message.token != null && message.hasOwnProperty("token"))
                object.token = options.bytes === String ? $util.base64.encode(message.token, 0, message.token.length) : options.bytes === Array ? Array.prototype.slice.call(message.token) : message.token;
            if (message.signature != null && message.hasOwnProperty("signature"))
                object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
            if (message.salt != null && message.hasOwnProperty("salt"))
                object.salt = options.bytes === String ? $util.base64.encode(message.salt, 0, message.salt.length) : options.bytes === Array ? Array.prototype.slice.call(message.salt) : message.salt;
            return object;
        };

        /**
         * Converts this SessionResolveChallengeRequest to JSON.
         * @function toJSON
         * @memberof types.SessionResolveChallengeRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SessionResolveChallengeRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SessionResolveChallengeRequest;
    })();

    types.SessionResolveChallengeResponse = (function() {

        /**
         * Properties of a SessionResolveChallengeResponse.
         * @memberof types
         * @interface ISessionResolveChallengeResponse
         * @property {Uint8Array|null} [salt] SessionResolveChallengeResponse salt
         */

        /**
         * Constructs a new SessionResolveChallengeResponse.
         * @memberof types
         * @classdesc Represents a SessionResolveChallengeResponse.
         * @implements ISessionResolveChallengeResponse
         * @constructor
         * @param {types.ISessionResolveChallengeResponse=} [properties] Properties to set
         */
        function SessionResolveChallengeResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SessionResolveChallengeResponse salt.
         * @member {Uint8Array} salt
         * @memberof types.SessionResolveChallengeResponse
         * @instance
         */
        SessionResolveChallengeResponse.prototype.salt = $util.newBuffer([]);

        /**
         * Creates a new SessionResolveChallengeResponse instance using the specified properties.
         * @function create
         * @memberof types.SessionResolveChallengeResponse
         * @static
         * @param {types.ISessionResolveChallengeResponse=} [properties] Properties to set
         * @returns {types.SessionResolveChallengeResponse} SessionResolveChallengeResponse instance
         */
        SessionResolveChallengeResponse.create = function create(properties) {
            return new SessionResolveChallengeResponse(properties);
        };

        /**
         * Encodes the specified SessionResolveChallengeResponse message. Does not implicitly {@link types.SessionResolveChallengeResponse.verify|verify} messages.
         * @function encode
         * @memberof types.SessionResolveChallengeResponse
         * @static
         * @param {types.ISessionResolveChallengeResponse} message SessionResolveChallengeResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SessionResolveChallengeResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.salt != null && message.hasOwnProperty("salt"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.salt);
            return writer;
        };

        /**
         * Encodes the specified SessionResolveChallengeResponse message, length delimited. Does not implicitly {@link types.SessionResolveChallengeResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof types.SessionResolveChallengeResponse
         * @static
         * @param {types.ISessionResolveChallengeResponse} message SessionResolveChallengeResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SessionResolveChallengeResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SessionResolveChallengeResponse message from the specified reader or buffer.
         * @function decode
         * @memberof types.SessionResolveChallengeResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {types.SessionResolveChallengeResponse} SessionResolveChallengeResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SessionResolveChallengeResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.types.SessionResolveChallengeResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.salt = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SessionResolveChallengeResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof types.SessionResolveChallengeResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {types.SessionResolveChallengeResponse} SessionResolveChallengeResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SessionResolveChallengeResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SessionResolveChallengeResponse message.
         * @function verify
         * @memberof types.SessionResolveChallengeResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SessionResolveChallengeResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.salt != null && message.hasOwnProperty("salt"))
                if (!(message.salt && typeof message.salt.length === "number" || $util.isString(message.salt)))
                    return "salt: buffer expected";
            return null;
        };

        /**
         * Creates a SessionResolveChallengeResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof types.SessionResolveChallengeResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {types.SessionResolveChallengeResponse} SessionResolveChallengeResponse
         */
        SessionResolveChallengeResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.types.SessionResolveChallengeResponse)
                return object;
            var message = new $root.types.SessionResolveChallengeResponse();
            if (object.salt != null)
                if (typeof object.salt === "string")
                    $util.base64.decode(object.salt, message.salt = $util.newBuffer($util.base64.length(object.salt)), 0);
                else if (object.salt.length)
                    message.salt = object.salt;
            return message;
        };

        /**
         * Creates a plain object from a SessionResolveChallengeResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof types.SessionResolveChallengeResponse
         * @static
         * @param {types.SessionResolveChallengeResponse} message SessionResolveChallengeResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SessionResolveChallengeResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.salt = options.bytes === String ? "" : [];
            if (message.salt != null && message.hasOwnProperty("salt"))
                object.salt = options.bytes === String ? $util.base64.encode(message.salt, 0, message.salt.length) : options.bytes === Array ? Array.prototype.slice.call(message.salt) : message.salt;
            return object;
        };

        /**
         * Converts this SessionResolveChallengeResponse to JSON.
         * @function toJSON
         * @memberof types.SessionResolveChallengeResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SessionResolveChallengeResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SessionResolveChallengeResponse;
    })();

    types.SessionSetSecretRequest = (function() {

        /**
         * Properties of a SessionSetSecretRequest.
         * @memberof types
         * @interface ISessionSetSecretRequest
         * @property {Uint8Array|null} [masterSalt] SessionSetSecretRequest masterSalt
         * @property {types.IIdentityEncryptedKey|null} [sharingEncrypted] SessionSetSecretRequest sharingEncrypted
         */

        /**
         * Constructs a new SessionSetSecretRequest.
         * @memberof types
         * @classdesc Represents a SessionSetSecretRequest.
         * @implements ISessionSetSecretRequest
         * @constructor
         * @param {types.ISessionSetSecretRequest=} [properties] Properties to set
         */
        function SessionSetSecretRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SessionSetSecretRequest masterSalt.
         * @member {Uint8Array} masterSalt
         * @memberof types.SessionSetSecretRequest
         * @instance
         */
        SessionSetSecretRequest.prototype.masterSalt = $util.newBuffer([]);

        /**
         * SessionSetSecretRequest sharingEncrypted.
         * @member {types.IIdentityEncryptedKey|null|undefined} sharingEncrypted
         * @memberof types.SessionSetSecretRequest
         * @instance
         */
        SessionSetSecretRequest.prototype.sharingEncrypted = null;

        /**
         * Creates a new SessionSetSecretRequest instance using the specified properties.
         * @function create
         * @memberof types.SessionSetSecretRequest
         * @static
         * @param {types.ISessionSetSecretRequest=} [properties] Properties to set
         * @returns {types.SessionSetSecretRequest} SessionSetSecretRequest instance
         */
        SessionSetSecretRequest.create = function create(properties) {
            return new SessionSetSecretRequest(properties);
        };

        /**
         * Encodes the specified SessionSetSecretRequest message. Does not implicitly {@link types.SessionSetSecretRequest.verify|verify} messages.
         * @function encode
         * @memberof types.SessionSetSecretRequest
         * @static
         * @param {types.ISessionSetSecretRequest} message SessionSetSecretRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SessionSetSecretRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.masterSalt != null && message.hasOwnProperty("masterSalt"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.masterSalt);
            if (message.sharingEncrypted != null && message.hasOwnProperty("sharingEncrypted"))
                $root.types.IdentityEncryptedKey.encode(message.sharingEncrypted, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SessionSetSecretRequest message, length delimited. Does not implicitly {@link types.SessionSetSecretRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof types.SessionSetSecretRequest
         * @static
         * @param {types.ISessionSetSecretRequest} message SessionSetSecretRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SessionSetSecretRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SessionSetSecretRequest message from the specified reader or buffer.
         * @function decode
         * @memberof types.SessionSetSecretRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {types.SessionSetSecretRequest} SessionSetSecretRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SessionSetSecretRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.types.SessionSetSecretRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.masterSalt = reader.bytes();
                    break;
                case 2:
                    message.sharingEncrypted = $root.types.IdentityEncryptedKey.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SessionSetSecretRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof types.SessionSetSecretRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {types.SessionSetSecretRequest} SessionSetSecretRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SessionSetSecretRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SessionSetSecretRequest message.
         * @function verify
         * @memberof types.SessionSetSecretRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SessionSetSecretRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.masterSalt != null && message.hasOwnProperty("masterSalt"))
                if (!(message.masterSalt && typeof message.masterSalt.length === "number" || $util.isString(message.masterSalt)))
                    return "masterSalt: buffer expected";
            if (message.sharingEncrypted != null && message.hasOwnProperty("sharingEncrypted")) {
                var error = $root.types.IdentityEncryptedKey.verify(message.sharingEncrypted);
                if (error)
                    return "sharingEncrypted." + error;
            }
            return null;
        };

        /**
         * Creates a SessionSetSecretRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof types.SessionSetSecretRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {types.SessionSetSecretRequest} SessionSetSecretRequest
         */
        SessionSetSecretRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.types.SessionSetSecretRequest)
                return object;
            var message = new $root.types.SessionSetSecretRequest();
            if (object.masterSalt != null)
                if (typeof object.masterSalt === "string")
                    $util.base64.decode(object.masterSalt, message.masterSalt = $util.newBuffer($util.base64.length(object.masterSalt)), 0);
                else if (object.masterSalt.length)
                    message.masterSalt = object.masterSalt;
            if (object.sharingEncrypted != null) {
                if (typeof object.sharingEncrypted !== "object")
                    throw TypeError(".types.SessionSetSecretRequest.sharingEncrypted: object expected");
                message.sharingEncrypted = $root.types.IdentityEncryptedKey.fromObject(object.sharingEncrypted);
            }
            return message;
        };

        /**
         * Creates a plain object from a SessionSetSecretRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof types.SessionSetSecretRequest
         * @static
         * @param {types.SessionSetSecretRequest} message SessionSetSecretRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SessionSetSecretRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.masterSalt = options.bytes === String ? "" : [];
                object.sharingEncrypted = null;
            }
            if (message.masterSalt != null && message.hasOwnProperty("masterSalt"))
                object.masterSalt = options.bytes === String ? $util.base64.encode(message.masterSalt, 0, message.masterSalt.length) : options.bytes === Array ? Array.prototype.slice.call(message.masterSalt) : message.masterSalt;
            if (message.sharingEncrypted != null && message.hasOwnProperty("sharingEncrypted"))
                object.sharingEncrypted = $root.types.IdentityEncryptedKey.toObject(message.sharingEncrypted, options);
            return object;
        };

        /**
         * Converts this SessionSetSecretRequest to JSON.
         * @function toJSON
         * @memberof types.SessionSetSecretRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SessionSetSecretRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SessionSetSecretRequest;
    })();

    types.SessionUnStaleResponse = (function() {

        /**
         * Properties of a SessionUnStaleResponse.
         * @memberof types
         * @interface ISessionUnStaleResponse
         * @property {types.IIdentityEncryption|null} [encryption] SessionUnStaleResponse encryption
         * @property {types.IIdentityPublicKey|null} [creator] SessionUnStaleResponse creator
         */

        /**
         * Constructs a new SessionUnStaleResponse.
         * @memberof types
         * @classdesc Represents a SessionUnStaleResponse.
         * @implements ISessionUnStaleResponse
         * @constructor
         * @param {types.ISessionUnStaleResponse=} [properties] Properties to set
         */
        function SessionUnStaleResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SessionUnStaleResponse encryption.
         * @member {types.IIdentityEncryption|null|undefined} encryption
         * @memberof types.SessionUnStaleResponse
         * @instance
         */
        SessionUnStaleResponse.prototype.encryption = null;

        /**
         * SessionUnStaleResponse creator.
         * @member {types.IIdentityPublicKey|null|undefined} creator
         * @memberof types.SessionUnStaleResponse
         * @instance
         */
        SessionUnStaleResponse.prototype.creator = null;

        /**
         * Creates a new SessionUnStaleResponse instance using the specified properties.
         * @function create
         * @memberof types.SessionUnStaleResponse
         * @static
         * @param {types.ISessionUnStaleResponse=} [properties] Properties to set
         * @returns {types.SessionUnStaleResponse} SessionUnStaleResponse instance
         */
        SessionUnStaleResponse.create = function create(properties) {
            return new SessionUnStaleResponse(properties);
        };

        /**
         * Encodes the specified SessionUnStaleResponse message. Does not implicitly {@link types.SessionUnStaleResponse.verify|verify} messages.
         * @function encode
         * @memberof types.SessionUnStaleResponse
         * @static
         * @param {types.ISessionUnStaleResponse} message SessionUnStaleResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SessionUnStaleResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.encryption != null && message.hasOwnProperty("encryption"))
                $root.types.IdentityEncryption.encode(message.encryption, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.creator != null && message.hasOwnProperty("creator"))
                $root.types.IdentityPublicKey.encode(message.creator, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SessionUnStaleResponse message, length delimited. Does not implicitly {@link types.SessionUnStaleResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof types.SessionUnStaleResponse
         * @static
         * @param {types.ISessionUnStaleResponse} message SessionUnStaleResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SessionUnStaleResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SessionUnStaleResponse message from the specified reader or buffer.
         * @function decode
         * @memberof types.SessionUnStaleResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {types.SessionUnStaleResponse} SessionUnStaleResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SessionUnStaleResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.types.SessionUnStaleResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.encryption = $root.types.IdentityEncryption.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.creator = $root.types.IdentityPublicKey.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SessionUnStaleResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof types.SessionUnStaleResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {types.SessionUnStaleResponse} SessionUnStaleResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SessionUnStaleResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SessionUnStaleResponse message.
         * @function verify
         * @memberof types.SessionUnStaleResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SessionUnStaleResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.encryption != null && message.hasOwnProperty("encryption")) {
                var error = $root.types.IdentityEncryption.verify(message.encryption);
                if (error)
                    return "encryption." + error;
            }
            if (message.creator != null && message.hasOwnProperty("creator")) {
                var error = $root.types.IdentityPublicKey.verify(message.creator);
                if (error)
                    return "creator." + error;
            }
            return null;
        };

        /**
         * Creates a SessionUnStaleResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof types.SessionUnStaleResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {types.SessionUnStaleResponse} SessionUnStaleResponse
         */
        SessionUnStaleResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.types.SessionUnStaleResponse)
                return object;
            var message = new $root.types.SessionUnStaleResponse();
            if (object.encryption != null) {
                if (typeof object.encryption !== "object")
                    throw TypeError(".types.SessionUnStaleResponse.encryption: object expected");
                message.encryption = $root.types.IdentityEncryption.fromObject(object.encryption);
            }
            if (object.creator != null) {
                if (typeof object.creator !== "object")
                    throw TypeError(".types.SessionUnStaleResponse.creator: object expected");
                message.creator = $root.types.IdentityPublicKey.fromObject(object.creator);
            }
            return message;
        };

        /**
         * Creates a plain object from a SessionUnStaleResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof types.SessionUnStaleResponse
         * @static
         * @param {types.SessionUnStaleResponse} message SessionUnStaleResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SessionUnStaleResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.encryption = null;
                object.creator = null;
            }
            if (message.encryption != null && message.hasOwnProperty("encryption"))
                object.encryption = $root.types.IdentityEncryption.toObject(message.encryption, options);
            if (message.creator != null && message.hasOwnProperty("creator"))
                object.creator = $root.types.IdentityPublicKey.toObject(message.creator, options);
            return object;
        };

        /**
         * Converts this SessionUnStaleResponse to JSON.
         * @function toJSON
         * @memberof types.SessionUnStaleResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SessionUnStaleResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SessionUnStaleResponse;
    })();

    types.SessionAuthenticateResponse = (function() {

        /**
         * Properties of a SessionAuthenticateResponse.
         * @memberof types
         * @interface ISessionAuthenticateResponse
         * @property {string|null} [ownerLogin] SessionAuthenticateResponse ownerLogin
         * @property {string|null} [assumeLogin] SessionAuthenticateResponse assumeLogin
         * @property {types.IdentityAccessKeyKind|null} [assumeKind] SessionAuthenticateResponse assumeKind
         */

        /**
         * Constructs a new SessionAuthenticateResponse.
         * @memberof types
         * @classdesc Represents a SessionAuthenticateResponse.
         * @implements ISessionAuthenticateResponse
         * @constructor
         * @param {types.ISessionAuthenticateResponse=} [properties] Properties to set
         */
        function SessionAuthenticateResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SessionAuthenticateResponse ownerLogin.
         * @member {string} ownerLogin
         * @memberof types.SessionAuthenticateResponse
         * @instance
         */
        SessionAuthenticateResponse.prototype.ownerLogin = "";

        /**
         * SessionAuthenticateResponse assumeLogin.
         * @member {string} assumeLogin
         * @memberof types.SessionAuthenticateResponse
         * @instance
         */
        SessionAuthenticateResponse.prototype.assumeLogin = "";

        /**
         * SessionAuthenticateResponse assumeKind.
         * @member {types.IdentityAccessKeyKind} assumeKind
         * @memberof types.SessionAuthenticateResponse
         * @instance
         */
        SessionAuthenticateResponse.prototype.assumeKind = 0;

        /**
         * Creates a new SessionAuthenticateResponse instance using the specified properties.
         * @function create
         * @memberof types.SessionAuthenticateResponse
         * @static
         * @param {types.ISessionAuthenticateResponse=} [properties] Properties to set
         * @returns {types.SessionAuthenticateResponse} SessionAuthenticateResponse instance
         */
        SessionAuthenticateResponse.create = function create(properties) {
            return new SessionAuthenticateResponse(properties);
        };

        /**
         * Encodes the specified SessionAuthenticateResponse message. Does not implicitly {@link types.SessionAuthenticateResponse.verify|verify} messages.
         * @function encode
         * @memberof types.SessionAuthenticateResponse
         * @static
         * @param {types.ISessionAuthenticateResponse} message SessionAuthenticateResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SessionAuthenticateResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ownerLogin != null && message.hasOwnProperty("ownerLogin"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.ownerLogin);
            if (message.assumeLogin != null && message.hasOwnProperty("assumeLogin"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.assumeLogin);
            if (message.assumeKind != null && message.hasOwnProperty("assumeKind"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.assumeKind);
            return writer;
        };

        /**
         * Encodes the specified SessionAuthenticateResponse message, length delimited. Does not implicitly {@link types.SessionAuthenticateResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof types.SessionAuthenticateResponse
         * @static
         * @param {types.ISessionAuthenticateResponse} message SessionAuthenticateResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SessionAuthenticateResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SessionAuthenticateResponse message from the specified reader or buffer.
         * @function decode
         * @memberof types.SessionAuthenticateResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {types.SessionAuthenticateResponse} SessionAuthenticateResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SessionAuthenticateResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.types.SessionAuthenticateResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ownerLogin = reader.string();
                    break;
                case 2:
                    message.assumeLogin = reader.string();
                    break;
                case 3:
                    message.assumeKind = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SessionAuthenticateResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof types.SessionAuthenticateResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {types.SessionAuthenticateResponse} SessionAuthenticateResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SessionAuthenticateResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SessionAuthenticateResponse message.
         * @function verify
         * @memberof types.SessionAuthenticateResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SessionAuthenticateResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ownerLogin != null && message.hasOwnProperty("ownerLogin"))
                if (!$util.isString(message.ownerLogin))
                    return "ownerLogin: string expected";
            if (message.assumeLogin != null && message.hasOwnProperty("assumeLogin"))
                if (!$util.isString(message.assumeLogin))
                    return "assumeLogin: string expected";
            if (message.assumeKind != null && message.hasOwnProperty("assumeKind"))
                switch (message.assumeKind) {
                default:
                    return "assumeKind: enum value expected";
                case 0:
                case 1:
                    break;
                }
            return null;
        };

        /**
         * Creates a SessionAuthenticateResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof types.SessionAuthenticateResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {types.SessionAuthenticateResponse} SessionAuthenticateResponse
         */
        SessionAuthenticateResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.types.SessionAuthenticateResponse)
                return object;
            var message = new $root.types.SessionAuthenticateResponse();
            if (object.ownerLogin != null)
                message.ownerLogin = String(object.ownerLogin);
            if (object.assumeLogin != null)
                message.assumeLogin = String(object.assumeLogin);
            switch (object.assumeKind) {
            case "READ":
            case 0:
                message.assumeKind = 0;
                break;
            case "WRITE":
            case 1:
                message.assumeKind = 1;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a SessionAuthenticateResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof types.SessionAuthenticateResponse
         * @static
         * @param {types.SessionAuthenticateResponse} message SessionAuthenticateResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SessionAuthenticateResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.ownerLogin = "";
                object.assumeLogin = "";
                object.assumeKind = options.enums === String ? "READ" : 0;
            }
            if (message.ownerLogin != null && message.hasOwnProperty("ownerLogin"))
                object.ownerLogin = message.ownerLogin;
            if (message.assumeLogin != null && message.hasOwnProperty("assumeLogin"))
                object.assumeLogin = message.assumeLogin;
            if (message.assumeKind != null && message.hasOwnProperty("assumeKind"))
                object.assumeKind = options.enums === String ? $root.types.IdentityAccessKeyKind[message.assumeKind] : message.assumeKind;
            return object;
        };

        /**
         * Converts this SessionAuthenticateResponse to JSON.
         * @function toJSON
         * @memberof types.SessionAuthenticateResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SessionAuthenticateResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SessionAuthenticateResponse;
    })();

    /**
     * ResourceType enum.
     * @name types.ResourceType
     * @enum {string}
     * @property {number} ANONYMOUS=0 ANONYMOUS value
     * @property {number} SES=1 SES value
     */
    types.ResourceType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "ANONYMOUS"] = 0;
        values[valuesById[1] = "SES"] = 1;
        return values;
    })();

    types.Resource = (function() {

        /**
         * Properties of a Resource.
         * @memberof types
         * @interface IResource
         * @property {number|Long|null} [id] Resource id
         * @property {string|null} [kind] Resource kind
         * @property {Uint8Array|null} [publicKey] Resource publicKey
         * @property {Uint8Array|null} [nonce] Resource nonce
         * @property {number|Long|null} [created] Resource created
         * @property {Uint8Array|null} [payload] Resource payload
         * @property {types.ResourceType|null} [type] Resource type
         */

        /**
         * Constructs a new Resource.
         * @memberof types
         * @classdesc Represents a Resource.
         * @implements IResource
         * @constructor
         * @param {types.IResource=} [properties] Properties to set
         */
        function Resource(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Resource id.
         * @member {number|Long} id
         * @memberof types.Resource
         * @instance
         */
        Resource.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Resource kind.
         * @member {string} kind
         * @memberof types.Resource
         * @instance
         */
        Resource.prototype.kind = "";

        /**
         * Resource publicKey.
         * @member {Uint8Array} publicKey
         * @memberof types.Resource
         * @instance
         */
        Resource.prototype.publicKey = $util.newBuffer([]);

        /**
         * Resource nonce.
         * @member {Uint8Array} nonce
         * @memberof types.Resource
         * @instance
         */
        Resource.prototype.nonce = $util.newBuffer([]);

        /**
         * Resource created.
         * @member {number|Long} created
         * @memberof types.Resource
         * @instance
         */
        Resource.prototype.created = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Resource payload.
         * @member {Uint8Array} payload
         * @memberof types.Resource
         * @instance
         */
        Resource.prototype.payload = $util.newBuffer([]);

        /**
         * Resource type.
         * @member {types.ResourceType} type
         * @memberof types.Resource
         * @instance
         */
        Resource.prototype.type = 0;

        /**
         * Creates a new Resource instance using the specified properties.
         * @function create
         * @memberof types.Resource
         * @static
         * @param {types.IResource=} [properties] Properties to set
         * @returns {types.Resource} Resource instance
         */
        Resource.create = function create(properties) {
            return new Resource(properties);
        };

        /**
         * Encodes the specified Resource message. Does not implicitly {@link types.Resource.verify|verify} messages.
         * @function encode
         * @memberof types.Resource
         * @static
         * @param {types.IResource} message Resource message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Resource.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
            if (message.kind != null && message.hasOwnProperty("kind"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.kind);
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.publicKey);
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.nonce);
            if (message.created != null && message.hasOwnProperty("created"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.created);
            if (message.payload != null && message.hasOwnProperty("payload"))
                writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.payload);
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.type);
            return writer;
        };

        /**
         * Encodes the specified Resource message, length delimited. Does not implicitly {@link types.Resource.verify|verify} messages.
         * @function encodeDelimited
         * @memberof types.Resource
         * @static
         * @param {types.IResource} message Resource message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Resource.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Resource message from the specified reader or buffer.
         * @function decode
         * @memberof types.Resource
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {types.Resource} Resource
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Resource.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.types.Resource();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.uint64();
                    break;
                case 2:
                    message.kind = reader.string();
                    break;
                case 3:
                    message.publicKey = reader.bytes();
                    break;
                case 4:
                    message.nonce = reader.bytes();
                    break;
                case 5:
                    message.created = reader.int64();
                    break;
                case 6:
                    message.payload = reader.bytes();
                    break;
                case 7:
                    message.type = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Resource message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof types.Resource
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {types.Resource} Resource
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Resource.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Resource message.
         * @function verify
         * @memberof types.Resource
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Resource.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                    return "id: integer|Long expected";
            if (message.kind != null && message.hasOwnProperty("kind"))
                if (!$util.isString(message.kind))
                    return "kind: string expected";
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                if (!(message.publicKey && typeof message.publicKey.length === "number" || $util.isString(message.publicKey)))
                    return "publicKey: buffer expected";
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                if (!(message.nonce && typeof message.nonce.length === "number" || $util.isString(message.nonce)))
                    return "nonce: buffer expected";
            if (message.created != null && message.hasOwnProperty("created"))
                if (!$util.isInteger(message.created) && !(message.created && $util.isInteger(message.created.low) && $util.isInteger(message.created.high)))
                    return "created: integer|Long expected";
            if (message.payload != null && message.hasOwnProperty("payload"))
                if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                    return "payload: buffer expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                    break;
                }
            return null;
        };

        /**
         * Creates a Resource message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof types.Resource
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {types.Resource} Resource
         */
        Resource.fromObject = function fromObject(object) {
            if (object instanceof $root.types.Resource)
                return object;
            var message = new $root.types.Resource();
            if (object.id != null)
                if ($util.Long)
                    (message.id = $util.Long.fromValue(object.id)).unsigned = true;
                else if (typeof object.id === "string")
                    message.id = parseInt(object.id, 10);
                else if (typeof object.id === "number")
                    message.id = object.id;
                else if (typeof object.id === "object")
                    message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
            if (object.kind != null)
                message.kind = String(object.kind);
            if (object.publicKey != null)
                if (typeof object.publicKey === "string")
                    $util.base64.decode(object.publicKey, message.publicKey = $util.newBuffer($util.base64.length(object.publicKey)), 0);
                else if (object.publicKey.length)
                    message.publicKey = object.publicKey;
            if (object.nonce != null)
                if (typeof object.nonce === "string")
                    $util.base64.decode(object.nonce, message.nonce = $util.newBuffer($util.base64.length(object.nonce)), 0);
                else if (object.nonce.length)
                    message.nonce = object.nonce;
            if (object.created != null)
                if ($util.Long)
                    (message.created = $util.Long.fromValue(object.created)).unsigned = false;
                else if (typeof object.created === "string")
                    message.created = parseInt(object.created, 10);
                else if (typeof object.created === "number")
                    message.created = object.created;
                else if (typeof object.created === "object")
                    message.created = new $util.LongBits(object.created.low >>> 0, object.created.high >>> 0).toNumber();
            if (object.payload != null)
                if (typeof object.payload === "string")
                    $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                else if (object.payload.length)
                    message.payload = object.payload;
            switch (object.type) {
            case "ANONYMOUS":
            case 0:
                message.type = 0;
                break;
            case "SES":
            case 1:
                message.type = 1;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a Resource message. Also converts values to other types if specified.
         * @function toObject
         * @memberof types.Resource
         * @static
         * @param {types.Resource} message Resource
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Resource.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.id = options.longs === String ? "0" : 0;
                object.kind = "";
                object.publicKey = options.bytes === String ? "" : [];
                object.nonce = options.bytes === String ? "" : [];
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.created = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.created = options.longs === String ? "0" : 0;
                object.payload = options.bytes === String ? "" : [];
                object.type = options.enums === String ? "ANONYMOUS" : 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                if (typeof message.id === "number")
                    object.id = options.longs === String ? String(message.id) : message.id;
                else
                    object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
            if (message.kind != null && message.hasOwnProperty("kind"))
                object.kind = message.kind;
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                object.publicKey = options.bytes === String ? $util.base64.encode(message.publicKey, 0, message.publicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.publicKey) : message.publicKey;
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                object.nonce = options.bytes === String ? $util.base64.encode(message.nonce, 0, message.nonce.length) : options.bytes === Array ? Array.prototype.slice.call(message.nonce) : message.nonce;
            if (message.created != null && message.hasOwnProperty("created"))
                if (typeof message.created === "number")
                    object.created = options.longs === String ? String(message.created) : message.created;
                else
                    object.created = options.longs === String ? $util.Long.prototype.toString.call(message.created) : options.longs === Number ? new $util.LongBits(message.created.low >>> 0, message.created.high >>> 0).toNumber() : message.created;
            if (message.payload != null && message.hasOwnProperty("payload"))
                object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.types.ResourceType[message.type] : message.type;
            return object;
        };

        /**
         * Converts this Resource to JSON.
         * @function toJSON
         * @memberof types.Resource
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Resource.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Resource;
    })();

    types.ResourceGetResponse = (function() {

        /**
         * Properties of a ResourceGetResponse.
         * @memberof types
         * @interface IResourceGetResponse
         * @property {types.IResource|null} [resource] ResourceGetResponse resource
         * @property {types.IIdentityKeyID|null} [creator] ResourceGetResponse creator
         * @property {Array.<types.ICipher>|null} [encryptedKey] ResourceGetResponse encryptedKey
         */

        /**
         * Constructs a new ResourceGetResponse.
         * @memberof types
         * @classdesc Represents a ResourceGetResponse.
         * @implements IResourceGetResponse
         * @constructor
         * @param {types.IResourceGetResponse=} [properties] Properties to set
         */
        function ResourceGetResponse(properties) {
            this.encryptedKey = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResourceGetResponse resource.
         * @member {types.IResource|null|undefined} resource
         * @memberof types.ResourceGetResponse
         * @instance
         */
        ResourceGetResponse.prototype.resource = null;

        /**
         * ResourceGetResponse creator.
         * @member {types.IIdentityKeyID|null|undefined} creator
         * @memberof types.ResourceGetResponse
         * @instance
         */
        ResourceGetResponse.prototype.creator = null;

        /**
         * ResourceGetResponse encryptedKey.
         * @member {Array.<types.ICipher>} encryptedKey
         * @memberof types.ResourceGetResponse
         * @instance
         */
        ResourceGetResponse.prototype.encryptedKey = $util.emptyArray;

        /**
         * Creates a new ResourceGetResponse instance using the specified properties.
         * @function create
         * @memberof types.ResourceGetResponse
         * @static
         * @param {types.IResourceGetResponse=} [properties] Properties to set
         * @returns {types.ResourceGetResponse} ResourceGetResponse instance
         */
        ResourceGetResponse.create = function create(properties) {
            return new ResourceGetResponse(properties);
        };

        /**
         * Encodes the specified ResourceGetResponse message. Does not implicitly {@link types.ResourceGetResponse.verify|verify} messages.
         * @function encode
         * @memberof types.ResourceGetResponse
         * @static
         * @param {types.IResourceGetResponse} message ResourceGetResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourceGetResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.resource != null && message.hasOwnProperty("resource"))
                $root.types.Resource.encode(message.resource, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.creator != null && message.hasOwnProperty("creator"))
                $root.types.IdentityKeyID.encode(message.creator, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.encryptedKey != null && message.encryptedKey.length)
                for (var i = 0; i < message.encryptedKey.length; ++i)
                    $root.types.Cipher.encode(message.encryptedKey[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ResourceGetResponse message, length delimited. Does not implicitly {@link types.ResourceGetResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof types.ResourceGetResponse
         * @static
         * @param {types.IResourceGetResponse} message ResourceGetResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourceGetResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResourceGetResponse message from the specified reader or buffer.
         * @function decode
         * @memberof types.ResourceGetResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {types.ResourceGetResponse} ResourceGetResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourceGetResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.types.ResourceGetResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.resource = $root.types.Resource.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.creator = $root.types.IdentityKeyID.decode(reader, reader.uint32());
                    break;
                case 3:
                    if (!(message.encryptedKey && message.encryptedKey.length))
                        message.encryptedKey = [];
                    message.encryptedKey.push($root.types.Cipher.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ResourceGetResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof types.ResourceGetResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {types.ResourceGetResponse} ResourceGetResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourceGetResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResourceGetResponse message.
         * @function verify
         * @memberof types.ResourceGetResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResourceGetResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.resource != null && message.hasOwnProperty("resource")) {
                var error = $root.types.Resource.verify(message.resource);
                if (error)
                    return "resource." + error;
            }
            if (message.creator != null && message.hasOwnProperty("creator")) {
                var error = $root.types.IdentityKeyID.verify(message.creator);
                if (error)
                    return "creator." + error;
            }
            if (message.encryptedKey != null && message.hasOwnProperty("encryptedKey")) {
                if (!Array.isArray(message.encryptedKey))
                    return "encryptedKey: array expected";
                for (var i = 0; i < message.encryptedKey.length; ++i) {
                    var error = $root.types.Cipher.verify(message.encryptedKey[i]);
                    if (error)
                        return "encryptedKey." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ResourceGetResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof types.ResourceGetResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {types.ResourceGetResponse} ResourceGetResponse
         */
        ResourceGetResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.types.ResourceGetResponse)
                return object;
            var message = new $root.types.ResourceGetResponse();
            if (object.resource != null) {
                if (typeof object.resource !== "object")
                    throw TypeError(".types.ResourceGetResponse.resource: object expected");
                message.resource = $root.types.Resource.fromObject(object.resource);
            }
            if (object.creator != null) {
                if (typeof object.creator !== "object")
                    throw TypeError(".types.ResourceGetResponse.creator: object expected");
                message.creator = $root.types.IdentityKeyID.fromObject(object.creator);
            }
            if (object.encryptedKey) {
                if (!Array.isArray(object.encryptedKey))
                    throw TypeError(".types.ResourceGetResponse.encryptedKey: array expected");
                message.encryptedKey = [];
                for (var i = 0; i < object.encryptedKey.length; ++i) {
                    if (typeof object.encryptedKey[i] !== "object")
                        throw TypeError(".types.ResourceGetResponse.encryptedKey: object expected");
                    message.encryptedKey[i] = $root.types.Cipher.fromObject(object.encryptedKey[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ResourceGetResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof types.ResourceGetResponse
         * @static
         * @param {types.ResourceGetResponse} message ResourceGetResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResourceGetResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.encryptedKey = [];
            if (options.defaults) {
                object.resource = null;
                object.creator = null;
            }
            if (message.resource != null && message.hasOwnProperty("resource"))
                object.resource = $root.types.Resource.toObject(message.resource, options);
            if (message.creator != null && message.hasOwnProperty("creator"))
                object.creator = $root.types.IdentityKeyID.toObject(message.creator, options);
            if (message.encryptedKey && message.encryptedKey.length) {
                object.encryptedKey = [];
                for (var j = 0; j < message.encryptedKey.length; ++j)
                    object.encryptedKey[j] = $root.types.Cipher.toObject(message.encryptedKey[j], options);
            }
            return object;
        };

        /**
         * Converts this ResourceGetResponse to JSON.
         * @function toJSON
         * @memberof types.ResourceGetResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResourceGetResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ResourceGetResponse;
    })();

    types.ResourceWithKey = (function() {

        /**
         * Properties of a ResourceWithKey.
         * @memberof types
         * @interface IResourceWithKey
         * @property {types.IResource|null} [resource] ResourceWithKey resource
         * @property {types.IIdentityKeyID|null} [owner] ResourceWithKey owner
         * @property {types.IIdentityKeyID|null} [creator] ResourceWithKey creator
         * @property {types.ICipher|null} [encryptedKey] ResourceWithKey encryptedKey
         */

        /**
         * Constructs a new ResourceWithKey.
         * @memberof types
         * @classdesc Represents a ResourceWithKey.
         * @implements IResourceWithKey
         * @constructor
         * @param {types.IResourceWithKey=} [properties] Properties to set
         */
        function ResourceWithKey(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResourceWithKey resource.
         * @member {types.IResource|null|undefined} resource
         * @memberof types.ResourceWithKey
         * @instance
         */
        ResourceWithKey.prototype.resource = null;

        /**
         * ResourceWithKey owner.
         * @member {types.IIdentityKeyID|null|undefined} owner
         * @memberof types.ResourceWithKey
         * @instance
         */
        ResourceWithKey.prototype.owner = null;

        /**
         * ResourceWithKey creator.
         * @member {types.IIdentityKeyID|null|undefined} creator
         * @memberof types.ResourceWithKey
         * @instance
         */
        ResourceWithKey.prototype.creator = null;

        /**
         * ResourceWithKey encryptedKey.
         * @member {types.ICipher|null|undefined} encryptedKey
         * @memberof types.ResourceWithKey
         * @instance
         */
        ResourceWithKey.prototype.encryptedKey = null;

        /**
         * Creates a new ResourceWithKey instance using the specified properties.
         * @function create
         * @memberof types.ResourceWithKey
         * @static
         * @param {types.IResourceWithKey=} [properties] Properties to set
         * @returns {types.ResourceWithKey} ResourceWithKey instance
         */
        ResourceWithKey.create = function create(properties) {
            return new ResourceWithKey(properties);
        };

        /**
         * Encodes the specified ResourceWithKey message. Does not implicitly {@link types.ResourceWithKey.verify|verify} messages.
         * @function encode
         * @memberof types.ResourceWithKey
         * @static
         * @param {types.IResourceWithKey} message ResourceWithKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourceWithKey.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.resource != null && message.hasOwnProperty("resource"))
                $root.types.Resource.encode(message.resource, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.owner != null && message.hasOwnProperty("owner"))
                $root.types.IdentityKeyID.encode(message.owner, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.creator != null && message.hasOwnProperty("creator"))
                $root.types.IdentityKeyID.encode(message.creator, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.encryptedKey != null && message.hasOwnProperty("encryptedKey"))
                $root.types.Cipher.encode(message.encryptedKey, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ResourceWithKey message, length delimited. Does not implicitly {@link types.ResourceWithKey.verify|verify} messages.
         * @function encodeDelimited
         * @memberof types.ResourceWithKey
         * @static
         * @param {types.IResourceWithKey} message ResourceWithKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourceWithKey.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResourceWithKey message from the specified reader or buffer.
         * @function decode
         * @memberof types.ResourceWithKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {types.ResourceWithKey} ResourceWithKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourceWithKey.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.types.ResourceWithKey();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.resource = $root.types.Resource.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.owner = $root.types.IdentityKeyID.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.creator = $root.types.IdentityKeyID.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.encryptedKey = $root.types.Cipher.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ResourceWithKey message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof types.ResourceWithKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {types.ResourceWithKey} ResourceWithKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourceWithKey.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResourceWithKey message.
         * @function verify
         * @memberof types.ResourceWithKey
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResourceWithKey.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.resource != null && message.hasOwnProperty("resource")) {
                var error = $root.types.Resource.verify(message.resource);
                if (error)
                    return "resource." + error;
            }
            if (message.owner != null && message.hasOwnProperty("owner")) {
                var error = $root.types.IdentityKeyID.verify(message.owner);
                if (error)
                    return "owner." + error;
            }
            if (message.creator != null && message.hasOwnProperty("creator")) {
                var error = $root.types.IdentityKeyID.verify(message.creator);
                if (error)
                    return "creator." + error;
            }
            if (message.encryptedKey != null && message.hasOwnProperty("encryptedKey")) {
                var error = $root.types.Cipher.verify(message.encryptedKey);
                if (error)
                    return "encryptedKey." + error;
            }
            return null;
        };

        /**
         * Creates a ResourceWithKey message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof types.ResourceWithKey
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {types.ResourceWithKey} ResourceWithKey
         */
        ResourceWithKey.fromObject = function fromObject(object) {
            if (object instanceof $root.types.ResourceWithKey)
                return object;
            var message = new $root.types.ResourceWithKey();
            if (object.resource != null) {
                if (typeof object.resource !== "object")
                    throw TypeError(".types.ResourceWithKey.resource: object expected");
                message.resource = $root.types.Resource.fromObject(object.resource);
            }
            if (object.owner != null) {
                if (typeof object.owner !== "object")
                    throw TypeError(".types.ResourceWithKey.owner: object expected");
                message.owner = $root.types.IdentityKeyID.fromObject(object.owner);
            }
            if (object.creator != null) {
                if (typeof object.creator !== "object")
                    throw TypeError(".types.ResourceWithKey.creator: object expected");
                message.creator = $root.types.IdentityKeyID.fromObject(object.creator);
            }
            if (object.encryptedKey != null) {
                if (typeof object.encryptedKey !== "object")
                    throw TypeError(".types.ResourceWithKey.encryptedKey: object expected");
                message.encryptedKey = $root.types.Cipher.fromObject(object.encryptedKey);
            }
            return message;
        };

        /**
         * Creates a plain object from a ResourceWithKey message. Also converts values to other types if specified.
         * @function toObject
         * @memberof types.ResourceWithKey
         * @static
         * @param {types.ResourceWithKey} message ResourceWithKey
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResourceWithKey.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.resource = null;
                object.owner = null;
                object.creator = null;
                object.encryptedKey = null;
            }
            if (message.resource != null && message.hasOwnProperty("resource"))
                object.resource = $root.types.Resource.toObject(message.resource, options);
            if (message.owner != null && message.hasOwnProperty("owner"))
                object.owner = $root.types.IdentityKeyID.toObject(message.owner, options);
            if (message.creator != null && message.hasOwnProperty("creator"))
                object.creator = $root.types.IdentityKeyID.toObject(message.creator, options);
            if (message.encryptedKey != null && message.hasOwnProperty("encryptedKey"))
                object.encryptedKey = $root.types.Cipher.toObject(message.encryptedKey, options);
            return object;
        };

        /**
         * Converts this ResourceWithKey to JSON.
         * @function toJSON
         * @memberof types.ResourceWithKey
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResourceWithKey.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ResourceWithKey;
    })();

    types.ResourceGetKeyResponse = (function() {

        /**
         * Properties of a ResourceGetKeyResponse.
         * @memberof types
         * @interface IResourceGetKeyResponse
         * @property {Array.<types.ICipher>|null} [encryptedKey] ResourceGetKeyResponse encryptedKey
         * @property {types.ResourceType|null} [type] ResourceGetKeyResponse type
         */

        /**
         * Constructs a new ResourceGetKeyResponse.
         * @memberof types
         * @classdesc Represents a ResourceGetKeyResponse.
         * @implements IResourceGetKeyResponse
         * @constructor
         * @param {types.IResourceGetKeyResponse=} [properties] Properties to set
         */
        function ResourceGetKeyResponse(properties) {
            this.encryptedKey = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResourceGetKeyResponse encryptedKey.
         * @member {Array.<types.ICipher>} encryptedKey
         * @memberof types.ResourceGetKeyResponse
         * @instance
         */
        ResourceGetKeyResponse.prototype.encryptedKey = $util.emptyArray;

        /**
         * ResourceGetKeyResponse type.
         * @member {types.ResourceType} type
         * @memberof types.ResourceGetKeyResponse
         * @instance
         */
        ResourceGetKeyResponse.prototype.type = 0;

        /**
         * Creates a new ResourceGetKeyResponse instance using the specified properties.
         * @function create
         * @memberof types.ResourceGetKeyResponse
         * @static
         * @param {types.IResourceGetKeyResponse=} [properties] Properties to set
         * @returns {types.ResourceGetKeyResponse} ResourceGetKeyResponse instance
         */
        ResourceGetKeyResponse.create = function create(properties) {
            return new ResourceGetKeyResponse(properties);
        };

        /**
         * Encodes the specified ResourceGetKeyResponse message. Does not implicitly {@link types.ResourceGetKeyResponse.verify|verify} messages.
         * @function encode
         * @memberof types.ResourceGetKeyResponse
         * @static
         * @param {types.IResourceGetKeyResponse} message ResourceGetKeyResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourceGetKeyResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.encryptedKey != null && message.encryptedKey.length)
                for (var i = 0; i < message.encryptedKey.length; ++i)
                    $root.types.Cipher.encode(message.encryptedKey[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
            return writer;
        };

        /**
         * Encodes the specified ResourceGetKeyResponse message, length delimited. Does not implicitly {@link types.ResourceGetKeyResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof types.ResourceGetKeyResponse
         * @static
         * @param {types.IResourceGetKeyResponse} message ResourceGetKeyResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourceGetKeyResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResourceGetKeyResponse message from the specified reader or buffer.
         * @function decode
         * @memberof types.ResourceGetKeyResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {types.ResourceGetKeyResponse} ResourceGetKeyResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourceGetKeyResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.types.ResourceGetKeyResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.encryptedKey && message.encryptedKey.length))
                        message.encryptedKey = [];
                    message.encryptedKey.push($root.types.Cipher.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.type = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ResourceGetKeyResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof types.ResourceGetKeyResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {types.ResourceGetKeyResponse} ResourceGetKeyResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourceGetKeyResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResourceGetKeyResponse message.
         * @function verify
         * @memberof types.ResourceGetKeyResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResourceGetKeyResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.encryptedKey != null && message.hasOwnProperty("encryptedKey")) {
                if (!Array.isArray(message.encryptedKey))
                    return "encryptedKey: array expected";
                for (var i = 0; i < message.encryptedKey.length; ++i) {
                    var error = $root.types.Cipher.verify(message.encryptedKey[i]);
                    if (error)
                        return "encryptedKey." + error;
                }
            }
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                    break;
                }
            return null;
        };

        /**
         * Creates a ResourceGetKeyResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof types.ResourceGetKeyResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {types.ResourceGetKeyResponse} ResourceGetKeyResponse
         */
        ResourceGetKeyResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.types.ResourceGetKeyResponse)
                return object;
            var message = new $root.types.ResourceGetKeyResponse();
            if (object.encryptedKey) {
                if (!Array.isArray(object.encryptedKey))
                    throw TypeError(".types.ResourceGetKeyResponse.encryptedKey: array expected");
                message.encryptedKey = [];
                for (var i = 0; i < object.encryptedKey.length; ++i) {
                    if (typeof object.encryptedKey[i] !== "object")
                        throw TypeError(".types.ResourceGetKeyResponse.encryptedKey: object expected");
                    message.encryptedKey[i] = $root.types.Cipher.fromObject(object.encryptedKey[i]);
                }
            }
            switch (object.type) {
            case "ANONYMOUS":
            case 0:
                message.type = 0;
                break;
            case "SES":
            case 1:
                message.type = 1;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a ResourceGetKeyResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof types.ResourceGetKeyResponse
         * @static
         * @param {types.ResourceGetKeyResponse} message ResourceGetKeyResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResourceGetKeyResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.encryptedKey = [];
            if (options.defaults)
                object.type = options.enums === String ? "ANONYMOUS" : 0;
            if (message.encryptedKey && message.encryptedKey.length) {
                object.encryptedKey = [];
                for (var j = 0; j < message.encryptedKey.length; ++j)
                    object.encryptedKey[j] = $root.types.Cipher.toObject(message.encryptedKey[j], options);
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.types.ResourceType[message.type] : message.type;
            return object;
        };

        /**
         * Converts this ResourceGetKeyResponse to JSON.
         * @function toJSON
         * @memberof types.ResourceGetKeyResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResourceGetKeyResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ResourceGetKeyResponse;
    })();

    types.ResourceShareEntry = (function() {

        /**
         * Properties of a ResourceShareEntry.
         * @memberof types
         * @interface IResourceShareEntry
         * @property {string|null} [login] ResourceShareEntry login
         * @property {number|null} [version] ResourceShareEntry version
         * @property {Uint8Array|null} [nonce] ResourceShareEntry nonce
         * @property {Uint8Array|null} [encryptedKey] ResourceShareEntry encryptedKey
         */

        /**
         * Constructs a new ResourceShareEntry.
         * @memberof types
         * @classdesc Represents a ResourceShareEntry.
         * @implements IResourceShareEntry
         * @constructor
         * @param {types.IResourceShareEntry=} [properties] Properties to set
         */
        function ResourceShareEntry(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResourceShareEntry login.
         * @member {string} login
         * @memberof types.ResourceShareEntry
         * @instance
         */
        ResourceShareEntry.prototype.login = "";

        /**
         * ResourceShareEntry version.
         * @member {number} version
         * @memberof types.ResourceShareEntry
         * @instance
         */
        ResourceShareEntry.prototype.version = 0;

        /**
         * ResourceShareEntry nonce.
         * @member {Uint8Array} nonce
         * @memberof types.ResourceShareEntry
         * @instance
         */
        ResourceShareEntry.prototype.nonce = $util.newBuffer([]);

        /**
         * ResourceShareEntry encryptedKey.
         * @member {Uint8Array} encryptedKey
         * @memberof types.ResourceShareEntry
         * @instance
         */
        ResourceShareEntry.prototype.encryptedKey = $util.newBuffer([]);

        /**
         * Creates a new ResourceShareEntry instance using the specified properties.
         * @function create
         * @memberof types.ResourceShareEntry
         * @static
         * @param {types.IResourceShareEntry=} [properties] Properties to set
         * @returns {types.ResourceShareEntry} ResourceShareEntry instance
         */
        ResourceShareEntry.create = function create(properties) {
            return new ResourceShareEntry(properties);
        };

        /**
         * Encodes the specified ResourceShareEntry message. Does not implicitly {@link types.ResourceShareEntry.verify|verify} messages.
         * @function encode
         * @memberof types.ResourceShareEntry
         * @static
         * @param {types.IResourceShareEntry} message ResourceShareEntry message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourceShareEntry.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            if (message.version != null && message.hasOwnProperty("version"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.version);
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.nonce);
            if (message.encryptedKey != null && message.hasOwnProperty("encryptedKey"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.encryptedKey);
            return writer;
        };

        /**
         * Encodes the specified ResourceShareEntry message, length delimited. Does not implicitly {@link types.ResourceShareEntry.verify|verify} messages.
         * @function encodeDelimited
         * @memberof types.ResourceShareEntry
         * @static
         * @param {types.IResourceShareEntry} message ResourceShareEntry message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourceShareEntry.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResourceShareEntry message from the specified reader or buffer.
         * @function decode
         * @memberof types.ResourceShareEntry
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {types.ResourceShareEntry} ResourceShareEntry
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourceShareEntry.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.types.ResourceShareEntry();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                case 2:
                    message.version = reader.uint32();
                    break;
                case 3:
                    message.nonce = reader.bytes();
                    break;
                case 4:
                    message.encryptedKey = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ResourceShareEntry message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof types.ResourceShareEntry
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {types.ResourceShareEntry} ResourceShareEntry
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourceShareEntry.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResourceShareEntry message.
         * @function verify
         * @memberof types.ResourceShareEntry
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResourceShareEntry.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isInteger(message.version))
                    return "version: integer expected";
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                if (!(message.nonce && typeof message.nonce.length === "number" || $util.isString(message.nonce)))
                    return "nonce: buffer expected";
            if (message.encryptedKey != null && message.hasOwnProperty("encryptedKey"))
                if (!(message.encryptedKey && typeof message.encryptedKey.length === "number" || $util.isString(message.encryptedKey)))
                    return "encryptedKey: buffer expected";
            return null;
        };

        /**
         * Creates a ResourceShareEntry message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof types.ResourceShareEntry
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {types.ResourceShareEntry} ResourceShareEntry
         */
        ResourceShareEntry.fromObject = function fromObject(object) {
            if (object instanceof $root.types.ResourceShareEntry)
                return object;
            var message = new $root.types.ResourceShareEntry();
            if (object.login != null)
                message.login = String(object.login);
            if (object.version != null)
                message.version = object.version >>> 0;
            if (object.nonce != null)
                if (typeof object.nonce === "string")
                    $util.base64.decode(object.nonce, message.nonce = $util.newBuffer($util.base64.length(object.nonce)), 0);
                else if (object.nonce.length)
                    message.nonce = object.nonce;
            if (object.encryptedKey != null)
                if (typeof object.encryptedKey === "string")
                    $util.base64.decode(object.encryptedKey, message.encryptedKey = $util.newBuffer($util.base64.length(object.encryptedKey)), 0);
                else if (object.encryptedKey.length)
                    message.encryptedKey = object.encryptedKey;
            return message;
        };

        /**
         * Creates a plain object from a ResourceShareEntry message. Also converts values to other types if specified.
         * @function toObject
         * @memberof types.ResourceShareEntry
         * @static
         * @param {types.ResourceShareEntry} message ResourceShareEntry
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResourceShareEntry.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.login = "";
                object.version = 0;
                object.nonce = options.bytes === String ? "" : [];
                object.encryptedKey = options.bytes === String ? "" : [];
            }
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                object.nonce = options.bytes === String ? $util.base64.encode(message.nonce, 0, message.nonce.length) : options.bytes === Array ? Array.prototype.slice.call(message.nonce) : message.nonce;
            if (message.encryptedKey != null && message.hasOwnProperty("encryptedKey"))
                object.encryptedKey = options.bytes === String ? $util.base64.encode(message.encryptedKey, 0, message.encryptedKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedKey) : message.encryptedKey;
            return object;
        };

        /**
         * Converts this ResourceShareEntry to JSON.
         * @function toJSON
         * @memberof types.ResourceShareEntry
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResourceShareEntry.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ResourceShareEntry;
    })();

    types.ResourcePostRequest = (function() {

        /**
         * Properties of a ResourcePostRequest.
         * @memberof types
         * @interface IResourcePostRequest
         * @property {string|null} [kind] ResourcePostRequest kind
         * @property {Uint8Array|null} [publicKey] ResourcePostRequest publicKey
         * @property {Uint8Array|null} [nonce] ResourcePostRequest nonce
         * @property {Uint8Array|null} [payload] ResourcePostRequest payload
         * @property {Array.<types.IResourceShareEntry>|null} [sharingGroup] ResourcePostRequest sharingGroup
         * @property {types.ResourceType|null} [type] ResourcePostRequest type
         */

        /**
         * Constructs a new ResourcePostRequest.
         * @memberof types
         * @classdesc Represents a ResourcePostRequest.
         * @implements IResourcePostRequest
         * @constructor
         * @param {types.IResourcePostRequest=} [properties] Properties to set
         */
        function ResourcePostRequest(properties) {
            this.sharingGroup = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResourcePostRequest kind.
         * @member {string} kind
         * @memberof types.ResourcePostRequest
         * @instance
         */
        ResourcePostRequest.prototype.kind = "";

        /**
         * ResourcePostRequest publicKey.
         * @member {Uint8Array} publicKey
         * @memberof types.ResourcePostRequest
         * @instance
         */
        ResourcePostRequest.prototype.publicKey = $util.newBuffer([]);

        /**
         * ResourcePostRequest nonce.
         * @member {Uint8Array} nonce
         * @memberof types.ResourcePostRequest
         * @instance
         */
        ResourcePostRequest.prototype.nonce = $util.newBuffer([]);

        /**
         * ResourcePostRequest payload.
         * @member {Uint8Array} payload
         * @memberof types.ResourcePostRequest
         * @instance
         */
        ResourcePostRequest.prototype.payload = $util.newBuffer([]);

        /**
         * ResourcePostRequest sharingGroup.
         * @member {Array.<types.IResourceShareEntry>} sharingGroup
         * @memberof types.ResourcePostRequest
         * @instance
         */
        ResourcePostRequest.prototype.sharingGroup = $util.emptyArray;

        /**
         * ResourcePostRequest type.
         * @member {types.ResourceType} type
         * @memberof types.ResourcePostRequest
         * @instance
         */
        ResourcePostRequest.prototype.type = 0;

        /**
         * Creates a new ResourcePostRequest instance using the specified properties.
         * @function create
         * @memberof types.ResourcePostRequest
         * @static
         * @param {types.IResourcePostRequest=} [properties] Properties to set
         * @returns {types.ResourcePostRequest} ResourcePostRequest instance
         */
        ResourcePostRequest.create = function create(properties) {
            return new ResourcePostRequest(properties);
        };

        /**
         * Encodes the specified ResourcePostRequest message. Does not implicitly {@link types.ResourcePostRequest.verify|verify} messages.
         * @function encode
         * @memberof types.ResourcePostRequest
         * @static
         * @param {types.IResourcePostRequest} message ResourcePostRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourcePostRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.kind != null && message.hasOwnProperty("kind"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.kind);
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.publicKey);
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.nonce);
            if (message.payload != null && message.hasOwnProperty("payload"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.payload);
            if (message.sharingGroup != null && message.sharingGroup.length)
                for (var i = 0; i < message.sharingGroup.length; ++i)
                    $root.types.ResourceShareEntry.encode(message.sharingGroup[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.type);
            return writer;
        };

        /**
         * Encodes the specified ResourcePostRequest message, length delimited. Does not implicitly {@link types.ResourcePostRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof types.ResourcePostRequest
         * @static
         * @param {types.IResourcePostRequest} message ResourcePostRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourcePostRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResourcePostRequest message from the specified reader or buffer.
         * @function decode
         * @memberof types.ResourcePostRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {types.ResourcePostRequest} ResourcePostRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourcePostRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.types.ResourcePostRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.kind = reader.string();
                    break;
                case 2:
                    message.publicKey = reader.bytes();
                    break;
                case 3:
                    message.nonce = reader.bytes();
                    break;
                case 4:
                    message.payload = reader.bytes();
                    break;
                case 5:
                    if (!(message.sharingGroup && message.sharingGroup.length))
                        message.sharingGroup = [];
                    message.sharingGroup.push($root.types.ResourceShareEntry.decode(reader, reader.uint32()));
                    break;
                case 6:
                    message.type = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ResourcePostRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof types.ResourcePostRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {types.ResourcePostRequest} ResourcePostRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourcePostRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResourcePostRequest message.
         * @function verify
         * @memberof types.ResourcePostRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResourcePostRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.kind != null && message.hasOwnProperty("kind"))
                if (!$util.isString(message.kind))
                    return "kind: string expected";
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                if (!(message.publicKey && typeof message.publicKey.length === "number" || $util.isString(message.publicKey)))
                    return "publicKey: buffer expected";
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                if (!(message.nonce && typeof message.nonce.length === "number" || $util.isString(message.nonce)))
                    return "nonce: buffer expected";
            if (message.payload != null && message.hasOwnProperty("payload"))
                if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                    return "payload: buffer expected";
            if (message.sharingGroup != null && message.hasOwnProperty("sharingGroup")) {
                if (!Array.isArray(message.sharingGroup))
                    return "sharingGroup: array expected";
                for (var i = 0; i < message.sharingGroup.length; ++i) {
                    var error = $root.types.ResourceShareEntry.verify(message.sharingGroup[i]);
                    if (error)
                        return "sharingGroup." + error;
                }
            }
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                    break;
                }
            return null;
        };

        /**
         * Creates a ResourcePostRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof types.ResourcePostRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {types.ResourcePostRequest} ResourcePostRequest
         */
        ResourcePostRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.types.ResourcePostRequest)
                return object;
            var message = new $root.types.ResourcePostRequest();
            if (object.kind != null)
                message.kind = String(object.kind);
            if (object.publicKey != null)
                if (typeof object.publicKey === "string")
                    $util.base64.decode(object.publicKey, message.publicKey = $util.newBuffer($util.base64.length(object.publicKey)), 0);
                else if (object.publicKey.length)
                    message.publicKey = object.publicKey;
            if (object.nonce != null)
                if (typeof object.nonce === "string")
                    $util.base64.decode(object.nonce, message.nonce = $util.newBuffer($util.base64.length(object.nonce)), 0);
                else if (object.nonce.length)
                    message.nonce = object.nonce;
            if (object.payload != null)
                if (typeof object.payload === "string")
                    $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                else if (object.payload.length)
                    message.payload = object.payload;
            if (object.sharingGroup) {
                if (!Array.isArray(object.sharingGroup))
                    throw TypeError(".types.ResourcePostRequest.sharingGroup: array expected");
                message.sharingGroup = [];
                for (var i = 0; i < object.sharingGroup.length; ++i) {
                    if (typeof object.sharingGroup[i] !== "object")
                        throw TypeError(".types.ResourcePostRequest.sharingGroup: object expected");
                    message.sharingGroup[i] = $root.types.ResourceShareEntry.fromObject(object.sharingGroup[i]);
                }
            }
            switch (object.type) {
            case "ANONYMOUS":
            case 0:
                message.type = 0;
                break;
            case "SES":
            case 1:
                message.type = 1;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a ResourcePostRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof types.ResourcePostRequest
         * @static
         * @param {types.ResourcePostRequest} message ResourcePostRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResourcePostRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.sharingGroup = [];
            if (options.defaults) {
                object.kind = "";
                object.publicKey = options.bytes === String ? "" : [];
                object.nonce = options.bytes === String ? "" : [];
                object.payload = options.bytes === String ? "" : [];
                object.type = options.enums === String ? "ANONYMOUS" : 0;
            }
            if (message.kind != null && message.hasOwnProperty("kind"))
                object.kind = message.kind;
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                object.publicKey = options.bytes === String ? $util.base64.encode(message.publicKey, 0, message.publicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.publicKey) : message.publicKey;
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                object.nonce = options.bytes === String ? $util.base64.encode(message.nonce, 0, message.nonce.length) : options.bytes === Array ? Array.prototype.slice.call(message.nonce) : message.nonce;
            if (message.payload != null && message.hasOwnProperty("payload"))
                object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
            if (message.sharingGroup && message.sharingGroup.length) {
                object.sharingGroup = [];
                for (var j = 0; j < message.sharingGroup.length; ++j)
                    object.sharingGroup[j] = $root.types.ResourceShareEntry.toObject(message.sharingGroup[j], options);
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.types.ResourceType[message.type] : message.type;
            return object;
        };

        /**
         * Converts this ResourcePostRequest to JSON.
         * @function toJSON
         * @memberof types.ResourcePostRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResourcePostRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ResourcePostRequest;
    })();

    types.ResourcePostResponse = (function() {

        /**
         * Properties of a ResourcePostResponse.
         * @memberof types
         * @interface IResourcePostResponse
         * @property {number|Long|null} [id] ResourcePostResponse id
         */

        /**
         * Constructs a new ResourcePostResponse.
         * @memberof types
         * @classdesc Represents a ResourcePostResponse.
         * @implements IResourcePostResponse
         * @constructor
         * @param {types.IResourcePostResponse=} [properties] Properties to set
         */
        function ResourcePostResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResourcePostResponse id.
         * @member {number|Long} id
         * @memberof types.ResourcePostResponse
         * @instance
         */
        ResourcePostResponse.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new ResourcePostResponse instance using the specified properties.
         * @function create
         * @memberof types.ResourcePostResponse
         * @static
         * @param {types.IResourcePostResponse=} [properties] Properties to set
         * @returns {types.ResourcePostResponse} ResourcePostResponse instance
         */
        ResourcePostResponse.create = function create(properties) {
            return new ResourcePostResponse(properties);
        };

        /**
         * Encodes the specified ResourcePostResponse message. Does not implicitly {@link types.ResourcePostResponse.verify|verify} messages.
         * @function encode
         * @memberof types.ResourcePostResponse
         * @static
         * @param {types.IResourcePostResponse} message ResourcePostResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourcePostResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
            return writer;
        };

        /**
         * Encodes the specified ResourcePostResponse message, length delimited. Does not implicitly {@link types.ResourcePostResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof types.ResourcePostResponse
         * @static
         * @param {types.IResourcePostResponse} message ResourcePostResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourcePostResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResourcePostResponse message from the specified reader or buffer.
         * @function decode
         * @memberof types.ResourcePostResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {types.ResourcePostResponse} ResourcePostResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourcePostResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.types.ResourcePostResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ResourcePostResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof types.ResourcePostResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {types.ResourcePostResponse} ResourcePostResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourcePostResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResourcePostResponse message.
         * @function verify
         * @memberof types.ResourcePostResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResourcePostResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                    return "id: integer|Long expected";
            return null;
        };

        /**
         * Creates a ResourcePostResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof types.ResourcePostResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {types.ResourcePostResponse} ResourcePostResponse
         */
        ResourcePostResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.types.ResourcePostResponse)
                return object;
            var message = new $root.types.ResourcePostResponse();
            if (object.id != null)
                if ($util.Long)
                    (message.id = $util.Long.fromValue(object.id)).unsigned = true;
                else if (typeof object.id === "string")
                    message.id = parseInt(object.id, 10);
                else if (typeof object.id === "number")
                    message.id = object.id;
                else if (typeof object.id === "object")
                    message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a ResourcePostResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof types.ResourcePostResponse
         * @static
         * @param {types.ResourcePostResponse} message ResourcePostResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResourcePostResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.id = options.longs === String ? "0" : 0;
            if (message.id != null && message.hasOwnProperty("id"))
                if (typeof message.id === "number")
                    object.id = options.longs === String ? String(message.id) : message.id;
                else
                    object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
            return object;
        };

        /**
         * Converts this ResourcePostResponse to JSON.
         * @function toJSON
         * @memberof types.ResourcePostResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResourcePostResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ResourcePostResponse;
    })();

    types.ResourceExtendSharingGroupRequest = (function() {

        /**
         * Properties of a ResourceExtendSharingGroupRequest.
         * @memberof types
         * @interface IResourceExtendSharingGroupRequest
         * @property {number|Long|null} [id] ResourceExtendSharingGroupRequest id
         * @property {Array.<types.IResourceShareEntry>|null} [sharingGroup] ResourceExtendSharingGroupRequest sharingGroup
         */

        /**
         * Constructs a new ResourceExtendSharingGroupRequest.
         * @memberof types
         * @classdesc Represents a ResourceExtendSharingGroupRequest.
         * @implements IResourceExtendSharingGroupRequest
         * @constructor
         * @param {types.IResourceExtendSharingGroupRequest=} [properties] Properties to set
         */
        function ResourceExtendSharingGroupRequest(properties) {
            this.sharingGroup = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResourceExtendSharingGroupRequest id.
         * @member {number|Long} id
         * @memberof types.ResourceExtendSharingGroupRequest
         * @instance
         */
        ResourceExtendSharingGroupRequest.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ResourceExtendSharingGroupRequest sharingGroup.
         * @member {Array.<types.IResourceShareEntry>} sharingGroup
         * @memberof types.ResourceExtendSharingGroupRequest
         * @instance
         */
        ResourceExtendSharingGroupRequest.prototype.sharingGroup = $util.emptyArray;

        /**
         * Creates a new ResourceExtendSharingGroupRequest instance using the specified properties.
         * @function create
         * @memberof types.ResourceExtendSharingGroupRequest
         * @static
         * @param {types.IResourceExtendSharingGroupRequest=} [properties] Properties to set
         * @returns {types.ResourceExtendSharingGroupRequest} ResourceExtendSharingGroupRequest instance
         */
        ResourceExtendSharingGroupRequest.create = function create(properties) {
            return new ResourceExtendSharingGroupRequest(properties);
        };

        /**
         * Encodes the specified ResourceExtendSharingGroupRequest message. Does not implicitly {@link types.ResourceExtendSharingGroupRequest.verify|verify} messages.
         * @function encode
         * @memberof types.ResourceExtendSharingGroupRequest
         * @static
         * @param {types.IResourceExtendSharingGroupRequest} message ResourceExtendSharingGroupRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourceExtendSharingGroupRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
            if (message.sharingGroup != null && message.sharingGroup.length)
                for (var i = 0; i < message.sharingGroup.length; ++i)
                    $root.types.ResourceShareEntry.encode(message.sharingGroup[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ResourceExtendSharingGroupRequest message, length delimited. Does not implicitly {@link types.ResourceExtendSharingGroupRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof types.ResourceExtendSharingGroupRequest
         * @static
         * @param {types.IResourceExtendSharingGroupRequest} message ResourceExtendSharingGroupRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourceExtendSharingGroupRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResourceExtendSharingGroupRequest message from the specified reader or buffer.
         * @function decode
         * @memberof types.ResourceExtendSharingGroupRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {types.ResourceExtendSharingGroupRequest} ResourceExtendSharingGroupRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourceExtendSharingGroupRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.types.ResourceExtendSharingGroupRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.uint64();
                    break;
                case 2:
                    if (!(message.sharingGroup && message.sharingGroup.length))
                        message.sharingGroup = [];
                    message.sharingGroup.push($root.types.ResourceShareEntry.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ResourceExtendSharingGroupRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof types.ResourceExtendSharingGroupRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {types.ResourceExtendSharingGroupRequest} ResourceExtendSharingGroupRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourceExtendSharingGroupRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResourceExtendSharingGroupRequest message.
         * @function verify
         * @memberof types.ResourceExtendSharingGroupRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResourceExtendSharingGroupRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                    return "id: integer|Long expected";
            if (message.sharingGroup != null && message.hasOwnProperty("sharingGroup")) {
                if (!Array.isArray(message.sharingGroup))
                    return "sharingGroup: array expected";
                for (var i = 0; i < message.sharingGroup.length; ++i) {
                    var error = $root.types.ResourceShareEntry.verify(message.sharingGroup[i]);
                    if (error)
                        return "sharingGroup." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ResourceExtendSharingGroupRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof types.ResourceExtendSharingGroupRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {types.ResourceExtendSharingGroupRequest} ResourceExtendSharingGroupRequest
         */
        ResourceExtendSharingGroupRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.types.ResourceExtendSharingGroupRequest)
                return object;
            var message = new $root.types.ResourceExtendSharingGroupRequest();
            if (object.id != null)
                if ($util.Long)
                    (message.id = $util.Long.fromValue(object.id)).unsigned = true;
                else if (typeof object.id === "string")
                    message.id = parseInt(object.id, 10);
                else if (typeof object.id === "number")
                    message.id = object.id;
                else if (typeof object.id === "object")
                    message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
            if (object.sharingGroup) {
                if (!Array.isArray(object.sharingGroup))
                    throw TypeError(".types.ResourceExtendSharingGroupRequest.sharingGroup: array expected");
                message.sharingGroup = [];
                for (var i = 0; i < object.sharingGroup.length; ++i) {
                    if (typeof object.sharingGroup[i] !== "object")
                        throw TypeError(".types.ResourceExtendSharingGroupRequest.sharingGroup: object expected");
                    message.sharingGroup[i] = $root.types.ResourceShareEntry.fromObject(object.sharingGroup[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ResourceExtendSharingGroupRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof types.ResourceExtendSharingGroupRequest
         * @static
         * @param {types.ResourceExtendSharingGroupRequest} message ResourceExtendSharingGroupRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResourceExtendSharingGroupRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.sharingGroup = [];
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.id = options.longs === String ? "0" : 0;
            if (message.id != null && message.hasOwnProperty("id"))
                if (typeof message.id === "number")
                    object.id = options.longs === String ? String(message.id) : message.id;
                else
                    object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
            if (message.sharingGroup && message.sharingGroup.length) {
                object.sharingGroup = [];
                for (var j = 0; j < message.sharingGroup.length; ++j)
                    object.sharingGroup[j] = $root.types.ResourceShareEntry.toObject(message.sharingGroup[j], options);
            }
            return object;
        };

        /**
         * Converts this ResourceExtendSharingGroupRequest to JSON.
         * @function toJSON
         * @memberof types.ResourceExtendSharingGroupRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResourceExtendSharingGroupRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ResourceExtendSharingGroupRequest;
    })();

    types.ResourceListResponse = (function() {

        /**
         * Properties of a ResourceListResponse.
         * @memberof types
         * @interface IResourceListResponse
         * @property {Array.<types.IResourceWithKey>|null} [resources] ResourceListResponse resources
         */

        /**
         * Constructs a new ResourceListResponse.
         * @memberof types
         * @classdesc Represents a ResourceListResponse.
         * @implements IResourceListResponse
         * @constructor
         * @param {types.IResourceListResponse=} [properties] Properties to set
         */
        function ResourceListResponse(properties) {
            this.resources = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResourceListResponse resources.
         * @member {Array.<types.IResourceWithKey>} resources
         * @memberof types.ResourceListResponse
         * @instance
         */
        ResourceListResponse.prototype.resources = $util.emptyArray;

        /**
         * Creates a new ResourceListResponse instance using the specified properties.
         * @function create
         * @memberof types.ResourceListResponse
         * @static
         * @param {types.IResourceListResponse=} [properties] Properties to set
         * @returns {types.ResourceListResponse} ResourceListResponse instance
         */
        ResourceListResponse.create = function create(properties) {
            return new ResourceListResponse(properties);
        };

        /**
         * Encodes the specified ResourceListResponse message. Does not implicitly {@link types.ResourceListResponse.verify|verify} messages.
         * @function encode
         * @memberof types.ResourceListResponse
         * @static
         * @param {types.IResourceListResponse} message ResourceListResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourceListResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.resources != null && message.resources.length)
                for (var i = 0; i < message.resources.length; ++i)
                    $root.types.ResourceWithKey.encode(message.resources[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ResourceListResponse message, length delimited. Does not implicitly {@link types.ResourceListResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof types.ResourceListResponse
         * @static
         * @param {types.IResourceListResponse} message ResourceListResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourceListResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResourceListResponse message from the specified reader or buffer.
         * @function decode
         * @memberof types.ResourceListResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {types.ResourceListResponse} ResourceListResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourceListResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.types.ResourceListResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.resources && message.resources.length))
                        message.resources = [];
                    message.resources.push($root.types.ResourceWithKey.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ResourceListResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof types.ResourceListResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {types.ResourceListResponse} ResourceListResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourceListResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResourceListResponse message.
         * @function verify
         * @memberof types.ResourceListResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResourceListResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.resources != null && message.hasOwnProperty("resources")) {
                if (!Array.isArray(message.resources))
                    return "resources: array expected";
                for (var i = 0; i < message.resources.length; ++i) {
                    var error = $root.types.ResourceWithKey.verify(message.resources[i]);
                    if (error)
                        return "resources." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ResourceListResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof types.ResourceListResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {types.ResourceListResponse} ResourceListResponse
         */
        ResourceListResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.types.ResourceListResponse)
                return object;
            var message = new $root.types.ResourceListResponse();
            if (object.resources) {
                if (!Array.isArray(object.resources))
                    throw TypeError(".types.ResourceListResponse.resources: array expected");
                message.resources = [];
                for (var i = 0; i < object.resources.length; ++i) {
                    if (typeof object.resources[i] !== "object")
                        throw TypeError(".types.ResourceListResponse.resources: object expected");
                    message.resources[i] = $root.types.ResourceWithKey.fromObject(object.resources[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ResourceListResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof types.ResourceListResponse
         * @static
         * @param {types.ResourceListResponse} message ResourceListResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResourceListResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.resources = [];
            if (message.resources && message.resources.length) {
                object.resources = [];
                for (var j = 0; j < message.resources.length; ++j)
                    object.resources[j] = $root.types.ResourceWithKey.toObject(message.resources[j], options);
            }
            return object;
        };

        /**
         * Converts this ResourceListResponse to JSON.
         * @function toJSON
         * @memberof types.ResourceListResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResourceListResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ResourceListResponse;
    })();

    types.ResourceGetSharingGroupResponse = (function() {

        /**
         * Properties of a ResourceGetSharingGroupResponse.
         * @memberof types
         * @interface IResourceGetSharingGroupResponse
         * @property {Array.<types.IResourceShareLink>|null} [sharingGroup] ResourceGetSharingGroupResponse sharingGroup
         */

        /**
         * Constructs a new ResourceGetSharingGroupResponse.
         * @memberof types
         * @classdesc Represents a ResourceGetSharingGroupResponse.
         * @implements IResourceGetSharingGroupResponse
         * @constructor
         * @param {types.IResourceGetSharingGroupResponse=} [properties] Properties to set
         */
        function ResourceGetSharingGroupResponse(properties) {
            this.sharingGroup = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResourceGetSharingGroupResponse sharingGroup.
         * @member {Array.<types.IResourceShareLink>} sharingGroup
         * @memberof types.ResourceGetSharingGroupResponse
         * @instance
         */
        ResourceGetSharingGroupResponse.prototype.sharingGroup = $util.emptyArray;

        /**
         * Creates a new ResourceGetSharingGroupResponse instance using the specified properties.
         * @function create
         * @memberof types.ResourceGetSharingGroupResponse
         * @static
         * @param {types.IResourceGetSharingGroupResponse=} [properties] Properties to set
         * @returns {types.ResourceGetSharingGroupResponse} ResourceGetSharingGroupResponse instance
         */
        ResourceGetSharingGroupResponse.create = function create(properties) {
            return new ResourceGetSharingGroupResponse(properties);
        };

        /**
         * Encodes the specified ResourceGetSharingGroupResponse message. Does not implicitly {@link types.ResourceGetSharingGroupResponse.verify|verify} messages.
         * @function encode
         * @memberof types.ResourceGetSharingGroupResponse
         * @static
         * @param {types.IResourceGetSharingGroupResponse} message ResourceGetSharingGroupResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourceGetSharingGroupResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.sharingGroup != null && message.sharingGroup.length)
                for (var i = 0; i < message.sharingGroup.length; ++i)
                    $root.types.ResourceShareLink.encode(message.sharingGroup[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ResourceGetSharingGroupResponse message, length delimited. Does not implicitly {@link types.ResourceGetSharingGroupResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof types.ResourceGetSharingGroupResponse
         * @static
         * @param {types.IResourceGetSharingGroupResponse} message ResourceGetSharingGroupResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourceGetSharingGroupResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResourceGetSharingGroupResponse message from the specified reader or buffer.
         * @function decode
         * @memberof types.ResourceGetSharingGroupResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {types.ResourceGetSharingGroupResponse} ResourceGetSharingGroupResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourceGetSharingGroupResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.types.ResourceGetSharingGroupResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.sharingGroup && message.sharingGroup.length))
                        message.sharingGroup = [];
                    message.sharingGroup.push($root.types.ResourceShareLink.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ResourceGetSharingGroupResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof types.ResourceGetSharingGroupResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {types.ResourceGetSharingGroupResponse} ResourceGetSharingGroupResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourceGetSharingGroupResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResourceGetSharingGroupResponse message.
         * @function verify
         * @memberof types.ResourceGetSharingGroupResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResourceGetSharingGroupResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.sharingGroup != null && message.hasOwnProperty("sharingGroup")) {
                if (!Array.isArray(message.sharingGroup))
                    return "sharingGroup: array expected";
                for (var i = 0; i < message.sharingGroup.length; ++i) {
                    var error = $root.types.ResourceShareLink.verify(message.sharingGroup[i]);
                    if (error)
                        return "sharingGroup." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ResourceGetSharingGroupResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof types.ResourceGetSharingGroupResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {types.ResourceGetSharingGroupResponse} ResourceGetSharingGroupResponse
         */
        ResourceGetSharingGroupResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.types.ResourceGetSharingGroupResponse)
                return object;
            var message = new $root.types.ResourceGetSharingGroupResponse();
            if (object.sharingGroup) {
                if (!Array.isArray(object.sharingGroup))
                    throw TypeError(".types.ResourceGetSharingGroupResponse.sharingGroup: array expected");
                message.sharingGroup = [];
                for (var i = 0; i < object.sharingGroup.length; ++i) {
                    if (typeof object.sharingGroup[i] !== "object")
                        throw TypeError(".types.ResourceGetSharingGroupResponse.sharingGroup: object expected");
                    message.sharingGroup[i] = $root.types.ResourceShareLink.fromObject(object.sharingGroup[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ResourceGetSharingGroupResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof types.ResourceGetSharingGroupResponse
         * @static
         * @param {types.ResourceGetSharingGroupResponse} message ResourceGetSharingGroupResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResourceGetSharingGroupResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.sharingGroup = [];
            if (message.sharingGroup && message.sharingGroup.length) {
                object.sharingGroup = [];
                for (var j = 0; j < message.sharingGroup.length; ++j)
                    object.sharingGroup[j] = $root.types.ResourceShareLink.toObject(message.sharingGroup[j], options);
            }
            return object;
        };

        /**
         * Converts this ResourceGetSharingGroupResponse to JSON.
         * @function toJSON
         * @memberof types.ResourceGetSharingGroupResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResourceGetSharingGroupResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ResourceGetSharingGroupResponse;
    })();

    types.ResourceShareLink = (function() {

        /**
         * Properties of a ResourceShareLink.
         * @memberof types
         * @interface IResourceShareLink
         * @property {types.IIdentityKeyID|null} [identityID] ResourceShareLink identityID
         */

        /**
         * Constructs a new ResourceShareLink.
         * @memberof types
         * @classdesc Represents a ResourceShareLink.
         * @implements IResourceShareLink
         * @constructor
         * @param {types.IResourceShareLink=} [properties] Properties to set
         */
        function ResourceShareLink(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResourceShareLink identityID.
         * @member {types.IIdentityKeyID|null|undefined} identityID
         * @memberof types.ResourceShareLink
         * @instance
         */
        ResourceShareLink.prototype.identityID = null;

        /**
         * Creates a new ResourceShareLink instance using the specified properties.
         * @function create
         * @memberof types.ResourceShareLink
         * @static
         * @param {types.IResourceShareLink=} [properties] Properties to set
         * @returns {types.ResourceShareLink} ResourceShareLink instance
         */
        ResourceShareLink.create = function create(properties) {
            return new ResourceShareLink(properties);
        };

        /**
         * Encodes the specified ResourceShareLink message. Does not implicitly {@link types.ResourceShareLink.verify|verify} messages.
         * @function encode
         * @memberof types.ResourceShareLink
         * @static
         * @param {types.IResourceShareLink} message ResourceShareLink message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourceShareLink.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.identityID != null && message.hasOwnProperty("identityID"))
                $root.types.IdentityKeyID.encode(message.identityID, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ResourceShareLink message, length delimited. Does not implicitly {@link types.ResourceShareLink.verify|verify} messages.
         * @function encodeDelimited
         * @memberof types.ResourceShareLink
         * @static
         * @param {types.IResourceShareLink} message ResourceShareLink message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourceShareLink.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResourceShareLink message from the specified reader or buffer.
         * @function decode
         * @memberof types.ResourceShareLink
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {types.ResourceShareLink} ResourceShareLink
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourceShareLink.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.types.ResourceShareLink();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.identityID = $root.types.IdentityKeyID.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ResourceShareLink message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof types.ResourceShareLink
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {types.ResourceShareLink} ResourceShareLink
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourceShareLink.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResourceShareLink message.
         * @function verify
         * @memberof types.ResourceShareLink
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResourceShareLink.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.identityID != null && message.hasOwnProperty("identityID")) {
                var error = $root.types.IdentityKeyID.verify(message.identityID);
                if (error)
                    return "identityID." + error;
            }
            return null;
        };

        /**
         * Creates a ResourceShareLink message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof types.ResourceShareLink
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {types.ResourceShareLink} ResourceShareLink
         */
        ResourceShareLink.fromObject = function fromObject(object) {
            if (object instanceof $root.types.ResourceShareLink)
                return object;
            var message = new $root.types.ResourceShareLink();
            if (object.identityID != null) {
                if (typeof object.identityID !== "object")
                    throw TypeError(".types.ResourceShareLink.identityID: object expected");
                message.identityID = $root.types.IdentityKeyID.fromObject(object.identityID);
            }
            return message;
        };

        /**
         * Creates a plain object from a ResourceShareLink message. Also converts values to other types if specified.
         * @function toObject
         * @memberof types.ResourceShareLink
         * @static
         * @param {types.ResourceShareLink} message ResourceShareLink
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResourceShareLink.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.identityID = null;
            if (message.identityID != null && message.hasOwnProperty("identityID"))
                object.identityID = $root.types.IdentityKeyID.toObject(message.identityID, options);
            return object;
        };

        /**
         * Converts this ResourceShareLink to JSON.
         * @function toJSON
         * @memberof types.ResourceShareLink
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResourceShareLink.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ResourceShareLink;
    })();

    types.Event = (function() {

        /**
         * Properties of an Event.
         * @memberof types
         * @interface IEvent
         * @property {google.protobuf.IAny|null} [payload] Event payload
         */

        /**
         * Constructs a new Event.
         * @memberof types
         * @classdesc Represents an Event.
         * @implements IEvent
         * @constructor
         * @param {types.IEvent=} [properties] Properties to set
         */
        function Event(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Event payload.
         * @member {google.protobuf.IAny|null|undefined} payload
         * @memberof types.Event
         * @instance
         */
        Event.prototype.payload = null;

        /**
         * Creates a new Event instance using the specified properties.
         * @function create
         * @memberof types.Event
         * @static
         * @param {types.IEvent=} [properties] Properties to set
         * @returns {types.Event} Event instance
         */
        Event.create = function create(properties) {
            return new Event(properties);
        };

        /**
         * Encodes the specified Event message. Does not implicitly {@link types.Event.verify|verify} messages.
         * @function encode
         * @memberof types.Event
         * @static
         * @param {types.IEvent} message Event message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Event.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.payload != null && message.hasOwnProperty("payload"))
                $root.google.protobuf.Any.encode(message.payload, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Event message, length delimited. Does not implicitly {@link types.Event.verify|verify} messages.
         * @function encodeDelimited
         * @memberof types.Event
         * @static
         * @param {types.IEvent} message Event message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Event.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Event message from the specified reader or buffer.
         * @function decode
         * @memberof types.Event
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {types.Event} Event
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Event.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.types.Event();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.payload = $root.google.protobuf.Any.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Event message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof types.Event
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {types.Event} Event
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Event.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Event message.
         * @function verify
         * @memberof types.Event
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Event.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.payload != null && message.hasOwnProperty("payload")) {
                var error = $root.google.protobuf.Any.verify(message.payload);
                if (error)
                    return "payload." + error;
            }
            return null;
        };

        /**
         * Creates an Event message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof types.Event
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {types.Event} Event
         */
        Event.fromObject = function fromObject(object) {
            if (object instanceof $root.types.Event)
                return object;
            var message = new $root.types.Event();
            if (object.payload != null) {
                if (typeof object.payload !== "object")
                    throw TypeError(".types.Event.payload: object expected");
                message.payload = $root.google.protobuf.Any.fromObject(object.payload);
            }
            return message;
        };

        /**
         * Creates a plain object from an Event message. Also converts values to other types if specified.
         * @function toObject
         * @memberof types.Event
         * @static
         * @param {types.Event} message Event
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Event.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.payload = null;
            if (message.payload != null && message.hasOwnProperty("payload"))
                object.payload = $root.google.protobuf.Any.toObject(message.payload, options);
            return object;
        };

        /**
         * Converts this Event to JSON.
         * @function toJSON
         * @memberof types.Event
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Event.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Event;
    })();

    types.EventChannelMessage = (function() {

        /**
         * Properties of an EventChannelMessage.
         * @memberof types
         * @interface IEventChannelMessage
         * @property {number|Long|null} [channelId] EventChannelMessage channelId
         * @property {Uint8Array|null} [content] EventChannelMessage content
         */

        /**
         * Constructs a new EventChannelMessage.
         * @memberof types
         * @classdesc Represents an EventChannelMessage.
         * @implements IEventChannelMessage
         * @constructor
         * @param {types.IEventChannelMessage=} [properties] Properties to set
         */
        function EventChannelMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EventChannelMessage channelId.
         * @member {number|Long} channelId
         * @memberof types.EventChannelMessage
         * @instance
         */
        EventChannelMessage.prototype.channelId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * EventChannelMessage content.
         * @member {Uint8Array} content
         * @memberof types.EventChannelMessage
         * @instance
         */
        EventChannelMessage.prototype.content = $util.newBuffer([]);

        /**
         * Creates a new EventChannelMessage instance using the specified properties.
         * @function create
         * @memberof types.EventChannelMessage
         * @static
         * @param {types.IEventChannelMessage=} [properties] Properties to set
         * @returns {types.EventChannelMessage} EventChannelMessage instance
         */
        EventChannelMessage.create = function create(properties) {
            return new EventChannelMessage(properties);
        };

        /**
         * Encodes the specified EventChannelMessage message. Does not implicitly {@link types.EventChannelMessage.verify|verify} messages.
         * @function encode
         * @memberof types.EventChannelMessage
         * @static
         * @param {types.IEventChannelMessage} message EventChannelMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EventChannelMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.channelId != null && message.hasOwnProperty("channelId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.channelId);
            if (message.content != null && message.hasOwnProperty("content"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.content);
            return writer;
        };

        /**
         * Encodes the specified EventChannelMessage message, length delimited. Does not implicitly {@link types.EventChannelMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof types.EventChannelMessage
         * @static
         * @param {types.IEventChannelMessage} message EventChannelMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EventChannelMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EventChannelMessage message from the specified reader or buffer.
         * @function decode
         * @memberof types.EventChannelMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {types.EventChannelMessage} EventChannelMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EventChannelMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.types.EventChannelMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.channelId = reader.uint64();
                    break;
                case 2:
                    message.content = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an EventChannelMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof types.EventChannelMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {types.EventChannelMessage} EventChannelMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EventChannelMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EventChannelMessage message.
         * @function verify
         * @memberof types.EventChannelMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EventChannelMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.channelId != null && message.hasOwnProperty("channelId"))
                if (!$util.isInteger(message.channelId) && !(message.channelId && $util.isInteger(message.channelId.low) && $util.isInteger(message.channelId.high)))
                    return "channelId: integer|Long expected";
            if (message.content != null && message.hasOwnProperty("content"))
                if (!(message.content && typeof message.content.length === "number" || $util.isString(message.content)))
                    return "content: buffer expected";
            return null;
        };

        /**
         * Creates an EventChannelMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof types.EventChannelMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {types.EventChannelMessage} EventChannelMessage
         */
        EventChannelMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.types.EventChannelMessage)
                return object;
            var message = new $root.types.EventChannelMessage();
            if (object.channelId != null)
                if ($util.Long)
                    (message.channelId = $util.Long.fromValue(object.channelId)).unsigned = true;
                else if (typeof object.channelId === "string")
                    message.channelId = parseInt(object.channelId, 10);
                else if (typeof object.channelId === "number")
                    message.channelId = object.channelId;
                else if (typeof object.channelId === "object")
                    message.channelId = new $util.LongBits(object.channelId.low >>> 0, object.channelId.high >>> 0).toNumber(true);
            if (object.content != null)
                if (typeof object.content === "string")
                    $util.base64.decode(object.content, message.content = $util.newBuffer($util.base64.length(object.content)), 0);
                else if (object.content.length)
                    message.content = object.content;
            return message;
        };

        /**
         * Creates a plain object from an EventChannelMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof types.EventChannelMessage
         * @static
         * @param {types.EventChannelMessage} message EventChannelMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EventChannelMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.channelId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.channelId = options.longs === String ? "0" : 0;
                object.content = options.bytes === String ? "" : [];
            }
            if (message.channelId != null && message.hasOwnProperty("channelId"))
                if (typeof message.channelId === "number")
                    object.channelId = options.longs === String ? String(message.channelId) : message.channelId;
                else
                    object.channelId = options.longs === String ? $util.Long.prototype.toString.call(message.channelId) : options.longs === Number ? new $util.LongBits(message.channelId.low >>> 0, message.channelId.high >>> 0).toNumber(true) : message.channelId;
            if (message.content != null && message.hasOwnProperty("content"))
                object.content = options.bytes === String ? $util.base64.encode(message.content, 0, message.content.length) : options.bytes === Array ? Array.prototype.slice.call(message.content) : message.content;
            return object;
        };

        /**
         * Converts this EventChannelMessage to JSON.
         * @function toJSON
         * @memberof types.EventChannelMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EventChannelMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EventChannelMessage;
    })();

    types.ChannelGetResponse = (function() {

        /**
         * Properties of a ChannelGetResponse.
         * @memberof types
         * @interface IChannelGetResponse
         * @property {number|Long|null} [id] ChannelGetResponse id
         * @property {types.IResourceGetResponse|null} [resource] ChannelGetResponse resource
         */

        /**
         * Constructs a new ChannelGetResponse.
         * @memberof types
         * @classdesc Represents a ChannelGetResponse.
         * @implements IChannelGetResponse
         * @constructor
         * @param {types.IChannelGetResponse=} [properties] Properties to set
         */
        function ChannelGetResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChannelGetResponse id.
         * @member {number|Long} id
         * @memberof types.ChannelGetResponse
         * @instance
         */
        ChannelGetResponse.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ChannelGetResponse resource.
         * @member {types.IResourceGetResponse|null|undefined} resource
         * @memberof types.ChannelGetResponse
         * @instance
         */
        ChannelGetResponse.prototype.resource = null;

        /**
         * Creates a new ChannelGetResponse instance using the specified properties.
         * @function create
         * @memberof types.ChannelGetResponse
         * @static
         * @param {types.IChannelGetResponse=} [properties] Properties to set
         * @returns {types.ChannelGetResponse} ChannelGetResponse instance
         */
        ChannelGetResponse.create = function create(properties) {
            return new ChannelGetResponse(properties);
        };

        /**
         * Encodes the specified ChannelGetResponse message. Does not implicitly {@link types.ChannelGetResponse.verify|verify} messages.
         * @function encode
         * @memberof types.ChannelGetResponse
         * @static
         * @param {types.IChannelGetResponse} message ChannelGetResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelGetResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
            if (message.resource != null && message.hasOwnProperty("resource"))
                $root.types.ResourceGetResponse.encode(message.resource, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ChannelGetResponse message, length delimited. Does not implicitly {@link types.ChannelGetResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof types.ChannelGetResponse
         * @static
         * @param {types.IChannelGetResponse} message ChannelGetResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelGetResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChannelGetResponse message from the specified reader or buffer.
         * @function decode
         * @memberof types.ChannelGetResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {types.ChannelGetResponse} ChannelGetResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelGetResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.types.ChannelGetResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.uint64();
                    break;
                case 2:
                    message.resource = $root.types.ResourceGetResponse.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChannelGetResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof types.ChannelGetResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {types.ChannelGetResponse} ChannelGetResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelGetResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChannelGetResponse message.
         * @function verify
         * @memberof types.ChannelGetResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChannelGetResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                    return "id: integer|Long expected";
            if (message.resource != null && message.hasOwnProperty("resource")) {
                var error = $root.types.ResourceGetResponse.verify(message.resource);
                if (error)
                    return "resource." + error;
            }
            return null;
        };

        /**
         * Creates a ChannelGetResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof types.ChannelGetResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {types.ChannelGetResponse} ChannelGetResponse
         */
        ChannelGetResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.types.ChannelGetResponse)
                return object;
            var message = new $root.types.ChannelGetResponse();
            if (object.id != null)
                if ($util.Long)
                    (message.id = $util.Long.fromValue(object.id)).unsigned = true;
                else if (typeof object.id === "string")
                    message.id = parseInt(object.id, 10);
                else if (typeof object.id === "number")
                    message.id = object.id;
                else if (typeof object.id === "object")
                    message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
            if (object.resource != null) {
                if (typeof object.resource !== "object")
                    throw TypeError(".types.ChannelGetResponse.resource: object expected");
                message.resource = $root.types.ResourceGetResponse.fromObject(object.resource);
            }
            return message;
        };

        /**
         * Creates a plain object from a ChannelGetResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof types.ChannelGetResponse
         * @static
         * @param {types.ChannelGetResponse} message ChannelGetResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChannelGetResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.id = options.longs === String ? "0" : 0;
                object.resource = null;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                if (typeof message.id === "number")
                    object.id = options.longs === String ? String(message.id) : message.id;
                else
                    object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
            if (message.resource != null && message.hasOwnProperty("resource"))
                object.resource = $root.types.ResourceGetResponse.toObject(message.resource, options);
            return object;
        };

        /**
         * Converts this ChannelGetResponse to JSON.
         * @function toJSON
         * @memberof types.ChannelGetResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChannelGetResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChannelGetResponse;
    })();

    types.ChannelPostRequest = (function() {

        /**
         * Properties of a ChannelPostRequest.
         * @memberof types
         * @interface IChannelPostRequest
         * @property {Uint8Array|null} [publicKey] ChannelPostRequest publicKey
         * @property {Uint8Array|null} [nonce] ChannelPostRequest nonce
         * @property {Uint8Array|null} [payload] ChannelPostRequest payload
         * @property {Array.<types.IResourceShareEntry>|null} [sharingGroup] ChannelPostRequest sharingGroup
         * @property {types.ResourceType|null} [type] ChannelPostRequest type
         */

        /**
         * Constructs a new ChannelPostRequest.
         * @memberof types
         * @classdesc Represents a ChannelPostRequest.
         * @implements IChannelPostRequest
         * @constructor
         * @param {types.IChannelPostRequest=} [properties] Properties to set
         */
        function ChannelPostRequest(properties) {
            this.sharingGroup = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChannelPostRequest publicKey.
         * @member {Uint8Array} publicKey
         * @memberof types.ChannelPostRequest
         * @instance
         */
        ChannelPostRequest.prototype.publicKey = $util.newBuffer([]);

        /**
         * ChannelPostRequest nonce.
         * @member {Uint8Array} nonce
         * @memberof types.ChannelPostRequest
         * @instance
         */
        ChannelPostRequest.prototype.nonce = $util.newBuffer([]);

        /**
         * ChannelPostRequest payload.
         * @member {Uint8Array} payload
         * @memberof types.ChannelPostRequest
         * @instance
         */
        ChannelPostRequest.prototype.payload = $util.newBuffer([]);

        /**
         * ChannelPostRequest sharingGroup.
         * @member {Array.<types.IResourceShareEntry>} sharingGroup
         * @memberof types.ChannelPostRequest
         * @instance
         */
        ChannelPostRequest.prototype.sharingGroup = $util.emptyArray;

        /**
         * ChannelPostRequest type.
         * @member {types.ResourceType} type
         * @memberof types.ChannelPostRequest
         * @instance
         */
        ChannelPostRequest.prototype.type = 0;

        /**
         * Creates a new ChannelPostRequest instance using the specified properties.
         * @function create
         * @memberof types.ChannelPostRequest
         * @static
         * @param {types.IChannelPostRequest=} [properties] Properties to set
         * @returns {types.ChannelPostRequest} ChannelPostRequest instance
         */
        ChannelPostRequest.create = function create(properties) {
            return new ChannelPostRequest(properties);
        };

        /**
         * Encodes the specified ChannelPostRequest message. Does not implicitly {@link types.ChannelPostRequest.verify|verify} messages.
         * @function encode
         * @memberof types.ChannelPostRequest
         * @static
         * @param {types.IChannelPostRequest} message ChannelPostRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelPostRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.publicKey);
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.nonce);
            if (message.payload != null && message.hasOwnProperty("payload"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.payload);
            if (message.sharingGroup != null && message.sharingGroup.length)
                for (var i = 0; i < message.sharingGroup.length; ++i)
                    $root.types.ResourceShareEntry.encode(message.sharingGroup[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.type);
            return writer;
        };

        /**
         * Encodes the specified ChannelPostRequest message, length delimited. Does not implicitly {@link types.ChannelPostRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof types.ChannelPostRequest
         * @static
         * @param {types.IChannelPostRequest} message ChannelPostRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelPostRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChannelPostRequest message from the specified reader or buffer.
         * @function decode
         * @memberof types.ChannelPostRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {types.ChannelPostRequest} ChannelPostRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelPostRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.types.ChannelPostRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.publicKey = reader.bytes();
                    break;
                case 2:
                    message.nonce = reader.bytes();
                    break;
                case 3:
                    message.payload = reader.bytes();
                    break;
                case 4:
                    if (!(message.sharingGroup && message.sharingGroup.length))
                        message.sharingGroup = [];
                    message.sharingGroup.push($root.types.ResourceShareEntry.decode(reader, reader.uint32()));
                    break;
                case 5:
                    message.type = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChannelPostRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof types.ChannelPostRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {types.ChannelPostRequest} ChannelPostRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelPostRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChannelPostRequest message.
         * @function verify
         * @memberof types.ChannelPostRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChannelPostRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                if (!(message.publicKey && typeof message.publicKey.length === "number" || $util.isString(message.publicKey)))
                    return "publicKey: buffer expected";
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                if (!(message.nonce && typeof message.nonce.length === "number" || $util.isString(message.nonce)))
                    return "nonce: buffer expected";
            if (message.payload != null && message.hasOwnProperty("payload"))
                if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                    return "payload: buffer expected";
            if (message.sharingGroup != null && message.hasOwnProperty("sharingGroup")) {
                if (!Array.isArray(message.sharingGroup))
                    return "sharingGroup: array expected";
                for (var i = 0; i < message.sharingGroup.length; ++i) {
                    var error = $root.types.ResourceShareEntry.verify(message.sharingGroup[i]);
                    if (error)
                        return "sharingGroup." + error;
                }
            }
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                    break;
                }
            return null;
        };

        /**
         * Creates a ChannelPostRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof types.ChannelPostRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {types.ChannelPostRequest} ChannelPostRequest
         */
        ChannelPostRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.types.ChannelPostRequest)
                return object;
            var message = new $root.types.ChannelPostRequest();
            if (object.publicKey != null)
                if (typeof object.publicKey === "string")
                    $util.base64.decode(object.publicKey, message.publicKey = $util.newBuffer($util.base64.length(object.publicKey)), 0);
                else if (object.publicKey.length)
                    message.publicKey = object.publicKey;
            if (object.nonce != null)
                if (typeof object.nonce === "string")
                    $util.base64.decode(object.nonce, message.nonce = $util.newBuffer($util.base64.length(object.nonce)), 0);
                else if (object.nonce.length)
                    message.nonce = object.nonce;
            if (object.payload != null)
                if (typeof object.payload === "string")
                    $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                else if (object.payload.length)
                    message.payload = object.payload;
            if (object.sharingGroup) {
                if (!Array.isArray(object.sharingGroup))
                    throw TypeError(".types.ChannelPostRequest.sharingGroup: array expected");
                message.sharingGroup = [];
                for (var i = 0; i < object.sharingGroup.length; ++i) {
                    if (typeof object.sharingGroup[i] !== "object")
                        throw TypeError(".types.ChannelPostRequest.sharingGroup: object expected");
                    message.sharingGroup[i] = $root.types.ResourceShareEntry.fromObject(object.sharingGroup[i]);
                }
            }
            switch (object.type) {
            case "ANONYMOUS":
            case 0:
                message.type = 0;
                break;
            case "SES":
            case 1:
                message.type = 1;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a ChannelPostRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof types.ChannelPostRequest
         * @static
         * @param {types.ChannelPostRequest} message ChannelPostRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChannelPostRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.sharingGroup = [];
            if (options.defaults) {
                object.publicKey = options.bytes === String ? "" : [];
                object.nonce = options.bytes === String ? "" : [];
                object.payload = options.bytes === String ? "" : [];
                object.type = options.enums === String ? "ANONYMOUS" : 0;
            }
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                object.publicKey = options.bytes === String ? $util.base64.encode(message.publicKey, 0, message.publicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.publicKey) : message.publicKey;
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                object.nonce = options.bytes === String ? $util.base64.encode(message.nonce, 0, message.nonce.length) : options.bytes === Array ? Array.prototype.slice.call(message.nonce) : message.nonce;
            if (message.payload != null && message.hasOwnProperty("payload"))
                object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
            if (message.sharingGroup && message.sharingGroup.length) {
                object.sharingGroup = [];
                for (var j = 0; j < message.sharingGroup.length; ++j)
                    object.sharingGroup[j] = $root.types.ResourceShareEntry.toObject(message.sharingGroup[j], options);
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.types.ResourceType[message.type] : message.type;
            return object;
        };

        /**
         * Converts this ChannelPostRequest to JSON.
         * @function toJSON
         * @memberof types.ChannelPostRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChannelPostRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChannelPostRequest;
    })();

    types.ChannelPostResponse = (function() {

        /**
         * Properties of a ChannelPostResponse.
         * @memberof types
         * @interface IChannelPostResponse
         * @property {number|Long|null} [id] ChannelPostResponse id
         */

        /**
         * Constructs a new ChannelPostResponse.
         * @memberof types
         * @classdesc Represents a ChannelPostResponse.
         * @implements IChannelPostResponse
         * @constructor
         * @param {types.IChannelPostResponse=} [properties] Properties to set
         */
        function ChannelPostResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChannelPostResponse id.
         * @member {number|Long} id
         * @memberof types.ChannelPostResponse
         * @instance
         */
        ChannelPostResponse.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new ChannelPostResponse instance using the specified properties.
         * @function create
         * @memberof types.ChannelPostResponse
         * @static
         * @param {types.IChannelPostResponse=} [properties] Properties to set
         * @returns {types.ChannelPostResponse} ChannelPostResponse instance
         */
        ChannelPostResponse.create = function create(properties) {
            return new ChannelPostResponse(properties);
        };

        /**
         * Encodes the specified ChannelPostResponse message. Does not implicitly {@link types.ChannelPostResponse.verify|verify} messages.
         * @function encode
         * @memberof types.ChannelPostResponse
         * @static
         * @param {types.IChannelPostResponse} message ChannelPostResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelPostResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
            return writer;
        };

        /**
         * Encodes the specified ChannelPostResponse message, length delimited. Does not implicitly {@link types.ChannelPostResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof types.ChannelPostResponse
         * @static
         * @param {types.IChannelPostResponse} message ChannelPostResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelPostResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChannelPostResponse message from the specified reader or buffer.
         * @function decode
         * @memberof types.ChannelPostResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {types.ChannelPostResponse} ChannelPostResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelPostResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.types.ChannelPostResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChannelPostResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof types.ChannelPostResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {types.ChannelPostResponse} ChannelPostResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelPostResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChannelPostResponse message.
         * @function verify
         * @memberof types.ChannelPostResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChannelPostResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                    return "id: integer|Long expected";
            return null;
        };

        /**
         * Creates a ChannelPostResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof types.ChannelPostResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {types.ChannelPostResponse} ChannelPostResponse
         */
        ChannelPostResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.types.ChannelPostResponse)
                return object;
            var message = new $root.types.ChannelPostResponse();
            if (object.id != null)
                if ($util.Long)
                    (message.id = $util.Long.fromValue(object.id)).unsigned = true;
                else if (typeof object.id === "string")
                    message.id = parseInt(object.id, 10);
                else if (typeof object.id === "number")
                    message.id = object.id;
                else if (typeof object.id === "object")
                    message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a ChannelPostResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof types.ChannelPostResponse
         * @static
         * @param {types.ChannelPostResponse} message ChannelPostResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChannelPostResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.id = options.longs === String ? "0" : 0;
            if (message.id != null && message.hasOwnProperty("id"))
                if (typeof message.id === "number")
                    object.id = options.longs === String ? String(message.id) : message.id;
                else
                    object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
            return object;
        };

        /**
         * Converts this ChannelPostResponse to JSON.
         * @function toJSON
         * @memberof types.ChannelPostResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChannelPostResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChannelPostResponse;
    })();

    types.ChannelPostMessageRequest = (function() {

        /**
         * Properties of a ChannelPostMessageRequest.
         * @memberof types
         * @interface IChannelPostMessageRequest
         * @property {number|Long|null} [channelId] ChannelPostMessageRequest channelId
         * @property {Uint8Array|null} [content] ChannelPostMessageRequest content
         */

        /**
         * Constructs a new ChannelPostMessageRequest.
         * @memberof types
         * @classdesc Represents a ChannelPostMessageRequest.
         * @implements IChannelPostMessageRequest
         * @constructor
         * @param {types.IChannelPostMessageRequest=} [properties] Properties to set
         */
        function ChannelPostMessageRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChannelPostMessageRequest channelId.
         * @member {number|Long} channelId
         * @memberof types.ChannelPostMessageRequest
         * @instance
         */
        ChannelPostMessageRequest.prototype.channelId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ChannelPostMessageRequest content.
         * @member {Uint8Array} content
         * @memberof types.ChannelPostMessageRequest
         * @instance
         */
        ChannelPostMessageRequest.prototype.content = $util.newBuffer([]);

        /**
         * Creates a new ChannelPostMessageRequest instance using the specified properties.
         * @function create
         * @memberof types.ChannelPostMessageRequest
         * @static
         * @param {types.IChannelPostMessageRequest=} [properties] Properties to set
         * @returns {types.ChannelPostMessageRequest} ChannelPostMessageRequest instance
         */
        ChannelPostMessageRequest.create = function create(properties) {
            return new ChannelPostMessageRequest(properties);
        };

        /**
         * Encodes the specified ChannelPostMessageRequest message. Does not implicitly {@link types.ChannelPostMessageRequest.verify|verify} messages.
         * @function encode
         * @memberof types.ChannelPostMessageRequest
         * @static
         * @param {types.IChannelPostMessageRequest} message ChannelPostMessageRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelPostMessageRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.channelId != null && message.hasOwnProperty("channelId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.channelId);
            if (message.content != null && message.hasOwnProperty("content"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.content);
            return writer;
        };

        /**
         * Encodes the specified ChannelPostMessageRequest message, length delimited. Does not implicitly {@link types.ChannelPostMessageRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof types.ChannelPostMessageRequest
         * @static
         * @param {types.IChannelPostMessageRequest} message ChannelPostMessageRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelPostMessageRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChannelPostMessageRequest message from the specified reader or buffer.
         * @function decode
         * @memberof types.ChannelPostMessageRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {types.ChannelPostMessageRequest} ChannelPostMessageRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelPostMessageRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.types.ChannelPostMessageRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.channelId = reader.uint64();
                    break;
                case 2:
                    message.content = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChannelPostMessageRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof types.ChannelPostMessageRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {types.ChannelPostMessageRequest} ChannelPostMessageRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelPostMessageRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChannelPostMessageRequest message.
         * @function verify
         * @memberof types.ChannelPostMessageRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChannelPostMessageRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.channelId != null && message.hasOwnProperty("channelId"))
                if (!$util.isInteger(message.channelId) && !(message.channelId && $util.isInteger(message.channelId.low) && $util.isInteger(message.channelId.high)))
                    return "channelId: integer|Long expected";
            if (message.content != null && message.hasOwnProperty("content"))
                if (!(message.content && typeof message.content.length === "number" || $util.isString(message.content)))
                    return "content: buffer expected";
            return null;
        };

        /**
         * Creates a ChannelPostMessageRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof types.ChannelPostMessageRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {types.ChannelPostMessageRequest} ChannelPostMessageRequest
         */
        ChannelPostMessageRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.types.ChannelPostMessageRequest)
                return object;
            var message = new $root.types.ChannelPostMessageRequest();
            if (object.channelId != null)
                if ($util.Long)
                    (message.channelId = $util.Long.fromValue(object.channelId)).unsigned = true;
                else if (typeof object.channelId === "string")
                    message.channelId = parseInt(object.channelId, 10);
                else if (typeof object.channelId === "number")
                    message.channelId = object.channelId;
                else if (typeof object.channelId === "object")
                    message.channelId = new $util.LongBits(object.channelId.low >>> 0, object.channelId.high >>> 0).toNumber(true);
            if (object.content != null)
                if (typeof object.content === "string")
                    $util.base64.decode(object.content, message.content = $util.newBuffer($util.base64.length(object.content)), 0);
                else if (object.content.length)
                    message.content = object.content;
            return message;
        };

        /**
         * Creates a plain object from a ChannelPostMessageRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof types.ChannelPostMessageRequest
         * @static
         * @param {types.ChannelPostMessageRequest} message ChannelPostMessageRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChannelPostMessageRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.channelId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.channelId = options.longs === String ? "0" : 0;
                object.content = options.bytes === String ? "" : [];
            }
            if (message.channelId != null && message.hasOwnProperty("channelId"))
                if (typeof message.channelId === "number")
                    object.channelId = options.longs === String ? String(message.channelId) : message.channelId;
                else
                    object.channelId = options.longs === String ? $util.Long.prototype.toString.call(message.channelId) : options.longs === Number ? new $util.LongBits(message.channelId.low >>> 0, message.channelId.high >>> 0).toNumber(true) : message.channelId;
            if (message.content != null && message.hasOwnProperty("content"))
                object.content = options.bytes === String ? $util.base64.encode(message.content, 0, message.content.length) : options.bytes === Array ? Array.prototype.slice.call(message.content) : message.content;
            return object;
        };

        /**
         * Converts this ChannelPostMessageRequest to JSON.
         * @function toJSON
         * @memberof types.ChannelPostMessageRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChannelPostMessageRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChannelPostMessageRequest;
    })();

    types.DelegatedPostRequest = (function() {

        /**
         * Properties of a DelegatedPostRequest.
         * @memberof types
         * @interface IDelegatedPostRequest
         * @property {Uint8Array|null} [publicKey] DelegatedPostRequest publicKey
         * @property {Uint8Array|null} [sign] DelegatedPostRequest sign
         * @property {string|null} [requester] DelegatedPostRequest requester
         * @property {types.IResourceShareEntry|null} [sharing] DelegatedPostRequest sharing
         */

        /**
         * Constructs a new DelegatedPostRequest.
         * @memberof types
         * @classdesc Represents a DelegatedPostRequest.
         * @implements IDelegatedPostRequest
         * @constructor
         * @param {types.IDelegatedPostRequest=} [properties] Properties to set
         */
        function DelegatedPostRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DelegatedPostRequest publicKey.
         * @member {Uint8Array} publicKey
         * @memberof types.DelegatedPostRequest
         * @instance
         */
        DelegatedPostRequest.prototype.publicKey = $util.newBuffer([]);

        /**
         * DelegatedPostRequest sign.
         * @member {Uint8Array} sign
         * @memberof types.DelegatedPostRequest
         * @instance
         */
        DelegatedPostRequest.prototype.sign = $util.newBuffer([]);

        /**
         * DelegatedPostRequest requester.
         * @member {string} requester
         * @memberof types.DelegatedPostRequest
         * @instance
         */
        DelegatedPostRequest.prototype.requester = "";

        /**
         * DelegatedPostRequest sharing.
         * @member {types.IResourceShareEntry|null|undefined} sharing
         * @memberof types.DelegatedPostRequest
         * @instance
         */
        DelegatedPostRequest.prototype.sharing = null;

        /**
         * Creates a new DelegatedPostRequest instance using the specified properties.
         * @function create
         * @memberof types.DelegatedPostRequest
         * @static
         * @param {types.IDelegatedPostRequest=} [properties] Properties to set
         * @returns {types.DelegatedPostRequest} DelegatedPostRequest instance
         */
        DelegatedPostRequest.create = function create(properties) {
            return new DelegatedPostRequest(properties);
        };

        /**
         * Encodes the specified DelegatedPostRequest message. Does not implicitly {@link types.DelegatedPostRequest.verify|verify} messages.
         * @function encode
         * @memberof types.DelegatedPostRequest
         * @static
         * @param {types.IDelegatedPostRequest} message DelegatedPostRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DelegatedPostRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.publicKey);
            if (message.sign != null && message.hasOwnProperty("sign"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.sign);
            if (message.requester != null && message.hasOwnProperty("requester"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.requester);
            if (message.sharing != null && message.hasOwnProperty("sharing"))
                $root.types.ResourceShareEntry.encode(message.sharing, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified DelegatedPostRequest message, length delimited. Does not implicitly {@link types.DelegatedPostRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof types.DelegatedPostRequest
         * @static
         * @param {types.IDelegatedPostRequest} message DelegatedPostRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DelegatedPostRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DelegatedPostRequest message from the specified reader or buffer.
         * @function decode
         * @memberof types.DelegatedPostRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {types.DelegatedPostRequest} DelegatedPostRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DelegatedPostRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.types.DelegatedPostRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.publicKey = reader.bytes();
                    break;
                case 2:
                    message.sign = reader.bytes();
                    break;
                case 3:
                    message.requester = reader.string();
                    break;
                case 4:
                    message.sharing = $root.types.ResourceShareEntry.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DelegatedPostRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof types.DelegatedPostRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {types.DelegatedPostRequest} DelegatedPostRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DelegatedPostRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DelegatedPostRequest message.
         * @function verify
         * @memberof types.DelegatedPostRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DelegatedPostRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                if (!(message.publicKey && typeof message.publicKey.length === "number" || $util.isString(message.publicKey)))
                    return "publicKey: buffer expected";
            if (message.sign != null && message.hasOwnProperty("sign"))
                if (!(message.sign && typeof message.sign.length === "number" || $util.isString(message.sign)))
                    return "sign: buffer expected";
            if (message.requester != null && message.hasOwnProperty("requester"))
                if (!$util.isString(message.requester))
                    return "requester: string expected";
            if (message.sharing != null && message.hasOwnProperty("sharing")) {
                var error = $root.types.ResourceShareEntry.verify(message.sharing);
                if (error)
                    return "sharing." + error;
            }
            return null;
        };

        /**
         * Creates a DelegatedPostRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof types.DelegatedPostRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {types.DelegatedPostRequest} DelegatedPostRequest
         */
        DelegatedPostRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.types.DelegatedPostRequest)
                return object;
            var message = new $root.types.DelegatedPostRequest();
            if (object.publicKey != null)
                if (typeof object.publicKey === "string")
                    $util.base64.decode(object.publicKey, message.publicKey = $util.newBuffer($util.base64.length(object.publicKey)), 0);
                else if (object.publicKey.length)
                    message.publicKey = object.publicKey;
            if (object.sign != null)
                if (typeof object.sign === "string")
                    $util.base64.decode(object.sign, message.sign = $util.newBuffer($util.base64.length(object.sign)), 0);
                else if (object.sign.length)
                    message.sign = object.sign;
            if (object.requester != null)
                message.requester = String(object.requester);
            if (object.sharing != null) {
                if (typeof object.sharing !== "object")
                    throw TypeError(".types.DelegatedPostRequest.sharing: object expected");
                message.sharing = $root.types.ResourceShareEntry.fromObject(object.sharing);
            }
            return message;
        };

        /**
         * Creates a plain object from a DelegatedPostRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof types.DelegatedPostRequest
         * @static
         * @param {types.DelegatedPostRequest} message DelegatedPostRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DelegatedPostRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.publicKey = options.bytes === String ? "" : [];
                object.sign = options.bytes === String ? "" : [];
                object.requester = "";
                object.sharing = null;
            }
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                object.publicKey = options.bytes === String ? $util.base64.encode(message.publicKey, 0, message.publicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.publicKey) : message.publicKey;
            if (message.sign != null && message.hasOwnProperty("sign"))
                object.sign = options.bytes === String ? $util.base64.encode(message.sign, 0, message.sign.length) : options.bytes === Array ? Array.prototype.slice.call(message.sign) : message.sign;
            if (message.requester != null && message.hasOwnProperty("requester"))
                object.requester = message.requester;
            if (message.sharing != null && message.hasOwnProperty("sharing"))
                object.sharing = $root.types.ResourceShareEntry.toObject(message.sharing, options);
            return object;
        };

        /**
         * Converts this DelegatedPostRequest to JSON.
         * @function toJSON
         * @memberof types.DelegatedPostRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DelegatedPostRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DelegatedPostRequest;
    })();

    types.DelegatedPostResponse = (function() {

        /**
         * Properties of a DelegatedPostResponse.
         * @memberof types
         * @interface IDelegatedPostResponse
         * @property {number|Long|null} [id] DelegatedPostResponse id
         */

        /**
         * Constructs a new DelegatedPostResponse.
         * @memberof types
         * @classdesc Represents a DelegatedPostResponse.
         * @implements IDelegatedPostResponse
         * @constructor
         * @param {types.IDelegatedPostResponse=} [properties] Properties to set
         */
        function DelegatedPostResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DelegatedPostResponse id.
         * @member {number|Long} id
         * @memberof types.DelegatedPostResponse
         * @instance
         */
        DelegatedPostResponse.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new DelegatedPostResponse instance using the specified properties.
         * @function create
         * @memberof types.DelegatedPostResponse
         * @static
         * @param {types.IDelegatedPostResponse=} [properties] Properties to set
         * @returns {types.DelegatedPostResponse} DelegatedPostResponse instance
         */
        DelegatedPostResponse.create = function create(properties) {
            return new DelegatedPostResponse(properties);
        };

        /**
         * Encodes the specified DelegatedPostResponse message. Does not implicitly {@link types.DelegatedPostResponse.verify|verify} messages.
         * @function encode
         * @memberof types.DelegatedPostResponse
         * @static
         * @param {types.IDelegatedPostResponse} message DelegatedPostResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DelegatedPostResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
            return writer;
        };

        /**
         * Encodes the specified DelegatedPostResponse message, length delimited. Does not implicitly {@link types.DelegatedPostResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof types.DelegatedPostResponse
         * @static
         * @param {types.IDelegatedPostResponse} message DelegatedPostResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DelegatedPostResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DelegatedPostResponse message from the specified reader or buffer.
         * @function decode
         * @memberof types.DelegatedPostResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {types.DelegatedPostResponse} DelegatedPostResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DelegatedPostResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.types.DelegatedPostResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DelegatedPostResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof types.DelegatedPostResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {types.DelegatedPostResponse} DelegatedPostResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DelegatedPostResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DelegatedPostResponse message.
         * @function verify
         * @memberof types.DelegatedPostResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DelegatedPostResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                    return "id: integer|Long expected";
            return null;
        };

        /**
         * Creates a DelegatedPostResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof types.DelegatedPostResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {types.DelegatedPostResponse} DelegatedPostResponse
         */
        DelegatedPostResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.types.DelegatedPostResponse)
                return object;
            var message = new $root.types.DelegatedPostResponse();
            if (object.id != null)
                if ($util.Long)
                    (message.id = $util.Long.fromValue(object.id)).unsigned = true;
                else if (typeof object.id === "string")
                    message.id = parseInt(object.id, 10);
                else if (typeof object.id === "number")
                    message.id = object.id;
                else if (typeof object.id === "object")
                    message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a DelegatedPostResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof types.DelegatedPostResponse
         * @static
         * @param {types.DelegatedPostResponse} message DelegatedPostResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DelegatedPostResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.id = options.longs === String ? "0" : 0;
            if (message.id != null && message.hasOwnProperty("id"))
                if (typeof message.id === "number")
                    object.id = options.longs === String ? String(message.id) : message.id;
                else
                    object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
            return object;
        };

        /**
         * Converts this DelegatedPostResponse to JSON.
         * @function toJSON
         * @memberof types.DelegatedPostResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DelegatedPostResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DelegatedPostResponse;
    })();

    types.DelegatedGetResponse = (function() {

        /**
         * Properties of a DelegatedGetResponse.
         * @memberof types
         * @interface IDelegatedGetResponse
         * @property {types.IResourceGetResponse|null} [resource] DelegatedGetResponse resource
         * @property {Uint8Array|null} [sign] DelegatedGetResponse sign
         */

        /**
         * Constructs a new DelegatedGetResponse.
         * @memberof types
         * @classdesc Represents a DelegatedGetResponse.
         * @implements IDelegatedGetResponse
         * @constructor
         * @param {types.IDelegatedGetResponse=} [properties] Properties to set
         */
        function DelegatedGetResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DelegatedGetResponse resource.
         * @member {types.IResourceGetResponse|null|undefined} resource
         * @memberof types.DelegatedGetResponse
         * @instance
         */
        DelegatedGetResponse.prototype.resource = null;

        /**
         * DelegatedGetResponse sign.
         * @member {Uint8Array} sign
         * @memberof types.DelegatedGetResponse
         * @instance
         */
        DelegatedGetResponse.prototype.sign = $util.newBuffer([]);

        /**
         * Creates a new DelegatedGetResponse instance using the specified properties.
         * @function create
         * @memberof types.DelegatedGetResponse
         * @static
         * @param {types.IDelegatedGetResponse=} [properties] Properties to set
         * @returns {types.DelegatedGetResponse} DelegatedGetResponse instance
         */
        DelegatedGetResponse.create = function create(properties) {
            return new DelegatedGetResponse(properties);
        };

        /**
         * Encodes the specified DelegatedGetResponse message. Does not implicitly {@link types.DelegatedGetResponse.verify|verify} messages.
         * @function encode
         * @memberof types.DelegatedGetResponse
         * @static
         * @param {types.IDelegatedGetResponse} message DelegatedGetResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DelegatedGetResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.resource != null && message.hasOwnProperty("resource"))
                $root.types.ResourceGetResponse.encode(message.resource, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.sign != null && message.hasOwnProperty("sign"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.sign);
            return writer;
        };

        /**
         * Encodes the specified DelegatedGetResponse message, length delimited. Does not implicitly {@link types.DelegatedGetResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof types.DelegatedGetResponse
         * @static
         * @param {types.IDelegatedGetResponse} message DelegatedGetResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DelegatedGetResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DelegatedGetResponse message from the specified reader or buffer.
         * @function decode
         * @memberof types.DelegatedGetResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {types.DelegatedGetResponse} DelegatedGetResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DelegatedGetResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.types.DelegatedGetResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.resource = $root.types.ResourceGetResponse.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.sign = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DelegatedGetResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof types.DelegatedGetResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {types.DelegatedGetResponse} DelegatedGetResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DelegatedGetResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DelegatedGetResponse message.
         * @function verify
         * @memberof types.DelegatedGetResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DelegatedGetResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.resource != null && message.hasOwnProperty("resource")) {
                var error = $root.types.ResourceGetResponse.verify(message.resource);
                if (error)
                    return "resource." + error;
            }
            if (message.sign != null && message.hasOwnProperty("sign"))
                if (!(message.sign && typeof message.sign.length === "number" || $util.isString(message.sign)))
                    return "sign: buffer expected";
            return null;
        };

        /**
         * Creates a DelegatedGetResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof types.DelegatedGetResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {types.DelegatedGetResponse} DelegatedGetResponse
         */
        DelegatedGetResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.types.DelegatedGetResponse)
                return object;
            var message = new $root.types.DelegatedGetResponse();
            if (object.resource != null) {
                if (typeof object.resource !== "object")
                    throw TypeError(".types.DelegatedGetResponse.resource: object expected");
                message.resource = $root.types.ResourceGetResponse.fromObject(object.resource);
            }
            if (object.sign != null)
                if (typeof object.sign === "string")
                    $util.base64.decode(object.sign, message.sign = $util.newBuffer($util.base64.length(object.sign)), 0);
                else if (object.sign.length)
                    message.sign = object.sign;
            return message;
        };

        /**
         * Creates a plain object from a DelegatedGetResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof types.DelegatedGetResponse
         * @static
         * @param {types.DelegatedGetResponse} message DelegatedGetResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DelegatedGetResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.resource = null;
                object.sign = options.bytes === String ? "" : [];
            }
            if (message.resource != null && message.hasOwnProperty("resource"))
                object.resource = $root.types.ResourceGetResponse.toObject(message.resource, options);
            if (message.sign != null && message.hasOwnProperty("sign"))
                object.sign = options.bytes === String ? $util.base64.encode(message.sign, 0, message.sign.length) : options.bytes === Array ? Array.prototype.slice.call(message.sign) : message.sign;
            return object;
        };

        /**
         * Converts this DelegatedGetResponse to JSON.
         * @function toJSON
         * @memberof types.DelegatedGetResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DelegatedGetResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DelegatedGetResponse;
    })();

    types.DelegatedKeys = (function() {

        /**
         * Properties of a DelegatedKeys.
         * @memberof types
         * @interface IDelegatedKeys
         * @property {string|null} [login] DelegatedKeys login
         * @property {number|null} [version] DelegatedKeys version
         * @property {Uint8Array|null} [signKey] DelegatedKeys signKey
         * @property {Uint8Array|null} [readKey] DelegatedKeys readKey
         * @property {Uint8Array|null} [sharingKey] DelegatedKeys sharingKey
         * @property {Uint8Array|null} [boxKey] DelegatedKeys boxKey
         */

        /**
         * Constructs a new DelegatedKeys.
         * @memberof types
         * @classdesc Represents a DelegatedKeys.
         * @implements IDelegatedKeys
         * @constructor
         * @param {types.IDelegatedKeys=} [properties] Properties to set
         */
        function DelegatedKeys(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DelegatedKeys login.
         * @member {string} login
         * @memberof types.DelegatedKeys
         * @instance
         */
        DelegatedKeys.prototype.login = "";

        /**
         * DelegatedKeys version.
         * @member {number} version
         * @memberof types.DelegatedKeys
         * @instance
         */
        DelegatedKeys.prototype.version = 0;

        /**
         * DelegatedKeys signKey.
         * @member {Uint8Array} signKey
         * @memberof types.DelegatedKeys
         * @instance
         */
        DelegatedKeys.prototype.signKey = $util.newBuffer([]);

        /**
         * DelegatedKeys readKey.
         * @member {Uint8Array} readKey
         * @memberof types.DelegatedKeys
         * @instance
         */
        DelegatedKeys.prototype.readKey = $util.newBuffer([]);

        /**
         * DelegatedKeys sharingKey.
         * @member {Uint8Array} sharingKey
         * @memberof types.DelegatedKeys
         * @instance
         */
        DelegatedKeys.prototype.sharingKey = $util.newBuffer([]);

        /**
         * DelegatedKeys boxKey.
         * @member {Uint8Array} boxKey
         * @memberof types.DelegatedKeys
         * @instance
         */
        DelegatedKeys.prototype.boxKey = $util.newBuffer([]);

        /**
         * Creates a new DelegatedKeys instance using the specified properties.
         * @function create
         * @memberof types.DelegatedKeys
         * @static
         * @param {types.IDelegatedKeys=} [properties] Properties to set
         * @returns {types.DelegatedKeys} DelegatedKeys instance
         */
        DelegatedKeys.create = function create(properties) {
            return new DelegatedKeys(properties);
        };

        /**
         * Encodes the specified DelegatedKeys message. Does not implicitly {@link types.DelegatedKeys.verify|verify} messages.
         * @function encode
         * @memberof types.DelegatedKeys
         * @static
         * @param {types.IDelegatedKeys} message DelegatedKeys message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DelegatedKeys.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            if (message.version != null && message.hasOwnProperty("version"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.version);
            if (message.signKey != null && message.hasOwnProperty("signKey"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.signKey);
            if (message.readKey != null && message.hasOwnProperty("readKey"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.readKey);
            if (message.sharingKey != null && message.hasOwnProperty("sharingKey"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.sharingKey);
            if (message.boxKey != null && message.hasOwnProperty("boxKey"))
                writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.boxKey);
            return writer;
        };

        /**
         * Encodes the specified DelegatedKeys message, length delimited. Does not implicitly {@link types.DelegatedKeys.verify|verify} messages.
         * @function encodeDelimited
         * @memberof types.DelegatedKeys
         * @static
         * @param {types.IDelegatedKeys} message DelegatedKeys message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DelegatedKeys.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DelegatedKeys message from the specified reader or buffer.
         * @function decode
         * @memberof types.DelegatedKeys
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {types.DelegatedKeys} DelegatedKeys
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DelegatedKeys.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.types.DelegatedKeys();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                case 2:
                    message.version = reader.uint32();
                    break;
                case 3:
                    message.signKey = reader.bytes();
                    break;
                case 4:
                    message.readKey = reader.bytes();
                    break;
                case 5:
                    message.sharingKey = reader.bytes();
                    break;
                case 6:
                    message.boxKey = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DelegatedKeys message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof types.DelegatedKeys
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {types.DelegatedKeys} DelegatedKeys
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DelegatedKeys.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DelegatedKeys message.
         * @function verify
         * @memberof types.DelegatedKeys
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DelegatedKeys.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isInteger(message.version))
                    return "version: integer expected";
            if (message.signKey != null && message.hasOwnProperty("signKey"))
                if (!(message.signKey && typeof message.signKey.length === "number" || $util.isString(message.signKey)))
                    return "signKey: buffer expected";
            if (message.readKey != null && message.hasOwnProperty("readKey"))
                if (!(message.readKey && typeof message.readKey.length === "number" || $util.isString(message.readKey)))
                    return "readKey: buffer expected";
            if (message.sharingKey != null && message.hasOwnProperty("sharingKey"))
                if (!(message.sharingKey && typeof message.sharingKey.length === "number" || $util.isString(message.sharingKey)))
                    return "sharingKey: buffer expected";
            if (message.boxKey != null && message.hasOwnProperty("boxKey"))
                if (!(message.boxKey && typeof message.boxKey.length === "number" || $util.isString(message.boxKey)))
                    return "boxKey: buffer expected";
            return null;
        };

        /**
         * Creates a DelegatedKeys message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof types.DelegatedKeys
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {types.DelegatedKeys} DelegatedKeys
         */
        DelegatedKeys.fromObject = function fromObject(object) {
            if (object instanceof $root.types.DelegatedKeys)
                return object;
            var message = new $root.types.DelegatedKeys();
            if (object.login != null)
                message.login = String(object.login);
            if (object.version != null)
                message.version = object.version >>> 0;
            if (object.signKey != null)
                if (typeof object.signKey === "string")
                    $util.base64.decode(object.signKey, message.signKey = $util.newBuffer($util.base64.length(object.signKey)), 0);
                else if (object.signKey.length)
                    message.signKey = object.signKey;
            if (object.readKey != null)
                if (typeof object.readKey === "string")
                    $util.base64.decode(object.readKey, message.readKey = $util.newBuffer($util.base64.length(object.readKey)), 0);
                else if (object.readKey.length)
                    message.readKey = object.readKey;
            if (object.sharingKey != null)
                if (typeof object.sharingKey === "string")
                    $util.base64.decode(object.sharingKey, message.sharingKey = $util.newBuffer($util.base64.length(object.sharingKey)), 0);
                else if (object.sharingKey.length)
                    message.sharingKey = object.sharingKey;
            if (object.boxKey != null)
                if (typeof object.boxKey === "string")
                    $util.base64.decode(object.boxKey, message.boxKey = $util.newBuffer($util.base64.length(object.boxKey)), 0);
                else if (object.boxKey.length)
                    message.boxKey = object.boxKey;
            return message;
        };

        /**
         * Creates a plain object from a DelegatedKeys message. Also converts values to other types if specified.
         * @function toObject
         * @memberof types.DelegatedKeys
         * @static
         * @param {types.DelegatedKeys} message DelegatedKeys
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DelegatedKeys.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.login = "";
                object.version = 0;
                object.signKey = options.bytes === String ? "" : [];
                object.readKey = options.bytes === String ? "" : [];
                object.sharingKey = options.bytes === String ? "" : [];
                object.boxKey = options.bytes === String ? "" : [];
            }
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            if (message.signKey != null && message.hasOwnProperty("signKey"))
                object.signKey = options.bytes === String ? $util.base64.encode(message.signKey, 0, message.signKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.signKey) : message.signKey;
            if (message.readKey != null && message.hasOwnProperty("readKey"))
                object.readKey = options.bytes === String ? $util.base64.encode(message.readKey, 0, message.readKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.readKey) : message.readKey;
            if (message.sharingKey != null && message.hasOwnProperty("sharingKey"))
                object.sharingKey = options.bytes === String ? $util.base64.encode(message.sharingKey, 0, message.sharingKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.sharingKey) : message.sharingKey;
            if (message.boxKey != null && message.hasOwnProperty("boxKey"))
                object.boxKey = options.bytes === String ? $util.base64.encode(message.boxKey, 0, message.boxKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.boxKey) : message.boxKey;
            return object;
        };

        /**
         * Converts this DelegatedKeys to JSON.
         * @function toJSON
         * @memberof types.DelegatedKeys
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DelegatedKeys.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DelegatedKeys;
    })();

    types.DelegatedGetKeysResponse = (function() {

        /**
         * Properties of a DelegatedGetKeysResponse.
         * @memberof types
         * @interface IDelegatedGetKeysResponse
         * @property {Uint8Array|null} [keys] DelegatedGetKeysResponse keys
         */

        /**
         * Constructs a new DelegatedGetKeysResponse.
         * @memberof types
         * @classdesc Represents a DelegatedGetKeysResponse.
         * @implements IDelegatedGetKeysResponse
         * @constructor
         * @param {types.IDelegatedGetKeysResponse=} [properties] Properties to set
         */
        function DelegatedGetKeysResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DelegatedGetKeysResponse keys.
         * @member {Uint8Array} keys
         * @memberof types.DelegatedGetKeysResponse
         * @instance
         */
        DelegatedGetKeysResponse.prototype.keys = $util.newBuffer([]);

        /**
         * Creates a new DelegatedGetKeysResponse instance using the specified properties.
         * @function create
         * @memberof types.DelegatedGetKeysResponse
         * @static
         * @param {types.IDelegatedGetKeysResponse=} [properties] Properties to set
         * @returns {types.DelegatedGetKeysResponse} DelegatedGetKeysResponse instance
         */
        DelegatedGetKeysResponse.create = function create(properties) {
            return new DelegatedGetKeysResponse(properties);
        };

        /**
         * Encodes the specified DelegatedGetKeysResponse message. Does not implicitly {@link types.DelegatedGetKeysResponse.verify|verify} messages.
         * @function encode
         * @memberof types.DelegatedGetKeysResponse
         * @static
         * @param {types.IDelegatedGetKeysResponse} message DelegatedGetKeysResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DelegatedGetKeysResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.keys != null && message.hasOwnProperty("keys"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.keys);
            return writer;
        };

        /**
         * Encodes the specified DelegatedGetKeysResponse message, length delimited. Does not implicitly {@link types.DelegatedGetKeysResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof types.DelegatedGetKeysResponse
         * @static
         * @param {types.IDelegatedGetKeysResponse} message DelegatedGetKeysResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DelegatedGetKeysResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DelegatedGetKeysResponse message from the specified reader or buffer.
         * @function decode
         * @memberof types.DelegatedGetKeysResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {types.DelegatedGetKeysResponse} DelegatedGetKeysResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DelegatedGetKeysResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.types.DelegatedGetKeysResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.keys = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DelegatedGetKeysResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof types.DelegatedGetKeysResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {types.DelegatedGetKeysResponse} DelegatedGetKeysResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DelegatedGetKeysResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DelegatedGetKeysResponse message.
         * @function verify
         * @memberof types.DelegatedGetKeysResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DelegatedGetKeysResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.keys != null && message.hasOwnProperty("keys"))
                if (!(message.keys && typeof message.keys.length === "number" || $util.isString(message.keys)))
                    return "keys: buffer expected";
            return null;
        };

        /**
         * Creates a DelegatedGetKeysResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof types.DelegatedGetKeysResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {types.DelegatedGetKeysResponse} DelegatedGetKeysResponse
         */
        DelegatedGetKeysResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.types.DelegatedGetKeysResponse)
                return object;
            var message = new $root.types.DelegatedGetKeysResponse();
            if (object.keys != null)
                if (typeof object.keys === "string")
                    $util.base64.decode(object.keys, message.keys = $util.newBuffer($util.base64.length(object.keys)), 0);
                else if (object.keys.length)
                    message.keys = object.keys;
            return message;
        };

        /**
         * Creates a plain object from a DelegatedGetKeysResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof types.DelegatedGetKeysResponse
         * @static
         * @param {types.DelegatedGetKeysResponse} message DelegatedGetKeysResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DelegatedGetKeysResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.keys = options.bytes === String ? "" : [];
            if (message.keys != null && message.hasOwnProperty("keys"))
                object.keys = options.bytes === String ? $util.base64.encode(message.keys, 0, message.keys.length) : options.bytes === Array ? Array.prototype.slice.call(message.keys) : message.keys;
            return object;
        };

        /**
         * Converts this DelegatedGetKeysResponse to JSON.
         * @function toJSON
         * @memberof types.DelegatedGetKeysResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DelegatedGetKeysResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DelegatedGetKeysResponse;
    })();

    types.DelegatedPostKeysRequest = (function() {

        /**
         * Properties of a DelegatedPostKeysRequest.
         * @memberof types
         * @interface IDelegatedPostKeysRequest
         * @property {number|Long|null} [DelegatedID] DelegatedPostKeysRequest DelegatedID
         * @property {Uint8Array|null} [keys] DelegatedPostKeysRequest keys
         */

        /**
         * Constructs a new DelegatedPostKeysRequest.
         * @memberof types
         * @classdesc Represents a DelegatedPostKeysRequest.
         * @implements IDelegatedPostKeysRequest
         * @constructor
         * @param {types.IDelegatedPostKeysRequest=} [properties] Properties to set
         */
        function DelegatedPostKeysRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DelegatedPostKeysRequest DelegatedID.
         * @member {number|Long} DelegatedID
         * @memberof types.DelegatedPostKeysRequest
         * @instance
         */
        DelegatedPostKeysRequest.prototype.DelegatedID = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * DelegatedPostKeysRequest keys.
         * @member {Uint8Array} keys
         * @memberof types.DelegatedPostKeysRequest
         * @instance
         */
        DelegatedPostKeysRequest.prototype.keys = $util.newBuffer([]);

        /**
         * Creates a new DelegatedPostKeysRequest instance using the specified properties.
         * @function create
         * @memberof types.DelegatedPostKeysRequest
         * @static
         * @param {types.IDelegatedPostKeysRequest=} [properties] Properties to set
         * @returns {types.DelegatedPostKeysRequest} DelegatedPostKeysRequest instance
         */
        DelegatedPostKeysRequest.create = function create(properties) {
            return new DelegatedPostKeysRequest(properties);
        };

        /**
         * Encodes the specified DelegatedPostKeysRequest message. Does not implicitly {@link types.DelegatedPostKeysRequest.verify|verify} messages.
         * @function encode
         * @memberof types.DelegatedPostKeysRequest
         * @static
         * @param {types.IDelegatedPostKeysRequest} message DelegatedPostKeysRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DelegatedPostKeysRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.DelegatedID != null && message.hasOwnProperty("DelegatedID"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.DelegatedID);
            if (message.keys != null && message.hasOwnProperty("keys"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.keys);
            return writer;
        };

        /**
         * Encodes the specified DelegatedPostKeysRequest message, length delimited. Does not implicitly {@link types.DelegatedPostKeysRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof types.DelegatedPostKeysRequest
         * @static
         * @param {types.IDelegatedPostKeysRequest} message DelegatedPostKeysRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DelegatedPostKeysRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DelegatedPostKeysRequest message from the specified reader or buffer.
         * @function decode
         * @memberof types.DelegatedPostKeysRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {types.DelegatedPostKeysRequest} DelegatedPostKeysRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DelegatedPostKeysRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.types.DelegatedPostKeysRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.DelegatedID = reader.uint64();
                    break;
                case 2:
                    message.keys = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DelegatedPostKeysRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof types.DelegatedPostKeysRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {types.DelegatedPostKeysRequest} DelegatedPostKeysRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DelegatedPostKeysRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DelegatedPostKeysRequest message.
         * @function verify
         * @memberof types.DelegatedPostKeysRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DelegatedPostKeysRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.DelegatedID != null && message.hasOwnProperty("DelegatedID"))
                if (!$util.isInteger(message.DelegatedID) && !(message.DelegatedID && $util.isInteger(message.DelegatedID.low) && $util.isInteger(message.DelegatedID.high)))
                    return "DelegatedID: integer|Long expected";
            if (message.keys != null && message.hasOwnProperty("keys"))
                if (!(message.keys && typeof message.keys.length === "number" || $util.isString(message.keys)))
                    return "keys: buffer expected";
            return null;
        };

        /**
         * Creates a DelegatedPostKeysRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof types.DelegatedPostKeysRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {types.DelegatedPostKeysRequest} DelegatedPostKeysRequest
         */
        DelegatedPostKeysRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.types.DelegatedPostKeysRequest)
                return object;
            var message = new $root.types.DelegatedPostKeysRequest();
            if (object.DelegatedID != null)
                if ($util.Long)
                    (message.DelegatedID = $util.Long.fromValue(object.DelegatedID)).unsigned = true;
                else if (typeof object.DelegatedID === "string")
                    message.DelegatedID = parseInt(object.DelegatedID, 10);
                else if (typeof object.DelegatedID === "number")
                    message.DelegatedID = object.DelegatedID;
                else if (typeof object.DelegatedID === "object")
                    message.DelegatedID = new $util.LongBits(object.DelegatedID.low >>> 0, object.DelegatedID.high >>> 0).toNumber(true);
            if (object.keys != null)
                if (typeof object.keys === "string")
                    $util.base64.decode(object.keys, message.keys = $util.newBuffer($util.base64.length(object.keys)), 0);
                else if (object.keys.length)
                    message.keys = object.keys;
            return message;
        };

        /**
         * Creates a plain object from a DelegatedPostKeysRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof types.DelegatedPostKeysRequest
         * @static
         * @param {types.DelegatedPostKeysRequest} message DelegatedPostKeysRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DelegatedPostKeysRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.DelegatedID = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.DelegatedID = options.longs === String ? "0" : 0;
                object.keys = options.bytes === String ? "" : [];
            }
            if (message.DelegatedID != null && message.hasOwnProperty("DelegatedID"))
                if (typeof message.DelegatedID === "number")
                    object.DelegatedID = options.longs === String ? String(message.DelegatedID) : message.DelegatedID;
                else
                    object.DelegatedID = options.longs === String ? $util.Long.prototype.toString.call(message.DelegatedID) : options.longs === Number ? new $util.LongBits(message.DelegatedID.low >>> 0, message.DelegatedID.high >>> 0).toNumber(true) : message.DelegatedID;
            if (message.keys != null && message.hasOwnProperty("keys"))
                object.keys = options.bytes === String ? $util.base64.encode(message.keys, 0, message.keys.length) : options.bytes === Array ? Array.prototype.slice.call(message.keys) : message.keys;
            return object;
        };

        /**
         * Converts this DelegatedPostKeysRequest to JSON.
         * @function toJSON
         * @memberof types.DelegatedPostKeysRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DelegatedPostKeysRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DelegatedPostKeysRequest;
    })();

    /**
     * RegisterTokenStatus enum.
     * @name types.RegisterTokenStatus
     * @enum {string}
     * @property {number} PENDING=0 PENDING value
     * @property {number} SENT=1 SENT value
     * @property {number} RECEIVED=2 RECEIVED value
     */
    types.RegisterTokenStatus = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "PENDING"] = 0;
        values[valuesById[1] = "SENT"] = 1;
        values[valuesById[2] = "RECEIVED"] = 2;
        return values;
    })();

    types.RegisterEmailValidationToken = (function() {

        /**
         * Properties of a RegisterEmailValidationToken.
         * @memberof types
         * @interface IRegisterEmailValidationToken
         * @property {Uint8Array|null} [token] RegisterEmailValidationToken token
         * @property {string|null} [email] RegisterEmailValidationToken email
         * @property {number|Long|null} [created] RegisterEmailValidationToken created
         * @property {types.RegisterTokenStatus|null} [status] RegisterEmailValidationToken status
         */

        /**
         * Constructs a new RegisterEmailValidationToken.
         * @memberof types
         * @classdesc Represents a RegisterEmailValidationToken.
         * @implements IRegisterEmailValidationToken
         * @constructor
         * @param {types.IRegisterEmailValidationToken=} [properties] Properties to set
         */
        function RegisterEmailValidationToken(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RegisterEmailValidationToken token.
         * @member {Uint8Array} token
         * @memberof types.RegisterEmailValidationToken
         * @instance
         */
        RegisterEmailValidationToken.prototype.token = $util.newBuffer([]);

        /**
         * RegisterEmailValidationToken email.
         * @member {string} email
         * @memberof types.RegisterEmailValidationToken
         * @instance
         */
        RegisterEmailValidationToken.prototype.email = "";

        /**
         * RegisterEmailValidationToken created.
         * @member {number|Long} created
         * @memberof types.RegisterEmailValidationToken
         * @instance
         */
        RegisterEmailValidationToken.prototype.created = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * RegisterEmailValidationToken status.
         * @member {types.RegisterTokenStatus} status
         * @memberof types.RegisterEmailValidationToken
         * @instance
         */
        RegisterEmailValidationToken.prototype.status = 0;

        /**
         * Creates a new RegisterEmailValidationToken instance using the specified properties.
         * @function create
         * @memberof types.RegisterEmailValidationToken
         * @static
         * @param {types.IRegisterEmailValidationToken=} [properties] Properties to set
         * @returns {types.RegisterEmailValidationToken} RegisterEmailValidationToken instance
         */
        RegisterEmailValidationToken.create = function create(properties) {
            return new RegisterEmailValidationToken(properties);
        };

        /**
         * Encodes the specified RegisterEmailValidationToken message. Does not implicitly {@link types.RegisterEmailValidationToken.verify|verify} messages.
         * @function encode
         * @memberof types.RegisterEmailValidationToken
         * @static
         * @param {types.IRegisterEmailValidationToken} message RegisterEmailValidationToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RegisterEmailValidationToken.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.token != null && message.hasOwnProperty("token"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.token);
            if (message.email != null && message.hasOwnProperty("email"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.email);
            if (message.created != null && message.hasOwnProperty("created"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.created);
            if (message.status != null && message.hasOwnProperty("status"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.status);
            return writer;
        };

        /**
         * Encodes the specified RegisterEmailValidationToken message, length delimited. Does not implicitly {@link types.RegisterEmailValidationToken.verify|verify} messages.
         * @function encodeDelimited
         * @memberof types.RegisterEmailValidationToken
         * @static
         * @param {types.IRegisterEmailValidationToken} message RegisterEmailValidationToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RegisterEmailValidationToken.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RegisterEmailValidationToken message from the specified reader or buffer.
         * @function decode
         * @memberof types.RegisterEmailValidationToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {types.RegisterEmailValidationToken} RegisterEmailValidationToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RegisterEmailValidationToken.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.types.RegisterEmailValidationToken();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.token = reader.bytes();
                    break;
                case 2:
                    message.email = reader.string();
                    break;
                case 3:
                    message.created = reader.int64();
                    break;
                case 4:
                    message.status = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RegisterEmailValidationToken message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof types.RegisterEmailValidationToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {types.RegisterEmailValidationToken} RegisterEmailValidationToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RegisterEmailValidationToken.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RegisterEmailValidationToken message.
         * @function verify
         * @memberof types.RegisterEmailValidationToken
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RegisterEmailValidationToken.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.token != null && message.hasOwnProperty("token"))
                if (!(message.token && typeof message.token.length === "number" || $util.isString(message.token)))
                    return "token: buffer expected";
            if (message.email != null && message.hasOwnProperty("email"))
                if (!$util.isString(message.email))
                    return "email: string expected";
            if (message.created != null && message.hasOwnProperty("created"))
                if (!$util.isInteger(message.created) && !(message.created && $util.isInteger(message.created.low) && $util.isInteger(message.created.high)))
                    return "created: integer|Long expected";
            if (message.status != null && message.hasOwnProperty("status"))
                switch (message.status) {
                default:
                    return "status: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            return null;
        };

        /**
         * Creates a RegisterEmailValidationToken message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof types.RegisterEmailValidationToken
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {types.RegisterEmailValidationToken} RegisterEmailValidationToken
         */
        RegisterEmailValidationToken.fromObject = function fromObject(object) {
            if (object instanceof $root.types.RegisterEmailValidationToken)
                return object;
            var message = new $root.types.RegisterEmailValidationToken();
            if (object.token != null)
                if (typeof object.token === "string")
                    $util.base64.decode(object.token, message.token = $util.newBuffer($util.base64.length(object.token)), 0);
                else if (object.token.length)
                    message.token = object.token;
            if (object.email != null)
                message.email = String(object.email);
            if (object.created != null)
                if ($util.Long)
                    (message.created = $util.Long.fromValue(object.created)).unsigned = false;
                else if (typeof object.created === "string")
                    message.created = parseInt(object.created, 10);
                else if (typeof object.created === "number")
                    message.created = object.created;
                else if (typeof object.created === "object")
                    message.created = new $util.LongBits(object.created.low >>> 0, object.created.high >>> 0).toNumber();
            switch (object.status) {
            case "PENDING":
            case 0:
                message.status = 0;
                break;
            case "SENT":
            case 1:
                message.status = 1;
                break;
            case "RECEIVED":
            case 2:
                message.status = 2;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a RegisterEmailValidationToken message. Also converts values to other types if specified.
         * @function toObject
         * @memberof types.RegisterEmailValidationToken
         * @static
         * @param {types.RegisterEmailValidationToken} message RegisterEmailValidationToken
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RegisterEmailValidationToken.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.token = options.bytes === String ? "" : [];
                object.email = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.created = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.created = options.longs === String ? "0" : 0;
                object.status = options.enums === String ? "PENDING" : 0;
            }
            if (message.token != null && message.hasOwnProperty("token"))
                object.token = options.bytes === String ? $util.base64.encode(message.token, 0, message.token.length) : options.bytes === Array ? Array.prototype.slice.call(message.token) : message.token;
            if (message.email != null && message.hasOwnProperty("email"))
                object.email = message.email;
            if (message.created != null && message.hasOwnProperty("created"))
                if (typeof message.created === "number")
                    object.created = options.longs === String ? String(message.created) : message.created;
                else
                    object.created = options.longs === String ? $util.Long.prototype.toString.call(message.created) : options.longs === Number ? new $util.LongBits(message.created.low >>> 0, message.created.high >>> 0).toNumber() : message.created;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = options.enums === String ? $root.types.RegisterTokenStatus[message.status] : message.status;
            return object;
        };

        /**
         * Converts this RegisterEmailValidationToken to JSON.
         * @function toJSON
         * @memberof types.RegisterEmailValidationToken
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RegisterEmailValidationToken.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RegisterEmailValidationToken;
    })();

    types.RegisterLinkRequest = (function() {

        /**
         * Properties of a RegisterLinkRequest.
         * @memberof types
         * @interface IRegisterLinkRequest
         * @property {string|null} [email] RegisterLinkRequest email
         */

        /**
         * Constructs a new RegisterLinkRequest.
         * @memberof types
         * @classdesc Represents a RegisterLinkRequest.
         * @implements IRegisterLinkRequest
         * @constructor
         * @param {types.IRegisterLinkRequest=} [properties] Properties to set
         */
        function RegisterLinkRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RegisterLinkRequest email.
         * @member {string} email
         * @memberof types.RegisterLinkRequest
         * @instance
         */
        RegisterLinkRequest.prototype.email = "";

        /**
         * Creates a new RegisterLinkRequest instance using the specified properties.
         * @function create
         * @memberof types.RegisterLinkRequest
         * @static
         * @param {types.IRegisterLinkRequest=} [properties] Properties to set
         * @returns {types.RegisterLinkRequest} RegisterLinkRequest instance
         */
        RegisterLinkRequest.create = function create(properties) {
            return new RegisterLinkRequest(properties);
        };

        /**
         * Encodes the specified RegisterLinkRequest message. Does not implicitly {@link types.RegisterLinkRequest.verify|verify} messages.
         * @function encode
         * @memberof types.RegisterLinkRequest
         * @static
         * @param {types.IRegisterLinkRequest} message RegisterLinkRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RegisterLinkRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.email != null && message.hasOwnProperty("email"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.email);
            return writer;
        };

        /**
         * Encodes the specified RegisterLinkRequest message, length delimited. Does not implicitly {@link types.RegisterLinkRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof types.RegisterLinkRequest
         * @static
         * @param {types.IRegisterLinkRequest} message RegisterLinkRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RegisterLinkRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RegisterLinkRequest message from the specified reader or buffer.
         * @function decode
         * @memberof types.RegisterLinkRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {types.RegisterLinkRequest} RegisterLinkRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RegisterLinkRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.types.RegisterLinkRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.email = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RegisterLinkRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof types.RegisterLinkRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {types.RegisterLinkRequest} RegisterLinkRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RegisterLinkRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RegisterLinkRequest message.
         * @function verify
         * @memberof types.RegisterLinkRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RegisterLinkRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.email != null && message.hasOwnProperty("email"))
                if (!$util.isString(message.email))
                    return "email: string expected";
            return null;
        };

        /**
         * Creates a RegisterLinkRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof types.RegisterLinkRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {types.RegisterLinkRequest} RegisterLinkRequest
         */
        RegisterLinkRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.types.RegisterLinkRequest)
                return object;
            var message = new $root.types.RegisterLinkRequest();
            if (object.email != null)
                message.email = String(object.email);
            return message;
        };

        /**
         * Creates a plain object from a RegisterLinkRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof types.RegisterLinkRequest
         * @static
         * @param {types.RegisterLinkRequest} message RegisterLinkRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RegisterLinkRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.email = "";
            if (message.email != null && message.hasOwnProperty("email"))
                object.email = message.email;
            return object;
        };

        /**
         * Converts this RegisterLinkRequest to JSON.
         * @function toJSON
         * @memberof types.RegisterLinkRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RegisterLinkRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RegisterLinkRequest;
    })();

    types.LinksGetResponse = (function() {

        /**
         * Properties of a LinksGetResponse.
         * @memberof types
         * @interface ILinksGetResponse
         * @property {Array.<types.IRegisterEmailValidationToken>|null} [links] LinksGetResponse links
         */

        /**
         * Constructs a new LinksGetResponse.
         * @memberof types
         * @classdesc Represents a LinksGetResponse.
         * @implements ILinksGetResponse
         * @constructor
         * @param {types.ILinksGetResponse=} [properties] Properties to set
         */
        function LinksGetResponse(properties) {
            this.links = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LinksGetResponse links.
         * @member {Array.<types.IRegisterEmailValidationToken>} links
         * @memberof types.LinksGetResponse
         * @instance
         */
        LinksGetResponse.prototype.links = $util.emptyArray;

        /**
         * Creates a new LinksGetResponse instance using the specified properties.
         * @function create
         * @memberof types.LinksGetResponse
         * @static
         * @param {types.ILinksGetResponse=} [properties] Properties to set
         * @returns {types.LinksGetResponse} LinksGetResponse instance
         */
        LinksGetResponse.create = function create(properties) {
            return new LinksGetResponse(properties);
        };

        /**
         * Encodes the specified LinksGetResponse message. Does not implicitly {@link types.LinksGetResponse.verify|verify} messages.
         * @function encode
         * @memberof types.LinksGetResponse
         * @static
         * @param {types.ILinksGetResponse} message LinksGetResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LinksGetResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.links != null && message.links.length)
                for (var i = 0; i < message.links.length; ++i)
                    $root.types.RegisterEmailValidationToken.encode(message.links[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified LinksGetResponse message, length delimited. Does not implicitly {@link types.LinksGetResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof types.LinksGetResponse
         * @static
         * @param {types.ILinksGetResponse} message LinksGetResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LinksGetResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LinksGetResponse message from the specified reader or buffer.
         * @function decode
         * @memberof types.LinksGetResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {types.LinksGetResponse} LinksGetResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LinksGetResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.types.LinksGetResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.links && message.links.length))
                        message.links = [];
                    message.links.push($root.types.RegisterEmailValidationToken.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LinksGetResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof types.LinksGetResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {types.LinksGetResponse} LinksGetResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LinksGetResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LinksGetResponse message.
         * @function verify
         * @memberof types.LinksGetResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LinksGetResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.links != null && message.hasOwnProperty("links")) {
                if (!Array.isArray(message.links))
                    return "links: array expected";
                for (var i = 0; i < message.links.length; ++i) {
                    var error = $root.types.RegisterEmailValidationToken.verify(message.links[i]);
                    if (error)
                        return "links." + error;
                }
            }
            return null;
        };

        /**
         * Creates a LinksGetResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof types.LinksGetResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {types.LinksGetResponse} LinksGetResponse
         */
        LinksGetResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.types.LinksGetResponse)
                return object;
            var message = new $root.types.LinksGetResponse();
            if (object.links) {
                if (!Array.isArray(object.links))
                    throw TypeError(".types.LinksGetResponse.links: array expected");
                message.links = [];
                for (var i = 0; i < object.links.length; ++i) {
                    if (typeof object.links[i] !== "object")
                        throw TypeError(".types.LinksGetResponse.links: object expected");
                    message.links[i] = $root.types.RegisterEmailValidationToken.fromObject(object.links[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a LinksGetResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof types.LinksGetResponse
         * @static
         * @param {types.LinksGetResponse} message LinksGetResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LinksGetResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.links = [];
            if (message.links && message.links.length) {
                object.links = [];
                for (var j = 0; j < message.links.length; ++j)
                    object.links[j] = $root.types.RegisterEmailValidationToken.toObject(message.links[j], options);
            }
            return object;
        };

        /**
         * Converts this LinksGetResponse to JSON.
         * @function toJSON
         * @memberof types.LinksGetResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LinksGetResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return LinksGetResponse;
    })();

    types.LinkTokenGetResponse = (function() {

        /**
         * Properties of a LinkTokenGetResponse.
         * @memberof types
         * @interface ILinkTokenGetResponse
         * @property {string|null} [email] LinkTokenGetResponse email
         */

        /**
         * Constructs a new LinkTokenGetResponse.
         * @memberof types
         * @classdesc Represents a LinkTokenGetResponse.
         * @implements ILinkTokenGetResponse
         * @constructor
         * @param {types.ILinkTokenGetResponse=} [properties] Properties to set
         */
        function LinkTokenGetResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LinkTokenGetResponse email.
         * @member {string} email
         * @memberof types.LinkTokenGetResponse
         * @instance
         */
        LinkTokenGetResponse.prototype.email = "";

        /**
         * Creates a new LinkTokenGetResponse instance using the specified properties.
         * @function create
         * @memberof types.LinkTokenGetResponse
         * @static
         * @param {types.ILinkTokenGetResponse=} [properties] Properties to set
         * @returns {types.LinkTokenGetResponse} LinkTokenGetResponse instance
         */
        LinkTokenGetResponse.create = function create(properties) {
            return new LinkTokenGetResponse(properties);
        };

        /**
         * Encodes the specified LinkTokenGetResponse message. Does not implicitly {@link types.LinkTokenGetResponse.verify|verify} messages.
         * @function encode
         * @memberof types.LinkTokenGetResponse
         * @static
         * @param {types.ILinkTokenGetResponse} message LinkTokenGetResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LinkTokenGetResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.email != null && message.hasOwnProperty("email"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.email);
            return writer;
        };

        /**
         * Encodes the specified LinkTokenGetResponse message, length delimited. Does not implicitly {@link types.LinkTokenGetResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof types.LinkTokenGetResponse
         * @static
         * @param {types.ILinkTokenGetResponse} message LinkTokenGetResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LinkTokenGetResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LinkTokenGetResponse message from the specified reader or buffer.
         * @function decode
         * @memberof types.LinkTokenGetResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {types.LinkTokenGetResponse} LinkTokenGetResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LinkTokenGetResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.types.LinkTokenGetResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.email = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LinkTokenGetResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof types.LinkTokenGetResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {types.LinkTokenGetResponse} LinkTokenGetResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LinkTokenGetResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LinkTokenGetResponse message.
         * @function verify
         * @memberof types.LinkTokenGetResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LinkTokenGetResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.email != null && message.hasOwnProperty("email"))
                if (!$util.isString(message.email))
                    return "email: string expected";
            return null;
        };

        /**
         * Creates a LinkTokenGetResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof types.LinkTokenGetResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {types.LinkTokenGetResponse} LinkTokenGetResponse
         */
        LinkTokenGetResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.types.LinkTokenGetResponse)
                return object;
            var message = new $root.types.LinkTokenGetResponse();
            if (object.email != null)
                message.email = String(object.email);
            return message;
        };

        /**
         * Creates a plain object from a LinkTokenGetResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof types.LinkTokenGetResponse
         * @static
         * @param {types.LinkTokenGetResponse} message LinkTokenGetResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LinkTokenGetResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.email = "";
            if (message.email != null && message.hasOwnProperty("email"))
                object.email = message.email;
            return object;
        };

        /**
         * Converts this LinkTokenGetResponse to JSON.
         * @function toJSON
         * @memberof types.LinkTokenGetResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LinkTokenGetResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return LinkTokenGetResponse;
    })();

    types.RegisterPostLinkTokenRequest = (function() {

        /**
         * Properties of a RegisterPostLinkTokenRequest.
         * @memberof types
         * @interface IRegisterPostLinkTokenRequest
         * @property {string|null} [token] RegisterPostLinkTokenRequest token
         * @property {types.IIdentityFields|null} [identity] RegisterPostLinkTokenRequest identity
         * @property {types.IIdentityEncryption|null} [encryption] RegisterPostLinkTokenRequest encryption
         */

        /**
         * Constructs a new RegisterPostLinkTokenRequest.
         * @memberof types
         * @classdesc Represents a RegisterPostLinkTokenRequest.
         * @implements IRegisterPostLinkTokenRequest
         * @constructor
         * @param {types.IRegisterPostLinkTokenRequest=} [properties] Properties to set
         */
        function RegisterPostLinkTokenRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RegisterPostLinkTokenRequest token.
         * @member {string} token
         * @memberof types.RegisterPostLinkTokenRequest
         * @instance
         */
        RegisterPostLinkTokenRequest.prototype.token = "";

        /**
         * RegisterPostLinkTokenRequest identity.
         * @member {types.IIdentityFields|null|undefined} identity
         * @memberof types.RegisterPostLinkTokenRequest
         * @instance
         */
        RegisterPostLinkTokenRequest.prototype.identity = null;

        /**
         * RegisterPostLinkTokenRequest encryption.
         * @member {types.IIdentityEncryption|null|undefined} encryption
         * @memberof types.RegisterPostLinkTokenRequest
         * @instance
         */
        RegisterPostLinkTokenRequest.prototype.encryption = null;

        /**
         * Creates a new RegisterPostLinkTokenRequest instance using the specified properties.
         * @function create
         * @memberof types.RegisterPostLinkTokenRequest
         * @static
         * @param {types.IRegisterPostLinkTokenRequest=} [properties] Properties to set
         * @returns {types.RegisterPostLinkTokenRequest} RegisterPostLinkTokenRequest instance
         */
        RegisterPostLinkTokenRequest.create = function create(properties) {
            return new RegisterPostLinkTokenRequest(properties);
        };

        /**
         * Encodes the specified RegisterPostLinkTokenRequest message. Does not implicitly {@link types.RegisterPostLinkTokenRequest.verify|verify} messages.
         * @function encode
         * @memberof types.RegisterPostLinkTokenRequest
         * @static
         * @param {types.IRegisterPostLinkTokenRequest} message RegisterPostLinkTokenRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RegisterPostLinkTokenRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.token != null && message.hasOwnProperty("token"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.token);
            if (message.identity != null && message.hasOwnProperty("identity"))
                $root.types.IdentityFields.encode(message.identity, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.encryption != null && message.hasOwnProperty("encryption"))
                $root.types.IdentityEncryption.encode(message.encryption, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified RegisterPostLinkTokenRequest message, length delimited. Does not implicitly {@link types.RegisterPostLinkTokenRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof types.RegisterPostLinkTokenRequest
         * @static
         * @param {types.IRegisterPostLinkTokenRequest} message RegisterPostLinkTokenRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RegisterPostLinkTokenRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RegisterPostLinkTokenRequest message from the specified reader or buffer.
         * @function decode
         * @memberof types.RegisterPostLinkTokenRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {types.RegisterPostLinkTokenRequest} RegisterPostLinkTokenRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RegisterPostLinkTokenRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.types.RegisterPostLinkTokenRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.token = reader.string();
                    break;
                case 2:
                    message.identity = $root.types.IdentityFields.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.encryption = $root.types.IdentityEncryption.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RegisterPostLinkTokenRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof types.RegisterPostLinkTokenRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {types.RegisterPostLinkTokenRequest} RegisterPostLinkTokenRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RegisterPostLinkTokenRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RegisterPostLinkTokenRequest message.
         * @function verify
         * @memberof types.RegisterPostLinkTokenRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RegisterPostLinkTokenRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.token != null && message.hasOwnProperty("token"))
                if (!$util.isString(message.token))
                    return "token: string expected";
            if (message.identity != null && message.hasOwnProperty("identity")) {
                var error = $root.types.IdentityFields.verify(message.identity);
                if (error)
                    return "identity." + error;
            }
            if (message.encryption != null && message.hasOwnProperty("encryption")) {
                var error = $root.types.IdentityEncryption.verify(message.encryption);
                if (error)
                    return "encryption." + error;
            }
            return null;
        };

        /**
         * Creates a RegisterPostLinkTokenRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof types.RegisterPostLinkTokenRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {types.RegisterPostLinkTokenRequest} RegisterPostLinkTokenRequest
         */
        RegisterPostLinkTokenRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.types.RegisterPostLinkTokenRequest)
                return object;
            var message = new $root.types.RegisterPostLinkTokenRequest();
            if (object.token != null)
                message.token = String(object.token);
            if (object.identity != null) {
                if (typeof object.identity !== "object")
                    throw TypeError(".types.RegisterPostLinkTokenRequest.identity: object expected");
                message.identity = $root.types.IdentityFields.fromObject(object.identity);
            }
            if (object.encryption != null) {
                if (typeof object.encryption !== "object")
                    throw TypeError(".types.RegisterPostLinkTokenRequest.encryption: object expected");
                message.encryption = $root.types.IdentityEncryption.fromObject(object.encryption);
            }
            return message;
        };

        /**
         * Creates a plain object from a RegisterPostLinkTokenRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof types.RegisterPostLinkTokenRequest
         * @static
         * @param {types.RegisterPostLinkTokenRequest} message RegisterPostLinkTokenRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RegisterPostLinkTokenRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.token = "";
                object.identity = null;
                object.encryption = null;
            }
            if (message.token != null && message.hasOwnProperty("token"))
                object.token = message.token;
            if (message.identity != null && message.hasOwnProperty("identity"))
                object.identity = $root.types.IdentityFields.toObject(message.identity, options);
            if (message.encryption != null && message.hasOwnProperty("encryption"))
                object.encryption = $root.types.IdentityEncryption.toObject(message.encryption, options);
            return object;
        };

        /**
         * Converts this RegisterPostLinkTokenRequest to JSON.
         * @function toJSON
         * @memberof types.RegisterPostLinkTokenRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RegisterPostLinkTokenRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RegisterPostLinkTokenRequest;
    })();

    return types;
})();

$root.events = (function() {

    /**
     * Namespace events.
     * @exports events
     * @namespace
     */
    var events = {};

    events.ChannelMessage = (function() {

        /**
         * Properties of a ChannelMessage.
         * @memberof events
         * @interface IChannelMessage
         * @property {number|Long|null} [channelId] ChannelMessage channelId
         * @property {Uint8Array|null} [content] ChannelMessage content
         */

        /**
         * Constructs a new ChannelMessage.
         * @memberof events
         * @classdesc Represents a ChannelMessage.
         * @implements IChannelMessage
         * @constructor
         * @param {events.IChannelMessage=} [properties] Properties to set
         */
        function ChannelMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChannelMessage channelId.
         * @member {number|Long} channelId
         * @memberof events.ChannelMessage
         * @instance
         */
        ChannelMessage.prototype.channelId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ChannelMessage content.
         * @member {Uint8Array} content
         * @memberof events.ChannelMessage
         * @instance
         */
        ChannelMessage.prototype.content = $util.newBuffer([]);

        /**
         * Creates a new ChannelMessage instance using the specified properties.
         * @function create
         * @memberof events.ChannelMessage
         * @static
         * @param {events.IChannelMessage=} [properties] Properties to set
         * @returns {events.ChannelMessage} ChannelMessage instance
         */
        ChannelMessage.create = function create(properties) {
            return new ChannelMessage(properties);
        };

        /**
         * Encodes the specified ChannelMessage message. Does not implicitly {@link events.ChannelMessage.verify|verify} messages.
         * @function encode
         * @memberof events.ChannelMessage
         * @static
         * @param {events.IChannelMessage} message ChannelMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.channelId != null && message.hasOwnProperty("channelId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.channelId);
            if (message.content != null && message.hasOwnProperty("content"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.content);
            return writer;
        };

        /**
         * Encodes the specified ChannelMessage message, length delimited. Does not implicitly {@link events.ChannelMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof events.ChannelMessage
         * @static
         * @param {events.IChannelMessage} message ChannelMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChannelMessage message from the specified reader or buffer.
         * @function decode
         * @memberof events.ChannelMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {events.ChannelMessage} ChannelMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.events.ChannelMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.channelId = reader.uint64();
                    break;
                case 2:
                    message.content = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChannelMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof events.ChannelMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {events.ChannelMessage} ChannelMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChannelMessage message.
         * @function verify
         * @memberof events.ChannelMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChannelMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.channelId != null && message.hasOwnProperty("channelId"))
                if (!$util.isInteger(message.channelId) && !(message.channelId && $util.isInteger(message.channelId.low) && $util.isInteger(message.channelId.high)))
                    return "channelId: integer|Long expected";
            if (message.content != null && message.hasOwnProperty("content"))
                if (!(message.content && typeof message.content.length === "number" || $util.isString(message.content)))
                    return "content: buffer expected";
            return null;
        };

        /**
         * Creates a ChannelMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof events.ChannelMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {events.ChannelMessage} ChannelMessage
         */
        ChannelMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.events.ChannelMessage)
                return object;
            var message = new $root.events.ChannelMessage();
            if (object.channelId != null)
                if ($util.Long)
                    (message.channelId = $util.Long.fromValue(object.channelId)).unsigned = true;
                else if (typeof object.channelId === "string")
                    message.channelId = parseInt(object.channelId, 10);
                else if (typeof object.channelId === "number")
                    message.channelId = object.channelId;
                else if (typeof object.channelId === "object")
                    message.channelId = new $util.LongBits(object.channelId.low >>> 0, object.channelId.high >>> 0).toNumber(true);
            if (object.content != null)
                if (typeof object.content === "string")
                    $util.base64.decode(object.content, message.content = $util.newBuffer($util.base64.length(object.content)), 0);
                else if (object.content.length)
                    message.content = object.content;
            return message;
        };

        /**
         * Creates a plain object from a ChannelMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof events.ChannelMessage
         * @static
         * @param {events.ChannelMessage} message ChannelMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChannelMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.channelId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.channelId = options.longs === String ? "0" : 0;
                object.content = options.bytes === String ? "" : [];
            }
            if (message.channelId != null && message.hasOwnProperty("channelId"))
                if (typeof message.channelId === "number")
                    object.channelId = options.longs === String ? String(message.channelId) : message.channelId;
                else
                    object.channelId = options.longs === String ? $util.Long.prototype.toString.call(message.channelId) : options.longs === Number ? new $util.LongBits(message.channelId.low >>> 0, message.channelId.high >>> 0).toNumber(true) : message.channelId;
            if (message.content != null && message.hasOwnProperty("content"))
                object.content = options.bytes === String ? $util.base64.encode(message.content, 0, message.content.length) : options.bytes === Array ? Array.prototype.slice.call(message.content) : message.content;
            return object;
        };

        /**
         * Converts this ChannelMessage to JSON.
         * @function toJSON
         * @memberof events.ChannelMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChannelMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChannelMessage;
    })();

    events.CommandResponse = (function() {

        /**
         * Properties of a CommandResponse.
         * @memberof events
         * @interface ICommandResponse
         * @property {number|null} [id] CommandResponse id
         * @property {errors.IProtoError|null} [error] CommandResponse error
         * @property {google.protobuf.IAny|null} [success] CommandResponse success
         */

        /**
         * Constructs a new CommandResponse.
         * @memberof events
         * @classdesc Represents a CommandResponse.
         * @implements ICommandResponse
         * @constructor
         * @param {events.ICommandResponse=} [properties] Properties to set
         */
        function CommandResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CommandResponse id.
         * @member {number} id
         * @memberof events.CommandResponse
         * @instance
         */
        CommandResponse.prototype.id = 0;

        /**
         * CommandResponse error.
         * @member {errors.IProtoError|null|undefined} error
         * @memberof events.CommandResponse
         * @instance
         */
        CommandResponse.prototype.error = null;

        /**
         * CommandResponse success.
         * @member {google.protobuf.IAny|null|undefined} success
         * @memberof events.CommandResponse
         * @instance
         */
        CommandResponse.prototype.success = null;

        /**
         * Creates a new CommandResponse instance using the specified properties.
         * @function create
         * @memberof events.CommandResponse
         * @static
         * @param {events.ICommandResponse=} [properties] Properties to set
         * @returns {events.CommandResponse} CommandResponse instance
         */
        CommandResponse.create = function create(properties) {
            return new CommandResponse(properties);
        };

        /**
         * Encodes the specified CommandResponse message. Does not implicitly {@link events.CommandResponse.verify|verify} messages.
         * @function encode
         * @memberof events.CommandResponse
         * @static
         * @param {events.ICommandResponse} message CommandResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CommandResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
            if (message.error != null && message.hasOwnProperty("error"))
                $root.errors.ProtoError.encode(message.error, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.success != null && message.hasOwnProperty("success"))
                $root.google.protobuf.Any.encode(message.success, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CommandResponse message, length delimited. Does not implicitly {@link events.CommandResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof events.CommandResponse
         * @static
         * @param {events.ICommandResponse} message CommandResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CommandResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CommandResponse message from the specified reader or buffer.
         * @function decode
         * @memberof events.CommandResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {events.CommandResponse} CommandResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CommandResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.events.CommandResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.uint32();
                    break;
                case 2:
                    message.error = $root.errors.ProtoError.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.success = $root.google.protobuf.Any.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CommandResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof events.CommandResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {events.CommandResponse} CommandResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CommandResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CommandResponse message.
         * @function verify
         * @memberof events.CommandResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CommandResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.error != null && message.hasOwnProperty("error")) {
                var error = $root.errors.ProtoError.verify(message.error);
                if (error)
                    return "error." + error;
            }
            if (message.success != null && message.hasOwnProperty("success")) {
                var error = $root.google.protobuf.Any.verify(message.success);
                if (error)
                    return "success." + error;
            }
            return null;
        };

        /**
         * Creates a CommandResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof events.CommandResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {events.CommandResponse} CommandResponse
         */
        CommandResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.events.CommandResponse)
                return object;
            var message = new $root.events.CommandResponse();
            if (object.id != null)
                message.id = object.id >>> 0;
            if (object.error != null) {
                if (typeof object.error !== "object")
                    throw TypeError(".events.CommandResponse.error: object expected");
                message.error = $root.errors.ProtoError.fromObject(object.error);
            }
            if (object.success != null) {
                if (typeof object.success !== "object")
                    throw TypeError(".events.CommandResponse.success: object expected");
                message.success = $root.google.protobuf.Any.fromObject(object.success);
            }
            return message;
        };

        /**
         * Creates a plain object from a CommandResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof events.CommandResponse
         * @static
         * @param {events.CommandResponse} message CommandResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CommandResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = 0;
                object.error = null;
                object.success = null;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.error != null && message.hasOwnProperty("error"))
                object.error = $root.errors.ProtoError.toObject(message.error, options);
            if (message.success != null && message.hasOwnProperty("success"))
                object.success = $root.google.protobuf.Any.toObject(message.success, options);
            return object;
        };

        /**
         * Converts this CommandResponse to JSON.
         * @function toJSON
         * @memberof events.CommandResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CommandResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CommandResponse;
    })();

    return events;
})();

module.exports = $root;
