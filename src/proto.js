/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
"use strict";

var $protobuf = require("protobufjs/minimal");

// Common aliases
var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

$root.api = (function() {

    /**
     * Namespace api.
     * @exports api
     * @namespace
     */
    var api = {};

    api.Cipher = (function() {

        /**
         * Properties of a Cipher.
         * @memberof api
         * @interface ICipher
         * @property {Uint8Array|null} [nonce] Cipher nonce
         * @property {Uint8Array|null} [message] Cipher message
         * @property {api.IIdentityKeyID|null} [sign] Cipher sign
         */

        /**
         * Constructs a new Cipher.
         * @memberof api
         * @classdesc Represents a Cipher.
         * @implements ICipher
         * @constructor
         * @param {api.ICipher=} [properties] Properties to set
         */
        function Cipher(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Cipher nonce.
         * @member {Uint8Array} nonce
         * @memberof api.Cipher
         * @instance
         */
        Cipher.prototype.nonce = $util.newBuffer([]);

        /**
         * Cipher message.
         * @member {Uint8Array} message
         * @memberof api.Cipher
         * @instance
         */
        Cipher.prototype.message = $util.newBuffer([]);

        /**
         * Cipher sign.
         * @member {api.IIdentityKeyID|null|undefined} sign
         * @memberof api.Cipher
         * @instance
         */
        Cipher.prototype.sign = null;

        /**
         * Creates a new Cipher instance using the specified properties.
         * @function create
         * @memberof api.Cipher
         * @static
         * @param {api.ICipher=} [properties] Properties to set
         * @returns {api.Cipher} Cipher instance
         */
        Cipher.create = function create(properties) {
            return new Cipher(properties);
        };

        /**
         * Encodes the specified Cipher message. Does not implicitly {@link api.Cipher.verify|verify} messages.
         * @function encode
         * @memberof api.Cipher
         * @static
         * @param {api.ICipher} message Cipher message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Cipher.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.nonce);
            if (message.message != null && message.hasOwnProperty("message"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.message);
            if (message.sign != null && message.hasOwnProperty("sign"))
                $root.api.IdentityKeyID.encode(message.sign, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Cipher message, length delimited. Does not implicitly {@link api.Cipher.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.Cipher
         * @static
         * @param {api.ICipher} message Cipher message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Cipher.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Cipher message from the specified reader or buffer.
         * @function decode
         * @memberof api.Cipher
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.Cipher} Cipher
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Cipher.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.Cipher();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.nonce = reader.bytes();
                    break;
                case 2:
                    message.message = reader.bytes();
                    break;
                case 3:
                    message.sign = $root.api.IdentityKeyID.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Cipher message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.Cipher
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.Cipher} Cipher
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Cipher.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Cipher message.
         * @function verify
         * @memberof api.Cipher
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Cipher.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                if (!(message.nonce && typeof message.nonce.length === "number" || $util.isString(message.nonce)))
                    return "nonce: buffer expected";
            if (message.message != null && message.hasOwnProperty("message"))
                if (!(message.message && typeof message.message.length === "number" || $util.isString(message.message)))
                    return "message: buffer expected";
            if (message.sign != null && message.hasOwnProperty("sign")) {
                var error = $root.api.IdentityKeyID.verify(message.sign);
                if (error)
                    return "sign." + error;
            }
            return null;
        };

        /**
         * Creates a Cipher message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.Cipher
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.Cipher} Cipher
         */
        Cipher.fromObject = function fromObject(object) {
            if (object instanceof $root.api.Cipher)
                return object;
            var message = new $root.api.Cipher();
            if (object.nonce != null)
                if (typeof object.nonce === "string")
                    $util.base64.decode(object.nonce, message.nonce = $util.newBuffer($util.base64.length(object.nonce)), 0);
                else if (object.nonce.length)
                    message.nonce = object.nonce;
            if (object.message != null)
                if (typeof object.message === "string")
                    $util.base64.decode(object.message, message.message = $util.newBuffer($util.base64.length(object.message)), 0);
                else if (object.message.length)
                    message.message = object.message;
            if (object.sign != null) {
                if (typeof object.sign !== "object")
                    throw TypeError(".api.Cipher.sign: object expected");
                message.sign = $root.api.IdentityKeyID.fromObject(object.sign);
            }
            return message;
        };

        /**
         * Creates a plain object from a Cipher message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.Cipher
         * @static
         * @param {api.Cipher} message Cipher
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Cipher.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.nonce = "";
                else {
                    object.nonce = [];
                    if (options.bytes !== Array)
                        object.nonce = $util.newBuffer(object.nonce);
                }
                if (options.bytes === String)
                    object.message = "";
                else {
                    object.message = [];
                    if (options.bytes !== Array)
                        object.message = $util.newBuffer(object.message);
                }
                object.sign = null;
            }
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                object.nonce = options.bytes === String ? $util.base64.encode(message.nonce, 0, message.nonce.length) : options.bytes === Array ? Array.prototype.slice.call(message.nonce) : message.nonce;
            if (message.message != null && message.hasOwnProperty("message"))
                object.message = options.bytes === String ? $util.base64.encode(message.message, 0, message.message.length) : options.bytes === Array ? Array.prototype.slice.call(message.message) : message.message;
            if (message.sign != null && message.hasOwnProperty("sign"))
                object.sign = $root.api.IdentityKeyID.toObject(message.sign, options);
            return object;
        };

        /**
         * Converts this Cipher to JSON.
         * @function toJSON
         * @memberof api.Cipher
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Cipher.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Cipher;
    })();

    api.IdentityFields = (function() {

        /**
         * Properties of an IdentityFields.
         * @memberof api
         * @interface IIdentityFields
         * @property {string|null} [login] IdentityFields login
         * @property {string|null} [name] IdentityFields name
         * @property {string|null} [kind] IdentityFields kind
         * @property {Uint8Array|null} [payload] IdentityFields payload
         */

        /**
         * Constructs a new IdentityFields.
         * @memberof api
         * @classdesc Represents an IdentityFields.
         * @implements IIdentityFields
         * @constructor
         * @param {api.IIdentityFields=} [properties] Properties to set
         */
        function IdentityFields(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityFields login.
         * @member {string} login
         * @memberof api.IdentityFields
         * @instance
         */
        IdentityFields.prototype.login = "";

        /**
         * IdentityFields name.
         * @member {string} name
         * @memberof api.IdentityFields
         * @instance
         */
        IdentityFields.prototype.name = "";

        /**
         * IdentityFields kind.
         * @member {string} kind
         * @memberof api.IdentityFields
         * @instance
         */
        IdentityFields.prototype.kind = "";

        /**
         * IdentityFields payload.
         * @member {Uint8Array} payload
         * @memberof api.IdentityFields
         * @instance
         */
        IdentityFields.prototype.payload = $util.newBuffer([]);

        /**
         * Creates a new IdentityFields instance using the specified properties.
         * @function create
         * @memberof api.IdentityFields
         * @static
         * @param {api.IIdentityFields=} [properties] Properties to set
         * @returns {api.IdentityFields} IdentityFields instance
         */
        IdentityFields.create = function create(properties) {
            return new IdentityFields(properties);
        };

        /**
         * Encodes the specified IdentityFields message. Does not implicitly {@link api.IdentityFields.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityFields
         * @static
         * @param {api.IIdentityFields} message IdentityFields message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityFields.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.kind != null && message.hasOwnProperty("kind"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.kind);
            if (message.payload != null && message.hasOwnProperty("payload"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.payload);
            return writer;
        };

        /**
         * Encodes the specified IdentityFields message, length delimited. Does not implicitly {@link api.IdentityFields.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityFields
         * @static
         * @param {api.IIdentityFields} message IdentityFields message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityFields.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityFields message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityFields
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityFields} IdentityFields
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityFields.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityFields();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 3:
                    message.kind = reader.string();
                    break;
                case 4:
                    message.payload = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityFields message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityFields
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityFields} IdentityFields
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityFields.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityFields message.
         * @function verify
         * @memberof api.IdentityFields
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityFields.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.kind != null && message.hasOwnProperty("kind"))
                if (!$util.isString(message.kind))
                    return "kind: string expected";
            if (message.payload != null && message.hasOwnProperty("payload"))
                if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                    return "payload: buffer expected";
            return null;
        };

        /**
         * Creates an IdentityFields message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityFields
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityFields} IdentityFields
         */
        IdentityFields.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityFields)
                return object;
            var message = new $root.api.IdentityFields();
            if (object.login != null)
                message.login = String(object.login);
            if (object.name != null)
                message.name = String(object.name);
            if (object.kind != null)
                message.kind = String(object.kind);
            if (object.payload != null)
                if (typeof object.payload === "string")
                    $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                else if (object.payload.length)
                    message.payload = object.payload;
            return message;
        };

        /**
         * Creates a plain object from an IdentityFields message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityFields
         * @static
         * @param {api.IdentityFields} message IdentityFields
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityFields.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.login = "";
                object.name = "";
                object.kind = "";
                if (options.bytes === String)
                    object.payload = "";
                else {
                    object.payload = [];
                    if (options.bytes !== Array)
                        object.payload = $util.newBuffer(object.payload);
                }
            }
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.kind != null && message.hasOwnProperty("kind"))
                object.kind = message.kind;
            if (message.payload != null && message.hasOwnProperty("payload"))
                object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
            return object;
        };

        /**
         * Converts this IdentityFields to JSON.
         * @function toJSON
         * @memberof api.IdentityFields
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityFields.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityFields;
    })();

    api.Identity = (function() {

        /**
         * Properties of an Identity.
         * @memberof api
         * @interface IIdentity
         * @property {string|null} [login] Identity login
         * @property {string|null} [name] Identity name
         * @property {string|null} [kind] Identity kind
         * @property {number|Long|null} [created] Identity created
         * @property {boolean|null} [admin] Identity admin
         * @property {boolean|null} [active] Identity active
         * @property {Uint8Array|null} [payload] Identity payload
         */

        /**
         * Constructs a new Identity.
         * @memberof api
         * @classdesc Represents an Identity.
         * @implements IIdentity
         * @constructor
         * @param {api.IIdentity=} [properties] Properties to set
         */
        function Identity(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Identity login.
         * @member {string} login
         * @memberof api.Identity
         * @instance
         */
        Identity.prototype.login = "";

        /**
         * Identity name.
         * @member {string} name
         * @memberof api.Identity
         * @instance
         */
        Identity.prototype.name = "";

        /**
         * Identity kind.
         * @member {string} kind
         * @memberof api.Identity
         * @instance
         */
        Identity.prototype.kind = "";

        /**
         * Identity created.
         * @member {number|Long} created
         * @memberof api.Identity
         * @instance
         */
        Identity.prototype.created = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Identity admin.
         * @member {boolean} admin
         * @memberof api.Identity
         * @instance
         */
        Identity.prototype.admin = false;

        /**
         * Identity active.
         * @member {boolean} active
         * @memberof api.Identity
         * @instance
         */
        Identity.prototype.active = false;

        /**
         * Identity payload.
         * @member {Uint8Array} payload
         * @memberof api.Identity
         * @instance
         */
        Identity.prototype.payload = $util.newBuffer([]);

        /**
         * Creates a new Identity instance using the specified properties.
         * @function create
         * @memberof api.Identity
         * @static
         * @param {api.IIdentity=} [properties] Properties to set
         * @returns {api.Identity} Identity instance
         */
        Identity.create = function create(properties) {
            return new Identity(properties);
        };

        /**
         * Encodes the specified Identity message. Does not implicitly {@link api.Identity.verify|verify} messages.
         * @function encode
         * @memberof api.Identity
         * @static
         * @param {api.IIdentity} message Identity message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Identity.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.kind != null && message.hasOwnProperty("kind"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.kind);
            if (message.created != null && message.hasOwnProperty("created"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.created);
            if (message.admin != null && message.hasOwnProperty("admin"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.admin);
            if (message.active != null && message.hasOwnProperty("active"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.active);
            if (message.payload != null && message.hasOwnProperty("payload"))
                writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.payload);
            return writer;
        };

        /**
         * Encodes the specified Identity message, length delimited. Does not implicitly {@link api.Identity.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.Identity
         * @static
         * @param {api.IIdentity} message Identity message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Identity.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Identity message from the specified reader or buffer.
         * @function decode
         * @memberof api.Identity
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.Identity} Identity
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Identity.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.Identity();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 3:
                    message.kind = reader.string();
                    break;
                case 4:
                    message.created = reader.int64();
                    break;
                case 5:
                    message.admin = reader.bool();
                    break;
                case 6:
                    message.active = reader.bool();
                    break;
                case 7:
                    message.payload = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Identity message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.Identity
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.Identity} Identity
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Identity.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Identity message.
         * @function verify
         * @memberof api.Identity
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Identity.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.kind != null && message.hasOwnProperty("kind"))
                if (!$util.isString(message.kind))
                    return "kind: string expected";
            if (message.created != null && message.hasOwnProperty("created"))
                if (!$util.isInteger(message.created) && !(message.created && $util.isInteger(message.created.low) && $util.isInteger(message.created.high)))
                    return "created: integer|Long expected";
            if (message.admin != null && message.hasOwnProperty("admin"))
                if (typeof message.admin !== "boolean")
                    return "admin: boolean expected";
            if (message.active != null && message.hasOwnProperty("active"))
                if (typeof message.active !== "boolean")
                    return "active: boolean expected";
            if (message.payload != null && message.hasOwnProperty("payload"))
                if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                    return "payload: buffer expected";
            return null;
        };

        /**
         * Creates an Identity message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.Identity
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.Identity} Identity
         */
        Identity.fromObject = function fromObject(object) {
            if (object instanceof $root.api.Identity)
                return object;
            var message = new $root.api.Identity();
            if (object.login != null)
                message.login = String(object.login);
            if (object.name != null)
                message.name = String(object.name);
            if (object.kind != null)
                message.kind = String(object.kind);
            if (object.created != null)
                if ($util.Long)
                    (message.created = $util.Long.fromValue(object.created)).unsigned = false;
                else if (typeof object.created === "string")
                    message.created = parseInt(object.created, 10);
                else if (typeof object.created === "number")
                    message.created = object.created;
                else if (typeof object.created === "object")
                    message.created = new $util.LongBits(object.created.low >>> 0, object.created.high >>> 0).toNumber();
            if (object.admin != null)
                message.admin = Boolean(object.admin);
            if (object.active != null)
                message.active = Boolean(object.active);
            if (object.payload != null)
                if (typeof object.payload === "string")
                    $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                else if (object.payload.length)
                    message.payload = object.payload;
            return message;
        };

        /**
         * Creates a plain object from an Identity message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.Identity
         * @static
         * @param {api.Identity} message Identity
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Identity.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.login = "";
                object.name = "";
                object.kind = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.created = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.created = options.longs === String ? "0" : 0;
                object.admin = false;
                object.active = false;
                if (options.bytes === String)
                    object.payload = "";
                else {
                    object.payload = [];
                    if (options.bytes !== Array)
                        object.payload = $util.newBuffer(object.payload);
                }
            }
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.kind != null && message.hasOwnProperty("kind"))
                object.kind = message.kind;
            if (message.created != null && message.hasOwnProperty("created"))
                if (typeof message.created === "number")
                    object.created = options.longs === String ? String(message.created) : message.created;
                else
                    object.created = options.longs === String ? $util.Long.prototype.toString.call(message.created) : options.longs === Number ? new $util.LongBits(message.created.low >>> 0, message.created.high >>> 0).toNumber() : message.created;
            if (message.admin != null && message.hasOwnProperty("admin"))
                object.admin = message.admin;
            if (message.active != null && message.hasOwnProperty("active"))
                object.active = message.active;
            if (message.payload != null && message.hasOwnProperty("payload"))
                object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
            return object;
        };

        /**
         * Converts this Identity to JSON.
         * @function toJSON
         * @memberof api.Identity
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Identity.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Identity;
    })();

    api.IdentityKeyID = (function() {

        /**
         * Properties of an IdentityKeyID.
         * @memberof api
         * @interface IIdentityKeyID
         * @property {string|null} [login] IdentityKeyID login
         * @property {number|null} [version] IdentityKeyID version
         */

        /**
         * Constructs a new IdentityKeyID.
         * @memberof api
         * @classdesc Represents an IdentityKeyID.
         * @implements IIdentityKeyID
         * @constructor
         * @param {api.IIdentityKeyID=} [properties] Properties to set
         */
        function IdentityKeyID(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityKeyID login.
         * @member {string} login
         * @memberof api.IdentityKeyID
         * @instance
         */
        IdentityKeyID.prototype.login = "";

        /**
         * IdentityKeyID version.
         * @member {number} version
         * @memberof api.IdentityKeyID
         * @instance
         */
        IdentityKeyID.prototype.version = 0;

        /**
         * Creates a new IdentityKeyID instance using the specified properties.
         * @function create
         * @memberof api.IdentityKeyID
         * @static
         * @param {api.IIdentityKeyID=} [properties] Properties to set
         * @returns {api.IdentityKeyID} IdentityKeyID instance
         */
        IdentityKeyID.create = function create(properties) {
            return new IdentityKeyID(properties);
        };

        /**
         * Encodes the specified IdentityKeyID message. Does not implicitly {@link api.IdentityKeyID.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityKeyID
         * @static
         * @param {api.IIdentityKeyID} message IdentityKeyID message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityKeyID.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            if (message.version != null && message.hasOwnProperty("version"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.version);
            return writer;
        };

        /**
         * Encodes the specified IdentityKeyID message, length delimited. Does not implicitly {@link api.IdentityKeyID.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityKeyID
         * @static
         * @param {api.IIdentityKeyID} message IdentityKeyID message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityKeyID.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityKeyID message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityKeyID
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityKeyID} IdentityKeyID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityKeyID.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityKeyID();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                case 2:
                    message.version = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityKeyID message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityKeyID
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityKeyID} IdentityKeyID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityKeyID.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityKeyID message.
         * @function verify
         * @memberof api.IdentityKeyID
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityKeyID.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isInteger(message.version))
                    return "version: integer expected";
            return null;
        };

        /**
         * Creates an IdentityKeyID message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityKeyID
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityKeyID} IdentityKeyID
         */
        IdentityKeyID.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityKeyID)
                return object;
            var message = new $root.api.IdentityKeyID();
            if (object.login != null)
                message.login = String(object.login);
            if (object.version != null)
                message.version = object.version >>> 0;
            return message;
        };

        /**
         * Creates a plain object from an IdentityKeyID message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityKeyID
         * @static
         * @param {api.IdentityKeyID} message IdentityKeyID
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityKeyID.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.login = "";
                object.version = 0;
            }
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            return object;
        };

        /**
         * Converts this IdentityKeyID to JSON.
         * @function toJSON
         * @memberof api.IdentityKeyID
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityKeyID.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityKeyID;
    })();

    api.IdentityPublicKey = (function() {

        /**
         * Properties of an IdentityPublicKey.
         * @memberof api
         * @interface IIdentityPublicKey
         * @property {Uint8Array|null} [sign] IdentityPublicKey sign
         * @property {Uint8Array|null} [box] IdentityPublicKey box
         * @property {string|null} [login] IdentityPublicKey login
         * @property {number|null} [version] IdentityPublicKey version
         */

        /**
         * Constructs a new IdentityPublicKey.
         * @memberof api
         * @classdesc Represents an IdentityPublicKey.
         * @implements IIdentityPublicKey
         * @constructor
         * @param {api.IIdentityPublicKey=} [properties] Properties to set
         */
        function IdentityPublicKey(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityPublicKey sign.
         * @member {Uint8Array} sign
         * @memberof api.IdentityPublicKey
         * @instance
         */
        IdentityPublicKey.prototype.sign = $util.newBuffer([]);

        /**
         * IdentityPublicKey box.
         * @member {Uint8Array} box
         * @memberof api.IdentityPublicKey
         * @instance
         */
        IdentityPublicKey.prototype.box = $util.newBuffer([]);

        /**
         * IdentityPublicKey login.
         * @member {string} login
         * @memberof api.IdentityPublicKey
         * @instance
         */
        IdentityPublicKey.prototype.login = "";

        /**
         * IdentityPublicKey version.
         * @member {number} version
         * @memberof api.IdentityPublicKey
         * @instance
         */
        IdentityPublicKey.prototype.version = 0;

        /**
         * Creates a new IdentityPublicKey instance using the specified properties.
         * @function create
         * @memberof api.IdentityPublicKey
         * @static
         * @param {api.IIdentityPublicKey=} [properties] Properties to set
         * @returns {api.IdentityPublicKey} IdentityPublicKey instance
         */
        IdentityPublicKey.create = function create(properties) {
            return new IdentityPublicKey(properties);
        };

        /**
         * Encodes the specified IdentityPublicKey message. Does not implicitly {@link api.IdentityPublicKey.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityPublicKey
         * @static
         * @param {api.IIdentityPublicKey} message IdentityPublicKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityPublicKey.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.sign != null && message.hasOwnProperty("sign"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.sign);
            if (message.box != null && message.hasOwnProperty("box"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.box);
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.login);
            if (message.version != null && message.hasOwnProperty("version"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.version);
            return writer;
        };

        /**
         * Encodes the specified IdentityPublicKey message, length delimited. Does not implicitly {@link api.IdentityPublicKey.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityPublicKey
         * @static
         * @param {api.IIdentityPublicKey} message IdentityPublicKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityPublicKey.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityPublicKey message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityPublicKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityPublicKey} IdentityPublicKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityPublicKey.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityPublicKey();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.sign = reader.bytes();
                    break;
                case 2:
                    message.box = reader.bytes();
                    break;
                case 3:
                    message.login = reader.string();
                    break;
                case 4:
                    message.version = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityPublicKey message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityPublicKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityPublicKey} IdentityPublicKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityPublicKey.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityPublicKey message.
         * @function verify
         * @memberof api.IdentityPublicKey
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityPublicKey.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.sign != null && message.hasOwnProperty("sign"))
                if (!(message.sign && typeof message.sign.length === "number" || $util.isString(message.sign)))
                    return "sign: buffer expected";
            if (message.box != null && message.hasOwnProperty("box"))
                if (!(message.box && typeof message.box.length === "number" || $util.isString(message.box)))
                    return "box: buffer expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isInteger(message.version))
                    return "version: integer expected";
            return null;
        };

        /**
         * Creates an IdentityPublicKey message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityPublicKey
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityPublicKey} IdentityPublicKey
         */
        IdentityPublicKey.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityPublicKey)
                return object;
            var message = new $root.api.IdentityPublicKey();
            if (object.sign != null)
                if (typeof object.sign === "string")
                    $util.base64.decode(object.sign, message.sign = $util.newBuffer($util.base64.length(object.sign)), 0);
                else if (object.sign.length)
                    message.sign = object.sign;
            if (object.box != null)
                if (typeof object.box === "string")
                    $util.base64.decode(object.box, message.box = $util.newBuffer($util.base64.length(object.box)), 0);
                else if (object.box.length)
                    message.box = object.box;
            if (object.login != null)
                message.login = String(object.login);
            if (object.version != null)
                message.version = object.version >>> 0;
            return message;
        };

        /**
         * Creates a plain object from an IdentityPublicKey message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityPublicKey
         * @static
         * @param {api.IdentityPublicKey} message IdentityPublicKey
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityPublicKey.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.sign = "";
                else {
                    object.sign = [];
                    if (options.bytes !== Array)
                        object.sign = $util.newBuffer(object.sign);
                }
                if (options.bytes === String)
                    object.box = "";
                else {
                    object.box = [];
                    if (options.bytes !== Array)
                        object.box = $util.newBuffer(object.box);
                }
                object.login = "";
                object.version = 0;
            }
            if (message.sign != null && message.hasOwnProperty("sign"))
                object.sign = options.bytes === String ? $util.base64.encode(message.sign, 0, message.sign.length) : options.bytes === Array ? Array.prototype.slice.call(message.sign) : message.sign;
            if (message.box != null && message.hasOwnProperty("box"))
                object.box = options.bytes === String ? $util.base64.encode(message.box, 0, message.box.length) : options.bytes === Array ? Array.prototype.slice.call(message.box) : message.box;
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            return object;
        };

        /**
         * Converts this IdentityPublicKey to JSON.
         * @function toJSON
         * @memberof api.IdentityPublicKey
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityPublicKey.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityPublicKey;
    })();

    api.IdentityPublicKeyWithMetadata = (function() {

        /**
         * Properties of an IdentityPublicKeyWithMetadata.
         * @memberof api
         * @interface IIdentityPublicKeyWithMetadata
         * @property {api.IIdentityPublicKey|null} [publicKey] IdentityPublicKeyWithMetadata publicKey
         * @property {number|Long|null} [created] IdentityPublicKeyWithMetadata created
         */

        /**
         * Constructs a new IdentityPublicKeyWithMetadata.
         * @memberof api
         * @classdesc Represents an IdentityPublicKeyWithMetadata.
         * @implements IIdentityPublicKeyWithMetadata
         * @constructor
         * @param {api.IIdentityPublicKeyWithMetadata=} [properties] Properties to set
         */
        function IdentityPublicKeyWithMetadata(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityPublicKeyWithMetadata publicKey.
         * @member {api.IIdentityPublicKey|null|undefined} publicKey
         * @memberof api.IdentityPublicKeyWithMetadata
         * @instance
         */
        IdentityPublicKeyWithMetadata.prototype.publicKey = null;

        /**
         * IdentityPublicKeyWithMetadata created.
         * @member {number|Long} created
         * @memberof api.IdentityPublicKeyWithMetadata
         * @instance
         */
        IdentityPublicKeyWithMetadata.prototype.created = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new IdentityPublicKeyWithMetadata instance using the specified properties.
         * @function create
         * @memberof api.IdentityPublicKeyWithMetadata
         * @static
         * @param {api.IIdentityPublicKeyWithMetadata=} [properties] Properties to set
         * @returns {api.IdentityPublicKeyWithMetadata} IdentityPublicKeyWithMetadata instance
         */
        IdentityPublicKeyWithMetadata.create = function create(properties) {
            return new IdentityPublicKeyWithMetadata(properties);
        };

        /**
         * Encodes the specified IdentityPublicKeyWithMetadata message. Does not implicitly {@link api.IdentityPublicKeyWithMetadata.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityPublicKeyWithMetadata
         * @static
         * @param {api.IIdentityPublicKeyWithMetadata} message IdentityPublicKeyWithMetadata message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityPublicKeyWithMetadata.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                $root.api.IdentityPublicKey.encode(message.publicKey, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.created != null && message.hasOwnProperty("created"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.created);
            return writer;
        };

        /**
         * Encodes the specified IdentityPublicKeyWithMetadata message, length delimited. Does not implicitly {@link api.IdentityPublicKeyWithMetadata.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityPublicKeyWithMetadata
         * @static
         * @param {api.IIdentityPublicKeyWithMetadata} message IdentityPublicKeyWithMetadata message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityPublicKeyWithMetadata.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityPublicKeyWithMetadata message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityPublicKeyWithMetadata
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityPublicKeyWithMetadata} IdentityPublicKeyWithMetadata
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityPublicKeyWithMetadata.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityPublicKeyWithMetadata();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.publicKey = $root.api.IdentityPublicKey.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.created = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityPublicKeyWithMetadata message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityPublicKeyWithMetadata
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityPublicKeyWithMetadata} IdentityPublicKeyWithMetadata
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityPublicKeyWithMetadata.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityPublicKeyWithMetadata message.
         * @function verify
         * @memberof api.IdentityPublicKeyWithMetadata
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityPublicKeyWithMetadata.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.publicKey != null && message.hasOwnProperty("publicKey")) {
                var error = $root.api.IdentityPublicKey.verify(message.publicKey);
                if (error)
                    return "publicKey." + error;
            }
            if (message.created != null && message.hasOwnProperty("created"))
                if (!$util.isInteger(message.created) && !(message.created && $util.isInteger(message.created.low) && $util.isInteger(message.created.high)))
                    return "created: integer|Long expected";
            return null;
        };

        /**
         * Creates an IdentityPublicKeyWithMetadata message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityPublicKeyWithMetadata
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityPublicKeyWithMetadata} IdentityPublicKeyWithMetadata
         */
        IdentityPublicKeyWithMetadata.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityPublicKeyWithMetadata)
                return object;
            var message = new $root.api.IdentityPublicKeyWithMetadata();
            if (object.publicKey != null) {
                if (typeof object.publicKey !== "object")
                    throw TypeError(".api.IdentityPublicKeyWithMetadata.publicKey: object expected");
                message.publicKey = $root.api.IdentityPublicKey.fromObject(object.publicKey);
            }
            if (object.created != null)
                if ($util.Long)
                    (message.created = $util.Long.fromValue(object.created)).unsigned = false;
                else if (typeof object.created === "string")
                    message.created = parseInt(object.created, 10);
                else if (typeof object.created === "number")
                    message.created = object.created;
                else if (typeof object.created === "object")
                    message.created = new $util.LongBits(object.created.low >>> 0, object.created.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an IdentityPublicKeyWithMetadata message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityPublicKeyWithMetadata
         * @static
         * @param {api.IdentityPublicKeyWithMetadata} message IdentityPublicKeyWithMetadata
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityPublicKeyWithMetadata.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.publicKey = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.created = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.created = options.longs === String ? "0" : 0;
            }
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                object.publicKey = $root.api.IdentityPublicKey.toObject(message.publicKey, options);
            if (message.created != null && message.hasOwnProperty("created"))
                if (typeof message.created === "number")
                    object.created = options.longs === String ? String(message.created) : message.created;
                else
                    object.created = options.longs === String ? $util.Long.prototype.toString.call(message.created) : options.longs === Number ? new $util.LongBits(message.created.low >>> 0, message.created.high >>> 0).toNumber() : message.created;
            return object;
        };

        /**
         * Converts this IdentityPublicKeyWithMetadata to JSON.
         * @function toJSON
         * @memberof api.IdentityPublicKeyWithMetadata
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityPublicKeyWithMetadata.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityPublicKeyWithMetadata;
    })();

    api.IdentityPublicChain = (function() {

        /**
         * Properties of an IdentityPublicChain.
         * @memberof api
         * @interface IIdentityPublicChain
         * @property {string|null} [login] IdentityPublicChain login
         * @property {number|null} [version] IdentityPublicChain version
         * @property {Array.<api.IdentityPublicChain.IElt>|null} [chains] IdentityPublicChain chains
         */

        /**
         * Constructs a new IdentityPublicChain.
         * @memberof api
         * @classdesc Represents an IdentityPublicChain.
         * @implements IIdentityPublicChain
         * @constructor
         * @param {api.IIdentityPublicChain=} [properties] Properties to set
         */
        function IdentityPublicChain(properties) {
            this.chains = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityPublicChain login.
         * @member {string} login
         * @memberof api.IdentityPublicChain
         * @instance
         */
        IdentityPublicChain.prototype.login = "";

        /**
         * IdentityPublicChain version.
         * @member {number} version
         * @memberof api.IdentityPublicChain
         * @instance
         */
        IdentityPublicChain.prototype.version = 0;

        /**
         * IdentityPublicChain chains.
         * @member {Array.<api.IdentityPublicChain.IElt>} chains
         * @memberof api.IdentityPublicChain
         * @instance
         */
        IdentityPublicChain.prototype.chains = $util.emptyArray;

        /**
         * Creates a new IdentityPublicChain instance using the specified properties.
         * @function create
         * @memberof api.IdentityPublicChain
         * @static
         * @param {api.IIdentityPublicChain=} [properties] Properties to set
         * @returns {api.IdentityPublicChain} IdentityPublicChain instance
         */
        IdentityPublicChain.create = function create(properties) {
            return new IdentityPublicChain(properties);
        };

        /**
         * Encodes the specified IdentityPublicChain message. Does not implicitly {@link api.IdentityPublicChain.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityPublicChain
         * @static
         * @param {api.IIdentityPublicChain} message IdentityPublicChain message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityPublicChain.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            if (message.version != null && message.hasOwnProperty("version"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.version);
            if (message.chains != null && message.chains.length)
                for (var i = 0; i < message.chains.length; ++i)
                    $root.api.IdentityPublicChain.Elt.encode(message.chains[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IdentityPublicChain message, length delimited. Does not implicitly {@link api.IdentityPublicChain.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityPublicChain
         * @static
         * @param {api.IIdentityPublicChain} message IdentityPublicChain message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityPublicChain.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityPublicChain message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityPublicChain
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityPublicChain} IdentityPublicChain
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityPublicChain.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityPublicChain();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                case 2:
                    message.version = reader.uint32();
                    break;
                case 3:
                    if (!(message.chains && message.chains.length))
                        message.chains = [];
                    message.chains.push($root.api.IdentityPublicChain.Elt.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityPublicChain message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityPublicChain
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityPublicChain} IdentityPublicChain
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityPublicChain.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityPublicChain message.
         * @function verify
         * @memberof api.IdentityPublicChain
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityPublicChain.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isInteger(message.version))
                    return "version: integer expected";
            if (message.chains != null && message.hasOwnProperty("chains")) {
                if (!Array.isArray(message.chains))
                    return "chains: array expected";
                for (var i = 0; i < message.chains.length; ++i) {
                    var error = $root.api.IdentityPublicChain.Elt.verify(message.chains[i]);
                    if (error)
                        return "chains." + error;
                }
            }
            return null;
        };

        /**
         * Creates an IdentityPublicChain message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityPublicChain
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityPublicChain} IdentityPublicChain
         */
        IdentityPublicChain.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityPublicChain)
                return object;
            var message = new $root.api.IdentityPublicChain();
            if (object.login != null)
                message.login = String(object.login);
            if (object.version != null)
                message.version = object.version >>> 0;
            if (object.chains) {
                if (!Array.isArray(object.chains))
                    throw TypeError(".api.IdentityPublicChain.chains: array expected");
                message.chains = [];
                for (var i = 0; i < object.chains.length; ++i) {
                    if (typeof object.chains[i] !== "object")
                        throw TypeError(".api.IdentityPublicChain.chains: object expected");
                    message.chains[i] = $root.api.IdentityPublicChain.Elt.fromObject(object.chains[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an IdentityPublicChain message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityPublicChain
         * @static
         * @param {api.IdentityPublicChain} message IdentityPublicChain
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityPublicChain.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.chains = [];
            if (options.defaults) {
                object.login = "";
                object.version = 0;
            }
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            if (message.chains && message.chains.length) {
                object.chains = [];
                for (var j = 0; j < message.chains.length; ++j)
                    object.chains[j] = $root.api.IdentityPublicChain.Elt.toObject(message.chains[j], options);
            }
            return object;
        };

        /**
         * Converts this IdentityPublicChain to JSON.
         * @function toJSON
         * @memberof api.IdentityPublicChain
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityPublicChain.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        IdentityPublicChain.Elt = (function() {

            /**
             * Properties of an Elt.
             * @memberof api.IdentityPublicChain
             * @interface IElt
             * @property {Uint8Array|null} [sign] Elt sign
             * @property {Uint8Array|null} [box] Elt box
             * @property {Uint8Array|null} [chain] Elt chain
             * @property {api.IIdentityKeyID|null} [mandate] Elt mandate
             * @property {number|null} [version] Elt version
             */

            /**
             * Constructs a new Elt.
             * @memberof api.IdentityPublicChain
             * @classdesc Represents an Elt.
             * @implements IElt
             * @constructor
             * @param {api.IdentityPublicChain.IElt=} [properties] Properties to set
             */
            function Elt(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Elt sign.
             * @member {Uint8Array} sign
             * @memberof api.IdentityPublicChain.Elt
             * @instance
             */
            Elt.prototype.sign = $util.newBuffer([]);

            /**
             * Elt box.
             * @member {Uint8Array} box
             * @memberof api.IdentityPublicChain.Elt
             * @instance
             */
            Elt.prototype.box = $util.newBuffer([]);

            /**
             * Elt chain.
             * @member {Uint8Array} chain
             * @memberof api.IdentityPublicChain.Elt
             * @instance
             */
            Elt.prototype.chain = $util.newBuffer([]);

            /**
             * Elt mandate.
             * @member {api.IIdentityKeyID|null|undefined} mandate
             * @memberof api.IdentityPublicChain.Elt
             * @instance
             */
            Elt.prototype.mandate = null;

            /**
             * Elt version.
             * @member {number} version
             * @memberof api.IdentityPublicChain.Elt
             * @instance
             */
            Elt.prototype.version = 0;

            /**
             * Creates a new Elt instance using the specified properties.
             * @function create
             * @memberof api.IdentityPublicChain.Elt
             * @static
             * @param {api.IdentityPublicChain.IElt=} [properties] Properties to set
             * @returns {api.IdentityPublicChain.Elt} Elt instance
             */
            Elt.create = function create(properties) {
                return new Elt(properties);
            };

            /**
             * Encodes the specified Elt message. Does not implicitly {@link api.IdentityPublicChain.Elt.verify|verify} messages.
             * @function encode
             * @memberof api.IdentityPublicChain.Elt
             * @static
             * @param {api.IdentityPublicChain.IElt} message Elt message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Elt.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sign != null && message.hasOwnProperty("sign"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.sign);
                if (message.box != null && message.hasOwnProperty("box"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.box);
                if (message.chain != null && message.hasOwnProperty("chain"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.chain);
                if (message.mandate != null && message.hasOwnProperty("mandate"))
                    $root.api.IdentityKeyID.encode(message.mandate, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.version != null && message.hasOwnProperty("version"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.version);
                return writer;
            };

            /**
             * Encodes the specified Elt message, length delimited. Does not implicitly {@link api.IdentityPublicChain.Elt.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.IdentityPublicChain.Elt
             * @static
             * @param {api.IdentityPublicChain.IElt} message Elt message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Elt.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Elt message from the specified reader or buffer.
             * @function decode
             * @memberof api.IdentityPublicChain.Elt
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.IdentityPublicChain.Elt} Elt
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Elt.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityPublicChain.Elt();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.sign = reader.bytes();
                        break;
                    case 2:
                        message.box = reader.bytes();
                        break;
                    case 3:
                        message.chain = reader.bytes();
                        break;
                    case 4:
                        message.mandate = $root.api.IdentityKeyID.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.version = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Elt message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.IdentityPublicChain.Elt
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.IdentityPublicChain.Elt} Elt
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Elt.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Elt message.
             * @function verify
             * @memberof api.IdentityPublicChain.Elt
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Elt.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.sign != null && message.hasOwnProperty("sign"))
                    if (!(message.sign && typeof message.sign.length === "number" || $util.isString(message.sign)))
                        return "sign: buffer expected";
                if (message.box != null && message.hasOwnProperty("box"))
                    if (!(message.box && typeof message.box.length === "number" || $util.isString(message.box)))
                        return "box: buffer expected";
                if (message.chain != null && message.hasOwnProperty("chain"))
                    if (!(message.chain && typeof message.chain.length === "number" || $util.isString(message.chain)))
                        return "chain: buffer expected";
                if (message.mandate != null && message.hasOwnProperty("mandate")) {
                    var error = $root.api.IdentityKeyID.verify(message.mandate);
                    if (error)
                        return "mandate." + error;
                }
                if (message.version != null && message.hasOwnProperty("version"))
                    if (!$util.isInteger(message.version))
                        return "version: integer expected";
                return null;
            };

            /**
             * Creates an Elt message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.IdentityPublicChain.Elt
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.IdentityPublicChain.Elt} Elt
             */
            Elt.fromObject = function fromObject(object) {
                if (object instanceof $root.api.IdentityPublicChain.Elt)
                    return object;
                var message = new $root.api.IdentityPublicChain.Elt();
                if (object.sign != null)
                    if (typeof object.sign === "string")
                        $util.base64.decode(object.sign, message.sign = $util.newBuffer($util.base64.length(object.sign)), 0);
                    else if (object.sign.length)
                        message.sign = object.sign;
                if (object.box != null)
                    if (typeof object.box === "string")
                        $util.base64.decode(object.box, message.box = $util.newBuffer($util.base64.length(object.box)), 0);
                    else if (object.box.length)
                        message.box = object.box;
                if (object.chain != null)
                    if (typeof object.chain === "string")
                        $util.base64.decode(object.chain, message.chain = $util.newBuffer($util.base64.length(object.chain)), 0);
                    else if (object.chain.length)
                        message.chain = object.chain;
                if (object.mandate != null) {
                    if (typeof object.mandate !== "object")
                        throw TypeError(".api.IdentityPublicChain.Elt.mandate: object expected");
                    message.mandate = $root.api.IdentityKeyID.fromObject(object.mandate);
                }
                if (object.version != null)
                    message.version = object.version >>> 0;
                return message;
            };

            /**
             * Creates a plain object from an Elt message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.IdentityPublicChain.Elt
             * @static
             * @param {api.IdentityPublicChain.Elt} message Elt
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Elt.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.sign = "";
                    else {
                        object.sign = [];
                        if (options.bytes !== Array)
                            object.sign = $util.newBuffer(object.sign);
                    }
                    if (options.bytes === String)
                        object.box = "";
                    else {
                        object.box = [];
                        if (options.bytes !== Array)
                            object.box = $util.newBuffer(object.box);
                    }
                    if (options.bytes === String)
                        object.chain = "";
                    else {
                        object.chain = [];
                        if (options.bytes !== Array)
                            object.chain = $util.newBuffer(object.chain);
                    }
                    object.mandate = null;
                    object.version = 0;
                }
                if (message.sign != null && message.hasOwnProperty("sign"))
                    object.sign = options.bytes === String ? $util.base64.encode(message.sign, 0, message.sign.length) : options.bytes === Array ? Array.prototype.slice.call(message.sign) : message.sign;
                if (message.box != null && message.hasOwnProperty("box"))
                    object.box = options.bytes === String ? $util.base64.encode(message.box, 0, message.box.length) : options.bytes === Array ? Array.prototype.slice.call(message.box) : message.box;
                if (message.chain != null && message.hasOwnProperty("chain"))
                    object.chain = options.bytes === String ? $util.base64.encode(message.chain, 0, message.chain.length) : options.bytes === Array ? Array.prototype.slice.call(message.chain) : message.chain;
                if (message.mandate != null && message.hasOwnProperty("mandate"))
                    object.mandate = $root.api.IdentityKeyID.toObject(message.mandate, options);
                if (message.version != null && message.hasOwnProperty("version"))
                    object.version = message.version;
                return object;
            };

            /**
             * Converts this Elt to JSON.
             * @function toJSON
             * @memberof api.IdentityPublicChain.Elt
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Elt.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Elt;
        })();

        return IdentityPublicChain;
    })();

    api.IdentityEncryptedKey = (function() {

        /**
         * Properties of an IdentityEncryptedKey.
         * @memberof api
         * @interface IIdentityEncryptedKey
         * @property {Uint8Array|null} [nonce] IdentityEncryptedKey nonce
         * @property {Uint8Array|null} [publicKey] IdentityEncryptedKey publicKey
         * @property {Uint8Array|null} [encryptedKey] IdentityEncryptedKey encryptedKey
         */

        /**
         * Constructs a new IdentityEncryptedKey.
         * @memberof api
         * @classdesc Represents an IdentityEncryptedKey.
         * @implements IIdentityEncryptedKey
         * @constructor
         * @param {api.IIdentityEncryptedKey=} [properties] Properties to set
         */
        function IdentityEncryptedKey(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityEncryptedKey nonce.
         * @member {Uint8Array} nonce
         * @memberof api.IdentityEncryptedKey
         * @instance
         */
        IdentityEncryptedKey.prototype.nonce = $util.newBuffer([]);

        /**
         * IdentityEncryptedKey publicKey.
         * @member {Uint8Array} publicKey
         * @memberof api.IdentityEncryptedKey
         * @instance
         */
        IdentityEncryptedKey.prototype.publicKey = $util.newBuffer([]);

        /**
         * IdentityEncryptedKey encryptedKey.
         * @member {Uint8Array} encryptedKey
         * @memberof api.IdentityEncryptedKey
         * @instance
         */
        IdentityEncryptedKey.prototype.encryptedKey = $util.newBuffer([]);

        /**
         * Creates a new IdentityEncryptedKey instance using the specified properties.
         * @function create
         * @memberof api.IdentityEncryptedKey
         * @static
         * @param {api.IIdentityEncryptedKey=} [properties] Properties to set
         * @returns {api.IdentityEncryptedKey} IdentityEncryptedKey instance
         */
        IdentityEncryptedKey.create = function create(properties) {
            return new IdentityEncryptedKey(properties);
        };

        /**
         * Encodes the specified IdentityEncryptedKey message. Does not implicitly {@link api.IdentityEncryptedKey.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityEncryptedKey
         * @static
         * @param {api.IIdentityEncryptedKey} message IdentityEncryptedKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityEncryptedKey.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.nonce);
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.publicKey);
            if (message.encryptedKey != null && message.hasOwnProperty("encryptedKey"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.encryptedKey);
            return writer;
        };

        /**
         * Encodes the specified IdentityEncryptedKey message, length delimited. Does not implicitly {@link api.IdentityEncryptedKey.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityEncryptedKey
         * @static
         * @param {api.IIdentityEncryptedKey} message IdentityEncryptedKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityEncryptedKey.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityEncryptedKey message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityEncryptedKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityEncryptedKey} IdentityEncryptedKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityEncryptedKey.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityEncryptedKey();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.nonce = reader.bytes();
                    break;
                case 2:
                    message.publicKey = reader.bytes();
                    break;
                case 3:
                    message.encryptedKey = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityEncryptedKey message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityEncryptedKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityEncryptedKey} IdentityEncryptedKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityEncryptedKey.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityEncryptedKey message.
         * @function verify
         * @memberof api.IdentityEncryptedKey
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityEncryptedKey.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                if (!(message.nonce && typeof message.nonce.length === "number" || $util.isString(message.nonce)))
                    return "nonce: buffer expected";
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                if (!(message.publicKey && typeof message.publicKey.length === "number" || $util.isString(message.publicKey)))
                    return "publicKey: buffer expected";
            if (message.encryptedKey != null && message.hasOwnProperty("encryptedKey"))
                if (!(message.encryptedKey && typeof message.encryptedKey.length === "number" || $util.isString(message.encryptedKey)))
                    return "encryptedKey: buffer expected";
            return null;
        };

        /**
         * Creates an IdentityEncryptedKey message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityEncryptedKey
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityEncryptedKey} IdentityEncryptedKey
         */
        IdentityEncryptedKey.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityEncryptedKey)
                return object;
            var message = new $root.api.IdentityEncryptedKey();
            if (object.nonce != null)
                if (typeof object.nonce === "string")
                    $util.base64.decode(object.nonce, message.nonce = $util.newBuffer($util.base64.length(object.nonce)), 0);
                else if (object.nonce.length)
                    message.nonce = object.nonce;
            if (object.publicKey != null)
                if (typeof object.publicKey === "string")
                    $util.base64.decode(object.publicKey, message.publicKey = $util.newBuffer($util.base64.length(object.publicKey)), 0);
                else if (object.publicKey.length)
                    message.publicKey = object.publicKey;
            if (object.encryptedKey != null)
                if (typeof object.encryptedKey === "string")
                    $util.base64.decode(object.encryptedKey, message.encryptedKey = $util.newBuffer($util.base64.length(object.encryptedKey)), 0);
                else if (object.encryptedKey.length)
                    message.encryptedKey = object.encryptedKey;
            return message;
        };

        /**
         * Creates a plain object from an IdentityEncryptedKey message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityEncryptedKey
         * @static
         * @param {api.IdentityEncryptedKey} message IdentityEncryptedKey
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityEncryptedKey.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.nonce = "";
                else {
                    object.nonce = [];
                    if (options.bytes !== Array)
                        object.nonce = $util.newBuffer(object.nonce);
                }
                if (options.bytes === String)
                    object.publicKey = "";
                else {
                    object.publicKey = [];
                    if (options.bytes !== Array)
                        object.publicKey = $util.newBuffer(object.publicKey);
                }
                if (options.bytes === String)
                    object.encryptedKey = "";
                else {
                    object.encryptedKey = [];
                    if (options.bytes !== Array)
                        object.encryptedKey = $util.newBuffer(object.encryptedKey);
                }
            }
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                object.nonce = options.bytes === String ? $util.base64.encode(message.nonce, 0, message.nonce.length) : options.bytes === Array ? Array.prototype.slice.call(message.nonce) : message.nonce;
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                object.publicKey = options.bytes === String ? $util.base64.encode(message.publicKey, 0, message.publicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.publicKey) : message.publicKey;
            if (message.encryptedKey != null && message.hasOwnProperty("encryptedKey"))
                object.encryptedKey = options.bytes === String ? $util.base64.encode(message.encryptedKey, 0, message.encryptedKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedKey) : message.encryptedKey;
            return object;
        };

        /**
         * Converts this IdentityEncryptedKey to JSON.
         * @function toJSON
         * @memberof api.IdentityEncryptedKey
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityEncryptedKey.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityEncryptedKey;
    })();

    api.IdentityEncryptedKeySet = (function() {

        /**
         * Properties of an IdentityEncryptedKeySet.
         * @memberof api
         * @interface IIdentityEncryptedKeySet
         * @property {number|null} [version] IdentityEncryptedKeySet version
         * @property {Uint8Array|null} [masterSalt] IdentityEncryptedKeySet masterSalt
         * @property {Uint8Array|null} [masterPublicKey] IdentityEncryptedKeySet masterPublicKey
         * @property {api.IIdentityEncryptedKey|null} [sharingEncrypted] IdentityEncryptedKeySet sharingEncrypted
         * @property {api.IIdentityEncryptedKey|null} [boxEncrypted] IdentityEncryptedKeySet boxEncrypted
         * @property {api.IIdentityEncryptedKey|null} [signEncrypted] IdentityEncryptedKeySet signEncrypted
         * @property {api.IIdentityEncryptedKey|null} [readEncrypted] IdentityEncryptedKeySet readEncrypted
         */

        /**
         * Constructs a new IdentityEncryptedKeySet.
         * @memberof api
         * @classdesc Represents an IdentityEncryptedKeySet.
         * @implements IIdentityEncryptedKeySet
         * @constructor
         * @param {api.IIdentityEncryptedKeySet=} [properties] Properties to set
         */
        function IdentityEncryptedKeySet(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityEncryptedKeySet version.
         * @member {number} version
         * @memberof api.IdentityEncryptedKeySet
         * @instance
         */
        IdentityEncryptedKeySet.prototype.version = 0;

        /**
         * IdentityEncryptedKeySet masterSalt.
         * @member {Uint8Array} masterSalt
         * @memberof api.IdentityEncryptedKeySet
         * @instance
         */
        IdentityEncryptedKeySet.prototype.masterSalt = $util.newBuffer([]);

        /**
         * IdentityEncryptedKeySet masterPublicKey.
         * @member {Uint8Array} masterPublicKey
         * @memberof api.IdentityEncryptedKeySet
         * @instance
         */
        IdentityEncryptedKeySet.prototype.masterPublicKey = $util.newBuffer([]);

        /**
         * IdentityEncryptedKeySet sharingEncrypted.
         * @member {api.IIdentityEncryptedKey|null|undefined} sharingEncrypted
         * @memberof api.IdentityEncryptedKeySet
         * @instance
         */
        IdentityEncryptedKeySet.prototype.sharingEncrypted = null;

        /**
         * IdentityEncryptedKeySet boxEncrypted.
         * @member {api.IIdentityEncryptedKey|null|undefined} boxEncrypted
         * @memberof api.IdentityEncryptedKeySet
         * @instance
         */
        IdentityEncryptedKeySet.prototype.boxEncrypted = null;

        /**
         * IdentityEncryptedKeySet signEncrypted.
         * @member {api.IIdentityEncryptedKey|null|undefined} signEncrypted
         * @memberof api.IdentityEncryptedKeySet
         * @instance
         */
        IdentityEncryptedKeySet.prototype.signEncrypted = null;

        /**
         * IdentityEncryptedKeySet readEncrypted.
         * @member {api.IIdentityEncryptedKey|null|undefined} readEncrypted
         * @memberof api.IdentityEncryptedKeySet
         * @instance
         */
        IdentityEncryptedKeySet.prototype.readEncrypted = null;

        /**
         * Creates a new IdentityEncryptedKeySet instance using the specified properties.
         * @function create
         * @memberof api.IdentityEncryptedKeySet
         * @static
         * @param {api.IIdentityEncryptedKeySet=} [properties] Properties to set
         * @returns {api.IdentityEncryptedKeySet} IdentityEncryptedKeySet instance
         */
        IdentityEncryptedKeySet.create = function create(properties) {
            return new IdentityEncryptedKeySet(properties);
        };

        /**
         * Encodes the specified IdentityEncryptedKeySet message. Does not implicitly {@link api.IdentityEncryptedKeySet.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityEncryptedKeySet
         * @static
         * @param {api.IIdentityEncryptedKeySet} message IdentityEncryptedKeySet message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityEncryptedKeySet.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.version != null && message.hasOwnProperty("version"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.version);
            if (message.masterSalt != null && message.hasOwnProperty("masterSalt"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.masterSalt);
            if (message.masterPublicKey != null && message.hasOwnProperty("masterPublicKey"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.masterPublicKey);
            if (message.sharingEncrypted != null && message.hasOwnProperty("sharingEncrypted"))
                $root.api.IdentityEncryptedKey.encode(message.sharingEncrypted, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.boxEncrypted != null && message.hasOwnProperty("boxEncrypted"))
                $root.api.IdentityEncryptedKey.encode(message.boxEncrypted, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.signEncrypted != null && message.hasOwnProperty("signEncrypted"))
                $root.api.IdentityEncryptedKey.encode(message.signEncrypted, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.readEncrypted != null && message.hasOwnProperty("readEncrypted"))
                $root.api.IdentityEncryptedKey.encode(message.readEncrypted, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IdentityEncryptedKeySet message, length delimited. Does not implicitly {@link api.IdentityEncryptedKeySet.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityEncryptedKeySet
         * @static
         * @param {api.IIdentityEncryptedKeySet} message IdentityEncryptedKeySet message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityEncryptedKeySet.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityEncryptedKeySet message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityEncryptedKeySet
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityEncryptedKeySet} IdentityEncryptedKeySet
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityEncryptedKeySet.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityEncryptedKeySet();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.version = reader.uint32();
                    break;
                case 2:
                    message.masterSalt = reader.bytes();
                    break;
                case 3:
                    message.masterPublicKey = reader.bytes();
                    break;
                case 4:
                    message.sharingEncrypted = $root.api.IdentityEncryptedKey.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.boxEncrypted = $root.api.IdentityEncryptedKey.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.signEncrypted = $root.api.IdentityEncryptedKey.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.readEncrypted = $root.api.IdentityEncryptedKey.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityEncryptedKeySet message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityEncryptedKeySet
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityEncryptedKeySet} IdentityEncryptedKeySet
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityEncryptedKeySet.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityEncryptedKeySet message.
         * @function verify
         * @memberof api.IdentityEncryptedKeySet
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityEncryptedKeySet.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isInteger(message.version))
                    return "version: integer expected";
            if (message.masterSalt != null && message.hasOwnProperty("masterSalt"))
                if (!(message.masterSalt && typeof message.masterSalt.length === "number" || $util.isString(message.masterSalt)))
                    return "masterSalt: buffer expected";
            if (message.masterPublicKey != null && message.hasOwnProperty("masterPublicKey"))
                if (!(message.masterPublicKey && typeof message.masterPublicKey.length === "number" || $util.isString(message.masterPublicKey)))
                    return "masterPublicKey: buffer expected";
            if (message.sharingEncrypted != null && message.hasOwnProperty("sharingEncrypted")) {
                var error = $root.api.IdentityEncryptedKey.verify(message.sharingEncrypted);
                if (error)
                    return "sharingEncrypted." + error;
            }
            if (message.boxEncrypted != null && message.hasOwnProperty("boxEncrypted")) {
                var error = $root.api.IdentityEncryptedKey.verify(message.boxEncrypted);
                if (error)
                    return "boxEncrypted." + error;
            }
            if (message.signEncrypted != null && message.hasOwnProperty("signEncrypted")) {
                var error = $root.api.IdentityEncryptedKey.verify(message.signEncrypted);
                if (error)
                    return "signEncrypted." + error;
            }
            if (message.readEncrypted != null && message.hasOwnProperty("readEncrypted")) {
                var error = $root.api.IdentityEncryptedKey.verify(message.readEncrypted);
                if (error)
                    return "readEncrypted." + error;
            }
            return null;
        };

        /**
         * Creates an IdentityEncryptedKeySet message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityEncryptedKeySet
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityEncryptedKeySet} IdentityEncryptedKeySet
         */
        IdentityEncryptedKeySet.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityEncryptedKeySet)
                return object;
            var message = new $root.api.IdentityEncryptedKeySet();
            if (object.version != null)
                message.version = object.version >>> 0;
            if (object.masterSalt != null)
                if (typeof object.masterSalt === "string")
                    $util.base64.decode(object.masterSalt, message.masterSalt = $util.newBuffer($util.base64.length(object.masterSalt)), 0);
                else if (object.masterSalt.length)
                    message.masterSalt = object.masterSalt;
            if (object.masterPublicKey != null)
                if (typeof object.masterPublicKey === "string")
                    $util.base64.decode(object.masterPublicKey, message.masterPublicKey = $util.newBuffer($util.base64.length(object.masterPublicKey)), 0);
                else if (object.masterPublicKey.length)
                    message.masterPublicKey = object.masterPublicKey;
            if (object.sharingEncrypted != null) {
                if (typeof object.sharingEncrypted !== "object")
                    throw TypeError(".api.IdentityEncryptedKeySet.sharingEncrypted: object expected");
                message.sharingEncrypted = $root.api.IdentityEncryptedKey.fromObject(object.sharingEncrypted);
            }
            if (object.boxEncrypted != null) {
                if (typeof object.boxEncrypted !== "object")
                    throw TypeError(".api.IdentityEncryptedKeySet.boxEncrypted: object expected");
                message.boxEncrypted = $root.api.IdentityEncryptedKey.fromObject(object.boxEncrypted);
            }
            if (object.signEncrypted != null) {
                if (typeof object.signEncrypted !== "object")
                    throw TypeError(".api.IdentityEncryptedKeySet.signEncrypted: object expected");
                message.signEncrypted = $root.api.IdentityEncryptedKey.fromObject(object.signEncrypted);
            }
            if (object.readEncrypted != null) {
                if (typeof object.readEncrypted !== "object")
                    throw TypeError(".api.IdentityEncryptedKeySet.readEncrypted: object expected");
                message.readEncrypted = $root.api.IdentityEncryptedKey.fromObject(object.readEncrypted);
            }
            return message;
        };

        /**
         * Creates a plain object from an IdentityEncryptedKeySet message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityEncryptedKeySet
         * @static
         * @param {api.IdentityEncryptedKeySet} message IdentityEncryptedKeySet
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityEncryptedKeySet.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.version = 0;
                if (options.bytes === String)
                    object.masterSalt = "";
                else {
                    object.masterSalt = [];
                    if (options.bytes !== Array)
                        object.masterSalt = $util.newBuffer(object.masterSalt);
                }
                if (options.bytes === String)
                    object.masterPublicKey = "";
                else {
                    object.masterPublicKey = [];
                    if (options.bytes !== Array)
                        object.masterPublicKey = $util.newBuffer(object.masterPublicKey);
                }
                object.sharingEncrypted = null;
                object.boxEncrypted = null;
                object.signEncrypted = null;
                object.readEncrypted = null;
            }
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            if (message.masterSalt != null && message.hasOwnProperty("masterSalt"))
                object.masterSalt = options.bytes === String ? $util.base64.encode(message.masterSalt, 0, message.masterSalt.length) : options.bytes === Array ? Array.prototype.slice.call(message.masterSalt) : message.masterSalt;
            if (message.masterPublicKey != null && message.hasOwnProperty("masterPublicKey"))
                object.masterPublicKey = options.bytes === String ? $util.base64.encode(message.masterPublicKey, 0, message.masterPublicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.masterPublicKey) : message.masterPublicKey;
            if (message.sharingEncrypted != null && message.hasOwnProperty("sharingEncrypted"))
                object.sharingEncrypted = $root.api.IdentityEncryptedKey.toObject(message.sharingEncrypted, options);
            if (message.boxEncrypted != null && message.hasOwnProperty("boxEncrypted"))
                object.boxEncrypted = $root.api.IdentityEncryptedKey.toObject(message.boxEncrypted, options);
            if (message.signEncrypted != null && message.hasOwnProperty("signEncrypted"))
                object.signEncrypted = $root.api.IdentityEncryptedKey.toObject(message.signEncrypted, options);
            if (message.readEncrypted != null && message.hasOwnProperty("readEncrypted"))
                object.readEncrypted = $root.api.IdentityEncryptedKey.toObject(message.readEncrypted, options);
            return object;
        };

        /**
         * Converts this IdentityEncryptedKeySet to JSON.
         * @function toJSON
         * @memberof api.IdentityEncryptedKeySet
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityEncryptedKeySet.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityEncryptedKeySet;
    })();

    /**
     * IdentityShareKind enum.
     * @name api.IdentityShareKind
     * @enum {string}
     * @property {number} BOX=0 BOX value
     * @property {number} SHARING=1 SHARING value
     */
    api.IdentityShareKind = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "BOX"] = 0;
        values[valuesById[1] = "SHARING"] = 1;
        return values;
    })();

    /**
     * IdentityAccessKeyKind enum.
     * @name api.IdentityAccessKeyKind
     * @enum {string}
     * @property {number} READ=0 READ value
     * @property {number} WRITE=1 WRITE value
     */
    api.IdentityAccessKeyKind = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "READ"] = 0;
        values[valuesById[1] = "WRITE"] = 1;
        return values;
    })();

    api.ApplicationIdentity = (function() {

        /**
         * Properties of an ApplicationIdentity.
         * @memberof api
         * @interface IApplicationIdentity
         * @property {api.IIdentity|null} [identity] ApplicationIdentity identity
         * @property {api.IIdentityExternalAuth|null} [auth] ApplicationIdentity auth
         */

        /**
         * Constructs a new ApplicationIdentity.
         * @memberof api
         * @classdesc Represents an ApplicationIdentity.
         * @implements IApplicationIdentity
         * @constructor
         * @param {api.IApplicationIdentity=} [properties] Properties to set
         */
        function ApplicationIdentity(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ApplicationIdentity identity.
         * @member {api.IIdentity|null|undefined} identity
         * @memberof api.ApplicationIdentity
         * @instance
         */
        ApplicationIdentity.prototype.identity = null;

        /**
         * ApplicationIdentity auth.
         * @member {api.IIdentityExternalAuth|null|undefined} auth
         * @memberof api.ApplicationIdentity
         * @instance
         */
        ApplicationIdentity.prototype.auth = null;

        /**
         * Creates a new ApplicationIdentity instance using the specified properties.
         * @function create
         * @memberof api.ApplicationIdentity
         * @static
         * @param {api.IApplicationIdentity=} [properties] Properties to set
         * @returns {api.ApplicationIdentity} ApplicationIdentity instance
         */
        ApplicationIdentity.create = function create(properties) {
            return new ApplicationIdentity(properties);
        };

        /**
         * Encodes the specified ApplicationIdentity message. Does not implicitly {@link api.ApplicationIdentity.verify|verify} messages.
         * @function encode
         * @memberof api.ApplicationIdentity
         * @static
         * @param {api.IApplicationIdentity} message ApplicationIdentity message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApplicationIdentity.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.identity != null && message.hasOwnProperty("identity"))
                $root.api.Identity.encode(message.identity, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.auth != null && message.hasOwnProperty("auth"))
                $root.api.IdentityExternalAuth.encode(message.auth, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ApplicationIdentity message, length delimited. Does not implicitly {@link api.ApplicationIdentity.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.ApplicationIdentity
         * @static
         * @param {api.IApplicationIdentity} message ApplicationIdentity message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApplicationIdentity.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ApplicationIdentity message from the specified reader or buffer.
         * @function decode
         * @memberof api.ApplicationIdentity
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.ApplicationIdentity} ApplicationIdentity
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApplicationIdentity.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ApplicationIdentity();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.identity = $root.api.Identity.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.auth = $root.api.IdentityExternalAuth.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ApplicationIdentity message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.ApplicationIdentity
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.ApplicationIdentity} ApplicationIdentity
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApplicationIdentity.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ApplicationIdentity message.
         * @function verify
         * @memberof api.ApplicationIdentity
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ApplicationIdentity.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.identity != null && message.hasOwnProperty("identity")) {
                var error = $root.api.Identity.verify(message.identity);
                if (error)
                    return "identity." + error;
            }
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.api.IdentityExternalAuth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            return null;
        };

        /**
         * Creates an ApplicationIdentity message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.ApplicationIdentity
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.ApplicationIdentity} ApplicationIdentity
         */
        ApplicationIdentity.fromObject = function fromObject(object) {
            if (object instanceof $root.api.ApplicationIdentity)
                return object;
            var message = new $root.api.ApplicationIdentity();
            if (object.identity != null) {
                if (typeof object.identity !== "object")
                    throw TypeError(".api.ApplicationIdentity.identity: object expected");
                message.identity = $root.api.Identity.fromObject(object.identity);
            }
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".api.ApplicationIdentity.auth: object expected");
                message.auth = $root.api.IdentityExternalAuth.fromObject(object.auth);
            }
            return message;
        };

        /**
         * Creates a plain object from an ApplicationIdentity message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.ApplicationIdentity
         * @static
         * @param {api.ApplicationIdentity} message ApplicationIdentity
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ApplicationIdentity.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.identity = null;
                object.auth = null;
            }
            if (message.identity != null && message.hasOwnProperty("identity"))
                object.identity = $root.api.Identity.toObject(message.identity, options);
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.api.IdentityExternalAuth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this ApplicationIdentity to JSON.
         * @function toJSON
         * @memberof api.ApplicationIdentity
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ApplicationIdentity.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ApplicationIdentity;
    })();

    api.IdentityRegisterRequest = (function() {

        /**
         * Properties of an IdentityRegisterRequest.
         * @memberof api
         * @interface IIdentityRegisterRequest
         * @property {api.IIdentityFields|null} [identity] IdentityRegisterRequest identity
         * @property {api.IIdentityEncryptedKeySet|null} [encryption] IdentityRegisterRequest encryption
         */

        /**
         * Constructs a new IdentityRegisterRequest.
         * @memberof api
         * @classdesc Represents an IdentityRegisterRequest.
         * @implements IIdentityRegisterRequest
         * @constructor
         * @param {api.IIdentityRegisterRequest=} [properties] Properties to set
         */
        function IdentityRegisterRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityRegisterRequest identity.
         * @member {api.IIdentityFields|null|undefined} identity
         * @memberof api.IdentityRegisterRequest
         * @instance
         */
        IdentityRegisterRequest.prototype.identity = null;

        /**
         * IdentityRegisterRequest encryption.
         * @member {api.IIdentityEncryptedKeySet|null|undefined} encryption
         * @memberof api.IdentityRegisterRequest
         * @instance
         */
        IdentityRegisterRequest.prototype.encryption = null;

        /**
         * Creates a new IdentityRegisterRequest instance using the specified properties.
         * @function create
         * @memberof api.IdentityRegisterRequest
         * @static
         * @param {api.IIdentityRegisterRequest=} [properties] Properties to set
         * @returns {api.IdentityRegisterRequest} IdentityRegisterRequest instance
         */
        IdentityRegisterRequest.create = function create(properties) {
            return new IdentityRegisterRequest(properties);
        };

        /**
         * Encodes the specified IdentityRegisterRequest message. Does not implicitly {@link api.IdentityRegisterRequest.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityRegisterRequest
         * @static
         * @param {api.IIdentityRegisterRequest} message IdentityRegisterRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityRegisterRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.identity != null && message.hasOwnProperty("identity"))
                $root.api.IdentityFields.encode(message.identity, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.encryption != null && message.hasOwnProperty("encryption"))
                $root.api.IdentityEncryptedKeySet.encode(message.encryption, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IdentityRegisterRequest message, length delimited. Does not implicitly {@link api.IdentityRegisterRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityRegisterRequest
         * @static
         * @param {api.IIdentityRegisterRequest} message IdentityRegisterRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityRegisterRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityRegisterRequest message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityRegisterRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityRegisterRequest} IdentityRegisterRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityRegisterRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityRegisterRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.identity = $root.api.IdentityFields.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.encryption = $root.api.IdentityEncryptedKeySet.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityRegisterRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityRegisterRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityRegisterRequest} IdentityRegisterRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityRegisterRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityRegisterRequest message.
         * @function verify
         * @memberof api.IdentityRegisterRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityRegisterRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.identity != null && message.hasOwnProperty("identity")) {
                var error = $root.api.IdentityFields.verify(message.identity);
                if (error)
                    return "identity." + error;
            }
            if (message.encryption != null && message.hasOwnProperty("encryption")) {
                var error = $root.api.IdentityEncryptedKeySet.verify(message.encryption);
                if (error)
                    return "encryption." + error;
            }
            return null;
        };

        /**
         * Creates an IdentityRegisterRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityRegisterRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityRegisterRequest} IdentityRegisterRequest
         */
        IdentityRegisterRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityRegisterRequest)
                return object;
            var message = new $root.api.IdentityRegisterRequest();
            if (object.identity != null) {
                if (typeof object.identity !== "object")
                    throw TypeError(".api.IdentityRegisterRequest.identity: object expected");
                message.identity = $root.api.IdentityFields.fromObject(object.identity);
            }
            if (object.encryption != null) {
                if (typeof object.encryption !== "object")
                    throw TypeError(".api.IdentityRegisterRequest.encryption: object expected");
                message.encryption = $root.api.IdentityEncryptedKeySet.fromObject(object.encryption);
            }
            return message;
        };

        /**
         * Creates a plain object from an IdentityRegisterRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityRegisterRequest
         * @static
         * @param {api.IdentityRegisterRequest} message IdentityRegisterRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityRegisterRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.identity = null;
                object.encryption = null;
            }
            if (message.identity != null && message.hasOwnProperty("identity"))
                object.identity = $root.api.IdentityFields.toObject(message.identity, options);
            if (message.encryption != null && message.hasOwnProperty("encryption"))
                object.encryption = $root.api.IdentityEncryptedKeySet.toObject(message.encryption, options);
            return object;
        };

        /**
         * Converts this IdentityRegisterRequest to JSON.
         * @function toJSON
         * @memberof api.IdentityRegisterRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityRegisterRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityRegisterRequest;
    })();

    api.IdentityGetRequest = (function() {

        /**
         * Properties of an IdentityGetRequest.
         * @memberof api
         * @interface IIdentityGetRequest
         * @property {string|null} [login] IdentityGetRequest login
         */

        /**
         * Constructs a new IdentityGetRequest.
         * @memberof api
         * @classdesc Represents an IdentityGetRequest.
         * @implements IIdentityGetRequest
         * @constructor
         * @param {api.IIdentityGetRequest=} [properties] Properties to set
         */
        function IdentityGetRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityGetRequest login.
         * @member {string} login
         * @memberof api.IdentityGetRequest
         * @instance
         */
        IdentityGetRequest.prototype.login = "";

        /**
         * Creates a new IdentityGetRequest instance using the specified properties.
         * @function create
         * @memberof api.IdentityGetRequest
         * @static
         * @param {api.IIdentityGetRequest=} [properties] Properties to set
         * @returns {api.IdentityGetRequest} IdentityGetRequest instance
         */
        IdentityGetRequest.create = function create(properties) {
            return new IdentityGetRequest(properties);
        };

        /**
         * Encodes the specified IdentityGetRequest message. Does not implicitly {@link api.IdentityGetRequest.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityGetRequest
         * @static
         * @param {api.IIdentityGetRequest} message IdentityGetRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            return writer;
        };

        /**
         * Encodes the specified IdentityGetRequest message, length delimited. Does not implicitly {@link api.IdentityGetRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityGetRequest
         * @static
         * @param {api.IIdentityGetRequest} message IdentityGetRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityGetRequest message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityGetRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityGetRequest} IdentityGetRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityGetRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityGetRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityGetRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityGetRequest} IdentityGetRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityGetRequest message.
         * @function verify
         * @memberof api.IdentityGetRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityGetRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            return null;
        };

        /**
         * Creates an IdentityGetRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityGetRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityGetRequest} IdentityGetRequest
         */
        IdentityGetRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityGetRequest)
                return object;
            var message = new $root.api.IdentityGetRequest();
            if (object.login != null)
                message.login = String(object.login);
            return message;
        };

        /**
         * Creates a plain object from an IdentityGetRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityGetRequest
         * @static
         * @param {api.IdentityGetRequest} message IdentityGetRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityGetRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.login = "";
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            return object;
        };

        /**
         * Converts this IdentityGetRequest to JSON.
         * @function toJSON
         * @memberof api.IdentityGetRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityGetRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityGetRequest;
    })();

    api.IdentityExternalAuth = (function() {

        /**
         * Properties of an IdentityExternalAuth.
         * @memberof api
         * @interface IIdentityExternalAuth
         * @property {api.IdentityExternalAuth.IJWT|null} [jwt] IdentityExternalAuth jwt
         */

        /**
         * Constructs a new IdentityExternalAuth.
         * @memberof api
         * @classdesc Represents an IdentityExternalAuth.
         * @implements IIdentityExternalAuth
         * @constructor
         * @param {api.IIdentityExternalAuth=} [properties] Properties to set
         */
        function IdentityExternalAuth(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityExternalAuth jwt.
         * @member {api.IdentityExternalAuth.IJWT|null|undefined} jwt
         * @memberof api.IdentityExternalAuth
         * @instance
         */
        IdentityExternalAuth.prototype.jwt = null;

        /**
         * Creates a new IdentityExternalAuth instance using the specified properties.
         * @function create
         * @memberof api.IdentityExternalAuth
         * @static
         * @param {api.IIdentityExternalAuth=} [properties] Properties to set
         * @returns {api.IdentityExternalAuth} IdentityExternalAuth instance
         */
        IdentityExternalAuth.create = function create(properties) {
            return new IdentityExternalAuth(properties);
        };

        /**
         * Encodes the specified IdentityExternalAuth message. Does not implicitly {@link api.IdentityExternalAuth.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityExternalAuth
         * @static
         * @param {api.IIdentityExternalAuth} message IdentityExternalAuth message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityExternalAuth.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.jwt != null && message.hasOwnProperty("jwt"))
                $root.api.IdentityExternalAuth.JWT.encode(message.jwt, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IdentityExternalAuth message, length delimited. Does not implicitly {@link api.IdentityExternalAuth.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityExternalAuth
         * @static
         * @param {api.IIdentityExternalAuth} message IdentityExternalAuth message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityExternalAuth.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityExternalAuth message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityExternalAuth
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityExternalAuth} IdentityExternalAuth
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityExternalAuth.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityExternalAuth();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.jwt = $root.api.IdentityExternalAuth.JWT.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityExternalAuth message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityExternalAuth
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityExternalAuth} IdentityExternalAuth
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityExternalAuth.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityExternalAuth message.
         * @function verify
         * @memberof api.IdentityExternalAuth
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityExternalAuth.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.jwt != null && message.hasOwnProperty("jwt")) {
                var error = $root.api.IdentityExternalAuth.JWT.verify(message.jwt);
                if (error)
                    return "jwt." + error;
            }
            return null;
        };

        /**
         * Creates an IdentityExternalAuth message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityExternalAuth
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityExternalAuth} IdentityExternalAuth
         */
        IdentityExternalAuth.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityExternalAuth)
                return object;
            var message = new $root.api.IdentityExternalAuth();
            if (object.jwt != null) {
                if (typeof object.jwt !== "object")
                    throw TypeError(".api.IdentityExternalAuth.jwt: object expected");
                message.jwt = $root.api.IdentityExternalAuth.JWT.fromObject(object.jwt);
            }
            return message;
        };

        /**
         * Creates a plain object from an IdentityExternalAuth message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityExternalAuth
         * @static
         * @param {api.IdentityExternalAuth} message IdentityExternalAuth
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityExternalAuth.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.jwt = null;
            if (message.jwt != null && message.hasOwnProperty("jwt"))
                object.jwt = $root.api.IdentityExternalAuth.JWT.toObject(message.jwt, options);
            return object;
        };

        /**
         * Converts this IdentityExternalAuth to JSON.
         * @function toJSON
         * @memberof api.IdentityExternalAuth
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityExternalAuth.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        IdentityExternalAuth.JWT = (function() {

            /**
             * Properties of a JWT.
             * @memberof api.IdentityExternalAuth
             * @interface IJWT
             * @property {string|null} [token] JWT token
             */

            /**
             * Constructs a new JWT.
             * @memberof api.IdentityExternalAuth
             * @classdesc Represents a JWT.
             * @implements IJWT
             * @constructor
             * @param {api.IdentityExternalAuth.IJWT=} [properties] Properties to set
             */
            function JWT(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * JWT token.
             * @member {string} token
             * @memberof api.IdentityExternalAuth.JWT
             * @instance
             */
            JWT.prototype.token = "";

            /**
             * Creates a new JWT instance using the specified properties.
             * @function create
             * @memberof api.IdentityExternalAuth.JWT
             * @static
             * @param {api.IdentityExternalAuth.IJWT=} [properties] Properties to set
             * @returns {api.IdentityExternalAuth.JWT} JWT instance
             */
            JWT.create = function create(properties) {
                return new JWT(properties);
            };

            /**
             * Encodes the specified JWT message. Does not implicitly {@link api.IdentityExternalAuth.JWT.verify|verify} messages.
             * @function encode
             * @memberof api.IdentityExternalAuth.JWT
             * @static
             * @param {api.IdentityExternalAuth.IJWT} message JWT message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            JWT.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.token != null && message.hasOwnProperty("token"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.token);
                return writer;
            };

            /**
             * Encodes the specified JWT message, length delimited. Does not implicitly {@link api.IdentityExternalAuth.JWT.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.IdentityExternalAuth.JWT
             * @static
             * @param {api.IdentityExternalAuth.IJWT} message JWT message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            JWT.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a JWT message from the specified reader or buffer.
             * @function decode
             * @memberof api.IdentityExternalAuth.JWT
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.IdentityExternalAuth.JWT} JWT
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            JWT.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityExternalAuth.JWT();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.token = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a JWT message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.IdentityExternalAuth.JWT
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.IdentityExternalAuth.JWT} JWT
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            JWT.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a JWT message.
             * @function verify
             * @memberof api.IdentityExternalAuth.JWT
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            JWT.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.token != null && message.hasOwnProperty("token"))
                    if (!$util.isString(message.token))
                        return "token: string expected";
                return null;
            };

            /**
             * Creates a JWT message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.IdentityExternalAuth.JWT
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.IdentityExternalAuth.JWT} JWT
             */
            JWT.fromObject = function fromObject(object) {
                if (object instanceof $root.api.IdentityExternalAuth.JWT)
                    return object;
                var message = new $root.api.IdentityExternalAuth.JWT();
                if (object.token != null)
                    message.token = String(object.token);
                return message;
            };

            /**
             * Creates a plain object from a JWT message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.IdentityExternalAuth.JWT
             * @static
             * @param {api.IdentityExternalAuth.JWT} message JWT
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            JWT.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.token = "";
                if (message.token != null && message.hasOwnProperty("token"))
                    object.token = message.token;
                return object;
            };

            /**
             * Converts this JWT to JSON.
             * @function toJSON
             * @memberof api.IdentityExternalAuth.JWT
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            JWT.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return JWT;
        })();

        return IdentityExternalAuth;
    })();

    api.RegisterApplicationIdentityRequest = (function() {

        /**
         * Properties of a RegisterApplicationIdentityRequest.
         * @memberof api
         * @interface IRegisterApplicationIdentityRequest
         * @property {string|null} [appID] RegisterApplicationIdentityRequest appID
         * @property {api.IIdentityFields|null} [identity] RegisterApplicationIdentityRequest identity
         * @property {api.IIdentityEncryptedKeySet|null} [encryption] RegisterApplicationIdentityRequest encryption
         * @property {Object.<string,api.IResourcePostRequest>|null} [resources] RegisterApplicationIdentityRequest resources
         * @property {api.IIdentityExternalAuth|null} [auth] RegisterApplicationIdentityRequest auth
         */

        /**
         * Constructs a new RegisterApplicationIdentityRequest.
         * @memberof api
         * @classdesc Represents a RegisterApplicationIdentityRequest.
         * @implements IRegisterApplicationIdentityRequest
         * @constructor
         * @param {api.IRegisterApplicationIdentityRequest=} [properties] Properties to set
         */
        function RegisterApplicationIdentityRequest(properties) {
            this.resources = {};
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RegisterApplicationIdentityRequest appID.
         * @member {string} appID
         * @memberof api.RegisterApplicationIdentityRequest
         * @instance
         */
        RegisterApplicationIdentityRequest.prototype.appID = "";

        /**
         * RegisterApplicationIdentityRequest identity.
         * @member {api.IIdentityFields|null|undefined} identity
         * @memberof api.RegisterApplicationIdentityRequest
         * @instance
         */
        RegisterApplicationIdentityRequest.prototype.identity = null;

        /**
         * RegisterApplicationIdentityRequest encryption.
         * @member {api.IIdentityEncryptedKeySet|null|undefined} encryption
         * @memberof api.RegisterApplicationIdentityRequest
         * @instance
         */
        RegisterApplicationIdentityRequest.prototype.encryption = null;

        /**
         * RegisterApplicationIdentityRequest resources.
         * @member {Object.<string,api.IResourcePostRequest>} resources
         * @memberof api.RegisterApplicationIdentityRequest
         * @instance
         */
        RegisterApplicationIdentityRequest.prototype.resources = $util.emptyObject;

        /**
         * RegisterApplicationIdentityRequest auth.
         * @member {api.IIdentityExternalAuth|null|undefined} auth
         * @memberof api.RegisterApplicationIdentityRequest
         * @instance
         */
        RegisterApplicationIdentityRequest.prototype.auth = null;

        /**
         * Creates a new RegisterApplicationIdentityRequest instance using the specified properties.
         * @function create
         * @memberof api.RegisterApplicationIdentityRequest
         * @static
         * @param {api.IRegisterApplicationIdentityRequest=} [properties] Properties to set
         * @returns {api.RegisterApplicationIdentityRequest} RegisterApplicationIdentityRequest instance
         */
        RegisterApplicationIdentityRequest.create = function create(properties) {
            return new RegisterApplicationIdentityRequest(properties);
        };

        /**
         * Encodes the specified RegisterApplicationIdentityRequest message. Does not implicitly {@link api.RegisterApplicationIdentityRequest.verify|verify} messages.
         * @function encode
         * @memberof api.RegisterApplicationIdentityRequest
         * @static
         * @param {api.IRegisterApplicationIdentityRequest} message RegisterApplicationIdentityRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RegisterApplicationIdentityRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.appID != null && message.hasOwnProperty("appID"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.appID);
            if (message.identity != null && message.hasOwnProperty("identity"))
                $root.api.IdentityFields.encode(message.identity, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.encryption != null && message.hasOwnProperty("encryption"))
                $root.api.IdentityEncryptedKeySet.encode(message.encryption, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.resources != null && message.hasOwnProperty("resources"))
                for (var keys = Object.keys(message.resources), i = 0; i < keys.length; ++i) {
                    writer.uint32(/* id 4, wireType 2 =*/34).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                    $root.api.ResourcePostRequest.encode(message.resources[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                }
            if (message.auth != null && message.hasOwnProperty("auth"))
                $root.api.IdentityExternalAuth.encode(message.auth, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified RegisterApplicationIdentityRequest message, length delimited. Does not implicitly {@link api.RegisterApplicationIdentityRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.RegisterApplicationIdentityRequest
         * @static
         * @param {api.IRegisterApplicationIdentityRequest} message RegisterApplicationIdentityRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RegisterApplicationIdentityRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RegisterApplicationIdentityRequest message from the specified reader or buffer.
         * @function decode
         * @memberof api.RegisterApplicationIdentityRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.RegisterApplicationIdentityRequest} RegisterApplicationIdentityRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RegisterApplicationIdentityRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.RegisterApplicationIdentityRequest(), key;
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.appID = reader.string();
                    break;
                case 2:
                    message.identity = $root.api.IdentityFields.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.encryption = $root.api.IdentityEncryptedKeySet.decode(reader, reader.uint32());
                    break;
                case 4:
                    reader.skip().pos++;
                    if (message.resources === $util.emptyObject)
                        message.resources = {};
                    key = reader.string();
                    reader.pos++;
                    message.resources[key] = $root.api.ResourcePostRequest.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.auth = $root.api.IdentityExternalAuth.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RegisterApplicationIdentityRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.RegisterApplicationIdentityRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.RegisterApplicationIdentityRequest} RegisterApplicationIdentityRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RegisterApplicationIdentityRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RegisterApplicationIdentityRequest message.
         * @function verify
         * @memberof api.RegisterApplicationIdentityRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RegisterApplicationIdentityRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.appID != null && message.hasOwnProperty("appID"))
                if (!$util.isString(message.appID))
                    return "appID: string expected";
            if (message.identity != null && message.hasOwnProperty("identity")) {
                var error = $root.api.IdentityFields.verify(message.identity);
                if (error)
                    return "identity." + error;
            }
            if (message.encryption != null && message.hasOwnProperty("encryption")) {
                var error = $root.api.IdentityEncryptedKeySet.verify(message.encryption);
                if (error)
                    return "encryption." + error;
            }
            if (message.resources != null && message.hasOwnProperty("resources")) {
                if (!$util.isObject(message.resources))
                    return "resources: object expected";
                var key = Object.keys(message.resources);
                for (var i = 0; i < key.length; ++i) {
                    var error = $root.api.ResourcePostRequest.verify(message.resources[key[i]]);
                    if (error)
                        return "resources." + error;
                }
            }
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.api.IdentityExternalAuth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            return null;
        };

        /**
         * Creates a RegisterApplicationIdentityRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.RegisterApplicationIdentityRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.RegisterApplicationIdentityRequest} RegisterApplicationIdentityRequest
         */
        RegisterApplicationIdentityRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.api.RegisterApplicationIdentityRequest)
                return object;
            var message = new $root.api.RegisterApplicationIdentityRequest();
            if (object.appID != null)
                message.appID = String(object.appID);
            if (object.identity != null) {
                if (typeof object.identity !== "object")
                    throw TypeError(".api.RegisterApplicationIdentityRequest.identity: object expected");
                message.identity = $root.api.IdentityFields.fromObject(object.identity);
            }
            if (object.encryption != null) {
                if (typeof object.encryption !== "object")
                    throw TypeError(".api.RegisterApplicationIdentityRequest.encryption: object expected");
                message.encryption = $root.api.IdentityEncryptedKeySet.fromObject(object.encryption);
            }
            if (object.resources) {
                if (typeof object.resources !== "object")
                    throw TypeError(".api.RegisterApplicationIdentityRequest.resources: object expected");
                message.resources = {};
                for (var keys = Object.keys(object.resources), i = 0; i < keys.length; ++i) {
                    if (typeof object.resources[keys[i]] !== "object")
                        throw TypeError(".api.RegisterApplicationIdentityRequest.resources: object expected");
                    message.resources[keys[i]] = $root.api.ResourcePostRequest.fromObject(object.resources[keys[i]]);
                }
            }
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".api.RegisterApplicationIdentityRequest.auth: object expected");
                message.auth = $root.api.IdentityExternalAuth.fromObject(object.auth);
            }
            return message;
        };

        /**
         * Creates a plain object from a RegisterApplicationIdentityRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.RegisterApplicationIdentityRequest
         * @static
         * @param {api.RegisterApplicationIdentityRequest} message RegisterApplicationIdentityRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RegisterApplicationIdentityRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.objects || options.defaults)
                object.resources = {};
            if (options.defaults) {
                object.appID = "";
                object.identity = null;
                object.encryption = null;
                object.auth = null;
            }
            if (message.appID != null && message.hasOwnProperty("appID"))
                object.appID = message.appID;
            if (message.identity != null && message.hasOwnProperty("identity"))
                object.identity = $root.api.IdentityFields.toObject(message.identity, options);
            if (message.encryption != null && message.hasOwnProperty("encryption"))
                object.encryption = $root.api.IdentityEncryptedKeySet.toObject(message.encryption, options);
            var keys2;
            if (message.resources && (keys2 = Object.keys(message.resources)).length) {
                object.resources = {};
                for (var j = 0; j < keys2.length; ++j)
                    object.resources[keys2[j]] = $root.api.ResourcePostRequest.toObject(message.resources[keys2[j]], options);
            }
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.api.IdentityExternalAuth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this RegisterApplicationIdentityRequest to JSON.
         * @function toJSON
         * @memberof api.RegisterApplicationIdentityRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RegisterApplicationIdentityRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RegisterApplicationIdentityRequest;
    })();

    api.RegisterApplicationIdentityResponse = (function() {

        /**
         * Properties of a RegisterApplicationIdentityResponse.
         * @memberof api
         * @interface IRegisterApplicationIdentityResponse
         * @property {string|null} [login] RegisterApplicationIdentityResponse login
         */

        /**
         * Constructs a new RegisterApplicationIdentityResponse.
         * @memberof api
         * @classdesc Represents a RegisterApplicationIdentityResponse.
         * @implements IRegisterApplicationIdentityResponse
         * @constructor
         * @param {api.IRegisterApplicationIdentityResponse=} [properties] Properties to set
         */
        function RegisterApplicationIdentityResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RegisterApplicationIdentityResponse login.
         * @member {string} login
         * @memberof api.RegisterApplicationIdentityResponse
         * @instance
         */
        RegisterApplicationIdentityResponse.prototype.login = "";

        /**
         * Creates a new RegisterApplicationIdentityResponse instance using the specified properties.
         * @function create
         * @memberof api.RegisterApplicationIdentityResponse
         * @static
         * @param {api.IRegisterApplicationIdentityResponse=} [properties] Properties to set
         * @returns {api.RegisterApplicationIdentityResponse} RegisterApplicationIdentityResponse instance
         */
        RegisterApplicationIdentityResponse.create = function create(properties) {
            return new RegisterApplicationIdentityResponse(properties);
        };

        /**
         * Encodes the specified RegisterApplicationIdentityResponse message. Does not implicitly {@link api.RegisterApplicationIdentityResponse.verify|verify} messages.
         * @function encode
         * @memberof api.RegisterApplicationIdentityResponse
         * @static
         * @param {api.IRegisterApplicationIdentityResponse} message RegisterApplicationIdentityResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RegisterApplicationIdentityResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            return writer;
        };

        /**
         * Encodes the specified RegisterApplicationIdentityResponse message, length delimited. Does not implicitly {@link api.RegisterApplicationIdentityResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.RegisterApplicationIdentityResponse
         * @static
         * @param {api.IRegisterApplicationIdentityResponse} message RegisterApplicationIdentityResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RegisterApplicationIdentityResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RegisterApplicationIdentityResponse message from the specified reader or buffer.
         * @function decode
         * @memberof api.RegisterApplicationIdentityResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.RegisterApplicationIdentityResponse} RegisterApplicationIdentityResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RegisterApplicationIdentityResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.RegisterApplicationIdentityResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RegisterApplicationIdentityResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.RegisterApplicationIdentityResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.RegisterApplicationIdentityResponse} RegisterApplicationIdentityResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RegisterApplicationIdentityResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RegisterApplicationIdentityResponse message.
         * @function verify
         * @memberof api.RegisterApplicationIdentityResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RegisterApplicationIdentityResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            return null;
        };

        /**
         * Creates a RegisterApplicationIdentityResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.RegisterApplicationIdentityResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.RegisterApplicationIdentityResponse} RegisterApplicationIdentityResponse
         */
        RegisterApplicationIdentityResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.api.RegisterApplicationIdentityResponse)
                return object;
            var message = new $root.api.RegisterApplicationIdentityResponse();
            if (object.login != null)
                message.login = String(object.login);
            return message;
        };

        /**
         * Creates a plain object from a RegisterApplicationIdentityResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.RegisterApplicationIdentityResponse
         * @static
         * @param {api.RegisterApplicationIdentityResponse} message RegisterApplicationIdentityResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RegisterApplicationIdentityResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.login = "";
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            return object;
        };

        /**
         * Converts this RegisterApplicationIdentityResponse to JSON.
         * @function toJSON
         * @memberof api.RegisterApplicationIdentityResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RegisterApplicationIdentityResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RegisterApplicationIdentityResponse;
    })();

    api.IdentityCreateRequest = (function() {

        /**
         * Properties of an IdentityCreateRequest.
         * @memberof api
         * @interface IIdentityCreateRequest
         * @property {api.IIdentityFields|null} [identity] IdentityCreateRequest identity
         * @property {api.IIdentityEncryptedKeySet|null} [encryption] IdentityCreateRequest encryption
         * @property {Uint8Array|null} [signChain] IdentityCreateRequest signChain
         * @property {Array.<api.IIdentityShareEntry>|null} [sharingGroup] IdentityCreateRequest sharingGroup
         * @property {string|null} [email] IdentityCreateRequest email
         */

        /**
         * Constructs a new IdentityCreateRequest.
         * @memberof api
         * @classdesc Represents an IdentityCreateRequest.
         * @implements IIdentityCreateRequest
         * @constructor
         * @param {api.IIdentityCreateRequest=} [properties] Properties to set
         */
        function IdentityCreateRequest(properties) {
            this.sharingGroup = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityCreateRequest identity.
         * @member {api.IIdentityFields|null|undefined} identity
         * @memberof api.IdentityCreateRequest
         * @instance
         */
        IdentityCreateRequest.prototype.identity = null;

        /**
         * IdentityCreateRequest encryption.
         * @member {api.IIdentityEncryptedKeySet|null|undefined} encryption
         * @memberof api.IdentityCreateRequest
         * @instance
         */
        IdentityCreateRequest.prototype.encryption = null;

        /**
         * IdentityCreateRequest signChain.
         * @member {Uint8Array} signChain
         * @memberof api.IdentityCreateRequest
         * @instance
         */
        IdentityCreateRequest.prototype.signChain = $util.newBuffer([]);

        /**
         * IdentityCreateRequest sharingGroup.
         * @member {Array.<api.IIdentityShareEntry>} sharingGroup
         * @memberof api.IdentityCreateRequest
         * @instance
         */
        IdentityCreateRequest.prototype.sharingGroup = $util.emptyArray;

        /**
         * IdentityCreateRequest email.
         * @member {string} email
         * @memberof api.IdentityCreateRequest
         * @instance
         */
        IdentityCreateRequest.prototype.email = "";

        /**
         * Creates a new IdentityCreateRequest instance using the specified properties.
         * @function create
         * @memberof api.IdentityCreateRequest
         * @static
         * @param {api.IIdentityCreateRequest=} [properties] Properties to set
         * @returns {api.IdentityCreateRequest} IdentityCreateRequest instance
         */
        IdentityCreateRequest.create = function create(properties) {
            return new IdentityCreateRequest(properties);
        };

        /**
         * Encodes the specified IdentityCreateRequest message. Does not implicitly {@link api.IdentityCreateRequest.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityCreateRequest
         * @static
         * @param {api.IIdentityCreateRequest} message IdentityCreateRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityCreateRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.identity != null && message.hasOwnProperty("identity"))
                $root.api.IdentityFields.encode(message.identity, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.encryption != null && message.hasOwnProperty("encryption"))
                $root.api.IdentityEncryptedKeySet.encode(message.encryption, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.signChain != null && message.hasOwnProperty("signChain"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.signChain);
            if (message.sharingGroup != null && message.sharingGroup.length)
                for (var i = 0; i < message.sharingGroup.length; ++i)
                    $root.api.IdentityShareEntry.encode(message.sharingGroup[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.email != null && message.hasOwnProperty("email"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.email);
            return writer;
        };

        /**
         * Encodes the specified IdentityCreateRequest message, length delimited. Does not implicitly {@link api.IdentityCreateRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityCreateRequest
         * @static
         * @param {api.IIdentityCreateRequest} message IdentityCreateRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityCreateRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityCreateRequest message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityCreateRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityCreateRequest} IdentityCreateRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityCreateRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityCreateRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.identity = $root.api.IdentityFields.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.encryption = $root.api.IdentityEncryptedKeySet.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.signChain = reader.bytes();
                    break;
                case 4:
                    if (!(message.sharingGroup && message.sharingGroup.length))
                        message.sharingGroup = [];
                    message.sharingGroup.push($root.api.IdentityShareEntry.decode(reader, reader.uint32()));
                    break;
                case 5:
                    message.email = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityCreateRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityCreateRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityCreateRequest} IdentityCreateRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityCreateRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityCreateRequest message.
         * @function verify
         * @memberof api.IdentityCreateRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityCreateRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.identity != null && message.hasOwnProperty("identity")) {
                var error = $root.api.IdentityFields.verify(message.identity);
                if (error)
                    return "identity." + error;
            }
            if (message.encryption != null && message.hasOwnProperty("encryption")) {
                var error = $root.api.IdentityEncryptedKeySet.verify(message.encryption);
                if (error)
                    return "encryption." + error;
            }
            if (message.signChain != null && message.hasOwnProperty("signChain"))
                if (!(message.signChain && typeof message.signChain.length === "number" || $util.isString(message.signChain)))
                    return "signChain: buffer expected";
            if (message.sharingGroup != null && message.hasOwnProperty("sharingGroup")) {
                if (!Array.isArray(message.sharingGroup))
                    return "sharingGroup: array expected";
                for (var i = 0; i < message.sharingGroup.length; ++i) {
                    var error = $root.api.IdentityShareEntry.verify(message.sharingGroup[i]);
                    if (error)
                        return "sharingGroup." + error;
                }
            }
            if (message.email != null && message.hasOwnProperty("email"))
                if (!$util.isString(message.email))
                    return "email: string expected";
            return null;
        };

        /**
         * Creates an IdentityCreateRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityCreateRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityCreateRequest} IdentityCreateRequest
         */
        IdentityCreateRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityCreateRequest)
                return object;
            var message = new $root.api.IdentityCreateRequest();
            if (object.identity != null) {
                if (typeof object.identity !== "object")
                    throw TypeError(".api.IdentityCreateRequest.identity: object expected");
                message.identity = $root.api.IdentityFields.fromObject(object.identity);
            }
            if (object.encryption != null) {
                if (typeof object.encryption !== "object")
                    throw TypeError(".api.IdentityCreateRequest.encryption: object expected");
                message.encryption = $root.api.IdentityEncryptedKeySet.fromObject(object.encryption);
            }
            if (object.signChain != null)
                if (typeof object.signChain === "string")
                    $util.base64.decode(object.signChain, message.signChain = $util.newBuffer($util.base64.length(object.signChain)), 0);
                else if (object.signChain.length)
                    message.signChain = object.signChain;
            if (object.sharingGroup) {
                if (!Array.isArray(object.sharingGroup))
                    throw TypeError(".api.IdentityCreateRequest.sharingGroup: array expected");
                message.sharingGroup = [];
                for (var i = 0; i < object.sharingGroup.length; ++i) {
                    if (typeof object.sharingGroup[i] !== "object")
                        throw TypeError(".api.IdentityCreateRequest.sharingGroup: object expected");
                    message.sharingGroup[i] = $root.api.IdentityShareEntry.fromObject(object.sharingGroup[i]);
                }
            }
            if (object.email != null)
                message.email = String(object.email);
            return message;
        };

        /**
         * Creates a plain object from an IdentityCreateRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityCreateRequest
         * @static
         * @param {api.IdentityCreateRequest} message IdentityCreateRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityCreateRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.sharingGroup = [];
            if (options.defaults) {
                object.identity = null;
                object.encryption = null;
                if (options.bytes === String)
                    object.signChain = "";
                else {
                    object.signChain = [];
                    if (options.bytes !== Array)
                        object.signChain = $util.newBuffer(object.signChain);
                }
                object.email = "";
            }
            if (message.identity != null && message.hasOwnProperty("identity"))
                object.identity = $root.api.IdentityFields.toObject(message.identity, options);
            if (message.encryption != null && message.hasOwnProperty("encryption"))
                object.encryption = $root.api.IdentityEncryptedKeySet.toObject(message.encryption, options);
            if (message.signChain != null && message.hasOwnProperty("signChain"))
                object.signChain = options.bytes === String ? $util.base64.encode(message.signChain, 0, message.signChain.length) : options.bytes === Array ? Array.prototype.slice.call(message.signChain) : message.signChain;
            if (message.sharingGroup && message.sharingGroup.length) {
                object.sharingGroup = [];
                for (var j = 0; j < message.sharingGroup.length; ++j)
                    object.sharingGroup[j] = $root.api.IdentityShareEntry.toObject(message.sharingGroup[j], options);
            }
            if (message.email != null && message.hasOwnProperty("email"))
                object.email = message.email;
            return object;
        };

        /**
         * Converts this IdentityCreateRequest to JSON.
         * @function toJSON
         * @memberof api.IdentityCreateRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityCreateRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityCreateRequest;
    })();

    api.IdentityKeysToReplaceRequest = (function() {

        /**
         * Properties of an IdentityKeysToReplaceRequest.
         * @memberof api
         * @interface IIdentityKeysToReplaceRequest
         * @property {string|null} [login] IdentityKeysToReplaceRequest login
         * @property {api.IIdentityEncryptedKeySet|null} [encryption] IdentityKeysToReplaceRequest encryption
         * @property {Uint8Array|null} [signChain] IdentityKeysToReplaceRequest signChain
         * @property {Array.<api.IIdentityShareEntry>|null} [sharingGroup] IdentityKeysToReplaceRequest sharingGroup
         */

        /**
         * Constructs a new IdentityKeysToReplaceRequest.
         * @memberof api
         * @classdesc Represents an IdentityKeysToReplaceRequest.
         * @implements IIdentityKeysToReplaceRequest
         * @constructor
         * @param {api.IIdentityKeysToReplaceRequest=} [properties] Properties to set
         */
        function IdentityKeysToReplaceRequest(properties) {
            this.sharingGroup = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityKeysToReplaceRequest login.
         * @member {string} login
         * @memberof api.IdentityKeysToReplaceRequest
         * @instance
         */
        IdentityKeysToReplaceRequest.prototype.login = "";

        /**
         * IdentityKeysToReplaceRequest encryption.
         * @member {api.IIdentityEncryptedKeySet|null|undefined} encryption
         * @memberof api.IdentityKeysToReplaceRequest
         * @instance
         */
        IdentityKeysToReplaceRequest.prototype.encryption = null;

        /**
         * IdentityKeysToReplaceRequest signChain.
         * @member {Uint8Array} signChain
         * @memberof api.IdentityKeysToReplaceRequest
         * @instance
         */
        IdentityKeysToReplaceRequest.prototype.signChain = $util.newBuffer([]);

        /**
         * IdentityKeysToReplaceRequest sharingGroup.
         * @member {Array.<api.IIdentityShareEntry>} sharingGroup
         * @memberof api.IdentityKeysToReplaceRequest
         * @instance
         */
        IdentityKeysToReplaceRequest.prototype.sharingGroup = $util.emptyArray;

        /**
         * Creates a new IdentityKeysToReplaceRequest instance using the specified properties.
         * @function create
         * @memberof api.IdentityKeysToReplaceRequest
         * @static
         * @param {api.IIdentityKeysToReplaceRequest=} [properties] Properties to set
         * @returns {api.IdentityKeysToReplaceRequest} IdentityKeysToReplaceRequest instance
         */
        IdentityKeysToReplaceRequest.create = function create(properties) {
            return new IdentityKeysToReplaceRequest(properties);
        };

        /**
         * Encodes the specified IdentityKeysToReplaceRequest message. Does not implicitly {@link api.IdentityKeysToReplaceRequest.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityKeysToReplaceRequest
         * @static
         * @param {api.IIdentityKeysToReplaceRequest} message IdentityKeysToReplaceRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityKeysToReplaceRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            if (message.encryption != null && message.hasOwnProperty("encryption"))
                $root.api.IdentityEncryptedKeySet.encode(message.encryption, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.signChain != null && message.hasOwnProperty("signChain"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.signChain);
            if (message.sharingGroup != null && message.sharingGroup.length)
                for (var i = 0; i < message.sharingGroup.length; ++i)
                    $root.api.IdentityShareEntry.encode(message.sharingGroup[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IdentityKeysToReplaceRequest message, length delimited. Does not implicitly {@link api.IdentityKeysToReplaceRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityKeysToReplaceRequest
         * @static
         * @param {api.IIdentityKeysToReplaceRequest} message IdentityKeysToReplaceRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityKeysToReplaceRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityKeysToReplaceRequest message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityKeysToReplaceRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityKeysToReplaceRequest} IdentityKeysToReplaceRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityKeysToReplaceRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityKeysToReplaceRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                case 2:
                    message.encryption = $root.api.IdentityEncryptedKeySet.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.signChain = reader.bytes();
                    break;
                case 4:
                    if (!(message.sharingGroup && message.sharingGroup.length))
                        message.sharingGroup = [];
                    message.sharingGroup.push($root.api.IdentityShareEntry.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityKeysToReplaceRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityKeysToReplaceRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityKeysToReplaceRequest} IdentityKeysToReplaceRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityKeysToReplaceRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityKeysToReplaceRequest message.
         * @function verify
         * @memberof api.IdentityKeysToReplaceRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityKeysToReplaceRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            if (message.encryption != null && message.hasOwnProperty("encryption")) {
                var error = $root.api.IdentityEncryptedKeySet.verify(message.encryption);
                if (error)
                    return "encryption." + error;
            }
            if (message.signChain != null && message.hasOwnProperty("signChain"))
                if (!(message.signChain && typeof message.signChain.length === "number" || $util.isString(message.signChain)))
                    return "signChain: buffer expected";
            if (message.sharingGroup != null && message.hasOwnProperty("sharingGroup")) {
                if (!Array.isArray(message.sharingGroup))
                    return "sharingGroup: array expected";
                for (var i = 0; i < message.sharingGroup.length; ++i) {
                    var error = $root.api.IdentityShareEntry.verify(message.sharingGroup[i]);
                    if (error)
                        return "sharingGroup." + error;
                }
            }
            return null;
        };

        /**
         * Creates an IdentityKeysToReplaceRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityKeysToReplaceRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityKeysToReplaceRequest} IdentityKeysToReplaceRequest
         */
        IdentityKeysToReplaceRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityKeysToReplaceRequest)
                return object;
            var message = new $root.api.IdentityKeysToReplaceRequest();
            if (object.login != null)
                message.login = String(object.login);
            if (object.encryption != null) {
                if (typeof object.encryption !== "object")
                    throw TypeError(".api.IdentityKeysToReplaceRequest.encryption: object expected");
                message.encryption = $root.api.IdentityEncryptedKeySet.fromObject(object.encryption);
            }
            if (object.signChain != null)
                if (typeof object.signChain === "string")
                    $util.base64.decode(object.signChain, message.signChain = $util.newBuffer($util.base64.length(object.signChain)), 0);
                else if (object.signChain.length)
                    message.signChain = object.signChain;
            if (object.sharingGroup) {
                if (!Array.isArray(object.sharingGroup))
                    throw TypeError(".api.IdentityKeysToReplaceRequest.sharingGroup: array expected");
                message.sharingGroup = [];
                for (var i = 0; i < object.sharingGroup.length; ++i) {
                    if (typeof object.sharingGroup[i] !== "object")
                        throw TypeError(".api.IdentityKeysToReplaceRequest.sharingGroup: object expected");
                    message.sharingGroup[i] = $root.api.IdentityShareEntry.fromObject(object.sharingGroup[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an IdentityKeysToReplaceRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityKeysToReplaceRequest
         * @static
         * @param {api.IdentityKeysToReplaceRequest} message IdentityKeysToReplaceRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityKeysToReplaceRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.sharingGroup = [];
            if (options.defaults) {
                object.login = "";
                object.encryption = null;
                if (options.bytes === String)
                    object.signChain = "";
                else {
                    object.signChain = [];
                    if (options.bytes !== Array)
                        object.signChain = $util.newBuffer(object.signChain);
                }
            }
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            if (message.encryption != null && message.hasOwnProperty("encryption"))
                object.encryption = $root.api.IdentityEncryptedKeySet.toObject(message.encryption, options);
            if (message.signChain != null && message.hasOwnProperty("signChain"))
                object.signChain = options.bytes === String ? $util.base64.encode(message.signChain, 0, message.signChain.length) : options.bytes === Array ? Array.prototype.slice.call(message.signChain) : message.signChain;
            if (message.sharingGroup && message.sharingGroup.length) {
                object.sharingGroup = [];
                for (var j = 0; j < message.sharingGroup.length; ++j)
                    object.sharingGroup[j] = $root.api.IdentityShareEntry.toObject(message.sharingGroup[j], options);
            }
            return object;
        };

        /**
         * Converts this IdentityKeysToReplaceRequest to JSON.
         * @function toJSON
         * @memberof api.IdentityKeysToReplaceRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityKeysToReplaceRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityKeysToReplaceRequest;
    })();

    api.IdentityListOptions = (function() {

        /**
         * Properties of an IdentityListOptions.
         * @memberof api
         * @interface IIdentityListOptions
         * @property {number|null} [offset] IdentityListOptions offset
         * @property {number|null} [limit] IdentityListOptions limit
         * @property {string|null} [loginPrefix] IdentityListOptions loginPrefix
         * @property {string|null} [kind] IdentityListOptions kind
         * @property {api.IdentitySortingField|null} [sortedBy] IdentityListOptions sortedBy
         * @property {api.SortingOrder|null} [order] IdentityListOptions order
         */

        /**
         * Constructs a new IdentityListOptions.
         * @memberof api
         * @classdesc Represents an IdentityListOptions.
         * @implements IIdentityListOptions
         * @constructor
         * @param {api.IIdentityListOptions=} [properties] Properties to set
         */
        function IdentityListOptions(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityListOptions offset.
         * @member {number} offset
         * @memberof api.IdentityListOptions
         * @instance
         */
        IdentityListOptions.prototype.offset = 0;

        /**
         * IdentityListOptions limit.
         * @member {number} limit
         * @memberof api.IdentityListOptions
         * @instance
         */
        IdentityListOptions.prototype.limit = 0;

        /**
         * IdentityListOptions loginPrefix.
         * @member {string} loginPrefix
         * @memberof api.IdentityListOptions
         * @instance
         */
        IdentityListOptions.prototype.loginPrefix = "";

        /**
         * IdentityListOptions kind.
         * @member {string} kind
         * @memberof api.IdentityListOptions
         * @instance
         */
        IdentityListOptions.prototype.kind = "";

        /**
         * IdentityListOptions sortedBy.
         * @member {api.IdentitySortingField} sortedBy
         * @memberof api.IdentityListOptions
         * @instance
         */
        IdentityListOptions.prototype.sortedBy = 0;

        /**
         * IdentityListOptions order.
         * @member {api.SortingOrder} order
         * @memberof api.IdentityListOptions
         * @instance
         */
        IdentityListOptions.prototype.order = 0;

        /**
         * Creates a new IdentityListOptions instance using the specified properties.
         * @function create
         * @memberof api.IdentityListOptions
         * @static
         * @param {api.IIdentityListOptions=} [properties] Properties to set
         * @returns {api.IdentityListOptions} IdentityListOptions instance
         */
        IdentityListOptions.create = function create(properties) {
            return new IdentityListOptions(properties);
        };

        /**
         * Encodes the specified IdentityListOptions message. Does not implicitly {@link api.IdentityListOptions.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityListOptions
         * @static
         * @param {api.IIdentityListOptions} message IdentityListOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityListOptions.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.offset != null && message.hasOwnProperty("offset"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.offset);
            if (message.limit != null && message.hasOwnProperty("limit"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.limit);
            if (message.loginPrefix != null && message.hasOwnProperty("loginPrefix"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.loginPrefix);
            if (message.kind != null && message.hasOwnProperty("kind"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.kind);
            if (message.sortedBy != null && message.hasOwnProperty("sortedBy"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.sortedBy);
            if (message.order != null && message.hasOwnProperty("order"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.order);
            return writer;
        };

        /**
         * Encodes the specified IdentityListOptions message, length delimited. Does not implicitly {@link api.IdentityListOptions.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityListOptions
         * @static
         * @param {api.IIdentityListOptions} message IdentityListOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityListOptions.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityListOptions message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityListOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityListOptions} IdentityListOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityListOptions.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityListOptions();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.offset = reader.uint32();
                    break;
                case 2:
                    message.limit = reader.uint32();
                    break;
                case 3:
                    message.loginPrefix = reader.string();
                    break;
                case 4:
                    message.kind = reader.string();
                    break;
                case 5:
                    message.sortedBy = reader.int32();
                    break;
                case 6:
                    message.order = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityListOptions message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityListOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityListOptions} IdentityListOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityListOptions.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityListOptions message.
         * @function verify
         * @memberof api.IdentityListOptions
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityListOptions.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.offset != null && message.hasOwnProperty("offset"))
                if (!$util.isInteger(message.offset))
                    return "offset: integer expected";
            if (message.limit != null && message.hasOwnProperty("limit"))
                if (!$util.isInteger(message.limit))
                    return "limit: integer expected";
            if (message.loginPrefix != null && message.hasOwnProperty("loginPrefix"))
                if (!$util.isString(message.loginPrefix))
                    return "loginPrefix: string expected";
            if (message.kind != null && message.hasOwnProperty("kind"))
                if (!$util.isString(message.kind))
                    return "kind: string expected";
            if (message.sortedBy != null && message.hasOwnProperty("sortedBy"))
                switch (message.sortedBy) {
                default:
                    return "sortedBy: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.order != null && message.hasOwnProperty("order"))
                switch (message.order) {
                default:
                    return "order: enum value expected";
                case 0:
                case 1:
                    break;
                }
            return null;
        };

        /**
         * Creates an IdentityListOptions message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityListOptions
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityListOptions} IdentityListOptions
         */
        IdentityListOptions.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityListOptions)
                return object;
            var message = new $root.api.IdentityListOptions();
            if (object.offset != null)
                message.offset = object.offset >>> 0;
            if (object.limit != null)
                message.limit = object.limit >>> 0;
            if (object.loginPrefix != null)
                message.loginPrefix = String(object.loginPrefix);
            if (object.kind != null)
                message.kind = String(object.kind);
            switch (object.sortedBy) {
            case "LOGIN":
            case 0:
                message.sortedBy = 0;
                break;
            case "CREATED":
            case 1:
                message.sortedBy = 1;
                break;
            case "KIND":
            case 2:
                message.sortedBy = 2;
                break;
            }
            switch (object.order) {
            case "DESC":
            case 0:
                message.order = 0;
                break;
            case "ASC":
            case 1:
                message.order = 1;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from an IdentityListOptions message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityListOptions
         * @static
         * @param {api.IdentityListOptions} message IdentityListOptions
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityListOptions.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.offset = 0;
                object.limit = 0;
                object.loginPrefix = "";
                object.kind = "";
                object.sortedBy = options.enums === String ? "LOGIN" : 0;
                object.order = options.enums === String ? "DESC" : 0;
            }
            if (message.offset != null && message.hasOwnProperty("offset"))
                object.offset = message.offset;
            if (message.limit != null && message.hasOwnProperty("limit"))
                object.limit = message.limit;
            if (message.loginPrefix != null && message.hasOwnProperty("loginPrefix"))
                object.loginPrefix = message.loginPrefix;
            if (message.kind != null && message.hasOwnProperty("kind"))
                object.kind = message.kind;
            if (message.sortedBy != null && message.hasOwnProperty("sortedBy"))
                object.sortedBy = options.enums === String ? $root.api.IdentitySortingField[message.sortedBy] : message.sortedBy;
            if (message.order != null && message.hasOwnProperty("order"))
                object.order = options.enums === String ? $root.api.SortingOrder[message.order] : message.order;
            return object;
        };

        /**
         * Converts this IdentityListOptions to JSON.
         * @function toJSON
         * @memberof api.IdentityListOptions
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityListOptions.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityListOptions;
    })();

    api.IdentityListRequest = (function() {

        /**
         * Properties of an IdentityListRequest.
         * @memberof api
         * @interface IIdentityListRequest
         * @property {api.IIdentityListOptions|null} [options] IdentityListRequest options
         */

        /**
         * Constructs a new IdentityListRequest.
         * @memberof api
         * @classdesc Represents an IdentityListRequest.
         * @implements IIdentityListRequest
         * @constructor
         * @param {api.IIdentityListRequest=} [properties] Properties to set
         */
        function IdentityListRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityListRequest options.
         * @member {api.IIdentityListOptions|null|undefined} options
         * @memberof api.IdentityListRequest
         * @instance
         */
        IdentityListRequest.prototype.options = null;

        /**
         * Creates a new IdentityListRequest instance using the specified properties.
         * @function create
         * @memberof api.IdentityListRequest
         * @static
         * @param {api.IIdentityListRequest=} [properties] Properties to set
         * @returns {api.IdentityListRequest} IdentityListRequest instance
         */
        IdentityListRequest.create = function create(properties) {
            return new IdentityListRequest(properties);
        };

        /**
         * Encodes the specified IdentityListRequest message. Does not implicitly {@link api.IdentityListRequest.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityListRequest
         * @static
         * @param {api.IIdentityListRequest} message IdentityListRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityListRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.options != null && message.hasOwnProperty("options"))
                $root.api.IdentityListOptions.encode(message.options, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IdentityListRequest message, length delimited. Does not implicitly {@link api.IdentityListRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityListRequest
         * @static
         * @param {api.IIdentityListRequest} message IdentityListRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityListRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityListRequest message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityListRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityListRequest} IdentityListRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityListRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityListRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.options = $root.api.IdentityListOptions.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityListRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityListRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityListRequest} IdentityListRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityListRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityListRequest message.
         * @function verify
         * @memberof api.IdentityListRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityListRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.options != null && message.hasOwnProperty("options")) {
                var error = $root.api.IdentityListOptions.verify(message.options);
                if (error)
                    return "options." + error;
            }
            return null;
        };

        /**
         * Creates an IdentityListRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityListRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityListRequest} IdentityListRequest
         */
        IdentityListRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityListRequest)
                return object;
            var message = new $root.api.IdentityListRequest();
            if (object.options != null) {
                if (typeof object.options !== "object")
                    throw TypeError(".api.IdentityListRequest.options: object expected");
                message.options = $root.api.IdentityListOptions.fromObject(object.options);
            }
            return message;
        };

        /**
         * Creates a plain object from an IdentityListRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityListRequest
         * @static
         * @param {api.IdentityListRequest} message IdentityListRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityListRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.options = null;
            if (message.options != null && message.hasOwnProperty("options"))
                object.options = $root.api.IdentityListOptions.toObject(message.options, options);
            return object;
        };

        /**
         * Converts this IdentityListRequest to JSON.
         * @function toJSON
         * @memberof api.IdentityListRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityListRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityListRequest;
    })();

    api.IdentityListResponse = (function() {

        /**
         * Properties of an IdentityListResponse.
         * @memberof api
         * @interface IIdentityListResponse
         * @property {Array.<api.IIdentity>|null} [identities] IdentityListResponse identities
         * @property {number|null} [totalIdentitiesCount] IdentityListResponse totalIdentitiesCount
         */

        /**
         * Constructs a new IdentityListResponse.
         * @memberof api
         * @classdesc Represents an IdentityListResponse.
         * @implements IIdentityListResponse
         * @constructor
         * @param {api.IIdentityListResponse=} [properties] Properties to set
         */
        function IdentityListResponse(properties) {
            this.identities = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityListResponse identities.
         * @member {Array.<api.IIdentity>} identities
         * @memberof api.IdentityListResponse
         * @instance
         */
        IdentityListResponse.prototype.identities = $util.emptyArray;

        /**
         * IdentityListResponse totalIdentitiesCount.
         * @member {number} totalIdentitiesCount
         * @memberof api.IdentityListResponse
         * @instance
         */
        IdentityListResponse.prototype.totalIdentitiesCount = 0;

        /**
         * Creates a new IdentityListResponse instance using the specified properties.
         * @function create
         * @memberof api.IdentityListResponse
         * @static
         * @param {api.IIdentityListResponse=} [properties] Properties to set
         * @returns {api.IdentityListResponse} IdentityListResponse instance
         */
        IdentityListResponse.create = function create(properties) {
            return new IdentityListResponse(properties);
        };

        /**
         * Encodes the specified IdentityListResponse message. Does not implicitly {@link api.IdentityListResponse.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityListResponse
         * @static
         * @param {api.IIdentityListResponse} message IdentityListResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityListResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.identities != null && message.identities.length)
                for (var i = 0; i < message.identities.length; ++i)
                    $root.api.Identity.encode(message.identities[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.totalIdentitiesCount != null && message.hasOwnProperty("totalIdentitiesCount"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.totalIdentitiesCount);
            return writer;
        };

        /**
         * Encodes the specified IdentityListResponse message, length delimited. Does not implicitly {@link api.IdentityListResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityListResponse
         * @static
         * @param {api.IIdentityListResponse} message IdentityListResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityListResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityListResponse message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityListResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityListResponse} IdentityListResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityListResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityListResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.identities && message.identities.length))
                        message.identities = [];
                    message.identities.push($root.api.Identity.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.totalIdentitiesCount = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityListResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityListResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityListResponse} IdentityListResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityListResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityListResponse message.
         * @function verify
         * @memberof api.IdentityListResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityListResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.identities != null && message.hasOwnProperty("identities")) {
                if (!Array.isArray(message.identities))
                    return "identities: array expected";
                for (var i = 0; i < message.identities.length; ++i) {
                    var error = $root.api.Identity.verify(message.identities[i]);
                    if (error)
                        return "identities." + error;
                }
            }
            if (message.totalIdentitiesCount != null && message.hasOwnProperty("totalIdentitiesCount"))
                if (!$util.isInteger(message.totalIdentitiesCount))
                    return "totalIdentitiesCount: integer expected";
            return null;
        };

        /**
         * Creates an IdentityListResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityListResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityListResponse} IdentityListResponse
         */
        IdentityListResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityListResponse)
                return object;
            var message = new $root.api.IdentityListResponse();
            if (object.identities) {
                if (!Array.isArray(object.identities))
                    throw TypeError(".api.IdentityListResponse.identities: array expected");
                message.identities = [];
                for (var i = 0; i < object.identities.length; ++i) {
                    if (typeof object.identities[i] !== "object")
                        throw TypeError(".api.IdentityListResponse.identities: object expected");
                    message.identities[i] = $root.api.Identity.fromObject(object.identities[i]);
                }
            }
            if (object.totalIdentitiesCount != null)
                message.totalIdentitiesCount = object.totalIdentitiesCount >>> 0;
            return message;
        };

        /**
         * Creates a plain object from an IdentityListResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityListResponse
         * @static
         * @param {api.IdentityListResponse} message IdentityListResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityListResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.identities = [];
            if (options.defaults)
                object.totalIdentitiesCount = 0;
            if (message.identities && message.identities.length) {
                object.identities = [];
                for (var j = 0; j < message.identities.length; ++j)
                    object.identities[j] = $root.api.Identity.toObject(message.identities[j], options);
            }
            if (message.totalIdentitiesCount != null && message.hasOwnProperty("totalIdentitiesCount"))
                object.totalIdentitiesCount = message.totalIdentitiesCount;
            return object;
        };

        /**
         * Converts this IdentityListResponse to JSON.
         * @function toJSON
         * @memberof api.IdentityListResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityListResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityListResponse;
    })();

    api.ApplicationListIdentitiesRequest = (function() {

        /**
         * Properties of an ApplicationListIdentitiesRequest.
         * @memberof api
         * @interface IApplicationListIdentitiesRequest
         * @property {string|null} [appID] ApplicationListIdentitiesRequest appID
         * @property {api.IIdentityListOptions|null} [options] ApplicationListIdentitiesRequest options
         */

        /**
         * Constructs a new ApplicationListIdentitiesRequest.
         * @memberof api
         * @classdesc Represents an ApplicationListIdentitiesRequest.
         * @implements IApplicationListIdentitiesRequest
         * @constructor
         * @param {api.IApplicationListIdentitiesRequest=} [properties] Properties to set
         */
        function ApplicationListIdentitiesRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ApplicationListIdentitiesRequest appID.
         * @member {string} appID
         * @memberof api.ApplicationListIdentitiesRequest
         * @instance
         */
        ApplicationListIdentitiesRequest.prototype.appID = "";

        /**
         * ApplicationListIdentitiesRequest options.
         * @member {api.IIdentityListOptions|null|undefined} options
         * @memberof api.ApplicationListIdentitiesRequest
         * @instance
         */
        ApplicationListIdentitiesRequest.prototype.options = null;

        /**
         * Creates a new ApplicationListIdentitiesRequest instance using the specified properties.
         * @function create
         * @memberof api.ApplicationListIdentitiesRequest
         * @static
         * @param {api.IApplicationListIdentitiesRequest=} [properties] Properties to set
         * @returns {api.ApplicationListIdentitiesRequest} ApplicationListIdentitiesRequest instance
         */
        ApplicationListIdentitiesRequest.create = function create(properties) {
            return new ApplicationListIdentitiesRequest(properties);
        };

        /**
         * Encodes the specified ApplicationListIdentitiesRequest message. Does not implicitly {@link api.ApplicationListIdentitiesRequest.verify|verify} messages.
         * @function encode
         * @memberof api.ApplicationListIdentitiesRequest
         * @static
         * @param {api.IApplicationListIdentitiesRequest} message ApplicationListIdentitiesRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApplicationListIdentitiesRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.appID != null && message.hasOwnProperty("appID"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.appID);
            if (message.options != null && message.hasOwnProperty("options"))
                $root.api.IdentityListOptions.encode(message.options, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ApplicationListIdentitiesRequest message, length delimited. Does not implicitly {@link api.ApplicationListIdentitiesRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.ApplicationListIdentitiesRequest
         * @static
         * @param {api.IApplicationListIdentitiesRequest} message ApplicationListIdentitiesRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApplicationListIdentitiesRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ApplicationListIdentitiesRequest message from the specified reader or buffer.
         * @function decode
         * @memberof api.ApplicationListIdentitiesRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.ApplicationListIdentitiesRequest} ApplicationListIdentitiesRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApplicationListIdentitiesRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ApplicationListIdentitiesRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.appID = reader.string();
                    break;
                case 2:
                    message.options = $root.api.IdentityListOptions.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ApplicationListIdentitiesRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.ApplicationListIdentitiesRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.ApplicationListIdentitiesRequest} ApplicationListIdentitiesRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApplicationListIdentitiesRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ApplicationListIdentitiesRequest message.
         * @function verify
         * @memberof api.ApplicationListIdentitiesRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ApplicationListIdentitiesRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.appID != null && message.hasOwnProperty("appID"))
                if (!$util.isString(message.appID))
                    return "appID: string expected";
            if (message.options != null && message.hasOwnProperty("options")) {
                var error = $root.api.IdentityListOptions.verify(message.options);
                if (error)
                    return "options." + error;
            }
            return null;
        };

        /**
         * Creates an ApplicationListIdentitiesRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.ApplicationListIdentitiesRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.ApplicationListIdentitiesRequest} ApplicationListIdentitiesRequest
         */
        ApplicationListIdentitiesRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.api.ApplicationListIdentitiesRequest)
                return object;
            var message = new $root.api.ApplicationListIdentitiesRequest();
            if (object.appID != null)
                message.appID = String(object.appID);
            if (object.options != null) {
                if (typeof object.options !== "object")
                    throw TypeError(".api.ApplicationListIdentitiesRequest.options: object expected");
                message.options = $root.api.IdentityListOptions.fromObject(object.options);
            }
            return message;
        };

        /**
         * Creates a plain object from an ApplicationListIdentitiesRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.ApplicationListIdentitiesRequest
         * @static
         * @param {api.ApplicationListIdentitiesRequest} message ApplicationListIdentitiesRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ApplicationListIdentitiesRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.appID = "";
                object.options = null;
            }
            if (message.appID != null && message.hasOwnProperty("appID"))
                object.appID = message.appID;
            if (message.options != null && message.hasOwnProperty("options"))
                object.options = $root.api.IdentityListOptions.toObject(message.options, options);
            return object;
        };

        /**
         * Converts this ApplicationListIdentitiesRequest to JSON.
         * @function toJSON
         * @memberof api.ApplicationListIdentitiesRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ApplicationListIdentitiesRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ApplicationListIdentitiesRequest;
    })();

    api.ApplicationListIdentitiesResponse = (function() {

        /**
         * Properties of an ApplicationListIdentitiesResponse.
         * @memberof api
         * @interface IApplicationListIdentitiesResponse
         * @property {Array.<api.IApplicationIdentity>|null} [identities] ApplicationListIdentitiesResponse identities
         * @property {number|null} [totalIdentitiesCount] ApplicationListIdentitiesResponse totalIdentitiesCount
         */

        /**
         * Constructs a new ApplicationListIdentitiesResponse.
         * @memberof api
         * @classdesc Represents an ApplicationListIdentitiesResponse.
         * @implements IApplicationListIdentitiesResponse
         * @constructor
         * @param {api.IApplicationListIdentitiesResponse=} [properties] Properties to set
         */
        function ApplicationListIdentitiesResponse(properties) {
            this.identities = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ApplicationListIdentitiesResponse identities.
         * @member {Array.<api.IApplicationIdentity>} identities
         * @memberof api.ApplicationListIdentitiesResponse
         * @instance
         */
        ApplicationListIdentitiesResponse.prototype.identities = $util.emptyArray;

        /**
         * ApplicationListIdentitiesResponse totalIdentitiesCount.
         * @member {number} totalIdentitiesCount
         * @memberof api.ApplicationListIdentitiesResponse
         * @instance
         */
        ApplicationListIdentitiesResponse.prototype.totalIdentitiesCount = 0;

        /**
         * Creates a new ApplicationListIdentitiesResponse instance using the specified properties.
         * @function create
         * @memberof api.ApplicationListIdentitiesResponse
         * @static
         * @param {api.IApplicationListIdentitiesResponse=} [properties] Properties to set
         * @returns {api.ApplicationListIdentitiesResponse} ApplicationListIdentitiesResponse instance
         */
        ApplicationListIdentitiesResponse.create = function create(properties) {
            return new ApplicationListIdentitiesResponse(properties);
        };

        /**
         * Encodes the specified ApplicationListIdentitiesResponse message. Does not implicitly {@link api.ApplicationListIdentitiesResponse.verify|verify} messages.
         * @function encode
         * @memberof api.ApplicationListIdentitiesResponse
         * @static
         * @param {api.IApplicationListIdentitiesResponse} message ApplicationListIdentitiesResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApplicationListIdentitiesResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.identities != null && message.identities.length)
                for (var i = 0; i < message.identities.length; ++i)
                    $root.api.ApplicationIdentity.encode(message.identities[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.totalIdentitiesCount != null && message.hasOwnProperty("totalIdentitiesCount"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.totalIdentitiesCount);
            return writer;
        };

        /**
         * Encodes the specified ApplicationListIdentitiesResponse message, length delimited. Does not implicitly {@link api.ApplicationListIdentitiesResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.ApplicationListIdentitiesResponse
         * @static
         * @param {api.IApplicationListIdentitiesResponse} message ApplicationListIdentitiesResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApplicationListIdentitiesResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ApplicationListIdentitiesResponse message from the specified reader or buffer.
         * @function decode
         * @memberof api.ApplicationListIdentitiesResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.ApplicationListIdentitiesResponse} ApplicationListIdentitiesResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApplicationListIdentitiesResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ApplicationListIdentitiesResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.identities && message.identities.length))
                        message.identities = [];
                    message.identities.push($root.api.ApplicationIdentity.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.totalIdentitiesCount = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ApplicationListIdentitiesResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.ApplicationListIdentitiesResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.ApplicationListIdentitiesResponse} ApplicationListIdentitiesResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApplicationListIdentitiesResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ApplicationListIdentitiesResponse message.
         * @function verify
         * @memberof api.ApplicationListIdentitiesResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ApplicationListIdentitiesResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.identities != null && message.hasOwnProperty("identities")) {
                if (!Array.isArray(message.identities))
                    return "identities: array expected";
                for (var i = 0; i < message.identities.length; ++i) {
                    var error = $root.api.ApplicationIdentity.verify(message.identities[i]);
                    if (error)
                        return "identities." + error;
                }
            }
            if (message.totalIdentitiesCount != null && message.hasOwnProperty("totalIdentitiesCount"))
                if (!$util.isInteger(message.totalIdentitiesCount))
                    return "totalIdentitiesCount: integer expected";
            return null;
        };

        /**
         * Creates an ApplicationListIdentitiesResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.ApplicationListIdentitiesResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.ApplicationListIdentitiesResponse} ApplicationListIdentitiesResponse
         */
        ApplicationListIdentitiesResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.api.ApplicationListIdentitiesResponse)
                return object;
            var message = new $root.api.ApplicationListIdentitiesResponse();
            if (object.identities) {
                if (!Array.isArray(object.identities))
                    throw TypeError(".api.ApplicationListIdentitiesResponse.identities: array expected");
                message.identities = [];
                for (var i = 0; i < object.identities.length; ++i) {
                    if (typeof object.identities[i] !== "object")
                        throw TypeError(".api.ApplicationListIdentitiesResponse.identities: object expected");
                    message.identities[i] = $root.api.ApplicationIdentity.fromObject(object.identities[i]);
                }
            }
            if (object.totalIdentitiesCount != null)
                message.totalIdentitiesCount = object.totalIdentitiesCount >>> 0;
            return message;
        };

        /**
         * Creates a plain object from an ApplicationListIdentitiesResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.ApplicationListIdentitiesResponse
         * @static
         * @param {api.ApplicationListIdentitiesResponse} message ApplicationListIdentitiesResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ApplicationListIdentitiesResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.identities = [];
            if (options.defaults)
                object.totalIdentitiesCount = 0;
            if (message.identities && message.identities.length) {
                object.identities = [];
                for (var j = 0; j < message.identities.length; ++j)
                    object.identities[j] = $root.api.ApplicationIdentity.toObject(message.identities[j], options);
            }
            if (message.totalIdentitiesCount != null && message.hasOwnProperty("totalIdentitiesCount"))
                object.totalIdentitiesCount = message.totalIdentitiesCount;
            return object;
        };

        /**
         * Converts this ApplicationListIdentitiesResponse to JSON.
         * @function toJSON
         * @memberof api.ApplicationListIdentitiesResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ApplicationListIdentitiesResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ApplicationListIdentitiesResponse;
    })();

    api.IdentityPromoteRequest = (function() {

        /**
         * Properties of an IdentityPromoteRequest.
         * @memberof api
         * @interface IIdentityPromoteRequest
         * @property {string|null} [login] IdentityPromoteRequest login
         * @property {boolean|null} [admin] IdentityPromoteRequest admin
         */

        /**
         * Constructs a new IdentityPromoteRequest.
         * @memberof api
         * @classdesc Represents an IdentityPromoteRequest.
         * @implements IIdentityPromoteRequest
         * @constructor
         * @param {api.IIdentityPromoteRequest=} [properties] Properties to set
         */
        function IdentityPromoteRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityPromoteRequest login.
         * @member {string} login
         * @memberof api.IdentityPromoteRequest
         * @instance
         */
        IdentityPromoteRequest.prototype.login = "";

        /**
         * IdentityPromoteRequest admin.
         * @member {boolean} admin
         * @memberof api.IdentityPromoteRequest
         * @instance
         */
        IdentityPromoteRequest.prototype.admin = false;

        /**
         * Creates a new IdentityPromoteRequest instance using the specified properties.
         * @function create
         * @memberof api.IdentityPromoteRequest
         * @static
         * @param {api.IIdentityPromoteRequest=} [properties] Properties to set
         * @returns {api.IdentityPromoteRequest} IdentityPromoteRequest instance
         */
        IdentityPromoteRequest.create = function create(properties) {
            return new IdentityPromoteRequest(properties);
        };

        /**
         * Encodes the specified IdentityPromoteRequest message. Does not implicitly {@link api.IdentityPromoteRequest.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityPromoteRequest
         * @static
         * @param {api.IIdentityPromoteRequest} message IdentityPromoteRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityPromoteRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            if (message.admin != null && message.hasOwnProperty("admin"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.admin);
            return writer;
        };

        /**
         * Encodes the specified IdentityPromoteRequest message, length delimited. Does not implicitly {@link api.IdentityPromoteRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityPromoteRequest
         * @static
         * @param {api.IIdentityPromoteRequest} message IdentityPromoteRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityPromoteRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityPromoteRequest message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityPromoteRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityPromoteRequest} IdentityPromoteRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityPromoteRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityPromoteRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                case 2:
                    message.admin = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityPromoteRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityPromoteRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityPromoteRequest} IdentityPromoteRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityPromoteRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityPromoteRequest message.
         * @function verify
         * @memberof api.IdentityPromoteRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityPromoteRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            if (message.admin != null && message.hasOwnProperty("admin"))
                if (typeof message.admin !== "boolean")
                    return "admin: boolean expected";
            return null;
        };

        /**
         * Creates an IdentityPromoteRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityPromoteRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityPromoteRequest} IdentityPromoteRequest
         */
        IdentityPromoteRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityPromoteRequest)
                return object;
            var message = new $root.api.IdentityPromoteRequest();
            if (object.login != null)
                message.login = String(object.login);
            if (object.admin != null)
                message.admin = Boolean(object.admin);
            return message;
        };

        /**
         * Creates a plain object from an IdentityPromoteRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityPromoteRequest
         * @static
         * @param {api.IdentityPromoteRequest} message IdentityPromoteRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityPromoteRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.login = "";
                object.admin = false;
            }
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            if (message.admin != null && message.hasOwnProperty("admin"))
                object.admin = message.admin;
            return object;
        };

        /**
         * Converts this IdentityPromoteRequest to JSON.
         * @function toJSON
         * @memberof api.IdentityPromoteRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityPromoteRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityPromoteRequest;
    })();

    api.IdentityGetKeySetRequest = (function() {

        /**
         * Properties of an IdentityGetKeySetRequest.
         * @memberof api
         * @interface IIdentityGetKeySetRequest
         * @property {number|null} [version] IdentityGetKeySetRequest version
         * @property {string|null} [login] IdentityGetKeySetRequest login
         */

        /**
         * Constructs a new IdentityGetKeySetRequest.
         * @memberof api
         * @classdesc Represents an IdentityGetKeySetRequest.
         * @implements IIdentityGetKeySetRequest
         * @constructor
         * @param {api.IIdentityGetKeySetRequest=} [properties] Properties to set
         */
        function IdentityGetKeySetRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityGetKeySetRequest version.
         * @member {number} version
         * @memberof api.IdentityGetKeySetRequest
         * @instance
         */
        IdentityGetKeySetRequest.prototype.version = 0;

        /**
         * IdentityGetKeySetRequest login.
         * @member {string} login
         * @memberof api.IdentityGetKeySetRequest
         * @instance
         */
        IdentityGetKeySetRequest.prototype.login = "";

        /**
         * Creates a new IdentityGetKeySetRequest instance using the specified properties.
         * @function create
         * @memberof api.IdentityGetKeySetRequest
         * @static
         * @param {api.IIdentityGetKeySetRequest=} [properties] Properties to set
         * @returns {api.IdentityGetKeySetRequest} IdentityGetKeySetRequest instance
         */
        IdentityGetKeySetRequest.create = function create(properties) {
            return new IdentityGetKeySetRequest(properties);
        };

        /**
         * Encodes the specified IdentityGetKeySetRequest message. Does not implicitly {@link api.IdentityGetKeySetRequest.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityGetKeySetRequest
         * @static
         * @param {api.IIdentityGetKeySetRequest} message IdentityGetKeySetRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetKeySetRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.version != null && message.hasOwnProperty("version"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.version);
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.login);
            return writer;
        };

        /**
         * Encodes the specified IdentityGetKeySetRequest message, length delimited. Does not implicitly {@link api.IdentityGetKeySetRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityGetKeySetRequest
         * @static
         * @param {api.IIdentityGetKeySetRequest} message IdentityGetKeySetRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetKeySetRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityGetKeySetRequest message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityGetKeySetRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityGetKeySetRequest} IdentityGetKeySetRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetKeySetRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityGetKeySetRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.version = reader.uint32();
                    break;
                case 2:
                    message.login = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityGetKeySetRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityGetKeySetRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityGetKeySetRequest} IdentityGetKeySetRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetKeySetRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityGetKeySetRequest message.
         * @function verify
         * @memberof api.IdentityGetKeySetRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityGetKeySetRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isInteger(message.version))
                    return "version: integer expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            return null;
        };

        /**
         * Creates an IdentityGetKeySetRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityGetKeySetRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityGetKeySetRequest} IdentityGetKeySetRequest
         */
        IdentityGetKeySetRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityGetKeySetRequest)
                return object;
            var message = new $root.api.IdentityGetKeySetRequest();
            if (object.version != null)
                message.version = object.version >>> 0;
            if (object.login != null)
                message.login = String(object.login);
            return message;
        };

        /**
         * Creates a plain object from an IdentityGetKeySetRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityGetKeySetRequest
         * @static
         * @param {api.IdentityGetKeySetRequest} message IdentityGetKeySetRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityGetKeySetRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.version = 0;
                object.login = "";
            }
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            return object;
        };

        /**
         * Converts this IdentityGetKeySetRequest to JSON.
         * @function toJSON
         * @memberof api.IdentityGetKeySetRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityGetKeySetRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityGetKeySetRequest;
    })();

    api.IdentityGetKeySetResponse = (function() {

        /**
         * Properties of an IdentityGetKeySetResponse.
         * @memberof api
         * @interface IIdentityGetKeySetResponse
         * @property {Array.<api.IdentityGetKeySetResponse.IPathElt>|null} [path] IdentityGetKeySetResponse path
         */

        /**
         * Constructs a new IdentityGetKeySetResponse.
         * @memberof api
         * @classdesc Represents an IdentityGetKeySetResponse.
         * @implements IIdentityGetKeySetResponse
         * @constructor
         * @param {api.IIdentityGetKeySetResponse=} [properties] Properties to set
         */
        function IdentityGetKeySetResponse(properties) {
            this.path = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityGetKeySetResponse path.
         * @member {Array.<api.IdentityGetKeySetResponse.IPathElt>} path
         * @memberof api.IdentityGetKeySetResponse
         * @instance
         */
        IdentityGetKeySetResponse.prototype.path = $util.emptyArray;

        /**
         * Creates a new IdentityGetKeySetResponse instance using the specified properties.
         * @function create
         * @memberof api.IdentityGetKeySetResponse
         * @static
         * @param {api.IIdentityGetKeySetResponse=} [properties] Properties to set
         * @returns {api.IdentityGetKeySetResponse} IdentityGetKeySetResponse instance
         */
        IdentityGetKeySetResponse.create = function create(properties) {
            return new IdentityGetKeySetResponse(properties);
        };

        /**
         * Encodes the specified IdentityGetKeySetResponse message. Does not implicitly {@link api.IdentityGetKeySetResponse.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityGetKeySetResponse
         * @static
         * @param {api.IIdentityGetKeySetResponse} message IdentityGetKeySetResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetKeySetResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.path != null && message.path.length)
                for (var i = 0; i < message.path.length; ++i)
                    $root.api.IdentityGetKeySetResponse.PathElt.encode(message.path[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IdentityGetKeySetResponse message, length delimited. Does not implicitly {@link api.IdentityGetKeySetResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityGetKeySetResponse
         * @static
         * @param {api.IIdentityGetKeySetResponse} message IdentityGetKeySetResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetKeySetResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityGetKeySetResponse message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityGetKeySetResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityGetKeySetResponse} IdentityGetKeySetResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetKeySetResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityGetKeySetResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.path && message.path.length))
                        message.path = [];
                    message.path.push($root.api.IdentityGetKeySetResponse.PathElt.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityGetKeySetResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityGetKeySetResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityGetKeySetResponse} IdentityGetKeySetResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetKeySetResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityGetKeySetResponse message.
         * @function verify
         * @memberof api.IdentityGetKeySetResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityGetKeySetResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.path != null && message.hasOwnProperty("path")) {
                if (!Array.isArray(message.path))
                    return "path: array expected";
                for (var i = 0; i < message.path.length; ++i) {
                    var error = $root.api.IdentityGetKeySetResponse.PathElt.verify(message.path[i]);
                    if (error)
                        return "path." + error;
                }
            }
            return null;
        };

        /**
         * Creates an IdentityGetKeySetResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityGetKeySetResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityGetKeySetResponse} IdentityGetKeySetResponse
         */
        IdentityGetKeySetResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityGetKeySetResponse)
                return object;
            var message = new $root.api.IdentityGetKeySetResponse();
            if (object.path) {
                if (!Array.isArray(object.path))
                    throw TypeError(".api.IdentityGetKeySetResponse.path: array expected");
                message.path = [];
                for (var i = 0; i < object.path.length; ++i) {
                    if (typeof object.path[i] !== "object")
                        throw TypeError(".api.IdentityGetKeySetResponse.path: object expected");
                    message.path[i] = $root.api.IdentityGetKeySetResponse.PathElt.fromObject(object.path[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an IdentityGetKeySetResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityGetKeySetResponse
         * @static
         * @param {api.IdentityGetKeySetResponse} message IdentityGetKeySetResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityGetKeySetResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.path = [];
            if (message.path && message.path.length) {
                object.path = [];
                for (var j = 0; j < message.path.length; ++j)
                    object.path[j] = $root.api.IdentityGetKeySetResponse.PathElt.toObject(message.path[j], options);
            }
            return object;
        };

        /**
         * Converts this IdentityGetKeySetResponse to JSON.
         * @function toJSON
         * @memberof api.IdentityGetKeySetResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityGetKeySetResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        IdentityGetKeySetResponse.PathElt = (function() {

            /**
             * Properties of a PathElt.
             * @memberof api.IdentityGetKeySetResponse
             * @interface IPathElt
             * @property {api.ICipher|null} [sharedKey] PathElt sharedKey
             * @property {api.IIdentityEncryptedKeySet|null} [encryptedKeySet] PathElt encryptedKeySet
             * @property {api.IIdentityKeyID|null} [id] PathElt id
             */

            /**
             * Constructs a new PathElt.
             * @memberof api.IdentityGetKeySetResponse
             * @classdesc Represents a PathElt.
             * @implements IPathElt
             * @constructor
             * @param {api.IdentityGetKeySetResponse.IPathElt=} [properties] Properties to set
             */
            function PathElt(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PathElt sharedKey.
             * @member {api.ICipher|null|undefined} sharedKey
             * @memberof api.IdentityGetKeySetResponse.PathElt
             * @instance
             */
            PathElt.prototype.sharedKey = null;

            /**
             * PathElt encryptedKeySet.
             * @member {api.IIdentityEncryptedKeySet|null|undefined} encryptedKeySet
             * @memberof api.IdentityGetKeySetResponse.PathElt
             * @instance
             */
            PathElt.prototype.encryptedKeySet = null;

            /**
             * PathElt id.
             * @member {api.IIdentityKeyID|null|undefined} id
             * @memberof api.IdentityGetKeySetResponse.PathElt
             * @instance
             */
            PathElt.prototype.id = null;

            /**
             * Creates a new PathElt instance using the specified properties.
             * @function create
             * @memberof api.IdentityGetKeySetResponse.PathElt
             * @static
             * @param {api.IdentityGetKeySetResponse.IPathElt=} [properties] Properties to set
             * @returns {api.IdentityGetKeySetResponse.PathElt} PathElt instance
             */
            PathElt.create = function create(properties) {
                return new PathElt(properties);
            };

            /**
             * Encodes the specified PathElt message. Does not implicitly {@link api.IdentityGetKeySetResponse.PathElt.verify|verify} messages.
             * @function encode
             * @memberof api.IdentityGetKeySetResponse.PathElt
             * @static
             * @param {api.IdentityGetKeySetResponse.IPathElt} message PathElt message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PathElt.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sharedKey != null && message.hasOwnProperty("sharedKey"))
                    $root.api.Cipher.encode(message.sharedKey, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.encryptedKeySet != null && message.hasOwnProperty("encryptedKeySet"))
                    $root.api.IdentityEncryptedKeySet.encode(message.encryptedKeySet, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.id != null && message.hasOwnProperty("id"))
                    $root.api.IdentityKeyID.encode(message.id, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified PathElt message, length delimited. Does not implicitly {@link api.IdentityGetKeySetResponse.PathElt.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.IdentityGetKeySetResponse.PathElt
             * @static
             * @param {api.IdentityGetKeySetResponse.IPathElt} message PathElt message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PathElt.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PathElt message from the specified reader or buffer.
             * @function decode
             * @memberof api.IdentityGetKeySetResponse.PathElt
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.IdentityGetKeySetResponse.PathElt} PathElt
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PathElt.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityGetKeySetResponse.PathElt();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.sharedKey = $root.api.Cipher.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.encryptedKeySet = $root.api.IdentityEncryptedKeySet.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.id = $root.api.IdentityKeyID.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PathElt message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.IdentityGetKeySetResponse.PathElt
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.IdentityGetKeySetResponse.PathElt} PathElt
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PathElt.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PathElt message.
             * @function verify
             * @memberof api.IdentityGetKeySetResponse.PathElt
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PathElt.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.sharedKey != null && message.hasOwnProperty("sharedKey")) {
                    var error = $root.api.Cipher.verify(message.sharedKey);
                    if (error)
                        return "sharedKey." + error;
                }
                if (message.encryptedKeySet != null && message.hasOwnProperty("encryptedKeySet")) {
                    var error = $root.api.IdentityEncryptedKeySet.verify(message.encryptedKeySet);
                    if (error)
                        return "encryptedKeySet." + error;
                }
                if (message.id != null && message.hasOwnProperty("id")) {
                    var error = $root.api.IdentityKeyID.verify(message.id);
                    if (error)
                        return "id." + error;
                }
                return null;
            };

            /**
             * Creates a PathElt message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.IdentityGetKeySetResponse.PathElt
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.IdentityGetKeySetResponse.PathElt} PathElt
             */
            PathElt.fromObject = function fromObject(object) {
                if (object instanceof $root.api.IdentityGetKeySetResponse.PathElt)
                    return object;
                var message = new $root.api.IdentityGetKeySetResponse.PathElt();
                if (object.sharedKey != null) {
                    if (typeof object.sharedKey !== "object")
                        throw TypeError(".api.IdentityGetKeySetResponse.PathElt.sharedKey: object expected");
                    message.sharedKey = $root.api.Cipher.fromObject(object.sharedKey);
                }
                if (object.encryptedKeySet != null) {
                    if (typeof object.encryptedKeySet !== "object")
                        throw TypeError(".api.IdentityGetKeySetResponse.PathElt.encryptedKeySet: object expected");
                    message.encryptedKeySet = $root.api.IdentityEncryptedKeySet.fromObject(object.encryptedKeySet);
                }
                if (object.id != null) {
                    if (typeof object.id !== "object")
                        throw TypeError(".api.IdentityGetKeySetResponse.PathElt.id: object expected");
                    message.id = $root.api.IdentityKeyID.fromObject(object.id);
                }
                return message;
            };

            /**
             * Creates a plain object from a PathElt message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.IdentityGetKeySetResponse.PathElt
             * @static
             * @param {api.IdentityGetKeySetResponse.PathElt} message PathElt
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PathElt.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.sharedKey = null;
                    object.encryptedKeySet = null;
                    object.id = null;
                }
                if (message.sharedKey != null && message.hasOwnProperty("sharedKey"))
                    object.sharedKey = $root.api.Cipher.toObject(message.sharedKey, options);
                if (message.encryptedKeySet != null && message.hasOwnProperty("encryptedKeySet"))
                    object.encryptedKeySet = $root.api.IdentityEncryptedKeySet.toObject(message.encryptedKeySet, options);
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = $root.api.IdentityKeyID.toObject(message.id, options);
                return object;
            };

            /**
             * Converts this PathElt to JSON.
             * @function toJSON
             * @memberof api.IdentityGetKeySetResponse.PathElt
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PathElt.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return PathElt;
        })();

        return IdentityGetKeySetResponse;
    })();

    api.IdentityGetSharingGroupRequest = (function() {

        /**
         * Properties of an IdentityGetSharingGroupRequest.
         * @memberof api
         * @interface IIdentityGetSharingGroupRequest
         * @property {string|null} [login] IdentityGetSharingGroupRequest login
         */

        /**
         * Constructs a new IdentityGetSharingGroupRequest.
         * @memberof api
         * @classdesc Represents an IdentityGetSharingGroupRequest.
         * @implements IIdentityGetSharingGroupRequest
         * @constructor
         * @param {api.IIdentityGetSharingGroupRequest=} [properties] Properties to set
         */
        function IdentityGetSharingGroupRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityGetSharingGroupRequest login.
         * @member {string} login
         * @memberof api.IdentityGetSharingGroupRequest
         * @instance
         */
        IdentityGetSharingGroupRequest.prototype.login = "";

        /**
         * Creates a new IdentityGetSharingGroupRequest instance using the specified properties.
         * @function create
         * @memberof api.IdentityGetSharingGroupRequest
         * @static
         * @param {api.IIdentityGetSharingGroupRequest=} [properties] Properties to set
         * @returns {api.IdentityGetSharingGroupRequest} IdentityGetSharingGroupRequest instance
         */
        IdentityGetSharingGroupRequest.create = function create(properties) {
            return new IdentityGetSharingGroupRequest(properties);
        };

        /**
         * Encodes the specified IdentityGetSharingGroupRequest message. Does not implicitly {@link api.IdentityGetSharingGroupRequest.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityGetSharingGroupRequest
         * @static
         * @param {api.IIdentityGetSharingGroupRequest} message IdentityGetSharingGroupRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetSharingGroupRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            return writer;
        };

        /**
         * Encodes the specified IdentityGetSharingGroupRequest message, length delimited. Does not implicitly {@link api.IdentityGetSharingGroupRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityGetSharingGroupRequest
         * @static
         * @param {api.IIdentityGetSharingGroupRequest} message IdentityGetSharingGroupRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetSharingGroupRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityGetSharingGroupRequest message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityGetSharingGroupRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityGetSharingGroupRequest} IdentityGetSharingGroupRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetSharingGroupRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityGetSharingGroupRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityGetSharingGroupRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityGetSharingGroupRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityGetSharingGroupRequest} IdentityGetSharingGroupRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetSharingGroupRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityGetSharingGroupRequest message.
         * @function verify
         * @memberof api.IdentityGetSharingGroupRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityGetSharingGroupRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            return null;
        };

        /**
         * Creates an IdentityGetSharingGroupRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityGetSharingGroupRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityGetSharingGroupRequest} IdentityGetSharingGroupRequest
         */
        IdentityGetSharingGroupRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityGetSharingGroupRequest)
                return object;
            var message = new $root.api.IdentityGetSharingGroupRequest();
            if (object.login != null)
                message.login = String(object.login);
            return message;
        };

        /**
         * Creates a plain object from an IdentityGetSharingGroupRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityGetSharingGroupRequest
         * @static
         * @param {api.IdentityGetSharingGroupRequest} message IdentityGetSharingGroupRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityGetSharingGroupRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.login = "";
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            return object;
        };

        /**
         * Converts this IdentityGetSharingGroupRequest to JSON.
         * @function toJSON
         * @memberof api.IdentityGetSharingGroupRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityGetSharingGroupRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityGetSharingGroupRequest;
    })();

    api.IdentityGetAccessGroupRequest = (function() {

        /**
         * Properties of an IdentityGetAccessGroupRequest.
         * @memberof api
         * @interface IIdentityGetAccessGroupRequest
         * @property {string|null} [login] IdentityGetAccessGroupRequest login
         */

        /**
         * Constructs a new IdentityGetAccessGroupRequest.
         * @memberof api
         * @classdesc Represents an IdentityGetAccessGroupRequest.
         * @implements IIdentityGetAccessGroupRequest
         * @constructor
         * @param {api.IIdentityGetAccessGroupRequest=} [properties] Properties to set
         */
        function IdentityGetAccessGroupRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityGetAccessGroupRequest login.
         * @member {string} login
         * @memberof api.IdentityGetAccessGroupRequest
         * @instance
         */
        IdentityGetAccessGroupRequest.prototype.login = "";

        /**
         * Creates a new IdentityGetAccessGroupRequest instance using the specified properties.
         * @function create
         * @memberof api.IdentityGetAccessGroupRequest
         * @static
         * @param {api.IIdentityGetAccessGroupRequest=} [properties] Properties to set
         * @returns {api.IdentityGetAccessGroupRequest} IdentityGetAccessGroupRequest instance
         */
        IdentityGetAccessGroupRequest.create = function create(properties) {
            return new IdentityGetAccessGroupRequest(properties);
        };

        /**
         * Encodes the specified IdentityGetAccessGroupRequest message. Does not implicitly {@link api.IdentityGetAccessGroupRequest.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityGetAccessGroupRequest
         * @static
         * @param {api.IIdentityGetAccessGroupRequest} message IdentityGetAccessGroupRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetAccessGroupRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            return writer;
        };

        /**
         * Encodes the specified IdentityGetAccessGroupRequest message, length delimited. Does not implicitly {@link api.IdentityGetAccessGroupRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityGetAccessGroupRequest
         * @static
         * @param {api.IIdentityGetAccessGroupRequest} message IdentityGetAccessGroupRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetAccessGroupRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityGetAccessGroupRequest message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityGetAccessGroupRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityGetAccessGroupRequest} IdentityGetAccessGroupRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetAccessGroupRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityGetAccessGroupRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityGetAccessGroupRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityGetAccessGroupRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityGetAccessGroupRequest} IdentityGetAccessGroupRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetAccessGroupRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityGetAccessGroupRequest message.
         * @function verify
         * @memberof api.IdentityGetAccessGroupRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityGetAccessGroupRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            return null;
        };

        /**
         * Creates an IdentityGetAccessGroupRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityGetAccessGroupRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityGetAccessGroupRequest} IdentityGetAccessGroupRequest
         */
        IdentityGetAccessGroupRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityGetAccessGroupRequest)
                return object;
            var message = new $root.api.IdentityGetAccessGroupRequest();
            if (object.login != null)
                message.login = String(object.login);
            return message;
        };

        /**
         * Creates a plain object from an IdentityGetAccessGroupRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityGetAccessGroupRequest
         * @static
         * @param {api.IdentityGetAccessGroupRequest} message IdentityGetAccessGroupRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityGetAccessGroupRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.login = "";
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            return object;
        };

        /**
         * Converts this IdentityGetAccessGroupRequest to JSON.
         * @function toJSON
         * @memberof api.IdentityGetAccessGroupRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityGetAccessGroupRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityGetAccessGroupRequest;
    })();

    api.IdentityGetSharingGraphRequest = (function() {

        /**
         * Properties of an IdentityGetSharingGraphRequest.
         * @memberof api
         * @interface IIdentityGetSharingGraphRequest
         * @property {string|null} [login] IdentityGetSharingGraphRequest login
         */

        /**
         * Constructs a new IdentityGetSharingGraphRequest.
         * @memberof api
         * @classdesc Represents an IdentityGetSharingGraphRequest.
         * @implements IIdentityGetSharingGraphRequest
         * @constructor
         * @param {api.IIdentityGetSharingGraphRequest=} [properties] Properties to set
         */
        function IdentityGetSharingGraphRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityGetSharingGraphRequest login.
         * @member {string} login
         * @memberof api.IdentityGetSharingGraphRequest
         * @instance
         */
        IdentityGetSharingGraphRequest.prototype.login = "";

        /**
         * Creates a new IdentityGetSharingGraphRequest instance using the specified properties.
         * @function create
         * @memberof api.IdentityGetSharingGraphRequest
         * @static
         * @param {api.IIdentityGetSharingGraphRequest=} [properties] Properties to set
         * @returns {api.IdentityGetSharingGraphRequest} IdentityGetSharingGraphRequest instance
         */
        IdentityGetSharingGraphRequest.create = function create(properties) {
            return new IdentityGetSharingGraphRequest(properties);
        };

        /**
         * Encodes the specified IdentityGetSharingGraphRequest message. Does not implicitly {@link api.IdentityGetSharingGraphRequest.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityGetSharingGraphRequest
         * @static
         * @param {api.IIdentityGetSharingGraphRequest} message IdentityGetSharingGraphRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetSharingGraphRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            return writer;
        };

        /**
         * Encodes the specified IdentityGetSharingGraphRequest message, length delimited. Does not implicitly {@link api.IdentityGetSharingGraphRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityGetSharingGraphRequest
         * @static
         * @param {api.IIdentityGetSharingGraphRequest} message IdentityGetSharingGraphRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetSharingGraphRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityGetSharingGraphRequest message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityGetSharingGraphRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityGetSharingGraphRequest} IdentityGetSharingGraphRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetSharingGraphRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityGetSharingGraphRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityGetSharingGraphRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityGetSharingGraphRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityGetSharingGraphRequest} IdentityGetSharingGraphRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetSharingGraphRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityGetSharingGraphRequest message.
         * @function verify
         * @memberof api.IdentityGetSharingGraphRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityGetSharingGraphRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            return null;
        };

        /**
         * Creates an IdentityGetSharingGraphRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityGetSharingGraphRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityGetSharingGraphRequest} IdentityGetSharingGraphRequest
         */
        IdentityGetSharingGraphRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityGetSharingGraphRequest)
                return object;
            var message = new $root.api.IdentityGetSharingGraphRequest();
            if (object.login != null)
                message.login = String(object.login);
            return message;
        };

        /**
         * Creates a plain object from an IdentityGetSharingGraphRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityGetSharingGraphRequest
         * @static
         * @param {api.IdentityGetSharingGraphRequest} message IdentityGetSharingGraphRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityGetSharingGraphRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.login = "";
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            return object;
        };

        /**
         * Converts this IdentityGetSharingGraphRequest to JSON.
         * @function toJSON
         * @memberof api.IdentityGetSharingGraphRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityGetSharingGraphRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityGetSharingGraphRequest;
    })();

    api.IdentityGetKeysToRenewRequest = (function() {

        /**
         * Properties of an IdentityGetKeysToRenewRequest.
         * @memberof api
         * @interface IIdentityGetKeysToRenewRequest
         * @property {string|null} [login] IdentityGetKeysToRenewRequest login
         */

        /**
         * Constructs a new IdentityGetKeysToRenewRequest.
         * @memberof api
         * @classdesc Represents an IdentityGetKeysToRenewRequest.
         * @implements IIdentityGetKeysToRenewRequest
         * @constructor
         * @param {api.IIdentityGetKeysToRenewRequest=} [properties] Properties to set
         */
        function IdentityGetKeysToRenewRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityGetKeysToRenewRequest login.
         * @member {string} login
         * @memberof api.IdentityGetKeysToRenewRequest
         * @instance
         */
        IdentityGetKeysToRenewRequest.prototype.login = "";

        /**
         * Creates a new IdentityGetKeysToRenewRequest instance using the specified properties.
         * @function create
         * @memberof api.IdentityGetKeysToRenewRequest
         * @static
         * @param {api.IIdentityGetKeysToRenewRequest=} [properties] Properties to set
         * @returns {api.IdentityGetKeysToRenewRequest} IdentityGetKeysToRenewRequest instance
         */
        IdentityGetKeysToRenewRequest.create = function create(properties) {
            return new IdentityGetKeysToRenewRequest(properties);
        };

        /**
         * Encodes the specified IdentityGetKeysToRenewRequest message. Does not implicitly {@link api.IdentityGetKeysToRenewRequest.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityGetKeysToRenewRequest
         * @static
         * @param {api.IIdentityGetKeysToRenewRequest} message IdentityGetKeysToRenewRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetKeysToRenewRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            return writer;
        };

        /**
         * Encodes the specified IdentityGetKeysToRenewRequest message, length delimited. Does not implicitly {@link api.IdentityGetKeysToRenewRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityGetKeysToRenewRequest
         * @static
         * @param {api.IIdentityGetKeysToRenewRequest} message IdentityGetKeysToRenewRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetKeysToRenewRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityGetKeysToRenewRequest message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityGetKeysToRenewRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityGetKeysToRenewRequest} IdentityGetKeysToRenewRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetKeysToRenewRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityGetKeysToRenewRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityGetKeysToRenewRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityGetKeysToRenewRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityGetKeysToRenewRequest} IdentityGetKeysToRenewRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetKeysToRenewRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityGetKeysToRenewRequest message.
         * @function verify
         * @memberof api.IdentityGetKeysToRenewRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityGetKeysToRenewRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            return null;
        };

        /**
         * Creates an IdentityGetKeysToRenewRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityGetKeysToRenewRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityGetKeysToRenewRequest} IdentityGetKeysToRenewRequest
         */
        IdentityGetKeysToRenewRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityGetKeysToRenewRequest)
                return object;
            var message = new $root.api.IdentityGetKeysToRenewRequest();
            if (object.login != null)
                message.login = String(object.login);
            return message;
        };

        /**
         * Creates a plain object from an IdentityGetKeysToRenewRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityGetKeysToRenewRequest
         * @static
         * @param {api.IdentityGetKeysToRenewRequest} message IdentityGetKeysToRenewRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityGetKeysToRenewRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.login = "";
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            return object;
        };

        /**
         * Converts this IdentityGetKeysToRenewRequest to JSON.
         * @function toJSON
         * @memberof api.IdentityGetKeysToRenewRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityGetKeysToRenewRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityGetKeysToRenewRequest;
    })();

    api.IdentityGetPublicKeysRequest = (function() {

        /**
         * Properties of an IdentityGetPublicKeysRequest.
         * @memberof api
         * @interface IIdentityGetPublicKeysRequest
         * @property {Array.<api.IIdentityKeyID>|null} [ids] IdentityGetPublicKeysRequest ids
         */

        /**
         * Constructs a new IdentityGetPublicKeysRequest.
         * @memberof api
         * @classdesc Represents an IdentityGetPublicKeysRequest.
         * @implements IIdentityGetPublicKeysRequest
         * @constructor
         * @param {api.IIdentityGetPublicKeysRequest=} [properties] Properties to set
         */
        function IdentityGetPublicKeysRequest(properties) {
            this.ids = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityGetPublicKeysRequest ids.
         * @member {Array.<api.IIdentityKeyID>} ids
         * @memberof api.IdentityGetPublicKeysRequest
         * @instance
         */
        IdentityGetPublicKeysRequest.prototype.ids = $util.emptyArray;

        /**
         * Creates a new IdentityGetPublicKeysRequest instance using the specified properties.
         * @function create
         * @memberof api.IdentityGetPublicKeysRequest
         * @static
         * @param {api.IIdentityGetPublicKeysRequest=} [properties] Properties to set
         * @returns {api.IdentityGetPublicKeysRequest} IdentityGetPublicKeysRequest instance
         */
        IdentityGetPublicKeysRequest.create = function create(properties) {
            return new IdentityGetPublicKeysRequest(properties);
        };

        /**
         * Encodes the specified IdentityGetPublicKeysRequest message. Does not implicitly {@link api.IdentityGetPublicKeysRequest.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityGetPublicKeysRequest
         * @static
         * @param {api.IIdentityGetPublicKeysRequest} message IdentityGetPublicKeysRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetPublicKeysRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ids != null && message.ids.length)
                for (var i = 0; i < message.ids.length; ++i)
                    $root.api.IdentityKeyID.encode(message.ids[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IdentityGetPublicKeysRequest message, length delimited. Does not implicitly {@link api.IdentityGetPublicKeysRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityGetPublicKeysRequest
         * @static
         * @param {api.IIdentityGetPublicKeysRequest} message IdentityGetPublicKeysRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetPublicKeysRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityGetPublicKeysRequest message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityGetPublicKeysRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityGetPublicKeysRequest} IdentityGetPublicKeysRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetPublicKeysRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityGetPublicKeysRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.ids && message.ids.length))
                        message.ids = [];
                    message.ids.push($root.api.IdentityKeyID.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityGetPublicKeysRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityGetPublicKeysRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityGetPublicKeysRequest} IdentityGetPublicKeysRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetPublicKeysRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityGetPublicKeysRequest message.
         * @function verify
         * @memberof api.IdentityGetPublicKeysRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityGetPublicKeysRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ids != null && message.hasOwnProperty("ids")) {
                if (!Array.isArray(message.ids))
                    return "ids: array expected";
                for (var i = 0; i < message.ids.length; ++i) {
                    var error = $root.api.IdentityKeyID.verify(message.ids[i]);
                    if (error)
                        return "ids." + error;
                }
            }
            return null;
        };

        /**
         * Creates an IdentityGetPublicKeysRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityGetPublicKeysRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityGetPublicKeysRequest} IdentityGetPublicKeysRequest
         */
        IdentityGetPublicKeysRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityGetPublicKeysRequest)
                return object;
            var message = new $root.api.IdentityGetPublicKeysRequest();
            if (object.ids) {
                if (!Array.isArray(object.ids))
                    throw TypeError(".api.IdentityGetPublicKeysRequest.ids: array expected");
                message.ids = [];
                for (var i = 0; i < object.ids.length; ++i) {
                    if (typeof object.ids[i] !== "object")
                        throw TypeError(".api.IdentityGetPublicKeysRequest.ids: object expected");
                    message.ids[i] = $root.api.IdentityKeyID.fromObject(object.ids[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an IdentityGetPublicKeysRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityGetPublicKeysRequest
         * @static
         * @param {api.IdentityGetPublicKeysRequest} message IdentityGetPublicKeysRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityGetPublicKeysRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.ids = [];
            if (message.ids && message.ids.length) {
                object.ids = [];
                for (var j = 0; j < message.ids.length; ++j)
                    object.ids[j] = $root.api.IdentityKeyID.toObject(message.ids[j], options);
            }
            return object;
        };

        /**
         * Converts this IdentityGetPublicKeysRequest to JSON.
         * @function toJSON
         * @memberof api.IdentityGetPublicKeysRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityGetPublicKeysRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityGetPublicKeysRequest;
    })();

    api.IdentityGetPublicKeysResponse = (function() {

        /**
         * Properties of an IdentityGetPublicKeysResponse.
         * @memberof api
         * @interface IIdentityGetPublicKeysResponse
         * @property {Array.<api.IIdentityPublicKey>|null} [publicKeys] IdentityGetPublicKeysResponse publicKeys
         */

        /**
         * Constructs a new IdentityGetPublicKeysResponse.
         * @memberof api
         * @classdesc Represents an IdentityGetPublicKeysResponse.
         * @implements IIdentityGetPublicKeysResponse
         * @constructor
         * @param {api.IIdentityGetPublicKeysResponse=} [properties] Properties to set
         */
        function IdentityGetPublicKeysResponse(properties) {
            this.publicKeys = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityGetPublicKeysResponse publicKeys.
         * @member {Array.<api.IIdentityPublicKey>} publicKeys
         * @memberof api.IdentityGetPublicKeysResponse
         * @instance
         */
        IdentityGetPublicKeysResponse.prototype.publicKeys = $util.emptyArray;

        /**
         * Creates a new IdentityGetPublicKeysResponse instance using the specified properties.
         * @function create
         * @memberof api.IdentityGetPublicKeysResponse
         * @static
         * @param {api.IIdentityGetPublicKeysResponse=} [properties] Properties to set
         * @returns {api.IdentityGetPublicKeysResponse} IdentityGetPublicKeysResponse instance
         */
        IdentityGetPublicKeysResponse.create = function create(properties) {
            return new IdentityGetPublicKeysResponse(properties);
        };

        /**
         * Encodes the specified IdentityGetPublicKeysResponse message. Does not implicitly {@link api.IdentityGetPublicKeysResponse.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityGetPublicKeysResponse
         * @static
         * @param {api.IIdentityGetPublicKeysResponse} message IdentityGetPublicKeysResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetPublicKeysResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.publicKeys != null && message.publicKeys.length)
                for (var i = 0; i < message.publicKeys.length; ++i)
                    $root.api.IdentityPublicKey.encode(message.publicKeys[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IdentityGetPublicKeysResponse message, length delimited. Does not implicitly {@link api.IdentityGetPublicKeysResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityGetPublicKeysResponse
         * @static
         * @param {api.IIdentityGetPublicKeysResponse} message IdentityGetPublicKeysResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetPublicKeysResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityGetPublicKeysResponse message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityGetPublicKeysResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityGetPublicKeysResponse} IdentityGetPublicKeysResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetPublicKeysResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityGetPublicKeysResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.publicKeys && message.publicKeys.length))
                        message.publicKeys = [];
                    message.publicKeys.push($root.api.IdentityPublicKey.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityGetPublicKeysResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityGetPublicKeysResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityGetPublicKeysResponse} IdentityGetPublicKeysResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetPublicKeysResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityGetPublicKeysResponse message.
         * @function verify
         * @memberof api.IdentityGetPublicKeysResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityGetPublicKeysResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.publicKeys != null && message.hasOwnProperty("publicKeys")) {
                if (!Array.isArray(message.publicKeys))
                    return "publicKeys: array expected";
                for (var i = 0; i < message.publicKeys.length; ++i) {
                    var error = $root.api.IdentityPublicKey.verify(message.publicKeys[i]);
                    if (error)
                        return "publicKeys." + error;
                }
            }
            return null;
        };

        /**
         * Creates an IdentityGetPublicKeysResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityGetPublicKeysResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityGetPublicKeysResponse} IdentityGetPublicKeysResponse
         */
        IdentityGetPublicKeysResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityGetPublicKeysResponse)
                return object;
            var message = new $root.api.IdentityGetPublicKeysResponse();
            if (object.publicKeys) {
                if (!Array.isArray(object.publicKeys))
                    throw TypeError(".api.IdentityGetPublicKeysResponse.publicKeys: array expected");
                message.publicKeys = [];
                for (var i = 0; i < object.publicKeys.length; ++i) {
                    if (typeof object.publicKeys[i] !== "object")
                        throw TypeError(".api.IdentityGetPublicKeysResponse.publicKeys: object expected");
                    message.publicKeys[i] = $root.api.IdentityPublicKey.fromObject(object.publicKeys[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an IdentityGetPublicKeysResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityGetPublicKeysResponse
         * @static
         * @param {api.IdentityGetPublicKeysResponse} message IdentityGetPublicKeysResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityGetPublicKeysResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.publicKeys = [];
            if (message.publicKeys && message.publicKeys.length) {
                object.publicKeys = [];
                for (var j = 0; j < message.publicKeys.length; ++j)
                    object.publicKeys[j] = $root.api.IdentityPublicKey.toObject(message.publicKeys[j], options);
            }
            return object;
        };

        /**
         * Converts this IdentityGetPublicKeysResponse to JSON.
         * @function toJSON
         * @memberof api.IdentityGetPublicKeysResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityGetPublicKeysResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityGetPublicKeysResponse;
    })();

    api.IdentityGetLatestPublicKeysRequest = (function() {

        /**
         * Properties of an IdentityGetLatestPublicKeysRequest.
         * @memberof api
         * @interface IIdentityGetLatestPublicKeysRequest
         * @property {Array.<string>|null} [logins] IdentityGetLatestPublicKeysRequest logins
         */

        /**
         * Constructs a new IdentityGetLatestPublicKeysRequest.
         * @memberof api
         * @classdesc Represents an IdentityGetLatestPublicKeysRequest.
         * @implements IIdentityGetLatestPublicKeysRequest
         * @constructor
         * @param {api.IIdentityGetLatestPublicKeysRequest=} [properties] Properties to set
         */
        function IdentityGetLatestPublicKeysRequest(properties) {
            this.logins = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityGetLatestPublicKeysRequest logins.
         * @member {Array.<string>} logins
         * @memberof api.IdentityGetLatestPublicKeysRequest
         * @instance
         */
        IdentityGetLatestPublicKeysRequest.prototype.logins = $util.emptyArray;

        /**
         * Creates a new IdentityGetLatestPublicKeysRequest instance using the specified properties.
         * @function create
         * @memberof api.IdentityGetLatestPublicKeysRequest
         * @static
         * @param {api.IIdentityGetLatestPublicKeysRequest=} [properties] Properties to set
         * @returns {api.IdentityGetLatestPublicKeysRequest} IdentityGetLatestPublicKeysRequest instance
         */
        IdentityGetLatestPublicKeysRequest.create = function create(properties) {
            return new IdentityGetLatestPublicKeysRequest(properties);
        };

        /**
         * Encodes the specified IdentityGetLatestPublicKeysRequest message. Does not implicitly {@link api.IdentityGetLatestPublicKeysRequest.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityGetLatestPublicKeysRequest
         * @static
         * @param {api.IIdentityGetLatestPublicKeysRequest} message IdentityGetLatestPublicKeysRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetLatestPublicKeysRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.logins != null && message.logins.length)
                for (var i = 0; i < message.logins.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.logins[i]);
            return writer;
        };

        /**
         * Encodes the specified IdentityGetLatestPublicKeysRequest message, length delimited. Does not implicitly {@link api.IdentityGetLatestPublicKeysRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityGetLatestPublicKeysRequest
         * @static
         * @param {api.IIdentityGetLatestPublicKeysRequest} message IdentityGetLatestPublicKeysRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetLatestPublicKeysRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityGetLatestPublicKeysRequest message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityGetLatestPublicKeysRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityGetLatestPublicKeysRequest} IdentityGetLatestPublicKeysRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetLatestPublicKeysRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityGetLatestPublicKeysRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.logins && message.logins.length))
                        message.logins = [];
                    message.logins.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityGetLatestPublicKeysRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityGetLatestPublicKeysRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityGetLatestPublicKeysRequest} IdentityGetLatestPublicKeysRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetLatestPublicKeysRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityGetLatestPublicKeysRequest message.
         * @function verify
         * @memberof api.IdentityGetLatestPublicKeysRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityGetLatestPublicKeysRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.logins != null && message.hasOwnProperty("logins")) {
                if (!Array.isArray(message.logins))
                    return "logins: array expected";
                for (var i = 0; i < message.logins.length; ++i)
                    if (!$util.isString(message.logins[i]))
                        return "logins: string[] expected";
            }
            return null;
        };

        /**
         * Creates an IdentityGetLatestPublicKeysRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityGetLatestPublicKeysRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityGetLatestPublicKeysRequest} IdentityGetLatestPublicKeysRequest
         */
        IdentityGetLatestPublicKeysRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityGetLatestPublicKeysRequest)
                return object;
            var message = new $root.api.IdentityGetLatestPublicKeysRequest();
            if (object.logins) {
                if (!Array.isArray(object.logins))
                    throw TypeError(".api.IdentityGetLatestPublicKeysRequest.logins: array expected");
                message.logins = [];
                for (var i = 0; i < object.logins.length; ++i)
                    message.logins[i] = String(object.logins[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from an IdentityGetLatestPublicKeysRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityGetLatestPublicKeysRequest
         * @static
         * @param {api.IdentityGetLatestPublicKeysRequest} message IdentityGetLatestPublicKeysRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityGetLatestPublicKeysRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.logins = [];
            if (message.logins && message.logins.length) {
                object.logins = [];
                for (var j = 0; j < message.logins.length; ++j)
                    object.logins[j] = message.logins[j];
            }
            return object;
        };

        /**
         * Converts this IdentityGetLatestPublicKeysRequest to JSON.
         * @function toJSON
         * @memberof api.IdentityGetLatestPublicKeysRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityGetLatestPublicKeysRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityGetLatestPublicKeysRequest;
    })();

    api.IdentityGetLatestPublicKeysResponse = (function() {

        /**
         * Properties of an IdentityGetLatestPublicKeysResponse.
         * @memberof api
         * @interface IIdentityGetLatestPublicKeysResponse
         * @property {Array.<api.IIdentityPublicKey>|null} [publicKeys] IdentityGetLatestPublicKeysResponse publicKeys
         */

        /**
         * Constructs a new IdentityGetLatestPublicKeysResponse.
         * @memberof api
         * @classdesc Represents an IdentityGetLatestPublicKeysResponse.
         * @implements IIdentityGetLatestPublicKeysResponse
         * @constructor
         * @param {api.IIdentityGetLatestPublicKeysResponse=} [properties] Properties to set
         */
        function IdentityGetLatestPublicKeysResponse(properties) {
            this.publicKeys = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityGetLatestPublicKeysResponse publicKeys.
         * @member {Array.<api.IIdentityPublicKey>} publicKeys
         * @memberof api.IdentityGetLatestPublicKeysResponse
         * @instance
         */
        IdentityGetLatestPublicKeysResponse.prototype.publicKeys = $util.emptyArray;

        /**
         * Creates a new IdentityGetLatestPublicKeysResponse instance using the specified properties.
         * @function create
         * @memberof api.IdentityGetLatestPublicKeysResponse
         * @static
         * @param {api.IIdentityGetLatestPublicKeysResponse=} [properties] Properties to set
         * @returns {api.IdentityGetLatestPublicKeysResponse} IdentityGetLatestPublicKeysResponse instance
         */
        IdentityGetLatestPublicKeysResponse.create = function create(properties) {
            return new IdentityGetLatestPublicKeysResponse(properties);
        };

        /**
         * Encodes the specified IdentityGetLatestPublicKeysResponse message. Does not implicitly {@link api.IdentityGetLatestPublicKeysResponse.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityGetLatestPublicKeysResponse
         * @static
         * @param {api.IIdentityGetLatestPublicKeysResponse} message IdentityGetLatestPublicKeysResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetLatestPublicKeysResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.publicKeys != null && message.publicKeys.length)
                for (var i = 0; i < message.publicKeys.length; ++i)
                    $root.api.IdentityPublicKey.encode(message.publicKeys[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IdentityGetLatestPublicKeysResponse message, length delimited. Does not implicitly {@link api.IdentityGetLatestPublicKeysResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityGetLatestPublicKeysResponse
         * @static
         * @param {api.IIdentityGetLatestPublicKeysResponse} message IdentityGetLatestPublicKeysResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetLatestPublicKeysResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityGetLatestPublicKeysResponse message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityGetLatestPublicKeysResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityGetLatestPublicKeysResponse} IdentityGetLatestPublicKeysResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetLatestPublicKeysResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityGetLatestPublicKeysResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.publicKeys && message.publicKeys.length))
                        message.publicKeys = [];
                    message.publicKeys.push($root.api.IdentityPublicKey.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityGetLatestPublicKeysResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityGetLatestPublicKeysResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityGetLatestPublicKeysResponse} IdentityGetLatestPublicKeysResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetLatestPublicKeysResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityGetLatestPublicKeysResponse message.
         * @function verify
         * @memberof api.IdentityGetLatestPublicKeysResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityGetLatestPublicKeysResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.publicKeys != null && message.hasOwnProperty("publicKeys")) {
                if (!Array.isArray(message.publicKeys))
                    return "publicKeys: array expected";
                for (var i = 0; i < message.publicKeys.length; ++i) {
                    var error = $root.api.IdentityPublicKey.verify(message.publicKeys[i]);
                    if (error)
                        return "publicKeys." + error;
                }
            }
            return null;
        };

        /**
         * Creates an IdentityGetLatestPublicKeysResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityGetLatestPublicKeysResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityGetLatestPublicKeysResponse} IdentityGetLatestPublicKeysResponse
         */
        IdentityGetLatestPublicKeysResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityGetLatestPublicKeysResponse)
                return object;
            var message = new $root.api.IdentityGetLatestPublicKeysResponse();
            if (object.publicKeys) {
                if (!Array.isArray(object.publicKeys))
                    throw TypeError(".api.IdentityGetLatestPublicKeysResponse.publicKeys: array expected");
                message.publicKeys = [];
                for (var i = 0; i < object.publicKeys.length; ++i) {
                    if (typeof object.publicKeys[i] !== "object")
                        throw TypeError(".api.IdentityGetLatestPublicKeysResponse.publicKeys: object expected");
                    message.publicKeys[i] = $root.api.IdentityPublicKey.fromObject(object.publicKeys[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an IdentityGetLatestPublicKeysResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityGetLatestPublicKeysResponse
         * @static
         * @param {api.IdentityGetLatestPublicKeysResponse} message IdentityGetLatestPublicKeysResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityGetLatestPublicKeysResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.publicKeys = [];
            if (message.publicKeys && message.publicKeys.length) {
                object.publicKeys = [];
                for (var j = 0; j < message.publicKeys.length; ++j)
                    object.publicKeys[j] = $root.api.IdentityPublicKey.toObject(message.publicKeys[j], options);
            }
            return object;
        };

        /**
         * Converts this IdentityGetLatestPublicKeysResponse to JSON.
         * @function toJSON
         * @memberof api.IdentityGetLatestPublicKeysResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityGetLatestPublicKeysResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityGetLatestPublicKeysResponse;
    })();

    api.IdentityGetPublicChainsRequest = (function() {

        /**
         * Properties of an IdentityGetPublicChainsRequest.
         * @memberof api
         * @interface IIdentityGetPublicChainsRequest
         * @property {Array.<api.IdentityGetPublicChainsRequest.IE>|null} [ids] IdentityGetPublicChainsRequest ids
         */

        /**
         * Constructs a new IdentityGetPublicChainsRequest.
         * @memberof api
         * @classdesc Represents an IdentityGetPublicChainsRequest.
         * @implements IIdentityGetPublicChainsRequest
         * @constructor
         * @param {api.IIdentityGetPublicChainsRequest=} [properties] Properties to set
         */
        function IdentityGetPublicChainsRequest(properties) {
            this.ids = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityGetPublicChainsRequest ids.
         * @member {Array.<api.IdentityGetPublicChainsRequest.IE>} ids
         * @memberof api.IdentityGetPublicChainsRequest
         * @instance
         */
        IdentityGetPublicChainsRequest.prototype.ids = $util.emptyArray;

        /**
         * Creates a new IdentityGetPublicChainsRequest instance using the specified properties.
         * @function create
         * @memberof api.IdentityGetPublicChainsRequest
         * @static
         * @param {api.IIdentityGetPublicChainsRequest=} [properties] Properties to set
         * @returns {api.IdentityGetPublicChainsRequest} IdentityGetPublicChainsRequest instance
         */
        IdentityGetPublicChainsRequest.create = function create(properties) {
            return new IdentityGetPublicChainsRequest(properties);
        };

        /**
         * Encodes the specified IdentityGetPublicChainsRequest message. Does not implicitly {@link api.IdentityGetPublicChainsRequest.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityGetPublicChainsRequest
         * @static
         * @param {api.IIdentityGetPublicChainsRequest} message IdentityGetPublicChainsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetPublicChainsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ids != null && message.ids.length)
                for (var i = 0; i < message.ids.length; ++i)
                    $root.api.IdentityGetPublicChainsRequest.E.encode(message.ids[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IdentityGetPublicChainsRequest message, length delimited. Does not implicitly {@link api.IdentityGetPublicChainsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityGetPublicChainsRequest
         * @static
         * @param {api.IIdentityGetPublicChainsRequest} message IdentityGetPublicChainsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetPublicChainsRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityGetPublicChainsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityGetPublicChainsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityGetPublicChainsRequest} IdentityGetPublicChainsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetPublicChainsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityGetPublicChainsRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.ids && message.ids.length))
                        message.ids = [];
                    message.ids.push($root.api.IdentityGetPublicChainsRequest.E.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityGetPublicChainsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityGetPublicChainsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityGetPublicChainsRequest} IdentityGetPublicChainsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetPublicChainsRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityGetPublicChainsRequest message.
         * @function verify
         * @memberof api.IdentityGetPublicChainsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityGetPublicChainsRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ids != null && message.hasOwnProperty("ids")) {
                if (!Array.isArray(message.ids))
                    return "ids: array expected";
                for (var i = 0; i < message.ids.length; ++i) {
                    var error = $root.api.IdentityGetPublicChainsRequest.E.verify(message.ids[i]);
                    if (error)
                        return "ids." + error;
                }
            }
            return null;
        };

        /**
         * Creates an IdentityGetPublicChainsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityGetPublicChainsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityGetPublicChainsRequest} IdentityGetPublicChainsRequest
         */
        IdentityGetPublicChainsRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityGetPublicChainsRequest)
                return object;
            var message = new $root.api.IdentityGetPublicChainsRequest();
            if (object.ids) {
                if (!Array.isArray(object.ids))
                    throw TypeError(".api.IdentityGetPublicChainsRequest.ids: array expected");
                message.ids = [];
                for (var i = 0; i < object.ids.length; ++i) {
                    if (typeof object.ids[i] !== "object")
                        throw TypeError(".api.IdentityGetPublicChainsRequest.ids: object expected");
                    message.ids[i] = $root.api.IdentityGetPublicChainsRequest.E.fromObject(object.ids[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an IdentityGetPublicChainsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityGetPublicChainsRequest
         * @static
         * @param {api.IdentityGetPublicChainsRequest} message IdentityGetPublicChainsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityGetPublicChainsRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.ids = [];
            if (message.ids && message.ids.length) {
                object.ids = [];
                for (var j = 0; j < message.ids.length; ++j)
                    object.ids[j] = $root.api.IdentityGetPublicChainsRequest.E.toObject(message.ids[j], options);
            }
            return object;
        };

        /**
         * Converts this IdentityGetPublicChainsRequest to JSON.
         * @function toJSON
         * @memberof api.IdentityGetPublicChainsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityGetPublicChainsRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        IdentityGetPublicChainsRequest.E = (function() {

            /**
             * Properties of a E.
             * @memberof api.IdentityGetPublicChainsRequest
             * @interface IE
             * @property {api.IIdentityKeyID|null} [id] E id
             * @property {number|null} [since] E since
             */

            /**
             * Constructs a new E.
             * @memberof api.IdentityGetPublicChainsRequest
             * @classdesc Represents a E.
             * @implements IE
             * @constructor
             * @param {api.IdentityGetPublicChainsRequest.IE=} [properties] Properties to set
             */
            function E(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * E id.
             * @member {api.IIdentityKeyID|null|undefined} id
             * @memberof api.IdentityGetPublicChainsRequest.E
             * @instance
             */
            E.prototype.id = null;

            /**
             * E since.
             * @member {number} since
             * @memberof api.IdentityGetPublicChainsRequest.E
             * @instance
             */
            E.prototype.since = 0;

            /**
             * Creates a new E instance using the specified properties.
             * @function create
             * @memberof api.IdentityGetPublicChainsRequest.E
             * @static
             * @param {api.IdentityGetPublicChainsRequest.IE=} [properties] Properties to set
             * @returns {api.IdentityGetPublicChainsRequest.E} E instance
             */
            E.create = function create(properties) {
                return new E(properties);
            };

            /**
             * Encodes the specified E message. Does not implicitly {@link api.IdentityGetPublicChainsRequest.E.verify|verify} messages.
             * @function encode
             * @memberof api.IdentityGetPublicChainsRequest.E
             * @static
             * @param {api.IdentityGetPublicChainsRequest.IE} message E message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            E.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && message.hasOwnProperty("id"))
                    $root.api.IdentityKeyID.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.since != null && message.hasOwnProperty("since"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.since);
                return writer;
            };

            /**
             * Encodes the specified E message, length delimited. Does not implicitly {@link api.IdentityGetPublicChainsRequest.E.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.IdentityGetPublicChainsRequest.E
             * @static
             * @param {api.IdentityGetPublicChainsRequest.IE} message E message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            E.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a E message from the specified reader or buffer.
             * @function decode
             * @memberof api.IdentityGetPublicChainsRequest.E
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.IdentityGetPublicChainsRequest.E} E
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            E.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityGetPublicChainsRequest.E();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = $root.api.IdentityKeyID.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.since = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a E message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.IdentityGetPublicChainsRequest.E
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.IdentityGetPublicChainsRequest.E} E
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            E.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a E message.
             * @function verify
             * @memberof api.IdentityGetPublicChainsRequest.E
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            E.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id")) {
                    var error = $root.api.IdentityKeyID.verify(message.id);
                    if (error)
                        return "id." + error;
                }
                if (message.since != null && message.hasOwnProperty("since"))
                    if (!$util.isInteger(message.since))
                        return "since: integer expected";
                return null;
            };

            /**
             * Creates a E message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.IdentityGetPublicChainsRequest.E
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.IdentityGetPublicChainsRequest.E} E
             */
            E.fromObject = function fromObject(object) {
                if (object instanceof $root.api.IdentityGetPublicChainsRequest.E)
                    return object;
                var message = new $root.api.IdentityGetPublicChainsRequest.E();
                if (object.id != null) {
                    if (typeof object.id !== "object")
                        throw TypeError(".api.IdentityGetPublicChainsRequest.E.id: object expected");
                    message.id = $root.api.IdentityKeyID.fromObject(object.id);
                }
                if (object.since != null)
                    message.since = object.since >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a E message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.IdentityGetPublicChainsRequest.E
             * @static
             * @param {api.IdentityGetPublicChainsRequest.E} message E
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            E.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.id = null;
                    object.since = 0;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = $root.api.IdentityKeyID.toObject(message.id, options);
                if (message.since != null && message.hasOwnProperty("since"))
                    object.since = message.since;
                return object;
            };

            /**
             * Converts this E to JSON.
             * @function toJSON
             * @memberof api.IdentityGetPublicChainsRequest.E
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            E.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return E;
        })();

        return IdentityGetPublicChainsRequest;
    })();

    api.IdentityGetPublicChainsResponse = (function() {

        /**
         * Properties of an IdentityGetPublicChainsResponse.
         * @memberof api
         * @interface IIdentityGetPublicChainsResponse
         * @property {Array.<api.IIdentityPublicChain>|null} [chains] IdentityGetPublicChainsResponse chains
         */

        /**
         * Constructs a new IdentityGetPublicChainsResponse.
         * @memberof api
         * @classdesc Represents an IdentityGetPublicChainsResponse.
         * @implements IIdentityGetPublicChainsResponse
         * @constructor
         * @param {api.IIdentityGetPublicChainsResponse=} [properties] Properties to set
         */
        function IdentityGetPublicChainsResponse(properties) {
            this.chains = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityGetPublicChainsResponse chains.
         * @member {Array.<api.IIdentityPublicChain>} chains
         * @memberof api.IdentityGetPublicChainsResponse
         * @instance
         */
        IdentityGetPublicChainsResponse.prototype.chains = $util.emptyArray;

        /**
         * Creates a new IdentityGetPublicChainsResponse instance using the specified properties.
         * @function create
         * @memberof api.IdentityGetPublicChainsResponse
         * @static
         * @param {api.IIdentityGetPublicChainsResponse=} [properties] Properties to set
         * @returns {api.IdentityGetPublicChainsResponse} IdentityGetPublicChainsResponse instance
         */
        IdentityGetPublicChainsResponse.create = function create(properties) {
            return new IdentityGetPublicChainsResponse(properties);
        };

        /**
         * Encodes the specified IdentityGetPublicChainsResponse message. Does not implicitly {@link api.IdentityGetPublicChainsResponse.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityGetPublicChainsResponse
         * @static
         * @param {api.IIdentityGetPublicChainsResponse} message IdentityGetPublicChainsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetPublicChainsResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.chains != null && message.chains.length)
                for (var i = 0; i < message.chains.length; ++i)
                    $root.api.IdentityPublicChain.encode(message.chains[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IdentityGetPublicChainsResponse message, length delimited. Does not implicitly {@link api.IdentityGetPublicChainsResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityGetPublicChainsResponse
         * @static
         * @param {api.IIdentityGetPublicChainsResponse} message IdentityGetPublicChainsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetPublicChainsResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityGetPublicChainsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityGetPublicChainsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityGetPublicChainsResponse} IdentityGetPublicChainsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetPublicChainsResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityGetPublicChainsResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.chains && message.chains.length))
                        message.chains = [];
                    message.chains.push($root.api.IdentityPublicChain.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityGetPublicChainsResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityGetPublicChainsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityGetPublicChainsResponse} IdentityGetPublicChainsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetPublicChainsResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityGetPublicChainsResponse message.
         * @function verify
         * @memberof api.IdentityGetPublicChainsResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityGetPublicChainsResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.chains != null && message.hasOwnProperty("chains")) {
                if (!Array.isArray(message.chains))
                    return "chains: array expected";
                for (var i = 0; i < message.chains.length; ++i) {
                    var error = $root.api.IdentityPublicChain.verify(message.chains[i]);
                    if (error)
                        return "chains." + error;
                }
            }
            return null;
        };

        /**
         * Creates an IdentityGetPublicChainsResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityGetPublicChainsResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityGetPublicChainsResponse} IdentityGetPublicChainsResponse
         */
        IdentityGetPublicChainsResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityGetPublicChainsResponse)
                return object;
            var message = new $root.api.IdentityGetPublicChainsResponse();
            if (object.chains) {
                if (!Array.isArray(object.chains))
                    throw TypeError(".api.IdentityGetPublicChainsResponse.chains: array expected");
                message.chains = [];
                for (var i = 0; i < object.chains.length; ++i) {
                    if (typeof object.chains[i] !== "object")
                        throw TypeError(".api.IdentityGetPublicChainsResponse.chains: object expected");
                    message.chains[i] = $root.api.IdentityPublicChain.fromObject(object.chains[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an IdentityGetPublicChainsResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityGetPublicChainsResponse
         * @static
         * @param {api.IdentityGetPublicChainsResponse} message IdentityGetPublicChainsResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityGetPublicChainsResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.chains = [];
            if (message.chains && message.chains.length) {
                object.chains = [];
                for (var j = 0; j < message.chains.length; ++j)
                    object.chains[j] = $root.api.IdentityPublicChain.toObject(message.chains[j], options);
            }
            return object;
        };

        /**
         * Converts this IdentityGetPublicChainsResponse to JSON.
         * @function toJSON
         * @memberof api.IdentityGetPublicChainsResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityGetPublicChainsResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityGetPublicChainsResponse;
    })();

    api.IdentityGetLatestPublicChainsRequest = (function() {

        /**
         * Properties of an IdentityGetLatestPublicChainsRequest.
         * @memberof api
         * @interface IIdentityGetLatestPublicChainsRequest
         * @property {Array.<api.IdentityGetLatestPublicChainsRequest.IE>|null} [ids] IdentityGetLatestPublicChainsRequest ids
         */

        /**
         * Constructs a new IdentityGetLatestPublicChainsRequest.
         * @memberof api
         * @classdesc Represents an IdentityGetLatestPublicChainsRequest.
         * @implements IIdentityGetLatestPublicChainsRequest
         * @constructor
         * @param {api.IIdentityGetLatestPublicChainsRequest=} [properties] Properties to set
         */
        function IdentityGetLatestPublicChainsRequest(properties) {
            this.ids = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityGetLatestPublicChainsRequest ids.
         * @member {Array.<api.IdentityGetLatestPublicChainsRequest.IE>} ids
         * @memberof api.IdentityGetLatestPublicChainsRequest
         * @instance
         */
        IdentityGetLatestPublicChainsRequest.prototype.ids = $util.emptyArray;

        /**
         * Creates a new IdentityGetLatestPublicChainsRequest instance using the specified properties.
         * @function create
         * @memberof api.IdentityGetLatestPublicChainsRequest
         * @static
         * @param {api.IIdentityGetLatestPublicChainsRequest=} [properties] Properties to set
         * @returns {api.IdentityGetLatestPublicChainsRequest} IdentityGetLatestPublicChainsRequest instance
         */
        IdentityGetLatestPublicChainsRequest.create = function create(properties) {
            return new IdentityGetLatestPublicChainsRequest(properties);
        };

        /**
         * Encodes the specified IdentityGetLatestPublicChainsRequest message. Does not implicitly {@link api.IdentityGetLatestPublicChainsRequest.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityGetLatestPublicChainsRequest
         * @static
         * @param {api.IIdentityGetLatestPublicChainsRequest} message IdentityGetLatestPublicChainsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetLatestPublicChainsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ids != null && message.ids.length)
                for (var i = 0; i < message.ids.length; ++i)
                    $root.api.IdentityGetLatestPublicChainsRequest.E.encode(message.ids[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IdentityGetLatestPublicChainsRequest message, length delimited. Does not implicitly {@link api.IdentityGetLatestPublicChainsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityGetLatestPublicChainsRequest
         * @static
         * @param {api.IIdentityGetLatestPublicChainsRequest} message IdentityGetLatestPublicChainsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetLatestPublicChainsRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityGetLatestPublicChainsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityGetLatestPublicChainsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityGetLatestPublicChainsRequest} IdentityGetLatestPublicChainsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetLatestPublicChainsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityGetLatestPublicChainsRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.ids && message.ids.length))
                        message.ids = [];
                    message.ids.push($root.api.IdentityGetLatestPublicChainsRequest.E.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityGetLatestPublicChainsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityGetLatestPublicChainsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityGetLatestPublicChainsRequest} IdentityGetLatestPublicChainsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetLatestPublicChainsRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityGetLatestPublicChainsRequest message.
         * @function verify
         * @memberof api.IdentityGetLatestPublicChainsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityGetLatestPublicChainsRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ids != null && message.hasOwnProperty("ids")) {
                if (!Array.isArray(message.ids))
                    return "ids: array expected";
                for (var i = 0; i < message.ids.length; ++i) {
                    var error = $root.api.IdentityGetLatestPublicChainsRequest.E.verify(message.ids[i]);
                    if (error)
                        return "ids." + error;
                }
            }
            return null;
        };

        /**
         * Creates an IdentityGetLatestPublicChainsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityGetLatestPublicChainsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityGetLatestPublicChainsRequest} IdentityGetLatestPublicChainsRequest
         */
        IdentityGetLatestPublicChainsRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityGetLatestPublicChainsRequest)
                return object;
            var message = new $root.api.IdentityGetLatestPublicChainsRequest();
            if (object.ids) {
                if (!Array.isArray(object.ids))
                    throw TypeError(".api.IdentityGetLatestPublicChainsRequest.ids: array expected");
                message.ids = [];
                for (var i = 0; i < object.ids.length; ++i) {
                    if (typeof object.ids[i] !== "object")
                        throw TypeError(".api.IdentityGetLatestPublicChainsRequest.ids: object expected");
                    message.ids[i] = $root.api.IdentityGetLatestPublicChainsRequest.E.fromObject(object.ids[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an IdentityGetLatestPublicChainsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityGetLatestPublicChainsRequest
         * @static
         * @param {api.IdentityGetLatestPublicChainsRequest} message IdentityGetLatestPublicChainsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityGetLatestPublicChainsRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.ids = [];
            if (message.ids && message.ids.length) {
                object.ids = [];
                for (var j = 0; j < message.ids.length; ++j)
                    object.ids[j] = $root.api.IdentityGetLatestPublicChainsRequest.E.toObject(message.ids[j], options);
            }
            return object;
        };

        /**
         * Converts this IdentityGetLatestPublicChainsRequest to JSON.
         * @function toJSON
         * @memberof api.IdentityGetLatestPublicChainsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityGetLatestPublicChainsRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        IdentityGetLatestPublicChainsRequest.E = (function() {

            /**
             * Properties of a E.
             * @memberof api.IdentityGetLatestPublicChainsRequest
             * @interface IE
             * @property {string|null} [login] E login
             * @property {number|null} [since] E since
             */

            /**
             * Constructs a new E.
             * @memberof api.IdentityGetLatestPublicChainsRequest
             * @classdesc Represents a E.
             * @implements IE
             * @constructor
             * @param {api.IdentityGetLatestPublicChainsRequest.IE=} [properties] Properties to set
             */
            function E(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * E login.
             * @member {string} login
             * @memberof api.IdentityGetLatestPublicChainsRequest.E
             * @instance
             */
            E.prototype.login = "";

            /**
             * E since.
             * @member {number} since
             * @memberof api.IdentityGetLatestPublicChainsRequest.E
             * @instance
             */
            E.prototype.since = 0;

            /**
             * Creates a new E instance using the specified properties.
             * @function create
             * @memberof api.IdentityGetLatestPublicChainsRequest.E
             * @static
             * @param {api.IdentityGetLatestPublicChainsRequest.IE=} [properties] Properties to set
             * @returns {api.IdentityGetLatestPublicChainsRequest.E} E instance
             */
            E.create = function create(properties) {
                return new E(properties);
            };

            /**
             * Encodes the specified E message. Does not implicitly {@link api.IdentityGetLatestPublicChainsRequest.E.verify|verify} messages.
             * @function encode
             * @memberof api.IdentityGetLatestPublicChainsRequest.E
             * @static
             * @param {api.IdentityGetLatestPublicChainsRequest.IE} message E message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            E.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.login != null && message.hasOwnProperty("login"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
                if (message.since != null && message.hasOwnProperty("since"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.since);
                return writer;
            };

            /**
             * Encodes the specified E message, length delimited. Does not implicitly {@link api.IdentityGetLatestPublicChainsRequest.E.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.IdentityGetLatestPublicChainsRequest.E
             * @static
             * @param {api.IdentityGetLatestPublicChainsRequest.IE} message E message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            E.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a E message from the specified reader or buffer.
             * @function decode
             * @memberof api.IdentityGetLatestPublicChainsRequest.E
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.IdentityGetLatestPublicChainsRequest.E} E
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            E.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityGetLatestPublicChainsRequest.E();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.login = reader.string();
                        break;
                    case 2:
                        message.since = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a E message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.IdentityGetLatestPublicChainsRequest.E
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.IdentityGetLatestPublicChainsRequest.E} E
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            E.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a E message.
             * @function verify
             * @memberof api.IdentityGetLatestPublicChainsRequest.E
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            E.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.login != null && message.hasOwnProperty("login"))
                    if (!$util.isString(message.login))
                        return "login: string expected";
                if (message.since != null && message.hasOwnProperty("since"))
                    if (!$util.isInteger(message.since))
                        return "since: integer expected";
                return null;
            };

            /**
             * Creates a E message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.IdentityGetLatestPublicChainsRequest.E
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.IdentityGetLatestPublicChainsRequest.E} E
             */
            E.fromObject = function fromObject(object) {
                if (object instanceof $root.api.IdentityGetLatestPublicChainsRequest.E)
                    return object;
                var message = new $root.api.IdentityGetLatestPublicChainsRequest.E();
                if (object.login != null)
                    message.login = String(object.login);
                if (object.since != null)
                    message.since = object.since >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a E message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.IdentityGetLatestPublicChainsRequest.E
             * @static
             * @param {api.IdentityGetLatestPublicChainsRequest.E} message E
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            E.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.login = "";
                    object.since = 0;
                }
                if (message.login != null && message.hasOwnProperty("login"))
                    object.login = message.login;
                if (message.since != null && message.hasOwnProperty("since"))
                    object.since = message.since;
                return object;
            };

            /**
             * Converts this E to JSON.
             * @function toJSON
             * @memberof api.IdentityGetLatestPublicChainsRequest.E
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            E.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return E;
        })();

        return IdentityGetLatestPublicChainsRequest;
    })();

    api.IdentityGetLatestPublicChainsResponse = (function() {

        /**
         * Properties of an IdentityGetLatestPublicChainsResponse.
         * @memberof api
         * @interface IIdentityGetLatestPublicChainsResponse
         * @property {Array.<api.IIdentityPublicChain>|null} [chains] IdentityGetLatestPublicChainsResponse chains
         */

        /**
         * Constructs a new IdentityGetLatestPublicChainsResponse.
         * @memberof api
         * @classdesc Represents an IdentityGetLatestPublicChainsResponse.
         * @implements IIdentityGetLatestPublicChainsResponse
         * @constructor
         * @param {api.IIdentityGetLatestPublicChainsResponse=} [properties] Properties to set
         */
        function IdentityGetLatestPublicChainsResponse(properties) {
            this.chains = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityGetLatestPublicChainsResponse chains.
         * @member {Array.<api.IIdentityPublicChain>} chains
         * @memberof api.IdentityGetLatestPublicChainsResponse
         * @instance
         */
        IdentityGetLatestPublicChainsResponse.prototype.chains = $util.emptyArray;

        /**
         * Creates a new IdentityGetLatestPublicChainsResponse instance using the specified properties.
         * @function create
         * @memberof api.IdentityGetLatestPublicChainsResponse
         * @static
         * @param {api.IIdentityGetLatestPublicChainsResponse=} [properties] Properties to set
         * @returns {api.IdentityGetLatestPublicChainsResponse} IdentityGetLatestPublicChainsResponse instance
         */
        IdentityGetLatestPublicChainsResponse.create = function create(properties) {
            return new IdentityGetLatestPublicChainsResponse(properties);
        };

        /**
         * Encodes the specified IdentityGetLatestPublicChainsResponse message. Does not implicitly {@link api.IdentityGetLatestPublicChainsResponse.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityGetLatestPublicChainsResponse
         * @static
         * @param {api.IIdentityGetLatestPublicChainsResponse} message IdentityGetLatestPublicChainsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetLatestPublicChainsResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.chains != null && message.chains.length)
                for (var i = 0; i < message.chains.length; ++i)
                    $root.api.IdentityPublicChain.encode(message.chains[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IdentityGetLatestPublicChainsResponse message, length delimited. Does not implicitly {@link api.IdentityGetLatestPublicChainsResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityGetLatestPublicChainsResponse
         * @static
         * @param {api.IIdentityGetLatestPublicChainsResponse} message IdentityGetLatestPublicChainsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetLatestPublicChainsResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityGetLatestPublicChainsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityGetLatestPublicChainsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityGetLatestPublicChainsResponse} IdentityGetLatestPublicChainsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetLatestPublicChainsResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityGetLatestPublicChainsResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.chains && message.chains.length))
                        message.chains = [];
                    message.chains.push($root.api.IdentityPublicChain.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityGetLatestPublicChainsResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityGetLatestPublicChainsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityGetLatestPublicChainsResponse} IdentityGetLatestPublicChainsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetLatestPublicChainsResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityGetLatestPublicChainsResponse message.
         * @function verify
         * @memberof api.IdentityGetLatestPublicChainsResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityGetLatestPublicChainsResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.chains != null && message.hasOwnProperty("chains")) {
                if (!Array.isArray(message.chains))
                    return "chains: array expected";
                for (var i = 0; i < message.chains.length; ++i) {
                    var error = $root.api.IdentityPublicChain.verify(message.chains[i]);
                    if (error)
                        return "chains." + error;
                }
            }
            return null;
        };

        /**
         * Creates an IdentityGetLatestPublicChainsResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityGetLatestPublicChainsResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityGetLatestPublicChainsResponse} IdentityGetLatestPublicChainsResponse
         */
        IdentityGetLatestPublicChainsResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityGetLatestPublicChainsResponse)
                return object;
            var message = new $root.api.IdentityGetLatestPublicChainsResponse();
            if (object.chains) {
                if (!Array.isArray(object.chains))
                    throw TypeError(".api.IdentityGetLatestPublicChainsResponse.chains: array expected");
                message.chains = [];
                for (var i = 0; i < object.chains.length; ++i) {
                    if (typeof object.chains[i] !== "object")
                        throw TypeError(".api.IdentityGetLatestPublicChainsResponse.chains: object expected");
                    message.chains[i] = $root.api.IdentityPublicChain.fromObject(object.chains[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an IdentityGetLatestPublicChainsResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityGetLatestPublicChainsResponse
         * @static
         * @param {api.IdentityGetLatestPublicChainsResponse} message IdentityGetLatestPublicChainsResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityGetLatestPublicChainsResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.chains = [];
            if (message.chains && message.chains.length) {
                object.chains = [];
                for (var j = 0; j < message.chains.length; ++j)
                    object.chains[j] = $root.api.IdentityPublicChain.toObject(message.chains[j], options);
            }
            return object;
        };

        /**
         * Converts this IdentityGetLatestPublicChainsResponse to JSON.
         * @function toJSON
         * @memberof api.IdentityGetLatestPublicChainsResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityGetLatestPublicChainsResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityGetLatestPublicChainsResponse;
    })();

    api.IdentityShareLink = (function() {

        /**
         * Properties of an IdentityShareLink.
         * @memberof api
         * @interface IIdentityShareLink
         * @property {api.IIdentityKeyID|null} [id] IdentityShareLink id
         * @property {api.IdentityShareKind|null} [kind] IdentityShareLink kind
         * @property {boolean|null} [locked] IdentityShareLink locked
         */

        /**
         * Constructs a new IdentityShareLink.
         * @memberof api
         * @classdesc Represents an IdentityShareLink.
         * @implements IIdentityShareLink
         * @constructor
         * @param {api.IIdentityShareLink=} [properties] Properties to set
         */
        function IdentityShareLink(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityShareLink id.
         * @member {api.IIdentityKeyID|null|undefined} id
         * @memberof api.IdentityShareLink
         * @instance
         */
        IdentityShareLink.prototype.id = null;

        /**
         * IdentityShareLink kind.
         * @member {api.IdentityShareKind} kind
         * @memberof api.IdentityShareLink
         * @instance
         */
        IdentityShareLink.prototype.kind = 0;

        /**
         * IdentityShareLink locked.
         * @member {boolean} locked
         * @memberof api.IdentityShareLink
         * @instance
         */
        IdentityShareLink.prototype.locked = false;

        /**
         * Creates a new IdentityShareLink instance using the specified properties.
         * @function create
         * @memberof api.IdentityShareLink
         * @static
         * @param {api.IIdentityShareLink=} [properties] Properties to set
         * @returns {api.IdentityShareLink} IdentityShareLink instance
         */
        IdentityShareLink.create = function create(properties) {
            return new IdentityShareLink(properties);
        };

        /**
         * Encodes the specified IdentityShareLink message. Does not implicitly {@link api.IdentityShareLink.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityShareLink
         * @static
         * @param {api.IIdentityShareLink} message IdentityShareLink message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityShareLink.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                $root.api.IdentityKeyID.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.kind != null && message.hasOwnProperty("kind"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.kind);
            if (message.locked != null && message.hasOwnProperty("locked"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.locked);
            return writer;
        };

        /**
         * Encodes the specified IdentityShareLink message, length delimited. Does not implicitly {@link api.IdentityShareLink.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityShareLink
         * @static
         * @param {api.IIdentityShareLink} message IdentityShareLink message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityShareLink.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityShareLink message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityShareLink
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityShareLink} IdentityShareLink
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityShareLink.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityShareLink();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = $root.api.IdentityKeyID.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.kind = reader.int32();
                    break;
                case 3:
                    message.locked = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityShareLink message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityShareLink
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityShareLink} IdentityShareLink
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityShareLink.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityShareLink message.
         * @function verify
         * @memberof api.IdentityShareLink
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityShareLink.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id")) {
                var error = $root.api.IdentityKeyID.verify(message.id);
                if (error)
                    return "id." + error;
            }
            if (message.kind != null && message.hasOwnProperty("kind"))
                switch (message.kind) {
                default:
                    return "kind: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.locked != null && message.hasOwnProperty("locked"))
                if (typeof message.locked !== "boolean")
                    return "locked: boolean expected";
            return null;
        };

        /**
         * Creates an IdentityShareLink message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityShareLink
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityShareLink} IdentityShareLink
         */
        IdentityShareLink.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityShareLink)
                return object;
            var message = new $root.api.IdentityShareLink();
            if (object.id != null) {
                if (typeof object.id !== "object")
                    throw TypeError(".api.IdentityShareLink.id: object expected");
                message.id = $root.api.IdentityKeyID.fromObject(object.id);
            }
            switch (object.kind) {
            case "BOX":
            case 0:
                message.kind = 0;
                break;
            case "SHARING":
            case 1:
                message.kind = 1;
                break;
            }
            if (object.locked != null)
                message.locked = Boolean(object.locked);
            return message;
        };

        /**
         * Creates a plain object from an IdentityShareLink message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityShareLink
         * @static
         * @param {api.IdentityShareLink} message IdentityShareLink
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityShareLink.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = null;
                object.kind = options.enums === String ? "BOX" : 0;
                object.locked = false;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = $root.api.IdentityKeyID.toObject(message.id, options);
            if (message.kind != null && message.hasOwnProperty("kind"))
                object.kind = options.enums === String ? $root.api.IdentityShareKind[message.kind] : message.kind;
            if (message.locked != null && message.hasOwnProperty("locked"))
                object.locked = message.locked;
            return object;
        };

        /**
         * Converts this IdentityShareLink to JSON.
         * @function toJSON
         * @memberof api.IdentityShareLink
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityShareLink.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityShareLink;
    })();

    api.IdentityGetSharingGroupResponse = (function() {

        /**
         * Properties of an IdentityGetSharingGroupResponse.
         * @memberof api
         * @interface IIdentityGetSharingGroupResponse
         * @property {Array.<api.IIdentityShareLink>|null} [sharingGroup] IdentityGetSharingGroupResponse sharingGroup
         */

        /**
         * Constructs a new IdentityGetSharingGroupResponse.
         * @memberof api
         * @classdesc Represents an IdentityGetSharingGroupResponse.
         * @implements IIdentityGetSharingGroupResponse
         * @constructor
         * @param {api.IIdentityGetSharingGroupResponse=} [properties] Properties to set
         */
        function IdentityGetSharingGroupResponse(properties) {
            this.sharingGroup = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityGetSharingGroupResponse sharingGroup.
         * @member {Array.<api.IIdentityShareLink>} sharingGroup
         * @memberof api.IdentityGetSharingGroupResponse
         * @instance
         */
        IdentityGetSharingGroupResponse.prototype.sharingGroup = $util.emptyArray;

        /**
         * Creates a new IdentityGetSharingGroupResponse instance using the specified properties.
         * @function create
         * @memberof api.IdentityGetSharingGroupResponse
         * @static
         * @param {api.IIdentityGetSharingGroupResponse=} [properties] Properties to set
         * @returns {api.IdentityGetSharingGroupResponse} IdentityGetSharingGroupResponse instance
         */
        IdentityGetSharingGroupResponse.create = function create(properties) {
            return new IdentityGetSharingGroupResponse(properties);
        };

        /**
         * Encodes the specified IdentityGetSharingGroupResponse message. Does not implicitly {@link api.IdentityGetSharingGroupResponse.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityGetSharingGroupResponse
         * @static
         * @param {api.IIdentityGetSharingGroupResponse} message IdentityGetSharingGroupResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetSharingGroupResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.sharingGroup != null && message.sharingGroup.length)
                for (var i = 0; i < message.sharingGroup.length; ++i)
                    $root.api.IdentityShareLink.encode(message.sharingGroup[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IdentityGetSharingGroupResponse message, length delimited. Does not implicitly {@link api.IdentityGetSharingGroupResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityGetSharingGroupResponse
         * @static
         * @param {api.IIdentityGetSharingGroupResponse} message IdentityGetSharingGroupResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetSharingGroupResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityGetSharingGroupResponse message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityGetSharingGroupResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityGetSharingGroupResponse} IdentityGetSharingGroupResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetSharingGroupResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityGetSharingGroupResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.sharingGroup && message.sharingGroup.length))
                        message.sharingGroup = [];
                    message.sharingGroup.push($root.api.IdentityShareLink.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityGetSharingGroupResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityGetSharingGroupResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityGetSharingGroupResponse} IdentityGetSharingGroupResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetSharingGroupResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityGetSharingGroupResponse message.
         * @function verify
         * @memberof api.IdentityGetSharingGroupResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityGetSharingGroupResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.sharingGroup != null && message.hasOwnProperty("sharingGroup")) {
                if (!Array.isArray(message.sharingGroup))
                    return "sharingGroup: array expected";
                for (var i = 0; i < message.sharingGroup.length; ++i) {
                    var error = $root.api.IdentityShareLink.verify(message.sharingGroup[i]);
                    if (error)
                        return "sharingGroup." + error;
                }
            }
            return null;
        };

        /**
         * Creates an IdentityGetSharingGroupResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityGetSharingGroupResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityGetSharingGroupResponse} IdentityGetSharingGroupResponse
         */
        IdentityGetSharingGroupResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityGetSharingGroupResponse)
                return object;
            var message = new $root.api.IdentityGetSharingGroupResponse();
            if (object.sharingGroup) {
                if (!Array.isArray(object.sharingGroup))
                    throw TypeError(".api.IdentityGetSharingGroupResponse.sharingGroup: array expected");
                message.sharingGroup = [];
                for (var i = 0; i < object.sharingGroup.length; ++i) {
                    if (typeof object.sharingGroup[i] !== "object")
                        throw TypeError(".api.IdentityGetSharingGroupResponse.sharingGroup: object expected");
                    message.sharingGroup[i] = $root.api.IdentityShareLink.fromObject(object.sharingGroup[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an IdentityGetSharingGroupResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityGetSharingGroupResponse
         * @static
         * @param {api.IdentityGetSharingGroupResponse} message IdentityGetSharingGroupResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityGetSharingGroupResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.sharingGroup = [];
            if (message.sharingGroup && message.sharingGroup.length) {
                object.sharingGroup = [];
                for (var j = 0; j < message.sharingGroup.length; ++j)
                    object.sharingGroup[j] = $root.api.IdentityShareLink.toObject(message.sharingGroup[j], options);
            }
            return object;
        };

        /**
         * Converts this IdentityGetSharingGroupResponse to JSON.
         * @function toJSON
         * @memberof api.IdentityGetSharingGroupResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityGetSharingGroupResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityGetSharingGroupResponse;
    })();

    api.IdentityGetAccessGroupResponse = (function() {

        /**
         * Properties of an IdentityGetAccessGroupResponse.
         * @memberof api
         * @interface IIdentityGetAccessGroupResponse
         * @property {Array.<api.IIdentityShareLink>|null} [accessGroup] IdentityGetAccessGroupResponse accessGroup
         */

        /**
         * Constructs a new IdentityGetAccessGroupResponse.
         * @memberof api
         * @classdesc Represents an IdentityGetAccessGroupResponse.
         * @implements IIdentityGetAccessGroupResponse
         * @constructor
         * @param {api.IIdentityGetAccessGroupResponse=} [properties] Properties to set
         */
        function IdentityGetAccessGroupResponse(properties) {
            this.accessGroup = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityGetAccessGroupResponse accessGroup.
         * @member {Array.<api.IIdentityShareLink>} accessGroup
         * @memberof api.IdentityGetAccessGroupResponse
         * @instance
         */
        IdentityGetAccessGroupResponse.prototype.accessGroup = $util.emptyArray;

        /**
         * Creates a new IdentityGetAccessGroupResponse instance using the specified properties.
         * @function create
         * @memberof api.IdentityGetAccessGroupResponse
         * @static
         * @param {api.IIdentityGetAccessGroupResponse=} [properties] Properties to set
         * @returns {api.IdentityGetAccessGroupResponse} IdentityGetAccessGroupResponse instance
         */
        IdentityGetAccessGroupResponse.create = function create(properties) {
            return new IdentityGetAccessGroupResponse(properties);
        };

        /**
         * Encodes the specified IdentityGetAccessGroupResponse message. Does not implicitly {@link api.IdentityGetAccessGroupResponse.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityGetAccessGroupResponse
         * @static
         * @param {api.IIdentityGetAccessGroupResponse} message IdentityGetAccessGroupResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetAccessGroupResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.accessGroup != null && message.accessGroup.length)
                for (var i = 0; i < message.accessGroup.length; ++i)
                    $root.api.IdentityShareLink.encode(message.accessGroup[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IdentityGetAccessGroupResponse message, length delimited. Does not implicitly {@link api.IdentityGetAccessGroupResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityGetAccessGroupResponse
         * @static
         * @param {api.IIdentityGetAccessGroupResponse} message IdentityGetAccessGroupResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetAccessGroupResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityGetAccessGroupResponse message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityGetAccessGroupResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityGetAccessGroupResponse} IdentityGetAccessGroupResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetAccessGroupResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityGetAccessGroupResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.accessGroup && message.accessGroup.length))
                        message.accessGroup = [];
                    message.accessGroup.push($root.api.IdentityShareLink.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityGetAccessGroupResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityGetAccessGroupResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityGetAccessGroupResponse} IdentityGetAccessGroupResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetAccessGroupResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityGetAccessGroupResponse message.
         * @function verify
         * @memberof api.IdentityGetAccessGroupResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityGetAccessGroupResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.accessGroup != null && message.hasOwnProperty("accessGroup")) {
                if (!Array.isArray(message.accessGroup))
                    return "accessGroup: array expected";
                for (var i = 0; i < message.accessGroup.length; ++i) {
                    var error = $root.api.IdentityShareLink.verify(message.accessGroup[i]);
                    if (error)
                        return "accessGroup." + error;
                }
            }
            return null;
        };

        /**
         * Creates an IdentityGetAccessGroupResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityGetAccessGroupResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityGetAccessGroupResponse} IdentityGetAccessGroupResponse
         */
        IdentityGetAccessGroupResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityGetAccessGroupResponse)
                return object;
            var message = new $root.api.IdentityGetAccessGroupResponse();
            if (object.accessGroup) {
                if (!Array.isArray(object.accessGroup))
                    throw TypeError(".api.IdentityGetAccessGroupResponse.accessGroup: array expected");
                message.accessGroup = [];
                for (var i = 0; i < object.accessGroup.length; ++i) {
                    if (typeof object.accessGroup[i] !== "object")
                        throw TypeError(".api.IdentityGetAccessGroupResponse.accessGroup: object expected");
                    message.accessGroup[i] = $root.api.IdentityShareLink.fromObject(object.accessGroup[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an IdentityGetAccessGroupResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityGetAccessGroupResponse
         * @static
         * @param {api.IdentityGetAccessGroupResponse} message IdentityGetAccessGroupResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityGetAccessGroupResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.accessGroup = [];
            if (message.accessGroup && message.accessGroup.length) {
                object.accessGroup = [];
                for (var j = 0; j < message.accessGroup.length; ++j)
                    object.accessGroup[j] = $root.api.IdentityShareLink.toObject(message.accessGroup[j], options);
            }
            return object;
        };

        /**
         * Converts this IdentityGetAccessGroupResponse to JSON.
         * @function toJSON
         * @memberof api.IdentityGetAccessGroupResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityGetAccessGroupResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityGetAccessGroupResponse;
    })();

    api.IdentityShareEntry = (function() {

        /**
         * Properties of an IdentityShareEntry.
         * @memberof api
         * @interface IIdentityShareEntry
         * @property {string|null} [login] IdentityShareEntry login
         * @property {number|null} [version] IdentityShareEntry version
         * @property {Uint8Array|null} [nonce] IdentityShareEntry nonce
         * @property {Uint8Array|null} [encryptedKey] IdentityShareEntry encryptedKey
         * @property {api.IdentityShareKind|null} [kind] IdentityShareEntry kind
         */

        /**
         * Constructs a new IdentityShareEntry.
         * @memberof api
         * @classdesc Represents an IdentityShareEntry.
         * @implements IIdentityShareEntry
         * @constructor
         * @param {api.IIdentityShareEntry=} [properties] Properties to set
         */
        function IdentityShareEntry(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityShareEntry login.
         * @member {string} login
         * @memberof api.IdentityShareEntry
         * @instance
         */
        IdentityShareEntry.prototype.login = "";

        /**
         * IdentityShareEntry version.
         * @member {number} version
         * @memberof api.IdentityShareEntry
         * @instance
         */
        IdentityShareEntry.prototype.version = 0;

        /**
         * IdentityShareEntry nonce.
         * @member {Uint8Array} nonce
         * @memberof api.IdentityShareEntry
         * @instance
         */
        IdentityShareEntry.prototype.nonce = $util.newBuffer([]);

        /**
         * IdentityShareEntry encryptedKey.
         * @member {Uint8Array} encryptedKey
         * @memberof api.IdentityShareEntry
         * @instance
         */
        IdentityShareEntry.prototype.encryptedKey = $util.newBuffer([]);

        /**
         * IdentityShareEntry kind.
         * @member {api.IdentityShareKind} kind
         * @memberof api.IdentityShareEntry
         * @instance
         */
        IdentityShareEntry.prototype.kind = 0;

        /**
         * Creates a new IdentityShareEntry instance using the specified properties.
         * @function create
         * @memberof api.IdentityShareEntry
         * @static
         * @param {api.IIdentityShareEntry=} [properties] Properties to set
         * @returns {api.IdentityShareEntry} IdentityShareEntry instance
         */
        IdentityShareEntry.create = function create(properties) {
            return new IdentityShareEntry(properties);
        };

        /**
         * Encodes the specified IdentityShareEntry message. Does not implicitly {@link api.IdentityShareEntry.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityShareEntry
         * @static
         * @param {api.IIdentityShareEntry} message IdentityShareEntry message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityShareEntry.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            if (message.version != null && message.hasOwnProperty("version"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.version);
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.nonce);
            if (message.encryptedKey != null && message.hasOwnProperty("encryptedKey"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.encryptedKey);
            if (message.kind != null && message.hasOwnProperty("kind"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.kind);
            return writer;
        };

        /**
         * Encodes the specified IdentityShareEntry message, length delimited. Does not implicitly {@link api.IdentityShareEntry.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityShareEntry
         * @static
         * @param {api.IIdentityShareEntry} message IdentityShareEntry message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityShareEntry.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityShareEntry message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityShareEntry
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityShareEntry} IdentityShareEntry
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityShareEntry.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityShareEntry();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                case 2:
                    message.version = reader.uint32();
                    break;
                case 3:
                    message.nonce = reader.bytes();
                    break;
                case 4:
                    message.encryptedKey = reader.bytes();
                    break;
                case 5:
                    message.kind = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityShareEntry message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityShareEntry
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityShareEntry} IdentityShareEntry
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityShareEntry.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityShareEntry message.
         * @function verify
         * @memberof api.IdentityShareEntry
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityShareEntry.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isInteger(message.version))
                    return "version: integer expected";
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                if (!(message.nonce && typeof message.nonce.length === "number" || $util.isString(message.nonce)))
                    return "nonce: buffer expected";
            if (message.encryptedKey != null && message.hasOwnProperty("encryptedKey"))
                if (!(message.encryptedKey && typeof message.encryptedKey.length === "number" || $util.isString(message.encryptedKey)))
                    return "encryptedKey: buffer expected";
            if (message.kind != null && message.hasOwnProperty("kind"))
                switch (message.kind) {
                default:
                    return "kind: enum value expected";
                case 0:
                case 1:
                    break;
                }
            return null;
        };

        /**
         * Creates an IdentityShareEntry message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityShareEntry
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityShareEntry} IdentityShareEntry
         */
        IdentityShareEntry.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityShareEntry)
                return object;
            var message = new $root.api.IdentityShareEntry();
            if (object.login != null)
                message.login = String(object.login);
            if (object.version != null)
                message.version = object.version >>> 0;
            if (object.nonce != null)
                if (typeof object.nonce === "string")
                    $util.base64.decode(object.nonce, message.nonce = $util.newBuffer($util.base64.length(object.nonce)), 0);
                else if (object.nonce.length)
                    message.nonce = object.nonce;
            if (object.encryptedKey != null)
                if (typeof object.encryptedKey === "string")
                    $util.base64.decode(object.encryptedKey, message.encryptedKey = $util.newBuffer($util.base64.length(object.encryptedKey)), 0);
                else if (object.encryptedKey.length)
                    message.encryptedKey = object.encryptedKey;
            switch (object.kind) {
            case "BOX":
            case 0:
                message.kind = 0;
                break;
            case "SHARING":
            case 1:
                message.kind = 1;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from an IdentityShareEntry message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityShareEntry
         * @static
         * @param {api.IdentityShareEntry} message IdentityShareEntry
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityShareEntry.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.login = "";
                object.version = 0;
                if (options.bytes === String)
                    object.nonce = "";
                else {
                    object.nonce = [];
                    if (options.bytes !== Array)
                        object.nonce = $util.newBuffer(object.nonce);
                }
                if (options.bytes === String)
                    object.encryptedKey = "";
                else {
                    object.encryptedKey = [];
                    if (options.bytes !== Array)
                        object.encryptedKey = $util.newBuffer(object.encryptedKey);
                }
                object.kind = options.enums === String ? "BOX" : 0;
            }
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                object.nonce = options.bytes === String ? $util.base64.encode(message.nonce, 0, message.nonce.length) : options.bytes === Array ? Array.prototype.slice.call(message.nonce) : message.nonce;
            if (message.encryptedKey != null && message.hasOwnProperty("encryptedKey"))
                object.encryptedKey = options.bytes === String ? $util.base64.encode(message.encryptedKey, 0, message.encryptedKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedKey) : message.encryptedKey;
            if (message.kind != null && message.hasOwnProperty("kind"))
                object.kind = options.enums === String ? $root.api.IdentityShareKind[message.kind] : message.kind;
            return object;
        };

        /**
         * Converts this IdentityShareEntry to JSON.
         * @function toJSON
         * @memberof api.IdentityShareEntry
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityShareEntry.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityShareEntry;
    })();

    api.IdentityShareRequest = (function() {

        /**
         * Properties of an IdentityShareRequest.
         * @memberof api
         * @interface IIdentityShareRequest
         * @property {string|null} [login] IdentityShareRequest login
         * @property {number|null} [version] IdentityShareRequest version
         * @property {Array.<api.IIdentityShareEntry>|null} [sharingGroup] IdentityShareRequest sharingGroup
         */

        /**
         * Constructs a new IdentityShareRequest.
         * @memberof api
         * @classdesc Represents an IdentityShareRequest.
         * @implements IIdentityShareRequest
         * @constructor
         * @param {api.IIdentityShareRequest=} [properties] Properties to set
         */
        function IdentityShareRequest(properties) {
            this.sharingGroup = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityShareRequest login.
         * @member {string} login
         * @memberof api.IdentityShareRequest
         * @instance
         */
        IdentityShareRequest.prototype.login = "";

        /**
         * IdentityShareRequest version.
         * @member {number} version
         * @memberof api.IdentityShareRequest
         * @instance
         */
        IdentityShareRequest.prototype.version = 0;

        /**
         * IdentityShareRequest sharingGroup.
         * @member {Array.<api.IIdentityShareEntry>} sharingGroup
         * @memberof api.IdentityShareRequest
         * @instance
         */
        IdentityShareRequest.prototype.sharingGroup = $util.emptyArray;

        /**
         * Creates a new IdentityShareRequest instance using the specified properties.
         * @function create
         * @memberof api.IdentityShareRequest
         * @static
         * @param {api.IIdentityShareRequest=} [properties] Properties to set
         * @returns {api.IdentityShareRequest} IdentityShareRequest instance
         */
        IdentityShareRequest.create = function create(properties) {
            return new IdentityShareRequest(properties);
        };

        /**
         * Encodes the specified IdentityShareRequest message. Does not implicitly {@link api.IdentityShareRequest.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityShareRequest
         * @static
         * @param {api.IIdentityShareRequest} message IdentityShareRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityShareRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            if (message.version != null && message.hasOwnProperty("version"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.version);
            if (message.sharingGroup != null && message.sharingGroup.length)
                for (var i = 0; i < message.sharingGroup.length; ++i)
                    $root.api.IdentityShareEntry.encode(message.sharingGroup[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IdentityShareRequest message, length delimited. Does not implicitly {@link api.IdentityShareRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityShareRequest
         * @static
         * @param {api.IIdentityShareRequest} message IdentityShareRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityShareRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityShareRequest message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityShareRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityShareRequest} IdentityShareRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityShareRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityShareRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                case 2:
                    message.version = reader.uint32();
                    break;
                case 3:
                    if (!(message.sharingGroup && message.sharingGroup.length))
                        message.sharingGroup = [];
                    message.sharingGroup.push($root.api.IdentityShareEntry.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityShareRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityShareRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityShareRequest} IdentityShareRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityShareRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityShareRequest message.
         * @function verify
         * @memberof api.IdentityShareRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityShareRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isInteger(message.version))
                    return "version: integer expected";
            if (message.sharingGroup != null && message.hasOwnProperty("sharingGroup")) {
                if (!Array.isArray(message.sharingGroup))
                    return "sharingGroup: array expected";
                for (var i = 0; i < message.sharingGroup.length; ++i) {
                    var error = $root.api.IdentityShareEntry.verify(message.sharingGroup[i]);
                    if (error)
                        return "sharingGroup." + error;
                }
            }
            return null;
        };

        /**
         * Creates an IdentityShareRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityShareRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityShareRequest} IdentityShareRequest
         */
        IdentityShareRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityShareRequest)
                return object;
            var message = new $root.api.IdentityShareRequest();
            if (object.login != null)
                message.login = String(object.login);
            if (object.version != null)
                message.version = object.version >>> 0;
            if (object.sharingGroup) {
                if (!Array.isArray(object.sharingGroup))
                    throw TypeError(".api.IdentityShareRequest.sharingGroup: array expected");
                message.sharingGroup = [];
                for (var i = 0; i < object.sharingGroup.length; ++i) {
                    if (typeof object.sharingGroup[i] !== "object")
                        throw TypeError(".api.IdentityShareRequest.sharingGroup: object expected");
                    message.sharingGroup[i] = $root.api.IdentityShareEntry.fromObject(object.sharingGroup[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an IdentityShareRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityShareRequest
         * @static
         * @param {api.IdentityShareRequest} message IdentityShareRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityShareRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.sharingGroup = [];
            if (options.defaults) {
                object.login = "";
                object.version = 0;
            }
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            if (message.sharingGroup && message.sharingGroup.length) {
                object.sharingGroup = [];
                for (var j = 0; j < message.sharingGroup.length; ++j)
                    object.sharingGroup[j] = $root.api.IdentityShareEntry.toObject(message.sharingGroup[j], options);
            }
            return object;
        };

        /**
         * Converts this IdentityShareRequest to JSON.
         * @function toJSON
         * @memberof api.IdentityShareRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityShareRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityShareRequest;
    })();

    api.IdentityGetEncryptionResponse = (function() {

        /**
         * Properties of an IdentityGetEncryptionResponse.
         * @memberof api
         * @interface IIdentityGetEncryptionResponse
         * @property {api.IIdentityEncryptedKeySet|null} [encryption] IdentityGetEncryptionResponse encryption
         */

        /**
         * Constructs a new IdentityGetEncryptionResponse.
         * @memberof api
         * @classdesc Represents an IdentityGetEncryptionResponse.
         * @implements IIdentityGetEncryptionResponse
         * @constructor
         * @param {api.IIdentityGetEncryptionResponse=} [properties] Properties to set
         */
        function IdentityGetEncryptionResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityGetEncryptionResponse encryption.
         * @member {api.IIdentityEncryptedKeySet|null|undefined} encryption
         * @memberof api.IdentityGetEncryptionResponse
         * @instance
         */
        IdentityGetEncryptionResponse.prototype.encryption = null;

        /**
         * Creates a new IdentityGetEncryptionResponse instance using the specified properties.
         * @function create
         * @memberof api.IdentityGetEncryptionResponse
         * @static
         * @param {api.IIdentityGetEncryptionResponse=} [properties] Properties to set
         * @returns {api.IdentityGetEncryptionResponse} IdentityGetEncryptionResponse instance
         */
        IdentityGetEncryptionResponse.create = function create(properties) {
            return new IdentityGetEncryptionResponse(properties);
        };

        /**
         * Encodes the specified IdentityGetEncryptionResponse message. Does not implicitly {@link api.IdentityGetEncryptionResponse.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityGetEncryptionResponse
         * @static
         * @param {api.IIdentityGetEncryptionResponse} message IdentityGetEncryptionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetEncryptionResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.encryption != null && message.hasOwnProperty("encryption"))
                $root.api.IdentityEncryptedKeySet.encode(message.encryption, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IdentityGetEncryptionResponse message, length delimited. Does not implicitly {@link api.IdentityGetEncryptionResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityGetEncryptionResponse
         * @static
         * @param {api.IIdentityGetEncryptionResponse} message IdentityGetEncryptionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetEncryptionResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityGetEncryptionResponse message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityGetEncryptionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityGetEncryptionResponse} IdentityGetEncryptionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetEncryptionResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityGetEncryptionResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.encryption = $root.api.IdentityEncryptedKeySet.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityGetEncryptionResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityGetEncryptionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityGetEncryptionResponse} IdentityGetEncryptionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetEncryptionResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityGetEncryptionResponse message.
         * @function verify
         * @memberof api.IdentityGetEncryptionResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityGetEncryptionResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.encryption != null && message.hasOwnProperty("encryption")) {
                var error = $root.api.IdentityEncryptedKeySet.verify(message.encryption);
                if (error)
                    return "encryption." + error;
            }
            return null;
        };

        /**
         * Creates an IdentityGetEncryptionResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityGetEncryptionResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityGetEncryptionResponse} IdentityGetEncryptionResponse
         */
        IdentityGetEncryptionResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityGetEncryptionResponse)
                return object;
            var message = new $root.api.IdentityGetEncryptionResponse();
            if (object.encryption != null) {
                if (typeof object.encryption !== "object")
                    throw TypeError(".api.IdentityGetEncryptionResponse.encryption: object expected");
                message.encryption = $root.api.IdentityEncryptedKeySet.fromObject(object.encryption);
            }
            return message;
        };

        /**
         * Creates a plain object from an IdentityGetEncryptionResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityGetEncryptionResponse
         * @static
         * @param {api.IdentityGetEncryptionResponse} message IdentityGetEncryptionResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityGetEncryptionResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.encryption = null;
            if (message.encryption != null && message.hasOwnProperty("encryption"))
                object.encryption = $root.api.IdentityEncryptedKeySet.toObject(message.encryption, options);
            return object;
        };

        /**
         * Converts this IdentityGetEncryptionResponse to JSON.
         * @function toJSON
         * @memberof api.IdentityGetEncryptionResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityGetEncryptionResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityGetEncryptionResponse;
    })();

    api.IdentityGetKeysToRenewResponse = (function() {

        /**
         * Properties of an IdentityGetKeysToRenewResponse.
         * @memberof api
         * @interface IIdentityGetKeysToRenewResponse
         * @property {api.IIdentityEncryptedKeySet|null} [encryption] IdentityGetKeysToRenewResponse encryption
         * @property {Array.<api.IIdentityPublicKey>|null} [sharingGroup] IdentityGetKeysToRenewResponse sharingGroup
         */

        /**
         * Constructs a new IdentityGetKeysToRenewResponse.
         * @memberof api
         * @classdesc Represents an IdentityGetKeysToRenewResponse.
         * @implements IIdentityGetKeysToRenewResponse
         * @constructor
         * @param {api.IIdentityGetKeysToRenewResponse=} [properties] Properties to set
         */
        function IdentityGetKeysToRenewResponse(properties) {
            this.sharingGroup = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityGetKeysToRenewResponse encryption.
         * @member {api.IIdentityEncryptedKeySet|null|undefined} encryption
         * @memberof api.IdentityGetKeysToRenewResponse
         * @instance
         */
        IdentityGetKeysToRenewResponse.prototype.encryption = null;

        /**
         * IdentityGetKeysToRenewResponse sharingGroup.
         * @member {Array.<api.IIdentityPublicKey>} sharingGroup
         * @memberof api.IdentityGetKeysToRenewResponse
         * @instance
         */
        IdentityGetKeysToRenewResponse.prototype.sharingGroup = $util.emptyArray;

        /**
         * Creates a new IdentityGetKeysToRenewResponse instance using the specified properties.
         * @function create
         * @memberof api.IdentityGetKeysToRenewResponse
         * @static
         * @param {api.IIdentityGetKeysToRenewResponse=} [properties] Properties to set
         * @returns {api.IdentityGetKeysToRenewResponse} IdentityGetKeysToRenewResponse instance
         */
        IdentityGetKeysToRenewResponse.create = function create(properties) {
            return new IdentityGetKeysToRenewResponse(properties);
        };

        /**
         * Encodes the specified IdentityGetKeysToRenewResponse message. Does not implicitly {@link api.IdentityGetKeysToRenewResponse.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityGetKeysToRenewResponse
         * @static
         * @param {api.IIdentityGetKeysToRenewResponse} message IdentityGetKeysToRenewResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetKeysToRenewResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.encryption != null && message.hasOwnProperty("encryption"))
                $root.api.IdentityEncryptedKeySet.encode(message.encryption, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.sharingGroup != null && message.sharingGroup.length)
                for (var i = 0; i < message.sharingGroup.length; ++i)
                    $root.api.IdentityPublicKey.encode(message.sharingGroup[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IdentityGetKeysToRenewResponse message, length delimited. Does not implicitly {@link api.IdentityGetKeysToRenewResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityGetKeysToRenewResponse
         * @static
         * @param {api.IIdentityGetKeysToRenewResponse} message IdentityGetKeysToRenewResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetKeysToRenewResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityGetKeysToRenewResponse message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityGetKeysToRenewResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityGetKeysToRenewResponse} IdentityGetKeysToRenewResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetKeysToRenewResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityGetKeysToRenewResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.encryption = $root.api.IdentityEncryptedKeySet.decode(reader, reader.uint32());
                    break;
                case 3:
                    if (!(message.sharingGroup && message.sharingGroup.length))
                        message.sharingGroup = [];
                    message.sharingGroup.push($root.api.IdentityPublicKey.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityGetKeysToRenewResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityGetKeysToRenewResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityGetKeysToRenewResponse} IdentityGetKeysToRenewResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetKeysToRenewResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityGetKeysToRenewResponse message.
         * @function verify
         * @memberof api.IdentityGetKeysToRenewResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityGetKeysToRenewResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.encryption != null && message.hasOwnProperty("encryption")) {
                var error = $root.api.IdentityEncryptedKeySet.verify(message.encryption);
                if (error)
                    return "encryption." + error;
            }
            if (message.sharingGroup != null && message.hasOwnProperty("sharingGroup")) {
                if (!Array.isArray(message.sharingGroup))
                    return "sharingGroup: array expected";
                for (var i = 0; i < message.sharingGroup.length; ++i) {
                    var error = $root.api.IdentityPublicKey.verify(message.sharingGroup[i]);
                    if (error)
                        return "sharingGroup." + error;
                }
            }
            return null;
        };

        /**
         * Creates an IdentityGetKeysToRenewResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityGetKeysToRenewResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityGetKeysToRenewResponse} IdentityGetKeysToRenewResponse
         */
        IdentityGetKeysToRenewResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityGetKeysToRenewResponse)
                return object;
            var message = new $root.api.IdentityGetKeysToRenewResponse();
            if (object.encryption != null) {
                if (typeof object.encryption !== "object")
                    throw TypeError(".api.IdentityGetKeysToRenewResponse.encryption: object expected");
                message.encryption = $root.api.IdentityEncryptedKeySet.fromObject(object.encryption);
            }
            if (object.sharingGroup) {
                if (!Array.isArray(object.sharingGroup))
                    throw TypeError(".api.IdentityGetKeysToRenewResponse.sharingGroup: array expected");
                message.sharingGroup = [];
                for (var i = 0; i < object.sharingGroup.length; ++i) {
                    if (typeof object.sharingGroup[i] !== "object")
                        throw TypeError(".api.IdentityGetKeysToRenewResponse.sharingGroup: object expected");
                    message.sharingGroup[i] = $root.api.IdentityPublicKey.fromObject(object.sharingGroup[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an IdentityGetKeysToRenewResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityGetKeysToRenewResponse
         * @static
         * @param {api.IdentityGetKeysToRenewResponse} message IdentityGetKeysToRenewResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityGetKeysToRenewResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.sharingGroup = [];
            if (options.defaults)
                object.encryption = null;
            if (message.encryption != null && message.hasOwnProperty("encryption"))
                object.encryption = $root.api.IdentityEncryptedKeySet.toObject(message.encryption, options);
            if (message.sharingGroup && message.sharingGroup.length) {
                object.sharingGroup = [];
                for (var j = 0; j < message.sharingGroup.length; ++j)
                    object.sharingGroup[j] = $root.api.IdentityPublicKey.toObject(message.sharingGroup[j], options);
            }
            return object;
        };

        /**
         * Converts this IdentityGetKeysToRenewResponse to JSON.
         * @function toJSON
         * @memberof api.IdentityGetKeysToRenewResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityGetKeysToRenewResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityGetKeysToRenewResponse;
    })();

    api.IdentityBackwardKey = (function() {

        /**
         * Properties of an IdentityBackwardKey.
         * @memberof api
         * @interface IIdentityBackwardKey
         * @property {Uint8Array|null} [nonce] IdentityBackwardKey nonce
         * @property {Uint8Array|null} [encryptedKey] IdentityBackwardKey encryptedKey
         */

        /**
         * Constructs a new IdentityBackwardKey.
         * @memberof api
         * @classdesc Represents an IdentityBackwardKey.
         * @implements IIdentityBackwardKey
         * @constructor
         * @param {api.IIdentityBackwardKey=} [properties] Properties to set
         */
        function IdentityBackwardKey(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityBackwardKey nonce.
         * @member {Uint8Array} nonce
         * @memberof api.IdentityBackwardKey
         * @instance
         */
        IdentityBackwardKey.prototype.nonce = $util.newBuffer([]);

        /**
         * IdentityBackwardKey encryptedKey.
         * @member {Uint8Array} encryptedKey
         * @memberof api.IdentityBackwardKey
         * @instance
         */
        IdentityBackwardKey.prototype.encryptedKey = $util.newBuffer([]);

        /**
         * Creates a new IdentityBackwardKey instance using the specified properties.
         * @function create
         * @memberof api.IdentityBackwardKey
         * @static
         * @param {api.IIdentityBackwardKey=} [properties] Properties to set
         * @returns {api.IdentityBackwardKey} IdentityBackwardKey instance
         */
        IdentityBackwardKey.create = function create(properties) {
            return new IdentityBackwardKey(properties);
        };

        /**
         * Encodes the specified IdentityBackwardKey message. Does not implicitly {@link api.IdentityBackwardKey.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityBackwardKey
         * @static
         * @param {api.IIdentityBackwardKey} message IdentityBackwardKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityBackwardKey.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.nonce);
            if (message.encryptedKey != null && message.hasOwnProperty("encryptedKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.encryptedKey);
            return writer;
        };

        /**
         * Encodes the specified IdentityBackwardKey message, length delimited. Does not implicitly {@link api.IdentityBackwardKey.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityBackwardKey
         * @static
         * @param {api.IIdentityBackwardKey} message IdentityBackwardKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityBackwardKey.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityBackwardKey message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityBackwardKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityBackwardKey} IdentityBackwardKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityBackwardKey.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityBackwardKey();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.nonce = reader.bytes();
                    break;
                case 2:
                    message.encryptedKey = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityBackwardKey message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityBackwardKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityBackwardKey} IdentityBackwardKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityBackwardKey.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityBackwardKey message.
         * @function verify
         * @memberof api.IdentityBackwardKey
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityBackwardKey.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                if (!(message.nonce && typeof message.nonce.length === "number" || $util.isString(message.nonce)))
                    return "nonce: buffer expected";
            if (message.encryptedKey != null && message.hasOwnProperty("encryptedKey"))
                if (!(message.encryptedKey && typeof message.encryptedKey.length === "number" || $util.isString(message.encryptedKey)))
                    return "encryptedKey: buffer expected";
            return null;
        };

        /**
         * Creates an IdentityBackwardKey message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityBackwardKey
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityBackwardKey} IdentityBackwardKey
         */
        IdentityBackwardKey.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityBackwardKey)
                return object;
            var message = new $root.api.IdentityBackwardKey();
            if (object.nonce != null)
                if (typeof object.nonce === "string")
                    $util.base64.decode(object.nonce, message.nonce = $util.newBuffer($util.base64.length(object.nonce)), 0);
                else if (object.nonce.length)
                    message.nonce = object.nonce;
            if (object.encryptedKey != null)
                if (typeof object.encryptedKey === "string")
                    $util.base64.decode(object.encryptedKey, message.encryptedKey = $util.newBuffer($util.base64.length(object.encryptedKey)), 0);
                else if (object.encryptedKey.length)
                    message.encryptedKey = object.encryptedKey;
            return message;
        };

        /**
         * Creates a plain object from an IdentityBackwardKey message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityBackwardKey
         * @static
         * @param {api.IdentityBackwardKey} message IdentityBackwardKey
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityBackwardKey.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.nonce = "";
                else {
                    object.nonce = [];
                    if (options.bytes !== Array)
                        object.nonce = $util.newBuffer(object.nonce);
                }
                if (options.bytes === String)
                    object.encryptedKey = "";
                else {
                    object.encryptedKey = [];
                    if (options.bytes !== Array)
                        object.encryptedKey = $util.newBuffer(object.encryptedKey);
                }
            }
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                object.nonce = options.bytes === String ? $util.base64.encode(message.nonce, 0, message.nonce.length) : options.bytes === Array ? Array.prototype.slice.call(message.nonce) : message.nonce;
            if (message.encryptedKey != null && message.hasOwnProperty("encryptedKey"))
                object.encryptedKey = options.bytes === String ? $util.base64.encode(message.encryptedKey, 0, message.encryptedKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedKey) : message.encryptedKey;
            return object;
        };

        /**
         * Converts this IdentityBackwardKey to JSON.
         * @function toJSON
         * @memberof api.IdentityBackwardKey
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityBackwardKey.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityBackwardKey;
    })();

    api.IdentityPostKeysToRenewRequest = (function() {

        /**
         * Properties of an IdentityPostKeysToRenewRequest.
         * @memberof api
         * @interface IIdentityPostKeysToRenewRequest
         * @property {string|null} [login] IdentityPostKeysToRenewRequest login
         * @property {api.IIdentityEncryptedKeySet|null} [encryption] IdentityPostKeysToRenewRequest encryption
         * @property {Uint8Array|null} [signChain] IdentityPostKeysToRenewRequest signChain
         * @property {Array.<api.IIdentityShareEntry>|null} [sharingGroup] IdentityPostKeysToRenewRequest sharingGroup
         * @property {api.IIdentityBackwardKey|null} [backward] IdentityPostKeysToRenewRequest backward
         */

        /**
         * Constructs a new IdentityPostKeysToRenewRequest.
         * @memberof api
         * @classdesc Represents an IdentityPostKeysToRenewRequest.
         * @implements IIdentityPostKeysToRenewRequest
         * @constructor
         * @param {api.IIdentityPostKeysToRenewRequest=} [properties] Properties to set
         */
        function IdentityPostKeysToRenewRequest(properties) {
            this.sharingGroup = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityPostKeysToRenewRequest login.
         * @member {string} login
         * @memberof api.IdentityPostKeysToRenewRequest
         * @instance
         */
        IdentityPostKeysToRenewRequest.prototype.login = "";

        /**
         * IdentityPostKeysToRenewRequest encryption.
         * @member {api.IIdentityEncryptedKeySet|null|undefined} encryption
         * @memberof api.IdentityPostKeysToRenewRequest
         * @instance
         */
        IdentityPostKeysToRenewRequest.prototype.encryption = null;

        /**
         * IdentityPostKeysToRenewRequest signChain.
         * @member {Uint8Array} signChain
         * @memberof api.IdentityPostKeysToRenewRequest
         * @instance
         */
        IdentityPostKeysToRenewRequest.prototype.signChain = $util.newBuffer([]);

        /**
         * IdentityPostKeysToRenewRequest sharingGroup.
         * @member {Array.<api.IIdentityShareEntry>} sharingGroup
         * @memberof api.IdentityPostKeysToRenewRequest
         * @instance
         */
        IdentityPostKeysToRenewRequest.prototype.sharingGroup = $util.emptyArray;

        /**
         * IdentityPostKeysToRenewRequest backward.
         * @member {api.IIdentityBackwardKey|null|undefined} backward
         * @memberof api.IdentityPostKeysToRenewRequest
         * @instance
         */
        IdentityPostKeysToRenewRequest.prototype.backward = null;

        /**
         * Creates a new IdentityPostKeysToRenewRequest instance using the specified properties.
         * @function create
         * @memberof api.IdentityPostKeysToRenewRequest
         * @static
         * @param {api.IIdentityPostKeysToRenewRequest=} [properties] Properties to set
         * @returns {api.IdentityPostKeysToRenewRequest} IdentityPostKeysToRenewRequest instance
         */
        IdentityPostKeysToRenewRequest.create = function create(properties) {
            return new IdentityPostKeysToRenewRequest(properties);
        };

        /**
         * Encodes the specified IdentityPostKeysToRenewRequest message. Does not implicitly {@link api.IdentityPostKeysToRenewRequest.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityPostKeysToRenewRequest
         * @static
         * @param {api.IIdentityPostKeysToRenewRequest} message IdentityPostKeysToRenewRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityPostKeysToRenewRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            if (message.encryption != null && message.hasOwnProperty("encryption"))
                $root.api.IdentityEncryptedKeySet.encode(message.encryption, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.signChain != null && message.hasOwnProperty("signChain"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.signChain);
            if (message.sharingGroup != null && message.sharingGroup.length)
                for (var i = 0; i < message.sharingGroup.length; ++i)
                    $root.api.IdentityShareEntry.encode(message.sharingGroup[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.backward != null && message.hasOwnProperty("backward"))
                $root.api.IdentityBackwardKey.encode(message.backward, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IdentityPostKeysToRenewRequest message, length delimited. Does not implicitly {@link api.IdentityPostKeysToRenewRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityPostKeysToRenewRequest
         * @static
         * @param {api.IIdentityPostKeysToRenewRequest} message IdentityPostKeysToRenewRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityPostKeysToRenewRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityPostKeysToRenewRequest message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityPostKeysToRenewRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityPostKeysToRenewRequest} IdentityPostKeysToRenewRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityPostKeysToRenewRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityPostKeysToRenewRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                case 2:
                    message.encryption = $root.api.IdentityEncryptedKeySet.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.signChain = reader.bytes();
                    break;
                case 4:
                    if (!(message.sharingGroup && message.sharingGroup.length))
                        message.sharingGroup = [];
                    message.sharingGroup.push($root.api.IdentityShareEntry.decode(reader, reader.uint32()));
                    break;
                case 5:
                    message.backward = $root.api.IdentityBackwardKey.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityPostKeysToRenewRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityPostKeysToRenewRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityPostKeysToRenewRequest} IdentityPostKeysToRenewRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityPostKeysToRenewRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityPostKeysToRenewRequest message.
         * @function verify
         * @memberof api.IdentityPostKeysToRenewRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityPostKeysToRenewRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            if (message.encryption != null && message.hasOwnProperty("encryption")) {
                var error = $root.api.IdentityEncryptedKeySet.verify(message.encryption);
                if (error)
                    return "encryption." + error;
            }
            if (message.signChain != null && message.hasOwnProperty("signChain"))
                if (!(message.signChain && typeof message.signChain.length === "number" || $util.isString(message.signChain)))
                    return "signChain: buffer expected";
            if (message.sharingGroup != null && message.hasOwnProperty("sharingGroup")) {
                if (!Array.isArray(message.sharingGroup))
                    return "sharingGroup: array expected";
                for (var i = 0; i < message.sharingGroup.length; ++i) {
                    var error = $root.api.IdentityShareEntry.verify(message.sharingGroup[i]);
                    if (error)
                        return "sharingGroup." + error;
                }
            }
            if (message.backward != null && message.hasOwnProperty("backward")) {
                var error = $root.api.IdentityBackwardKey.verify(message.backward);
                if (error)
                    return "backward." + error;
            }
            return null;
        };

        /**
         * Creates an IdentityPostKeysToRenewRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityPostKeysToRenewRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityPostKeysToRenewRequest} IdentityPostKeysToRenewRequest
         */
        IdentityPostKeysToRenewRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityPostKeysToRenewRequest)
                return object;
            var message = new $root.api.IdentityPostKeysToRenewRequest();
            if (object.login != null)
                message.login = String(object.login);
            if (object.encryption != null) {
                if (typeof object.encryption !== "object")
                    throw TypeError(".api.IdentityPostKeysToRenewRequest.encryption: object expected");
                message.encryption = $root.api.IdentityEncryptedKeySet.fromObject(object.encryption);
            }
            if (object.signChain != null)
                if (typeof object.signChain === "string")
                    $util.base64.decode(object.signChain, message.signChain = $util.newBuffer($util.base64.length(object.signChain)), 0);
                else if (object.signChain.length)
                    message.signChain = object.signChain;
            if (object.sharingGroup) {
                if (!Array.isArray(object.sharingGroup))
                    throw TypeError(".api.IdentityPostKeysToRenewRequest.sharingGroup: array expected");
                message.sharingGroup = [];
                for (var i = 0; i < object.sharingGroup.length; ++i) {
                    if (typeof object.sharingGroup[i] !== "object")
                        throw TypeError(".api.IdentityPostKeysToRenewRequest.sharingGroup: object expected");
                    message.sharingGroup[i] = $root.api.IdentityShareEntry.fromObject(object.sharingGroup[i]);
                }
            }
            if (object.backward != null) {
                if (typeof object.backward !== "object")
                    throw TypeError(".api.IdentityPostKeysToRenewRequest.backward: object expected");
                message.backward = $root.api.IdentityBackwardKey.fromObject(object.backward);
            }
            return message;
        };

        /**
         * Creates a plain object from an IdentityPostKeysToRenewRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityPostKeysToRenewRequest
         * @static
         * @param {api.IdentityPostKeysToRenewRequest} message IdentityPostKeysToRenewRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityPostKeysToRenewRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.sharingGroup = [];
            if (options.defaults) {
                object.login = "";
                object.encryption = null;
                if (options.bytes === String)
                    object.signChain = "";
                else {
                    object.signChain = [];
                    if (options.bytes !== Array)
                        object.signChain = $util.newBuffer(object.signChain);
                }
                object.backward = null;
            }
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            if (message.encryption != null && message.hasOwnProperty("encryption"))
                object.encryption = $root.api.IdentityEncryptedKeySet.toObject(message.encryption, options);
            if (message.signChain != null && message.hasOwnProperty("signChain"))
                object.signChain = options.bytes === String ? $util.base64.encode(message.signChain, 0, message.signChain.length) : options.bytes === Array ? Array.prototype.slice.call(message.signChain) : message.signChain;
            if (message.sharingGroup && message.sharingGroup.length) {
                object.sharingGroup = [];
                for (var j = 0; j < message.sharingGroup.length; ++j)
                    object.sharingGroup[j] = $root.api.IdentityShareEntry.toObject(message.sharingGroup[j], options);
            }
            if (message.backward != null && message.hasOwnProperty("backward"))
                object.backward = $root.api.IdentityBackwardKey.toObject(message.backward, options);
            return object;
        };

        /**
         * Converts this IdentityPostKeysToRenewRequest to JSON.
         * @function toJSON
         * @memberof api.IdentityPostKeysToRenewRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityPostKeysToRenewRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityPostKeysToRenewRequest;
    })();

    api.IdentityGetSharingGraphElement = (function() {

        /**
         * Properties of an IdentityGetSharingGraphElement.
         * @memberof api
         * @interface IIdentityGetSharingGraphElement
         * @property {string|null} [login] IdentityGetSharingGraphElement login
         * @property {number|null} [version] IdentityGetSharingGraphElement version
         * @property {Uint8Array|null} [masterPublicKey] IdentityGetSharingGraphElement masterPublicKey
         * @property {api.ICipher|null} [sharingKey] IdentityGetSharingGraphElement sharingKey
         * @property {api.ICipher|null} [boxKey] IdentityGetSharingGraphElement boxKey
         * @property {api.ICipher|null} [signKey] IdentityGetSharingGraphElement signKey
         * @property {Array.<api.IIdentityPublicKey>|null} [sharingGroup] IdentityGetSharingGraphElement sharingGroup
         * @property {api.IIdentityKeyID|null} [sharedFrom] IdentityGetSharingGraphElement sharedFrom
         * @property {boolean|null} [latest] IdentityGetSharingGraphElement latest
         * @property {Uint8Array|null} [boxPublicKey] IdentityGetSharingGraphElement boxPublicKey
         * @property {Uint8Array|null} [signPublicKey] IdentityGetSharingGraphElement signPublicKey
         */

        /**
         * Constructs a new IdentityGetSharingGraphElement.
         * @memberof api
         * @classdesc Represents an IdentityGetSharingGraphElement.
         * @implements IIdentityGetSharingGraphElement
         * @constructor
         * @param {api.IIdentityGetSharingGraphElement=} [properties] Properties to set
         */
        function IdentityGetSharingGraphElement(properties) {
            this.sharingGroup = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityGetSharingGraphElement login.
         * @member {string} login
         * @memberof api.IdentityGetSharingGraphElement
         * @instance
         */
        IdentityGetSharingGraphElement.prototype.login = "";

        /**
         * IdentityGetSharingGraphElement version.
         * @member {number} version
         * @memberof api.IdentityGetSharingGraphElement
         * @instance
         */
        IdentityGetSharingGraphElement.prototype.version = 0;

        /**
         * IdentityGetSharingGraphElement masterPublicKey.
         * @member {Uint8Array} masterPublicKey
         * @memberof api.IdentityGetSharingGraphElement
         * @instance
         */
        IdentityGetSharingGraphElement.prototype.masterPublicKey = $util.newBuffer([]);

        /**
         * IdentityGetSharingGraphElement sharingKey.
         * @member {api.ICipher|null|undefined} sharingKey
         * @memberof api.IdentityGetSharingGraphElement
         * @instance
         */
        IdentityGetSharingGraphElement.prototype.sharingKey = null;

        /**
         * IdentityGetSharingGraphElement boxKey.
         * @member {api.ICipher|null|undefined} boxKey
         * @memberof api.IdentityGetSharingGraphElement
         * @instance
         */
        IdentityGetSharingGraphElement.prototype.boxKey = null;

        /**
         * IdentityGetSharingGraphElement signKey.
         * @member {api.ICipher|null|undefined} signKey
         * @memberof api.IdentityGetSharingGraphElement
         * @instance
         */
        IdentityGetSharingGraphElement.prototype.signKey = null;

        /**
         * IdentityGetSharingGraphElement sharingGroup.
         * @member {Array.<api.IIdentityPublicKey>} sharingGroup
         * @memberof api.IdentityGetSharingGraphElement
         * @instance
         */
        IdentityGetSharingGraphElement.prototype.sharingGroup = $util.emptyArray;

        /**
         * IdentityGetSharingGraphElement sharedFrom.
         * @member {api.IIdentityKeyID|null|undefined} sharedFrom
         * @memberof api.IdentityGetSharingGraphElement
         * @instance
         */
        IdentityGetSharingGraphElement.prototype.sharedFrom = null;

        /**
         * IdentityGetSharingGraphElement latest.
         * @member {boolean} latest
         * @memberof api.IdentityGetSharingGraphElement
         * @instance
         */
        IdentityGetSharingGraphElement.prototype.latest = false;

        /**
         * IdentityGetSharingGraphElement boxPublicKey.
         * @member {Uint8Array} boxPublicKey
         * @memberof api.IdentityGetSharingGraphElement
         * @instance
         */
        IdentityGetSharingGraphElement.prototype.boxPublicKey = $util.newBuffer([]);

        /**
         * IdentityGetSharingGraphElement signPublicKey.
         * @member {Uint8Array} signPublicKey
         * @memberof api.IdentityGetSharingGraphElement
         * @instance
         */
        IdentityGetSharingGraphElement.prototype.signPublicKey = $util.newBuffer([]);

        /**
         * Creates a new IdentityGetSharingGraphElement instance using the specified properties.
         * @function create
         * @memberof api.IdentityGetSharingGraphElement
         * @static
         * @param {api.IIdentityGetSharingGraphElement=} [properties] Properties to set
         * @returns {api.IdentityGetSharingGraphElement} IdentityGetSharingGraphElement instance
         */
        IdentityGetSharingGraphElement.create = function create(properties) {
            return new IdentityGetSharingGraphElement(properties);
        };

        /**
         * Encodes the specified IdentityGetSharingGraphElement message. Does not implicitly {@link api.IdentityGetSharingGraphElement.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityGetSharingGraphElement
         * @static
         * @param {api.IIdentityGetSharingGraphElement} message IdentityGetSharingGraphElement message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetSharingGraphElement.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            if (message.version != null && message.hasOwnProperty("version"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.version);
            if (message.masterPublicKey != null && message.hasOwnProperty("masterPublicKey"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.masterPublicKey);
            if (message.sharingKey != null && message.hasOwnProperty("sharingKey"))
                $root.api.Cipher.encode(message.sharingKey, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.boxKey != null && message.hasOwnProperty("boxKey"))
                $root.api.Cipher.encode(message.boxKey, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.signKey != null && message.hasOwnProperty("signKey"))
                $root.api.Cipher.encode(message.signKey, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.sharingGroup != null && message.sharingGroup.length)
                for (var i = 0; i < message.sharingGroup.length; ++i)
                    $root.api.IdentityPublicKey.encode(message.sharingGroup[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.sharedFrom != null && message.hasOwnProperty("sharedFrom"))
                $root.api.IdentityKeyID.encode(message.sharedFrom, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.latest != null && message.hasOwnProperty("latest"))
                writer.uint32(/* id 10, wireType 0 =*/80).bool(message.latest);
            if (message.boxPublicKey != null && message.hasOwnProperty("boxPublicKey"))
                writer.uint32(/* id 11, wireType 2 =*/90).bytes(message.boxPublicKey);
            if (message.signPublicKey != null && message.hasOwnProperty("signPublicKey"))
                writer.uint32(/* id 12, wireType 2 =*/98).bytes(message.signPublicKey);
            return writer;
        };

        /**
         * Encodes the specified IdentityGetSharingGraphElement message, length delimited. Does not implicitly {@link api.IdentityGetSharingGraphElement.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityGetSharingGraphElement
         * @static
         * @param {api.IIdentityGetSharingGraphElement} message IdentityGetSharingGraphElement message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetSharingGraphElement.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityGetSharingGraphElement message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityGetSharingGraphElement
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityGetSharingGraphElement} IdentityGetSharingGraphElement
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetSharingGraphElement.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityGetSharingGraphElement();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                case 2:
                    message.version = reader.uint32();
                    break;
                case 3:
                    message.masterPublicKey = reader.bytes();
                    break;
                case 4:
                    message.sharingKey = $root.api.Cipher.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.boxKey = $root.api.Cipher.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.signKey = $root.api.Cipher.decode(reader, reader.uint32());
                    break;
                case 8:
                    if (!(message.sharingGroup && message.sharingGroup.length))
                        message.sharingGroup = [];
                    message.sharingGroup.push($root.api.IdentityPublicKey.decode(reader, reader.uint32()));
                    break;
                case 9:
                    message.sharedFrom = $root.api.IdentityKeyID.decode(reader, reader.uint32());
                    break;
                case 10:
                    message.latest = reader.bool();
                    break;
                case 11:
                    message.boxPublicKey = reader.bytes();
                    break;
                case 12:
                    message.signPublicKey = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityGetSharingGraphElement message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityGetSharingGraphElement
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityGetSharingGraphElement} IdentityGetSharingGraphElement
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetSharingGraphElement.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityGetSharingGraphElement message.
         * @function verify
         * @memberof api.IdentityGetSharingGraphElement
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityGetSharingGraphElement.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isInteger(message.version))
                    return "version: integer expected";
            if (message.masterPublicKey != null && message.hasOwnProperty("masterPublicKey"))
                if (!(message.masterPublicKey && typeof message.masterPublicKey.length === "number" || $util.isString(message.masterPublicKey)))
                    return "masterPublicKey: buffer expected";
            if (message.sharingKey != null && message.hasOwnProperty("sharingKey")) {
                var error = $root.api.Cipher.verify(message.sharingKey);
                if (error)
                    return "sharingKey." + error;
            }
            if (message.boxKey != null && message.hasOwnProperty("boxKey")) {
                var error = $root.api.Cipher.verify(message.boxKey);
                if (error)
                    return "boxKey." + error;
            }
            if (message.signKey != null && message.hasOwnProperty("signKey")) {
                var error = $root.api.Cipher.verify(message.signKey);
                if (error)
                    return "signKey." + error;
            }
            if (message.sharingGroup != null && message.hasOwnProperty("sharingGroup")) {
                if (!Array.isArray(message.sharingGroup))
                    return "sharingGroup: array expected";
                for (var i = 0; i < message.sharingGroup.length; ++i) {
                    var error = $root.api.IdentityPublicKey.verify(message.sharingGroup[i]);
                    if (error)
                        return "sharingGroup." + error;
                }
            }
            if (message.sharedFrom != null && message.hasOwnProperty("sharedFrom")) {
                var error = $root.api.IdentityKeyID.verify(message.sharedFrom);
                if (error)
                    return "sharedFrom." + error;
            }
            if (message.latest != null && message.hasOwnProperty("latest"))
                if (typeof message.latest !== "boolean")
                    return "latest: boolean expected";
            if (message.boxPublicKey != null && message.hasOwnProperty("boxPublicKey"))
                if (!(message.boxPublicKey && typeof message.boxPublicKey.length === "number" || $util.isString(message.boxPublicKey)))
                    return "boxPublicKey: buffer expected";
            if (message.signPublicKey != null && message.hasOwnProperty("signPublicKey"))
                if (!(message.signPublicKey && typeof message.signPublicKey.length === "number" || $util.isString(message.signPublicKey)))
                    return "signPublicKey: buffer expected";
            return null;
        };

        /**
         * Creates an IdentityGetSharingGraphElement message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityGetSharingGraphElement
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityGetSharingGraphElement} IdentityGetSharingGraphElement
         */
        IdentityGetSharingGraphElement.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityGetSharingGraphElement)
                return object;
            var message = new $root.api.IdentityGetSharingGraphElement();
            if (object.login != null)
                message.login = String(object.login);
            if (object.version != null)
                message.version = object.version >>> 0;
            if (object.masterPublicKey != null)
                if (typeof object.masterPublicKey === "string")
                    $util.base64.decode(object.masterPublicKey, message.masterPublicKey = $util.newBuffer($util.base64.length(object.masterPublicKey)), 0);
                else if (object.masterPublicKey.length)
                    message.masterPublicKey = object.masterPublicKey;
            if (object.sharingKey != null) {
                if (typeof object.sharingKey !== "object")
                    throw TypeError(".api.IdentityGetSharingGraphElement.sharingKey: object expected");
                message.sharingKey = $root.api.Cipher.fromObject(object.sharingKey);
            }
            if (object.boxKey != null) {
                if (typeof object.boxKey !== "object")
                    throw TypeError(".api.IdentityGetSharingGraphElement.boxKey: object expected");
                message.boxKey = $root.api.Cipher.fromObject(object.boxKey);
            }
            if (object.signKey != null) {
                if (typeof object.signKey !== "object")
                    throw TypeError(".api.IdentityGetSharingGraphElement.signKey: object expected");
                message.signKey = $root.api.Cipher.fromObject(object.signKey);
            }
            if (object.sharingGroup) {
                if (!Array.isArray(object.sharingGroup))
                    throw TypeError(".api.IdentityGetSharingGraphElement.sharingGroup: array expected");
                message.sharingGroup = [];
                for (var i = 0; i < object.sharingGroup.length; ++i) {
                    if (typeof object.sharingGroup[i] !== "object")
                        throw TypeError(".api.IdentityGetSharingGraphElement.sharingGroup: object expected");
                    message.sharingGroup[i] = $root.api.IdentityPublicKey.fromObject(object.sharingGroup[i]);
                }
            }
            if (object.sharedFrom != null) {
                if (typeof object.sharedFrom !== "object")
                    throw TypeError(".api.IdentityGetSharingGraphElement.sharedFrom: object expected");
                message.sharedFrom = $root.api.IdentityKeyID.fromObject(object.sharedFrom);
            }
            if (object.latest != null)
                message.latest = Boolean(object.latest);
            if (object.boxPublicKey != null)
                if (typeof object.boxPublicKey === "string")
                    $util.base64.decode(object.boxPublicKey, message.boxPublicKey = $util.newBuffer($util.base64.length(object.boxPublicKey)), 0);
                else if (object.boxPublicKey.length)
                    message.boxPublicKey = object.boxPublicKey;
            if (object.signPublicKey != null)
                if (typeof object.signPublicKey === "string")
                    $util.base64.decode(object.signPublicKey, message.signPublicKey = $util.newBuffer($util.base64.length(object.signPublicKey)), 0);
                else if (object.signPublicKey.length)
                    message.signPublicKey = object.signPublicKey;
            return message;
        };

        /**
         * Creates a plain object from an IdentityGetSharingGraphElement message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityGetSharingGraphElement
         * @static
         * @param {api.IdentityGetSharingGraphElement} message IdentityGetSharingGraphElement
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityGetSharingGraphElement.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.sharingGroup = [];
            if (options.defaults) {
                object.login = "";
                object.version = 0;
                if (options.bytes === String)
                    object.masterPublicKey = "";
                else {
                    object.masterPublicKey = [];
                    if (options.bytes !== Array)
                        object.masterPublicKey = $util.newBuffer(object.masterPublicKey);
                }
                object.sharingKey = null;
                object.boxKey = null;
                object.signKey = null;
                object.sharedFrom = null;
                object.latest = false;
                if (options.bytes === String)
                    object.boxPublicKey = "";
                else {
                    object.boxPublicKey = [];
                    if (options.bytes !== Array)
                        object.boxPublicKey = $util.newBuffer(object.boxPublicKey);
                }
                if (options.bytes === String)
                    object.signPublicKey = "";
                else {
                    object.signPublicKey = [];
                    if (options.bytes !== Array)
                        object.signPublicKey = $util.newBuffer(object.signPublicKey);
                }
            }
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            if (message.masterPublicKey != null && message.hasOwnProperty("masterPublicKey"))
                object.masterPublicKey = options.bytes === String ? $util.base64.encode(message.masterPublicKey, 0, message.masterPublicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.masterPublicKey) : message.masterPublicKey;
            if (message.sharingKey != null && message.hasOwnProperty("sharingKey"))
                object.sharingKey = $root.api.Cipher.toObject(message.sharingKey, options);
            if (message.boxKey != null && message.hasOwnProperty("boxKey"))
                object.boxKey = $root.api.Cipher.toObject(message.boxKey, options);
            if (message.signKey != null && message.hasOwnProperty("signKey"))
                object.signKey = $root.api.Cipher.toObject(message.signKey, options);
            if (message.sharingGroup && message.sharingGroup.length) {
                object.sharingGroup = [];
                for (var j = 0; j < message.sharingGroup.length; ++j)
                    object.sharingGroup[j] = $root.api.IdentityPublicKey.toObject(message.sharingGroup[j], options);
            }
            if (message.sharedFrom != null && message.hasOwnProperty("sharedFrom"))
                object.sharedFrom = $root.api.IdentityKeyID.toObject(message.sharedFrom, options);
            if (message.latest != null && message.hasOwnProperty("latest"))
                object.latest = message.latest;
            if (message.boxPublicKey != null && message.hasOwnProperty("boxPublicKey"))
                object.boxPublicKey = options.bytes === String ? $util.base64.encode(message.boxPublicKey, 0, message.boxPublicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.boxPublicKey) : message.boxPublicKey;
            if (message.signPublicKey != null && message.hasOwnProperty("signPublicKey"))
                object.signPublicKey = options.bytes === String ? $util.base64.encode(message.signPublicKey, 0, message.signPublicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.signPublicKey) : message.signPublicKey;
            return object;
        };

        /**
         * Converts this IdentityGetSharingGraphElement to JSON.
         * @function toJSON
         * @memberof api.IdentityGetSharingGraphElement
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityGetSharingGraphElement.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityGetSharingGraphElement;
    })();

    api.IdentityGetSharingGraphResponse = (function() {

        /**
         * Properties of an IdentityGetSharingGraphResponse.
         * @memberof api
         * @interface IIdentityGetSharingGraphResponse
         * @property {Array.<api.IIdentityGetSharingGraphElement>|null} [graph] IdentityGetSharingGraphResponse graph
         */

        /**
         * Constructs a new IdentityGetSharingGraphResponse.
         * @memberof api
         * @classdesc Represents an IdentityGetSharingGraphResponse.
         * @implements IIdentityGetSharingGraphResponse
         * @constructor
         * @param {api.IIdentityGetSharingGraphResponse=} [properties] Properties to set
         */
        function IdentityGetSharingGraphResponse(properties) {
            this.graph = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityGetSharingGraphResponse graph.
         * @member {Array.<api.IIdentityGetSharingGraphElement>} graph
         * @memberof api.IdentityGetSharingGraphResponse
         * @instance
         */
        IdentityGetSharingGraphResponse.prototype.graph = $util.emptyArray;

        /**
         * Creates a new IdentityGetSharingGraphResponse instance using the specified properties.
         * @function create
         * @memberof api.IdentityGetSharingGraphResponse
         * @static
         * @param {api.IIdentityGetSharingGraphResponse=} [properties] Properties to set
         * @returns {api.IdentityGetSharingGraphResponse} IdentityGetSharingGraphResponse instance
         */
        IdentityGetSharingGraphResponse.create = function create(properties) {
            return new IdentityGetSharingGraphResponse(properties);
        };

        /**
         * Encodes the specified IdentityGetSharingGraphResponse message. Does not implicitly {@link api.IdentityGetSharingGraphResponse.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityGetSharingGraphResponse
         * @static
         * @param {api.IIdentityGetSharingGraphResponse} message IdentityGetSharingGraphResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetSharingGraphResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.graph != null && message.graph.length)
                for (var i = 0; i < message.graph.length; ++i)
                    $root.api.IdentityGetSharingGraphElement.encode(message.graph[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IdentityGetSharingGraphResponse message, length delimited. Does not implicitly {@link api.IdentityGetSharingGraphResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityGetSharingGraphResponse
         * @static
         * @param {api.IIdentityGetSharingGraphResponse} message IdentityGetSharingGraphResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetSharingGraphResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityGetSharingGraphResponse message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityGetSharingGraphResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityGetSharingGraphResponse} IdentityGetSharingGraphResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetSharingGraphResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityGetSharingGraphResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.graph && message.graph.length))
                        message.graph = [];
                    message.graph.push($root.api.IdentityGetSharingGraphElement.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityGetSharingGraphResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityGetSharingGraphResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityGetSharingGraphResponse} IdentityGetSharingGraphResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetSharingGraphResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityGetSharingGraphResponse message.
         * @function verify
         * @memberof api.IdentityGetSharingGraphResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityGetSharingGraphResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.graph != null && message.hasOwnProperty("graph")) {
                if (!Array.isArray(message.graph))
                    return "graph: array expected";
                for (var i = 0; i < message.graph.length; ++i) {
                    var error = $root.api.IdentityGetSharingGraphElement.verify(message.graph[i]);
                    if (error)
                        return "graph." + error;
                }
            }
            return null;
        };

        /**
         * Creates an IdentityGetSharingGraphResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityGetSharingGraphResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityGetSharingGraphResponse} IdentityGetSharingGraphResponse
         */
        IdentityGetSharingGraphResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityGetSharingGraphResponse)
                return object;
            var message = new $root.api.IdentityGetSharingGraphResponse();
            if (object.graph) {
                if (!Array.isArray(object.graph))
                    throw TypeError(".api.IdentityGetSharingGraphResponse.graph: array expected");
                message.graph = [];
                for (var i = 0; i < object.graph.length; ++i) {
                    if (typeof object.graph[i] !== "object")
                        throw TypeError(".api.IdentityGetSharingGraphResponse.graph: object expected");
                    message.graph[i] = $root.api.IdentityGetSharingGraphElement.fromObject(object.graph[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an IdentityGetSharingGraphResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityGetSharingGraphResponse
         * @static
         * @param {api.IdentityGetSharingGraphResponse} message IdentityGetSharingGraphResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityGetSharingGraphResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.graph = [];
            if (message.graph && message.graph.length) {
                object.graph = [];
                for (var j = 0; j < message.graph.length; ++j)
                    object.graph[j] = $root.api.IdentityGetSharingGraphElement.toObject(message.graph[j], options);
            }
            return object;
        };

        /**
         * Converts this IdentityGetSharingGraphResponse to JSON.
         * @function toJSON
         * @memberof api.IdentityGetSharingGraphResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityGetSharingGraphResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityGetSharingGraphResponse;
    })();

    api.IdentityPostSharingGraphElement = (function() {

        /**
         * Properties of an IdentityPostSharingGraphElement.
         * @memberof api
         * @interface IIdentityPostSharingGraphElement
         * @property {string|null} [login] IdentityPostSharingGraphElement login
         * @property {number|null} [version] IdentityPostSharingGraphElement version
         * @property {Uint8Array|null} [signChain] IdentityPostSharingGraphElement signChain
         * @property {Array.<api.IIdentityShareEntry>|null} [sharingGroup] IdentityPostSharingGraphElement sharingGroup
         * @property {api.IIdentityBackwardKey|null} [backward] IdentityPostSharingGraphElement backward
         * @property {api.IIdentityEncryptedKeySet|null} [encryption] IdentityPostSharingGraphElement encryption
         */

        /**
         * Constructs a new IdentityPostSharingGraphElement.
         * @memberof api
         * @classdesc Represents an IdentityPostSharingGraphElement.
         * @implements IIdentityPostSharingGraphElement
         * @constructor
         * @param {api.IIdentityPostSharingGraphElement=} [properties] Properties to set
         */
        function IdentityPostSharingGraphElement(properties) {
            this.sharingGroup = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityPostSharingGraphElement login.
         * @member {string} login
         * @memberof api.IdentityPostSharingGraphElement
         * @instance
         */
        IdentityPostSharingGraphElement.prototype.login = "";

        /**
         * IdentityPostSharingGraphElement version.
         * @member {number} version
         * @memberof api.IdentityPostSharingGraphElement
         * @instance
         */
        IdentityPostSharingGraphElement.prototype.version = 0;

        /**
         * IdentityPostSharingGraphElement signChain.
         * @member {Uint8Array} signChain
         * @memberof api.IdentityPostSharingGraphElement
         * @instance
         */
        IdentityPostSharingGraphElement.prototype.signChain = $util.newBuffer([]);

        /**
         * IdentityPostSharingGraphElement sharingGroup.
         * @member {Array.<api.IIdentityShareEntry>} sharingGroup
         * @memberof api.IdentityPostSharingGraphElement
         * @instance
         */
        IdentityPostSharingGraphElement.prototype.sharingGroup = $util.emptyArray;

        /**
         * IdentityPostSharingGraphElement backward.
         * @member {api.IIdentityBackwardKey|null|undefined} backward
         * @memberof api.IdentityPostSharingGraphElement
         * @instance
         */
        IdentityPostSharingGraphElement.prototype.backward = null;

        /**
         * IdentityPostSharingGraphElement encryption.
         * @member {api.IIdentityEncryptedKeySet|null|undefined} encryption
         * @memberof api.IdentityPostSharingGraphElement
         * @instance
         */
        IdentityPostSharingGraphElement.prototype.encryption = null;

        /**
         * Creates a new IdentityPostSharingGraphElement instance using the specified properties.
         * @function create
         * @memberof api.IdentityPostSharingGraphElement
         * @static
         * @param {api.IIdentityPostSharingGraphElement=} [properties] Properties to set
         * @returns {api.IdentityPostSharingGraphElement} IdentityPostSharingGraphElement instance
         */
        IdentityPostSharingGraphElement.create = function create(properties) {
            return new IdentityPostSharingGraphElement(properties);
        };

        /**
         * Encodes the specified IdentityPostSharingGraphElement message. Does not implicitly {@link api.IdentityPostSharingGraphElement.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityPostSharingGraphElement
         * @static
         * @param {api.IIdentityPostSharingGraphElement} message IdentityPostSharingGraphElement message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityPostSharingGraphElement.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            if (message.version != null && message.hasOwnProperty("version"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.version);
            if (message.signChain != null && message.hasOwnProperty("signChain"))
                writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.signChain);
            if (message.sharingGroup != null && message.sharingGroup.length)
                for (var i = 0; i < message.sharingGroup.length; ++i)
                    $root.api.IdentityShareEntry.encode(message.sharingGroup[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.backward != null && message.hasOwnProperty("backward"))
                $root.api.IdentityBackwardKey.encode(message.backward, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.encryption != null && message.hasOwnProperty("encryption"))
                $root.api.IdentityEncryptedKeySet.encode(message.encryption, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IdentityPostSharingGraphElement message, length delimited. Does not implicitly {@link api.IdentityPostSharingGraphElement.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityPostSharingGraphElement
         * @static
         * @param {api.IIdentityPostSharingGraphElement} message IdentityPostSharingGraphElement message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityPostSharingGraphElement.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityPostSharingGraphElement message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityPostSharingGraphElement
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityPostSharingGraphElement} IdentityPostSharingGraphElement
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityPostSharingGraphElement.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityPostSharingGraphElement();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                case 2:
                    message.version = reader.uint32();
                    break;
                case 7:
                    message.signChain = reader.bytes();
                    break;
                case 8:
                    if (!(message.sharingGroup && message.sharingGroup.length))
                        message.sharingGroup = [];
                    message.sharingGroup.push($root.api.IdentityShareEntry.decode(reader, reader.uint32()));
                    break;
                case 9:
                    message.backward = $root.api.IdentityBackwardKey.decode(reader, reader.uint32());
                    break;
                case 10:
                    message.encryption = $root.api.IdentityEncryptedKeySet.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityPostSharingGraphElement message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityPostSharingGraphElement
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityPostSharingGraphElement} IdentityPostSharingGraphElement
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityPostSharingGraphElement.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityPostSharingGraphElement message.
         * @function verify
         * @memberof api.IdentityPostSharingGraphElement
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityPostSharingGraphElement.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isInteger(message.version))
                    return "version: integer expected";
            if (message.signChain != null && message.hasOwnProperty("signChain"))
                if (!(message.signChain && typeof message.signChain.length === "number" || $util.isString(message.signChain)))
                    return "signChain: buffer expected";
            if (message.sharingGroup != null && message.hasOwnProperty("sharingGroup")) {
                if (!Array.isArray(message.sharingGroup))
                    return "sharingGroup: array expected";
                for (var i = 0; i < message.sharingGroup.length; ++i) {
                    var error = $root.api.IdentityShareEntry.verify(message.sharingGroup[i]);
                    if (error)
                        return "sharingGroup." + error;
                }
            }
            if (message.backward != null && message.hasOwnProperty("backward")) {
                var error = $root.api.IdentityBackwardKey.verify(message.backward);
                if (error)
                    return "backward." + error;
            }
            if (message.encryption != null && message.hasOwnProperty("encryption")) {
                var error = $root.api.IdentityEncryptedKeySet.verify(message.encryption);
                if (error)
                    return "encryption." + error;
            }
            return null;
        };

        /**
         * Creates an IdentityPostSharingGraphElement message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityPostSharingGraphElement
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityPostSharingGraphElement} IdentityPostSharingGraphElement
         */
        IdentityPostSharingGraphElement.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityPostSharingGraphElement)
                return object;
            var message = new $root.api.IdentityPostSharingGraphElement();
            if (object.login != null)
                message.login = String(object.login);
            if (object.version != null)
                message.version = object.version >>> 0;
            if (object.signChain != null)
                if (typeof object.signChain === "string")
                    $util.base64.decode(object.signChain, message.signChain = $util.newBuffer($util.base64.length(object.signChain)), 0);
                else if (object.signChain.length)
                    message.signChain = object.signChain;
            if (object.sharingGroup) {
                if (!Array.isArray(object.sharingGroup))
                    throw TypeError(".api.IdentityPostSharingGraphElement.sharingGroup: array expected");
                message.sharingGroup = [];
                for (var i = 0; i < object.sharingGroup.length; ++i) {
                    if (typeof object.sharingGroup[i] !== "object")
                        throw TypeError(".api.IdentityPostSharingGraphElement.sharingGroup: object expected");
                    message.sharingGroup[i] = $root.api.IdentityShareEntry.fromObject(object.sharingGroup[i]);
                }
            }
            if (object.backward != null) {
                if (typeof object.backward !== "object")
                    throw TypeError(".api.IdentityPostSharingGraphElement.backward: object expected");
                message.backward = $root.api.IdentityBackwardKey.fromObject(object.backward);
            }
            if (object.encryption != null) {
                if (typeof object.encryption !== "object")
                    throw TypeError(".api.IdentityPostSharingGraphElement.encryption: object expected");
                message.encryption = $root.api.IdentityEncryptedKeySet.fromObject(object.encryption);
            }
            return message;
        };

        /**
         * Creates a plain object from an IdentityPostSharingGraphElement message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityPostSharingGraphElement
         * @static
         * @param {api.IdentityPostSharingGraphElement} message IdentityPostSharingGraphElement
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityPostSharingGraphElement.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.sharingGroup = [];
            if (options.defaults) {
                object.login = "";
                object.version = 0;
                if (options.bytes === String)
                    object.signChain = "";
                else {
                    object.signChain = [];
                    if (options.bytes !== Array)
                        object.signChain = $util.newBuffer(object.signChain);
                }
                object.backward = null;
                object.encryption = null;
            }
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            if (message.signChain != null && message.hasOwnProperty("signChain"))
                object.signChain = options.bytes === String ? $util.base64.encode(message.signChain, 0, message.signChain.length) : options.bytes === Array ? Array.prototype.slice.call(message.signChain) : message.signChain;
            if (message.sharingGroup && message.sharingGroup.length) {
                object.sharingGroup = [];
                for (var j = 0; j < message.sharingGroup.length; ++j)
                    object.sharingGroup[j] = $root.api.IdentityShareEntry.toObject(message.sharingGroup[j], options);
            }
            if (message.backward != null && message.hasOwnProperty("backward"))
                object.backward = $root.api.IdentityBackwardKey.toObject(message.backward, options);
            if (message.encryption != null && message.hasOwnProperty("encryption"))
                object.encryption = $root.api.IdentityEncryptedKeySet.toObject(message.encryption, options);
            return object;
        };

        /**
         * Converts this IdentityPostSharingGraphElement to JSON.
         * @function toJSON
         * @memberof api.IdentityPostSharingGraphElement
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityPostSharingGraphElement.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityPostSharingGraphElement;
    })();

    api.IdentityPostSharingGraphRequest = (function() {

        /**
         * Properties of an IdentityPostSharingGraphRequest.
         * @memberof api
         * @interface IIdentityPostSharingGraphRequest
         * @property {string|null} [login] IdentityPostSharingGraphRequest login
         * @property {Array.<api.IIdentityPostSharingGraphElement>|null} [graph] IdentityPostSharingGraphRequest graph
         */

        /**
         * Constructs a new IdentityPostSharingGraphRequest.
         * @memberof api
         * @classdesc Represents an IdentityPostSharingGraphRequest.
         * @implements IIdentityPostSharingGraphRequest
         * @constructor
         * @param {api.IIdentityPostSharingGraphRequest=} [properties] Properties to set
         */
        function IdentityPostSharingGraphRequest(properties) {
            this.graph = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityPostSharingGraphRequest login.
         * @member {string} login
         * @memberof api.IdentityPostSharingGraphRequest
         * @instance
         */
        IdentityPostSharingGraphRequest.prototype.login = "";

        /**
         * IdentityPostSharingGraphRequest graph.
         * @member {Array.<api.IIdentityPostSharingGraphElement>} graph
         * @memberof api.IdentityPostSharingGraphRequest
         * @instance
         */
        IdentityPostSharingGraphRequest.prototype.graph = $util.emptyArray;

        /**
         * Creates a new IdentityPostSharingGraphRequest instance using the specified properties.
         * @function create
         * @memberof api.IdentityPostSharingGraphRequest
         * @static
         * @param {api.IIdentityPostSharingGraphRequest=} [properties] Properties to set
         * @returns {api.IdentityPostSharingGraphRequest} IdentityPostSharingGraphRequest instance
         */
        IdentityPostSharingGraphRequest.create = function create(properties) {
            return new IdentityPostSharingGraphRequest(properties);
        };

        /**
         * Encodes the specified IdentityPostSharingGraphRequest message. Does not implicitly {@link api.IdentityPostSharingGraphRequest.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityPostSharingGraphRequest
         * @static
         * @param {api.IIdentityPostSharingGraphRequest} message IdentityPostSharingGraphRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityPostSharingGraphRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            if (message.graph != null && message.graph.length)
                for (var i = 0; i < message.graph.length; ++i)
                    $root.api.IdentityPostSharingGraphElement.encode(message.graph[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IdentityPostSharingGraphRequest message, length delimited. Does not implicitly {@link api.IdentityPostSharingGraphRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityPostSharingGraphRequest
         * @static
         * @param {api.IIdentityPostSharingGraphRequest} message IdentityPostSharingGraphRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityPostSharingGraphRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityPostSharingGraphRequest message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityPostSharingGraphRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityPostSharingGraphRequest} IdentityPostSharingGraphRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityPostSharingGraphRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityPostSharingGraphRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                case 2:
                    if (!(message.graph && message.graph.length))
                        message.graph = [];
                    message.graph.push($root.api.IdentityPostSharingGraphElement.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityPostSharingGraphRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityPostSharingGraphRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityPostSharingGraphRequest} IdentityPostSharingGraphRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityPostSharingGraphRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityPostSharingGraphRequest message.
         * @function verify
         * @memberof api.IdentityPostSharingGraphRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityPostSharingGraphRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            if (message.graph != null && message.hasOwnProperty("graph")) {
                if (!Array.isArray(message.graph))
                    return "graph: array expected";
                for (var i = 0; i < message.graph.length; ++i) {
                    var error = $root.api.IdentityPostSharingGraphElement.verify(message.graph[i]);
                    if (error)
                        return "graph." + error;
                }
            }
            return null;
        };

        /**
         * Creates an IdentityPostSharingGraphRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityPostSharingGraphRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityPostSharingGraphRequest} IdentityPostSharingGraphRequest
         */
        IdentityPostSharingGraphRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityPostSharingGraphRequest)
                return object;
            var message = new $root.api.IdentityPostSharingGraphRequest();
            if (object.login != null)
                message.login = String(object.login);
            if (object.graph) {
                if (!Array.isArray(object.graph))
                    throw TypeError(".api.IdentityPostSharingGraphRequest.graph: array expected");
                message.graph = [];
                for (var i = 0; i < object.graph.length; ++i) {
                    if (typeof object.graph[i] !== "object")
                        throw TypeError(".api.IdentityPostSharingGraphRequest.graph: object expected");
                    message.graph[i] = $root.api.IdentityPostSharingGraphElement.fromObject(object.graph[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an IdentityPostSharingGraphRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityPostSharingGraphRequest
         * @static
         * @param {api.IdentityPostSharingGraphRequest} message IdentityPostSharingGraphRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityPostSharingGraphRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.graph = [];
            if (options.defaults)
                object.login = "";
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            if (message.graph && message.graph.length) {
                object.graph = [];
                for (var j = 0; j < message.graph.length; ++j)
                    object.graph[j] = $root.api.IdentityPostSharingGraphElement.toObject(message.graph[j], options);
            }
            return object;
        };

        /**
         * Converts this IdentityPostSharingGraphRequest to JSON.
         * @function toJSON
         * @memberof api.IdentityPostSharingGraphRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityPostSharingGraphRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityPostSharingGraphRequest;
    })();

    api.IdentityToggleActiveStatusRequest = (function() {

        /**
         * Properties of an IdentityToggleActiveStatusRequest.
         * @memberof api
         * @interface IIdentityToggleActiveStatusRequest
         * @property {string|null} [login] IdentityToggleActiveStatusRequest login
         * @property {boolean|null} [active] IdentityToggleActiveStatusRequest active
         */

        /**
         * Constructs a new IdentityToggleActiveStatusRequest.
         * @memberof api
         * @classdesc Represents an IdentityToggleActiveStatusRequest.
         * @implements IIdentityToggleActiveStatusRequest
         * @constructor
         * @param {api.IIdentityToggleActiveStatusRequest=} [properties] Properties to set
         */
        function IdentityToggleActiveStatusRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityToggleActiveStatusRequest login.
         * @member {string} login
         * @memberof api.IdentityToggleActiveStatusRequest
         * @instance
         */
        IdentityToggleActiveStatusRequest.prototype.login = "";

        /**
         * IdentityToggleActiveStatusRequest active.
         * @member {boolean} active
         * @memberof api.IdentityToggleActiveStatusRequest
         * @instance
         */
        IdentityToggleActiveStatusRequest.prototype.active = false;

        /**
         * Creates a new IdentityToggleActiveStatusRequest instance using the specified properties.
         * @function create
         * @memberof api.IdentityToggleActiveStatusRequest
         * @static
         * @param {api.IIdentityToggleActiveStatusRequest=} [properties] Properties to set
         * @returns {api.IdentityToggleActiveStatusRequest} IdentityToggleActiveStatusRequest instance
         */
        IdentityToggleActiveStatusRequest.create = function create(properties) {
            return new IdentityToggleActiveStatusRequest(properties);
        };

        /**
         * Encodes the specified IdentityToggleActiveStatusRequest message. Does not implicitly {@link api.IdentityToggleActiveStatusRequest.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityToggleActiveStatusRequest
         * @static
         * @param {api.IIdentityToggleActiveStatusRequest} message IdentityToggleActiveStatusRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityToggleActiveStatusRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            if (message.active != null && message.hasOwnProperty("active"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.active);
            return writer;
        };

        /**
         * Encodes the specified IdentityToggleActiveStatusRequest message, length delimited. Does not implicitly {@link api.IdentityToggleActiveStatusRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityToggleActiveStatusRequest
         * @static
         * @param {api.IIdentityToggleActiveStatusRequest} message IdentityToggleActiveStatusRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityToggleActiveStatusRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityToggleActiveStatusRequest message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityToggleActiveStatusRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityToggleActiveStatusRequest} IdentityToggleActiveStatusRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityToggleActiveStatusRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityToggleActiveStatusRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                case 2:
                    message.active = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityToggleActiveStatusRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityToggleActiveStatusRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityToggleActiveStatusRequest} IdentityToggleActiveStatusRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityToggleActiveStatusRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityToggleActiveStatusRequest message.
         * @function verify
         * @memberof api.IdentityToggleActiveStatusRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityToggleActiveStatusRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            if (message.active != null && message.hasOwnProperty("active"))
                if (typeof message.active !== "boolean")
                    return "active: boolean expected";
            return null;
        };

        /**
         * Creates an IdentityToggleActiveStatusRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityToggleActiveStatusRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityToggleActiveStatusRequest} IdentityToggleActiveStatusRequest
         */
        IdentityToggleActiveStatusRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityToggleActiveStatusRequest)
                return object;
            var message = new $root.api.IdentityToggleActiveStatusRequest();
            if (object.login != null)
                message.login = String(object.login);
            if (object.active != null)
                message.active = Boolean(object.active);
            return message;
        };

        /**
         * Creates a plain object from an IdentityToggleActiveStatusRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityToggleActiveStatusRequest
         * @static
         * @param {api.IdentityToggleActiveStatusRequest} message IdentityToggleActiveStatusRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityToggleActiveStatusRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.login = "";
                object.active = false;
            }
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            if (message.active != null && message.hasOwnProperty("active"))
                object.active = message.active;
            return object;
        };

        /**
         * Converts this IdentityToggleActiveStatusRequest to JSON.
         * @function toJSON
         * @memberof api.IdentityToggleActiveStatusRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityToggleActiveStatusRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityToggleActiveStatusRequest;
    })();

    api.IdentityGetLockedVersionsRequest = (function() {

        /**
         * Properties of an IdentityGetLockedVersionsRequest.
         * @memberof api
         * @interface IIdentityGetLockedVersionsRequest
         * @property {string|null} [login] IdentityGetLockedVersionsRequest login
         * @property {boolean|null} [withChallenge] IdentityGetLockedVersionsRequest withChallenge
         */

        /**
         * Constructs a new IdentityGetLockedVersionsRequest.
         * @memberof api
         * @classdesc Represents an IdentityGetLockedVersionsRequest.
         * @implements IIdentityGetLockedVersionsRequest
         * @constructor
         * @param {api.IIdentityGetLockedVersionsRequest=} [properties] Properties to set
         */
        function IdentityGetLockedVersionsRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityGetLockedVersionsRequest login.
         * @member {string} login
         * @memberof api.IdentityGetLockedVersionsRequest
         * @instance
         */
        IdentityGetLockedVersionsRequest.prototype.login = "";

        /**
         * IdentityGetLockedVersionsRequest withChallenge.
         * @member {boolean} withChallenge
         * @memberof api.IdentityGetLockedVersionsRequest
         * @instance
         */
        IdentityGetLockedVersionsRequest.prototype.withChallenge = false;

        /**
         * Creates a new IdentityGetLockedVersionsRequest instance using the specified properties.
         * @function create
         * @memberof api.IdentityGetLockedVersionsRequest
         * @static
         * @param {api.IIdentityGetLockedVersionsRequest=} [properties] Properties to set
         * @returns {api.IdentityGetLockedVersionsRequest} IdentityGetLockedVersionsRequest instance
         */
        IdentityGetLockedVersionsRequest.create = function create(properties) {
            return new IdentityGetLockedVersionsRequest(properties);
        };

        /**
         * Encodes the specified IdentityGetLockedVersionsRequest message. Does not implicitly {@link api.IdentityGetLockedVersionsRequest.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityGetLockedVersionsRequest
         * @static
         * @param {api.IIdentityGetLockedVersionsRequest} message IdentityGetLockedVersionsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetLockedVersionsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            if (message.withChallenge != null && message.hasOwnProperty("withChallenge"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.withChallenge);
            return writer;
        };

        /**
         * Encodes the specified IdentityGetLockedVersionsRequest message, length delimited. Does not implicitly {@link api.IdentityGetLockedVersionsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityGetLockedVersionsRequest
         * @static
         * @param {api.IIdentityGetLockedVersionsRequest} message IdentityGetLockedVersionsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetLockedVersionsRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityGetLockedVersionsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityGetLockedVersionsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityGetLockedVersionsRequest} IdentityGetLockedVersionsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetLockedVersionsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityGetLockedVersionsRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                case 2:
                    message.withChallenge = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityGetLockedVersionsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityGetLockedVersionsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityGetLockedVersionsRequest} IdentityGetLockedVersionsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetLockedVersionsRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityGetLockedVersionsRequest message.
         * @function verify
         * @memberof api.IdentityGetLockedVersionsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityGetLockedVersionsRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            if (message.withChallenge != null && message.hasOwnProperty("withChallenge"))
                if (typeof message.withChallenge !== "boolean")
                    return "withChallenge: boolean expected";
            return null;
        };

        /**
         * Creates an IdentityGetLockedVersionsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityGetLockedVersionsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityGetLockedVersionsRequest} IdentityGetLockedVersionsRequest
         */
        IdentityGetLockedVersionsRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityGetLockedVersionsRequest)
                return object;
            var message = new $root.api.IdentityGetLockedVersionsRequest();
            if (object.login != null)
                message.login = String(object.login);
            if (object.withChallenge != null)
                message.withChallenge = Boolean(object.withChallenge);
            return message;
        };

        /**
         * Creates a plain object from an IdentityGetLockedVersionsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityGetLockedVersionsRequest
         * @static
         * @param {api.IdentityGetLockedVersionsRequest} message IdentityGetLockedVersionsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityGetLockedVersionsRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.login = "";
                object.withChallenge = false;
            }
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            if (message.withChallenge != null && message.hasOwnProperty("withChallenge"))
                object.withChallenge = message.withChallenge;
            return object;
        };

        /**
         * Converts this IdentityGetLockedVersionsRequest to JSON.
         * @function toJSON
         * @memberof api.IdentityGetLockedVersionsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityGetLockedVersionsRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityGetLockedVersionsRequest;
    })();

    api.IdentityGetLockedVersionsResponse = (function() {

        /**
         * Properties of an IdentityGetLockedVersionsResponse.
         * @memberof api
         * @interface IIdentityGetLockedVersionsResponse
         * @property {Array.<api.IdentityGetLockedVersionsResponse.ILockedVersion>|null} [lockedVersions] IdentityGetLockedVersionsResponse lockedVersions
         */

        /**
         * Constructs a new IdentityGetLockedVersionsResponse.
         * @memberof api
         * @classdesc Represents an IdentityGetLockedVersionsResponse.
         * @implements IIdentityGetLockedVersionsResponse
         * @constructor
         * @param {api.IIdentityGetLockedVersionsResponse=} [properties] Properties to set
         */
        function IdentityGetLockedVersionsResponse(properties) {
            this.lockedVersions = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityGetLockedVersionsResponse lockedVersions.
         * @member {Array.<api.IdentityGetLockedVersionsResponse.ILockedVersion>} lockedVersions
         * @memberof api.IdentityGetLockedVersionsResponse
         * @instance
         */
        IdentityGetLockedVersionsResponse.prototype.lockedVersions = $util.emptyArray;

        /**
         * Creates a new IdentityGetLockedVersionsResponse instance using the specified properties.
         * @function create
         * @memberof api.IdentityGetLockedVersionsResponse
         * @static
         * @param {api.IIdentityGetLockedVersionsResponse=} [properties] Properties to set
         * @returns {api.IdentityGetLockedVersionsResponse} IdentityGetLockedVersionsResponse instance
         */
        IdentityGetLockedVersionsResponse.create = function create(properties) {
            return new IdentityGetLockedVersionsResponse(properties);
        };

        /**
         * Encodes the specified IdentityGetLockedVersionsResponse message. Does not implicitly {@link api.IdentityGetLockedVersionsResponse.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityGetLockedVersionsResponse
         * @static
         * @param {api.IIdentityGetLockedVersionsResponse} message IdentityGetLockedVersionsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetLockedVersionsResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.lockedVersions != null && message.lockedVersions.length)
                for (var i = 0; i < message.lockedVersions.length; ++i)
                    $root.api.IdentityGetLockedVersionsResponse.LockedVersion.encode(message.lockedVersions[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IdentityGetLockedVersionsResponse message, length delimited. Does not implicitly {@link api.IdentityGetLockedVersionsResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityGetLockedVersionsResponse
         * @static
         * @param {api.IIdentityGetLockedVersionsResponse} message IdentityGetLockedVersionsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetLockedVersionsResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityGetLockedVersionsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityGetLockedVersionsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityGetLockedVersionsResponse} IdentityGetLockedVersionsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetLockedVersionsResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityGetLockedVersionsResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.lockedVersions && message.lockedVersions.length))
                        message.lockedVersions = [];
                    message.lockedVersions.push($root.api.IdentityGetLockedVersionsResponse.LockedVersion.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityGetLockedVersionsResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityGetLockedVersionsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityGetLockedVersionsResponse} IdentityGetLockedVersionsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetLockedVersionsResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityGetLockedVersionsResponse message.
         * @function verify
         * @memberof api.IdentityGetLockedVersionsResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityGetLockedVersionsResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.lockedVersions != null && message.hasOwnProperty("lockedVersions")) {
                if (!Array.isArray(message.lockedVersions))
                    return "lockedVersions: array expected";
                for (var i = 0; i < message.lockedVersions.length; ++i) {
                    var error = $root.api.IdentityGetLockedVersionsResponse.LockedVersion.verify(message.lockedVersions[i]);
                    if (error)
                        return "lockedVersions." + error;
                }
            }
            return null;
        };

        /**
         * Creates an IdentityGetLockedVersionsResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityGetLockedVersionsResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityGetLockedVersionsResponse} IdentityGetLockedVersionsResponse
         */
        IdentityGetLockedVersionsResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityGetLockedVersionsResponse)
                return object;
            var message = new $root.api.IdentityGetLockedVersionsResponse();
            if (object.lockedVersions) {
                if (!Array.isArray(object.lockedVersions))
                    throw TypeError(".api.IdentityGetLockedVersionsResponse.lockedVersions: array expected");
                message.lockedVersions = [];
                for (var i = 0; i < object.lockedVersions.length; ++i) {
                    if (typeof object.lockedVersions[i] !== "object")
                        throw TypeError(".api.IdentityGetLockedVersionsResponse.lockedVersions: object expected");
                    message.lockedVersions[i] = $root.api.IdentityGetLockedVersionsResponse.LockedVersion.fromObject(object.lockedVersions[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an IdentityGetLockedVersionsResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityGetLockedVersionsResponse
         * @static
         * @param {api.IdentityGetLockedVersionsResponse} message IdentityGetLockedVersionsResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityGetLockedVersionsResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.lockedVersions = [];
            if (message.lockedVersions && message.lockedVersions.length) {
                object.lockedVersions = [];
                for (var j = 0; j < message.lockedVersions.length; ++j)
                    object.lockedVersions[j] = $root.api.IdentityGetLockedVersionsResponse.LockedVersion.toObject(message.lockedVersions[j], options);
            }
            return object;
        };

        /**
         * Converts this IdentityGetLockedVersionsResponse to JSON.
         * @function toJSON
         * @memberof api.IdentityGetLockedVersionsResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityGetLockedVersionsResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        IdentityGetLockedVersionsResponse.IdentityChallenge = (function() {

            /**
             * Properties of an IdentityChallenge.
             * @memberof api.IdentityGetLockedVersionsResponse
             * @interface IIdentityChallenge
             * @property {Uint8Array|null} [salt] IdentityChallenge salt
             * @property {Uint8Array|null} [token] IdentityChallenge token
             * @property {api.IIdentityEncryptedKeySet|null} [encryption] IdentityChallenge encryption
             */

            /**
             * Constructs a new IdentityChallenge.
             * @memberof api.IdentityGetLockedVersionsResponse
             * @classdesc Represents an IdentityChallenge.
             * @implements IIdentityChallenge
             * @constructor
             * @param {api.IdentityGetLockedVersionsResponse.IIdentityChallenge=} [properties] Properties to set
             */
            function IdentityChallenge(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * IdentityChallenge salt.
             * @member {Uint8Array} salt
             * @memberof api.IdentityGetLockedVersionsResponse.IdentityChallenge
             * @instance
             */
            IdentityChallenge.prototype.salt = $util.newBuffer([]);

            /**
             * IdentityChallenge token.
             * @member {Uint8Array} token
             * @memberof api.IdentityGetLockedVersionsResponse.IdentityChallenge
             * @instance
             */
            IdentityChallenge.prototype.token = $util.newBuffer([]);

            /**
             * IdentityChallenge encryption.
             * @member {api.IIdentityEncryptedKeySet|null|undefined} encryption
             * @memberof api.IdentityGetLockedVersionsResponse.IdentityChallenge
             * @instance
             */
            IdentityChallenge.prototype.encryption = null;

            /**
             * Creates a new IdentityChallenge instance using the specified properties.
             * @function create
             * @memberof api.IdentityGetLockedVersionsResponse.IdentityChallenge
             * @static
             * @param {api.IdentityGetLockedVersionsResponse.IIdentityChallenge=} [properties] Properties to set
             * @returns {api.IdentityGetLockedVersionsResponse.IdentityChallenge} IdentityChallenge instance
             */
            IdentityChallenge.create = function create(properties) {
                return new IdentityChallenge(properties);
            };

            /**
             * Encodes the specified IdentityChallenge message. Does not implicitly {@link api.IdentityGetLockedVersionsResponse.IdentityChallenge.verify|verify} messages.
             * @function encode
             * @memberof api.IdentityGetLockedVersionsResponse.IdentityChallenge
             * @static
             * @param {api.IdentityGetLockedVersionsResponse.IIdentityChallenge} message IdentityChallenge message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            IdentityChallenge.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.salt != null && message.hasOwnProperty("salt"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.salt);
                if (message.token != null && message.hasOwnProperty("token"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.token);
                if (message.encryption != null && message.hasOwnProperty("encryption"))
                    $root.api.IdentityEncryptedKeySet.encode(message.encryption, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified IdentityChallenge message, length delimited. Does not implicitly {@link api.IdentityGetLockedVersionsResponse.IdentityChallenge.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.IdentityGetLockedVersionsResponse.IdentityChallenge
             * @static
             * @param {api.IdentityGetLockedVersionsResponse.IIdentityChallenge} message IdentityChallenge message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            IdentityChallenge.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an IdentityChallenge message from the specified reader or buffer.
             * @function decode
             * @memberof api.IdentityGetLockedVersionsResponse.IdentityChallenge
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.IdentityGetLockedVersionsResponse.IdentityChallenge} IdentityChallenge
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            IdentityChallenge.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityGetLockedVersionsResponse.IdentityChallenge();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.salt = reader.bytes();
                        break;
                    case 2:
                        message.token = reader.bytes();
                        break;
                    case 3:
                        message.encryption = $root.api.IdentityEncryptedKeySet.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an IdentityChallenge message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.IdentityGetLockedVersionsResponse.IdentityChallenge
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.IdentityGetLockedVersionsResponse.IdentityChallenge} IdentityChallenge
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            IdentityChallenge.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an IdentityChallenge message.
             * @function verify
             * @memberof api.IdentityGetLockedVersionsResponse.IdentityChallenge
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            IdentityChallenge.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.salt != null && message.hasOwnProperty("salt"))
                    if (!(message.salt && typeof message.salt.length === "number" || $util.isString(message.salt)))
                        return "salt: buffer expected";
                if (message.token != null && message.hasOwnProperty("token"))
                    if (!(message.token && typeof message.token.length === "number" || $util.isString(message.token)))
                        return "token: buffer expected";
                if (message.encryption != null && message.hasOwnProperty("encryption")) {
                    var error = $root.api.IdentityEncryptedKeySet.verify(message.encryption);
                    if (error)
                        return "encryption." + error;
                }
                return null;
            };

            /**
             * Creates an IdentityChallenge message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.IdentityGetLockedVersionsResponse.IdentityChallenge
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.IdentityGetLockedVersionsResponse.IdentityChallenge} IdentityChallenge
             */
            IdentityChallenge.fromObject = function fromObject(object) {
                if (object instanceof $root.api.IdentityGetLockedVersionsResponse.IdentityChallenge)
                    return object;
                var message = new $root.api.IdentityGetLockedVersionsResponse.IdentityChallenge();
                if (object.salt != null)
                    if (typeof object.salt === "string")
                        $util.base64.decode(object.salt, message.salt = $util.newBuffer($util.base64.length(object.salt)), 0);
                    else if (object.salt.length)
                        message.salt = object.salt;
                if (object.token != null)
                    if (typeof object.token === "string")
                        $util.base64.decode(object.token, message.token = $util.newBuffer($util.base64.length(object.token)), 0);
                    else if (object.token.length)
                        message.token = object.token;
                if (object.encryption != null) {
                    if (typeof object.encryption !== "object")
                        throw TypeError(".api.IdentityGetLockedVersionsResponse.IdentityChallenge.encryption: object expected");
                    message.encryption = $root.api.IdentityEncryptedKeySet.fromObject(object.encryption);
                }
                return message;
            };

            /**
             * Creates a plain object from an IdentityChallenge message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.IdentityGetLockedVersionsResponse.IdentityChallenge
             * @static
             * @param {api.IdentityGetLockedVersionsResponse.IdentityChallenge} message IdentityChallenge
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            IdentityChallenge.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.salt = "";
                    else {
                        object.salt = [];
                        if (options.bytes !== Array)
                            object.salt = $util.newBuffer(object.salt);
                    }
                    if (options.bytes === String)
                        object.token = "";
                    else {
                        object.token = [];
                        if (options.bytes !== Array)
                            object.token = $util.newBuffer(object.token);
                    }
                    object.encryption = null;
                }
                if (message.salt != null && message.hasOwnProperty("salt"))
                    object.salt = options.bytes === String ? $util.base64.encode(message.salt, 0, message.salt.length) : options.bytes === Array ? Array.prototype.slice.call(message.salt) : message.salt;
                if (message.token != null && message.hasOwnProperty("token"))
                    object.token = options.bytes === String ? $util.base64.encode(message.token, 0, message.token.length) : options.bytes === Array ? Array.prototype.slice.call(message.token) : message.token;
                if (message.encryption != null && message.hasOwnProperty("encryption"))
                    object.encryption = $root.api.IdentityEncryptedKeySet.toObject(message.encryption, options);
                return object;
            };

            /**
             * Converts this IdentityChallenge to JSON.
             * @function toJSON
             * @memberof api.IdentityGetLockedVersionsResponse.IdentityChallenge
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            IdentityChallenge.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return IdentityChallenge;
        })();

        IdentityGetLockedVersionsResponse.LockedVersion = (function() {

            /**
             * Properties of a LockedVersion.
             * @memberof api.IdentityGetLockedVersionsResponse
             * @interface ILockedVersion
             * @property {api.IIdentityPublicKeyWithMetadata|null} [publicKey] LockedVersion publicKey
             * @property {api.IdentityGetLockedVersionsResponse.IIdentityChallenge|null} [challenge] LockedVersion challenge
             */

            /**
             * Constructs a new LockedVersion.
             * @memberof api.IdentityGetLockedVersionsResponse
             * @classdesc Represents a LockedVersion.
             * @implements ILockedVersion
             * @constructor
             * @param {api.IdentityGetLockedVersionsResponse.ILockedVersion=} [properties] Properties to set
             */
            function LockedVersion(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LockedVersion publicKey.
             * @member {api.IIdentityPublicKeyWithMetadata|null|undefined} publicKey
             * @memberof api.IdentityGetLockedVersionsResponse.LockedVersion
             * @instance
             */
            LockedVersion.prototype.publicKey = null;

            /**
             * LockedVersion challenge.
             * @member {api.IdentityGetLockedVersionsResponse.IIdentityChallenge|null|undefined} challenge
             * @memberof api.IdentityGetLockedVersionsResponse.LockedVersion
             * @instance
             */
            LockedVersion.prototype.challenge = null;

            /**
             * Creates a new LockedVersion instance using the specified properties.
             * @function create
             * @memberof api.IdentityGetLockedVersionsResponse.LockedVersion
             * @static
             * @param {api.IdentityGetLockedVersionsResponse.ILockedVersion=} [properties] Properties to set
             * @returns {api.IdentityGetLockedVersionsResponse.LockedVersion} LockedVersion instance
             */
            LockedVersion.create = function create(properties) {
                return new LockedVersion(properties);
            };

            /**
             * Encodes the specified LockedVersion message. Does not implicitly {@link api.IdentityGetLockedVersionsResponse.LockedVersion.verify|verify} messages.
             * @function encode
             * @memberof api.IdentityGetLockedVersionsResponse.LockedVersion
             * @static
             * @param {api.IdentityGetLockedVersionsResponse.ILockedVersion} message LockedVersion message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LockedVersion.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                    $root.api.IdentityPublicKeyWithMetadata.encode(message.publicKey, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.challenge != null && message.hasOwnProperty("challenge"))
                    $root.api.IdentityGetLockedVersionsResponse.IdentityChallenge.encode(message.challenge, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified LockedVersion message, length delimited. Does not implicitly {@link api.IdentityGetLockedVersionsResponse.LockedVersion.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.IdentityGetLockedVersionsResponse.LockedVersion
             * @static
             * @param {api.IdentityGetLockedVersionsResponse.ILockedVersion} message LockedVersion message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LockedVersion.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a LockedVersion message from the specified reader or buffer.
             * @function decode
             * @memberof api.IdentityGetLockedVersionsResponse.LockedVersion
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.IdentityGetLockedVersionsResponse.LockedVersion} LockedVersion
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LockedVersion.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityGetLockedVersionsResponse.LockedVersion();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.publicKey = $root.api.IdentityPublicKeyWithMetadata.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.challenge = $root.api.IdentityGetLockedVersionsResponse.IdentityChallenge.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a LockedVersion message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.IdentityGetLockedVersionsResponse.LockedVersion
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.IdentityGetLockedVersionsResponse.LockedVersion} LockedVersion
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LockedVersion.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a LockedVersion message.
             * @function verify
             * @memberof api.IdentityGetLockedVersionsResponse.LockedVersion
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LockedVersion.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.publicKey != null && message.hasOwnProperty("publicKey")) {
                    var error = $root.api.IdentityPublicKeyWithMetadata.verify(message.publicKey);
                    if (error)
                        return "publicKey." + error;
                }
                if (message.challenge != null && message.hasOwnProperty("challenge")) {
                    var error = $root.api.IdentityGetLockedVersionsResponse.IdentityChallenge.verify(message.challenge);
                    if (error)
                        return "challenge." + error;
                }
                return null;
            };

            /**
             * Creates a LockedVersion message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.IdentityGetLockedVersionsResponse.LockedVersion
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.IdentityGetLockedVersionsResponse.LockedVersion} LockedVersion
             */
            LockedVersion.fromObject = function fromObject(object) {
                if (object instanceof $root.api.IdentityGetLockedVersionsResponse.LockedVersion)
                    return object;
                var message = new $root.api.IdentityGetLockedVersionsResponse.LockedVersion();
                if (object.publicKey != null) {
                    if (typeof object.publicKey !== "object")
                        throw TypeError(".api.IdentityGetLockedVersionsResponse.LockedVersion.publicKey: object expected");
                    message.publicKey = $root.api.IdentityPublicKeyWithMetadata.fromObject(object.publicKey);
                }
                if (object.challenge != null) {
                    if (typeof object.challenge !== "object")
                        throw TypeError(".api.IdentityGetLockedVersionsResponse.LockedVersion.challenge: object expected");
                    message.challenge = $root.api.IdentityGetLockedVersionsResponse.IdentityChallenge.fromObject(object.challenge);
                }
                return message;
            };

            /**
             * Creates a plain object from a LockedVersion message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.IdentityGetLockedVersionsResponse.LockedVersion
             * @static
             * @param {api.IdentityGetLockedVersionsResponse.LockedVersion} message LockedVersion
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LockedVersion.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.publicKey = null;
                    object.challenge = null;
                }
                if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                    object.publicKey = $root.api.IdentityPublicKeyWithMetadata.toObject(message.publicKey, options);
                if (message.challenge != null && message.hasOwnProperty("challenge"))
                    object.challenge = $root.api.IdentityGetLockedVersionsResponse.IdentityChallenge.toObject(message.challenge, options);
                return object;
            };

            /**
             * Converts this LockedVersion to JSON.
             * @function toJSON
             * @memberof api.IdentityGetLockedVersionsResponse.LockedVersion
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LockedVersion.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return LockedVersion;
        })();

        return IdentityGetLockedVersionsResponse;
    })();

    api.IdentitySetNamedResourceRequest = (function() {

        /**
         * Properties of an IdentitySetNamedResourceRequest.
         * @memberof api
         * @interface IIdentitySetNamedResourceRequest
         * @property {string|null} [login] IdentitySetNamedResourceRequest login
         * @property {string|null} [resourceName] IdentitySetNamedResourceRequest resourceName
         * @property {number|Long|null} [resourceID] IdentitySetNamedResourceRequest resourceID
         */

        /**
         * Constructs a new IdentitySetNamedResourceRequest.
         * @memberof api
         * @classdesc Represents an IdentitySetNamedResourceRequest.
         * @implements IIdentitySetNamedResourceRequest
         * @constructor
         * @param {api.IIdentitySetNamedResourceRequest=} [properties] Properties to set
         */
        function IdentitySetNamedResourceRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentitySetNamedResourceRequest login.
         * @member {string} login
         * @memberof api.IdentitySetNamedResourceRequest
         * @instance
         */
        IdentitySetNamedResourceRequest.prototype.login = "";

        /**
         * IdentitySetNamedResourceRequest resourceName.
         * @member {string} resourceName
         * @memberof api.IdentitySetNamedResourceRequest
         * @instance
         */
        IdentitySetNamedResourceRequest.prototype.resourceName = "";

        /**
         * IdentitySetNamedResourceRequest resourceID.
         * @member {number|Long} resourceID
         * @memberof api.IdentitySetNamedResourceRequest
         * @instance
         */
        IdentitySetNamedResourceRequest.prototype.resourceID = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new IdentitySetNamedResourceRequest instance using the specified properties.
         * @function create
         * @memberof api.IdentitySetNamedResourceRequest
         * @static
         * @param {api.IIdentitySetNamedResourceRequest=} [properties] Properties to set
         * @returns {api.IdentitySetNamedResourceRequest} IdentitySetNamedResourceRequest instance
         */
        IdentitySetNamedResourceRequest.create = function create(properties) {
            return new IdentitySetNamedResourceRequest(properties);
        };

        /**
         * Encodes the specified IdentitySetNamedResourceRequest message. Does not implicitly {@link api.IdentitySetNamedResourceRequest.verify|verify} messages.
         * @function encode
         * @memberof api.IdentitySetNamedResourceRequest
         * @static
         * @param {api.IIdentitySetNamedResourceRequest} message IdentitySetNamedResourceRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentitySetNamedResourceRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            if (message.resourceName != null && message.hasOwnProperty("resourceName"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.resourceName);
            if (message.resourceID != null && message.hasOwnProperty("resourceID"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.resourceID);
            return writer;
        };

        /**
         * Encodes the specified IdentitySetNamedResourceRequest message, length delimited. Does not implicitly {@link api.IdentitySetNamedResourceRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentitySetNamedResourceRequest
         * @static
         * @param {api.IIdentitySetNamedResourceRequest} message IdentitySetNamedResourceRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentitySetNamedResourceRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentitySetNamedResourceRequest message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentitySetNamedResourceRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentitySetNamedResourceRequest} IdentitySetNamedResourceRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentitySetNamedResourceRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentitySetNamedResourceRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                case 2:
                    message.resourceName = reader.string();
                    break;
                case 3:
                    message.resourceID = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentitySetNamedResourceRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentitySetNamedResourceRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentitySetNamedResourceRequest} IdentitySetNamedResourceRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentitySetNamedResourceRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentitySetNamedResourceRequest message.
         * @function verify
         * @memberof api.IdentitySetNamedResourceRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentitySetNamedResourceRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            if (message.resourceName != null && message.hasOwnProperty("resourceName"))
                if (!$util.isString(message.resourceName))
                    return "resourceName: string expected";
            if (message.resourceID != null && message.hasOwnProperty("resourceID"))
                if (!$util.isInteger(message.resourceID) && !(message.resourceID && $util.isInteger(message.resourceID.low) && $util.isInteger(message.resourceID.high)))
                    return "resourceID: integer|Long expected";
            return null;
        };

        /**
         * Creates an IdentitySetNamedResourceRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentitySetNamedResourceRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentitySetNamedResourceRequest} IdentitySetNamedResourceRequest
         */
        IdentitySetNamedResourceRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentitySetNamedResourceRequest)
                return object;
            var message = new $root.api.IdentitySetNamedResourceRequest();
            if (object.login != null)
                message.login = String(object.login);
            if (object.resourceName != null)
                message.resourceName = String(object.resourceName);
            if (object.resourceID != null)
                if ($util.Long)
                    (message.resourceID = $util.Long.fromValue(object.resourceID)).unsigned = true;
                else if (typeof object.resourceID === "string")
                    message.resourceID = parseInt(object.resourceID, 10);
                else if (typeof object.resourceID === "number")
                    message.resourceID = object.resourceID;
                else if (typeof object.resourceID === "object")
                    message.resourceID = new $util.LongBits(object.resourceID.low >>> 0, object.resourceID.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from an IdentitySetNamedResourceRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentitySetNamedResourceRequest
         * @static
         * @param {api.IdentitySetNamedResourceRequest} message IdentitySetNamedResourceRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentitySetNamedResourceRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.login = "";
                object.resourceName = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.resourceID = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.resourceID = options.longs === String ? "0" : 0;
            }
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            if (message.resourceName != null && message.hasOwnProperty("resourceName"))
                object.resourceName = message.resourceName;
            if (message.resourceID != null && message.hasOwnProperty("resourceID"))
                if (typeof message.resourceID === "number")
                    object.resourceID = options.longs === String ? String(message.resourceID) : message.resourceID;
                else
                    object.resourceID = options.longs === String ? $util.Long.prototype.toString.call(message.resourceID) : options.longs === Number ? new $util.LongBits(message.resourceID.low >>> 0, message.resourceID.high >>> 0).toNumber(true) : message.resourceID;
            return object;
        };

        /**
         * Converts this IdentitySetNamedResourceRequest to JSON.
         * @function toJSON
         * @memberof api.IdentitySetNamedResourceRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentitySetNamedResourceRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentitySetNamedResourceRequest;
    })();

    api.IdentityGetNamedResourceRequest = (function() {

        /**
         * Properties of an IdentityGetNamedResourceRequest.
         * @memberof api
         * @interface IIdentityGetNamedResourceRequest
         * @property {string|null} [login] IdentityGetNamedResourceRequest login
         * @property {string|null} [resourceName] IdentityGetNamedResourceRequest resourceName
         */

        /**
         * Constructs a new IdentityGetNamedResourceRequest.
         * @memberof api
         * @classdesc Represents an IdentityGetNamedResourceRequest.
         * @implements IIdentityGetNamedResourceRequest
         * @constructor
         * @param {api.IIdentityGetNamedResourceRequest=} [properties] Properties to set
         */
        function IdentityGetNamedResourceRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityGetNamedResourceRequest login.
         * @member {string} login
         * @memberof api.IdentityGetNamedResourceRequest
         * @instance
         */
        IdentityGetNamedResourceRequest.prototype.login = "";

        /**
         * IdentityGetNamedResourceRequest resourceName.
         * @member {string} resourceName
         * @memberof api.IdentityGetNamedResourceRequest
         * @instance
         */
        IdentityGetNamedResourceRequest.prototype.resourceName = "";

        /**
         * Creates a new IdentityGetNamedResourceRequest instance using the specified properties.
         * @function create
         * @memberof api.IdentityGetNamedResourceRequest
         * @static
         * @param {api.IIdentityGetNamedResourceRequest=} [properties] Properties to set
         * @returns {api.IdentityGetNamedResourceRequest} IdentityGetNamedResourceRequest instance
         */
        IdentityGetNamedResourceRequest.create = function create(properties) {
            return new IdentityGetNamedResourceRequest(properties);
        };

        /**
         * Encodes the specified IdentityGetNamedResourceRequest message. Does not implicitly {@link api.IdentityGetNamedResourceRequest.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityGetNamedResourceRequest
         * @static
         * @param {api.IIdentityGetNamedResourceRequest} message IdentityGetNamedResourceRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetNamedResourceRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            if (message.resourceName != null && message.hasOwnProperty("resourceName"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.resourceName);
            return writer;
        };

        /**
         * Encodes the specified IdentityGetNamedResourceRequest message, length delimited. Does not implicitly {@link api.IdentityGetNamedResourceRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityGetNamedResourceRequest
         * @static
         * @param {api.IIdentityGetNamedResourceRequest} message IdentityGetNamedResourceRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetNamedResourceRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityGetNamedResourceRequest message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityGetNamedResourceRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityGetNamedResourceRequest} IdentityGetNamedResourceRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetNamedResourceRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityGetNamedResourceRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                case 2:
                    message.resourceName = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityGetNamedResourceRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityGetNamedResourceRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityGetNamedResourceRequest} IdentityGetNamedResourceRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetNamedResourceRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityGetNamedResourceRequest message.
         * @function verify
         * @memberof api.IdentityGetNamedResourceRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityGetNamedResourceRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            if (message.resourceName != null && message.hasOwnProperty("resourceName"))
                if (!$util.isString(message.resourceName))
                    return "resourceName: string expected";
            return null;
        };

        /**
         * Creates an IdentityGetNamedResourceRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityGetNamedResourceRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityGetNamedResourceRequest} IdentityGetNamedResourceRequest
         */
        IdentityGetNamedResourceRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityGetNamedResourceRequest)
                return object;
            var message = new $root.api.IdentityGetNamedResourceRequest();
            if (object.login != null)
                message.login = String(object.login);
            if (object.resourceName != null)
                message.resourceName = String(object.resourceName);
            return message;
        };

        /**
         * Creates a plain object from an IdentityGetNamedResourceRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityGetNamedResourceRequest
         * @static
         * @param {api.IdentityGetNamedResourceRequest} message IdentityGetNamedResourceRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityGetNamedResourceRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.login = "";
                object.resourceName = "";
            }
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            if (message.resourceName != null && message.hasOwnProperty("resourceName"))
                object.resourceName = message.resourceName;
            return object;
        };

        /**
         * Converts this IdentityGetNamedResourceRequest to JSON.
         * @function toJSON
         * @memberof api.IdentityGetNamedResourceRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityGetNamedResourceRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityGetNamedResourceRequest;
    })();

    api.IdentityGetNamedResourceResponse = (function() {

        /**
         * Properties of an IdentityGetNamedResourceResponse.
         * @memberof api
         * @interface IIdentityGetNamedResourceResponse
         * @property {api.IResourceGetResponse|null} [resource] IdentityGetNamedResourceResponse resource
         */

        /**
         * Constructs a new IdentityGetNamedResourceResponse.
         * @memberof api
         * @classdesc Represents an IdentityGetNamedResourceResponse.
         * @implements IIdentityGetNamedResourceResponse
         * @constructor
         * @param {api.IIdentityGetNamedResourceResponse=} [properties] Properties to set
         */
        function IdentityGetNamedResourceResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityGetNamedResourceResponse resource.
         * @member {api.IResourceGetResponse|null|undefined} resource
         * @memberof api.IdentityGetNamedResourceResponse
         * @instance
         */
        IdentityGetNamedResourceResponse.prototype.resource = null;

        /**
         * Creates a new IdentityGetNamedResourceResponse instance using the specified properties.
         * @function create
         * @memberof api.IdentityGetNamedResourceResponse
         * @static
         * @param {api.IIdentityGetNamedResourceResponse=} [properties] Properties to set
         * @returns {api.IdentityGetNamedResourceResponse} IdentityGetNamedResourceResponse instance
         */
        IdentityGetNamedResourceResponse.create = function create(properties) {
            return new IdentityGetNamedResourceResponse(properties);
        };

        /**
         * Encodes the specified IdentityGetNamedResourceResponse message. Does not implicitly {@link api.IdentityGetNamedResourceResponse.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityGetNamedResourceResponse
         * @static
         * @param {api.IIdentityGetNamedResourceResponse} message IdentityGetNamedResourceResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetNamedResourceResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.resource != null && message.hasOwnProperty("resource"))
                $root.api.ResourceGetResponse.encode(message.resource, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IdentityGetNamedResourceResponse message, length delimited. Does not implicitly {@link api.IdentityGetNamedResourceResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityGetNamedResourceResponse
         * @static
         * @param {api.IIdentityGetNamedResourceResponse} message IdentityGetNamedResourceResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetNamedResourceResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityGetNamedResourceResponse message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityGetNamedResourceResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityGetNamedResourceResponse} IdentityGetNamedResourceResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetNamedResourceResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityGetNamedResourceResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.resource = $root.api.ResourceGetResponse.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityGetNamedResourceResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityGetNamedResourceResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityGetNamedResourceResponse} IdentityGetNamedResourceResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetNamedResourceResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityGetNamedResourceResponse message.
         * @function verify
         * @memberof api.IdentityGetNamedResourceResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityGetNamedResourceResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.resource != null && message.hasOwnProperty("resource")) {
                var error = $root.api.ResourceGetResponse.verify(message.resource);
                if (error)
                    return "resource." + error;
            }
            return null;
        };

        /**
         * Creates an IdentityGetNamedResourceResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityGetNamedResourceResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityGetNamedResourceResponse} IdentityGetNamedResourceResponse
         */
        IdentityGetNamedResourceResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityGetNamedResourceResponse)
                return object;
            var message = new $root.api.IdentityGetNamedResourceResponse();
            if (object.resource != null) {
                if (typeof object.resource !== "object")
                    throw TypeError(".api.IdentityGetNamedResourceResponse.resource: object expected");
                message.resource = $root.api.ResourceGetResponse.fromObject(object.resource);
            }
            return message;
        };

        /**
         * Creates a plain object from an IdentityGetNamedResourceResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityGetNamedResourceResponse
         * @static
         * @param {api.IdentityGetNamedResourceResponse} message IdentityGetNamedResourceResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityGetNamedResourceResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.resource = null;
            if (message.resource != null && message.hasOwnProperty("resource"))
                object.resource = $root.api.ResourceGetResponse.toObject(message.resource, options);
            return object;
        };

        /**
         * Converts this IdentityGetNamedResourceResponse to JSON.
         * @function toJSON
         * @memberof api.IdentityGetNamedResourceResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityGetNamedResourceResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityGetNamedResourceResponse;
    })();

    /**
     * IdentitySortingField enum.
     * @name api.IdentitySortingField
     * @enum {string}
     * @property {number} LOGIN=0 LOGIN value
     * @property {number} CREATED=1 CREATED value
     * @property {number} KIND=2 KIND value
     */
    api.IdentitySortingField = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "LOGIN"] = 0;
        values[valuesById[1] = "CREATED"] = 1;
        values[valuesById[2] = "KIND"] = 2;
        return values;
    })();

    /**
     * SortingOrder enum.
     * @name api.SortingOrder
     * @enum {string}
     * @property {number} DESC=0 DESC value
     * @property {number} ASC=1 ASC value
     */
    api.SortingOrder = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DESC"] = 0;
        values[valuesById[1] = "ASC"] = 1;
        return values;
    })();

    /**
     * SessionSaltKind enum.
     * @name api.SessionSaltKind
     * @enum {string}
     * @property {number} TIME=0 TIME value
     * @property {number} RAND=1 RAND value
     */
    api.SessionSaltKind = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "TIME"] = 0;
        values[valuesById[1] = "RAND"] = 1;
        return values;
    })();

    api.SessionCreateChallengeRequest = (function() {

        /**
         * Properties of a SessionCreateChallengeRequest.
         * @memberof api
         * @interface ISessionCreateChallengeRequest
         * @property {string|null} [login] SessionCreateChallengeRequest login
         * @property {api.SessionSaltKind|null} [saltKind] SessionCreateChallengeRequest saltKind
         * @property {number|null} [duration] SessionCreateChallengeRequest duration
         */

        /**
         * Constructs a new SessionCreateChallengeRequest.
         * @memberof api
         * @classdesc Represents a SessionCreateChallengeRequest.
         * @implements ISessionCreateChallengeRequest
         * @constructor
         * @param {api.ISessionCreateChallengeRequest=} [properties] Properties to set
         */
        function SessionCreateChallengeRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SessionCreateChallengeRequest login.
         * @member {string} login
         * @memberof api.SessionCreateChallengeRequest
         * @instance
         */
        SessionCreateChallengeRequest.prototype.login = "";

        /**
         * SessionCreateChallengeRequest saltKind.
         * @member {api.SessionSaltKind} saltKind
         * @memberof api.SessionCreateChallengeRequest
         * @instance
         */
        SessionCreateChallengeRequest.prototype.saltKind = 0;

        /**
         * SessionCreateChallengeRequest duration.
         * @member {number} duration
         * @memberof api.SessionCreateChallengeRequest
         * @instance
         */
        SessionCreateChallengeRequest.prototype.duration = 0;

        /**
         * Creates a new SessionCreateChallengeRequest instance using the specified properties.
         * @function create
         * @memberof api.SessionCreateChallengeRequest
         * @static
         * @param {api.ISessionCreateChallengeRequest=} [properties] Properties to set
         * @returns {api.SessionCreateChallengeRequest} SessionCreateChallengeRequest instance
         */
        SessionCreateChallengeRequest.create = function create(properties) {
            return new SessionCreateChallengeRequest(properties);
        };

        /**
         * Encodes the specified SessionCreateChallengeRequest message. Does not implicitly {@link api.SessionCreateChallengeRequest.verify|verify} messages.
         * @function encode
         * @memberof api.SessionCreateChallengeRequest
         * @static
         * @param {api.ISessionCreateChallengeRequest} message SessionCreateChallengeRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SessionCreateChallengeRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            if (message.saltKind != null && message.hasOwnProperty("saltKind"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.saltKind);
            if (message.duration != null && message.hasOwnProperty("duration"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.duration);
            return writer;
        };

        /**
         * Encodes the specified SessionCreateChallengeRequest message, length delimited. Does not implicitly {@link api.SessionCreateChallengeRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.SessionCreateChallengeRequest
         * @static
         * @param {api.ISessionCreateChallengeRequest} message SessionCreateChallengeRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SessionCreateChallengeRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SessionCreateChallengeRequest message from the specified reader or buffer.
         * @function decode
         * @memberof api.SessionCreateChallengeRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.SessionCreateChallengeRequest} SessionCreateChallengeRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SessionCreateChallengeRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.SessionCreateChallengeRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                case 2:
                    message.saltKind = reader.int32();
                    break;
                case 3:
                    message.duration = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SessionCreateChallengeRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.SessionCreateChallengeRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.SessionCreateChallengeRequest} SessionCreateChallengeRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SessionCreateChallengeRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SessionCreateChallengeRequest message.
         * @function verify
         * @memberof api.SessionCreateChallengeRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SessionCreateChallengeRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            if (message.saltKind != null && message.hasOwnProperty("saltKind"))
                switch (message.saltKind) {
                default:
                    return "saltKind: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.duration != null && message.hasOwnProperty("duration"))
                if (!$util.isInteger(message.duration))
                    return "duration: integer expected";
            return null;
        };

        /**
         * Creates a SessionCreateChallengeRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.SessionCreateChallengeRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.SessionCreateChallengeRequest} SessionCreateChallengeRequest
         */
        SessionCreateChallengeRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.api.SessionCreateChallengeRequest)
                return object;
            var message = new $root.api.SessionCreateChallengeRequest();
            if (object.login != null)
                message.login = String(object.login);
            switch (object.saltKind) {
            case "TIME":
            case 0:
                message.saltKind = 0;
                break;
            case "RAND":
            case 1:
                message.saltKind = 1;
                break;
            }
            if (object.duration != null)
                message.duration = object.duration >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a SessionCreateChallengeRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.SessionCreateChallengeRequest
         * @static
         * @param {api.SessionCreateChallengeRequest} message SessionCreateChallengeRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SessionCreateChallengeRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.login = "";
                object.saltKind = options.enums === String ? "TIME" : 0;
                object.duration = 0;
            }
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            if (message.saltKind != null && message.hasOwnProperty("saltKind"))
                object.saltKind = options.enums === String ? $root.api.SessionSaltKind[message.saltKind] : message.saltKind;
            if (message.duration != null && message.hasOwnProperty("duration"))
                object.duration = message.duration;
            return object;
        };

        /**
         * Converts this SessionCreateChallengeRequest to JSON.
         * @function toJSON
         * @memberof api.SessionCreateChallengeRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SessionCreateChallengeRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SessionCreateChallengeRequest;
    })();

    api.SessionCreateChallengeResponse = (function() {

        /**
         * Properties of a SessionCreateChallengeResponse.
         * @memberof api
         * @interface ISessionCreateChallengeResponse
         * @property {Uint8Array|null} [salt] SessionCreateChallengeResponse salt
         * @property {Uint8Array|null} [token] SessionCreateChallengeResponse token
         * @property {api.IIdentityEncryptedKeySet|null} [encryption] SessionCreateChallengeResponse encryption
         * @property {api.SessionSaltKind|null} [saltKind] SessionCreateChallengeResponse saltKind
         */

        /**
         * Constructs a new SessionCreateChallengeResponse.
         * @memberof api
         * @classdesc Represents a SessionCreateChallengeResponse.
         * @implements ISessionCreateChallengeResponse
         * @constructor
         * @param {api.ISessionCreateChallengeResponse=} [properties] Properties to set
         */
        function SessionCreateChallengeResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SessionCreateChallengeResponse salt.
         * @member {Uint8Array} salt
         * @memberof api.SessionCreateChallengeResponse
         * @instance
         */
        SessionCreateChallengeResponse.prototype.salt = $util.newBuffer([]);

        /**
         * SessionCreateChallengeResponse token.
         * @member {Uint8Array} token
         * @memberof api.SessionCreateChallengeResponse
         * @instance
         */
        SessionCreateChallengeResponse.prototype.token = $util.newBuffer([]);

        /**
         * SessionCreateChallengeResponse encryption.
         * @member {api.IIdentityEncryptedKeySet|null|undefined} encryption
         * @memberof api.SessionCreateChallengeResponse
         * @instance
         */
        SessionCreateChallengeResponse.prototype.encryption = null;

        /**
         * SessionCreateChallengeResponse saltKind.
         * @member {api.SessionSaltKind} saltKind
         * @memberof api.SessionCreateChallengeResponse
         * @instance
         */
        SessionCreateChallengeResponse.prototype.saltKind = 0;

        /**
         * Creates a new SessionCreateChallengeResponse instance using the specified properties.
         * @function create
         * @memberof api.SessionCreateChallengeResponse
         * @static
         * @param {api.ISessionCreateChallengeResponse=} [properties] Properties to set
         * @returns {api.SessionCreateChallengeResponse} SessionCreateChallengeResponse instance
         */
        SessionCreateChallengeResponse.create = function create(properties) {
            return new SessionCreateChallengeResponse(properties);
        };

        /**
         * Encodes the specified SessionCreateChallengeResponse message. Does not implicitly {@link api.SessionCreateChallengeResponse.verify|verify} messages.
         * @function encode
         * @memberof api.SessionCreateChallengeResponse
         * @static
         * @param {api.ISessionCreateChallengeResponse} message SessionCreateChallengeResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SessionCreateChallengeResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.salt != null && message.hasOwnProperty("salt"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.salt);
            if (message.token != null && message.hasOwnProperty("token"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.token);
            if (message.encryption != null && message.hasOwnProperty("encryption"))
                $root.api.IdentityEncryptedKeySet.encode(message.encryption, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.saltKind != null && message.hasOwnProperty("saltKind"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.saltKind);
            return writer;
        };

        /**
         * Encodes the specified SessionCreateChallengeResponse message, length delimited. Does not implicitly {@link api.SessionCreateChallengeResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.SessionCreateChallengeResponse
         * @static
         * @param {api.ISessionCreateChallengeResponse} message SessionCreateChallengeResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SessionCreateChallengeResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SessionCreateChallengeResponse message from the specified reader or buffer.
         * @function decode
         * @memberof api.SessionCreateChallengeResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.SessionCreateChallengeResponse} SessionCreateChallengeResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SessionCreateChallengeResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.SessionCreateChallengeResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.salt = reader.bytes();
                    break;
                case 2:
                    message.token = reader.bytes();
                    break;
                case 3:
                    message.encryption = $root.api.IdentityEncryptedKeySet.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.saltKind = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SessionCreateChallengeResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.SessionCreateChallengeResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.SessionCreateChallengeResponse} SessionCreateChallengeResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SessionCreateChallengeResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SessionCreateChallengeResponse message.
         * @function verify
         * @memberof api.SessionCreateChallengeResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SessionCreateChallengeResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.salt != null && message.hasOwnProperty("salt"))
                if (!(message.salt && typeof message.salt.length === "number" || $util.isString(message.salt)))
                    return "salt: buffer expected";
            if (message.token != null && message.hasOwnProperty("token"))
                if (!(message.token && typeof message.token.length === "number" || $util.isString(message.token)))
                    return "token: buffer expected";
            if (message.encryption != null && message.hasOwnProperty("encryption")) {
                var error = $root.api.IdentityEncryptedKeySet.verify(message.encryption);
                if (error)
                    return "encryption." + error;
            }
            if (message.saltKind != null && message.hasOwnProperty("saltKind"))
                switch (message.saltKind) {
                default:
                    return "saltKind: enum value expected";
                case 0:
                case 1:
                    break;
                }
            return null;
        };

        /**
         * Creates a SessionCreateChallengeResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.SessionCreateChallengeResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.SessionCreateChallengeResponse} SessionCreateChallengeResponse
         */
        SessionCreateChallengeResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.api.SessionCreateChallengeResponse)
                return object;
            var message = new $root.api.SessionCreateChallengeResponse();
            if (object.salt != null)
                if (typeof object.salt === "string")
                    $util.base64.decode(object.salt, message.salt = $util.newBuffer($util.base64.length(object.salt)), 0);
                else if (object.salt.length)
                    message.salt = object.salt;
            if (object.token != null)
                if (typeof object.token === "string")
                    $util.base64.decode(object.token, message.token = $util.newBuffer($util.base64.length(object.token)), 0);
                else if (object.token.length)
                    message.token = object.token;
            if (object.encryption != null) {
                if (typeof object.encryption !== "object")
                    throw TypeError(".api.SessionCreateChallengeResponse.encryption: object expected");
                message.encryption = $root.api.IdentityEncryptedKeySet.fromObject(object.encryption);
            }
            switch (object.saltKind) {
            case "TIME":
            case 0:
                message.saltKind = 0;
                break;
            case "RAND":
            case 1:
                message.saltKind = 1;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a SessionCreateChallengeResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.SessionCreateChallengeResponse
         * @static
         * @param {api.SessionCreateChallengeResponse} message SessionCreateChallengeResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SessionCreateChallengeResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.salt = "";
                else {
                    object.salt = [];
                    if (options.bytes !== Array)
                        object.salt = $util.newBuffer(object.salt);
                }
                if (options.bytes === String)
                    object.token = "";
                else {
                    object.token = [];
                    if (options.bytes !== Array)
                        object.token = $util.newBuffer(object.token);
                }
                object.encryption = null;
                object.saltKind = options.enums === String ? "TIME" : 0;
            }
            if (message.salt != null && message.hasOwnProperty("salt"))
                object.salt = options.bytes === String ? $util.base64.encode(message.salt, 0, message.salt.length) : options.bytes === Array ? Array.prototype.slice.call(message.salt) : message.salt;
            if (message.token != null && message.hasOwnProperty("token"))
                object.token = options.bytes === String ? $util.base64.encode(message.token, 0, message.token.length) : options.bytes === Array ? Array.prototype.slice.call(message.token) : message.token;
            if (message.encryption != null && message.hasOwnProperty("encryption"))
                object.encryption = $root.api.IdentityEncryptedKeySet.toObject(message.encryption, options);
            if (message.saltKind != null && message.hasOwnProperty("saltKind"))
                object.saltKind = options.enums === String ? $root.api.SessionSaltKind[message.saltKind] : message.saltKind;
            return object;
        };

        /**
         * Converts this SessionCreateChallengeResponse to JSON.
         * @function toJSON
         * @memberof api.SessionCreateChallengeResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SessionCreateChallengeResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SessionCreateChallengeResponse;
    })();

    api.SessionResolveChallengeRequest = (function() {

        /**
         * Properties of a SessionResolveChallengeRequest.
         * @memberof api
         * @interface ISessionResolveChallengeRequest
         * @property {Uint8Array|null} [token] SessionResolveChallengeRequest token
         * @property {Uint8Array|null} [signature] SessionResolveChallengeRequest signature
         * @property {Uint8Array|null} [salt] SessionResolveChallengeRequest salt
         */

        /**
         * Constructs a new SessionResolveChallengeRequest.
         * @memberof api
         * @classdesc Represents a SessionResolveChallengeRequest.
         * @implements ISessionResolveChallengeRequest
         * @constructor
         * @param {api.ISessionResolveChallengeRequest=} [properties] Properties to set
         */
        function SessionResolveChallengeRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SessionResolveChallengeRequest token.
         * @member {Uint8Array} token
         * @memberof api.SessionResolveChallengeRequest
         * @instance
         */
        SessionResolveChallengeRequest.prototype.token = $util.newBuffer([]);

        /**
         * SessionResolveChallengeRequest signature.
         * @member {Uint8Array} signature
         * @memberof api.SessionResolveChallengeRequest
         * @instance
         */
        SessionResolveChallengeRequest.prototype.signature = $util.newBuffer([]);

        /**
         * SessionResolveChallengeRequest salt.
         * @member {Uint8Array} salt
         * @memberof api.SessionResolveChallengeRequest
         * @instance
         */
        SessionResolveChallengeRequest.prototype.salt = $util.newBuffer([]);

        /**
         * Creates a new SessionResolveChallengeRequest instance using the specified properties.
         * @function create
         * @memberof api.SessionResolveChallengeRequest
         * @static
         * @param {api.ISessionResolveChallengeRequest=} [properties] Properties to set
         * @returns {api.SessionResolveChallengeRequest} SessionResolveChallengeRequest instance
         */
        SessionResolveChallengeRequest.create = function create(properties) {
            return new SessionResolveChallengeRequest(properties);
        };

        /**
         * Encodes the specified SessionResolveChallengeRequest message. Does not implicitly {@link api.SessionResolveChallengeRequest.verify|verify} messages.
         * @function encode
         * @memberof api.SessionResolveChallengeRequest
         * @static
         * @param {api.ISessionResolveChallengeRequest} message SessionResolveChallengeRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SessionResolveChallengeRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.token != null && message.hasOwnProperty("token"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.token);
            if (message.signature != null && message.hasOwnProperty("signature"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.signature);
            if (message.salt != null && message.hasOwnProperty("salt"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.salt);
            return writer;
        };

        /**
         * Encodes the specified SessionResolveChallengeRequest message, length delimited. Does not implicitly {@link api.SessionResolveChallengeRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.SessionResolveChallengeRequest
         * @static
         * @param {api.ISessionResolveChallengeRequest} message SessionResolveChallengeRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SessionResolveChallengeRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SessionResolveChallengeRequest message from the specified reader or buffer.
         * @function decode
         * @memberof api.SessionResolveChallengeRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.SessionResolveChallengeRequest} SessionResolveChallengeRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SessionResolveChallengeRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.SessionResolveChallengeRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.token = reader.bytes();
                    break;
                case 2:
                    message.signature = reader.bytes();
                    break;
                case 3:
                    message.salt = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SessionResolveChallengeRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.SessionResolveChallengeRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.SessionResolveChallengeRequest} SessionResolveChallengeRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SessionResolveChallengeRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SessionResolveChallengeRequest message.
         * @function verify
         * @memberof api.SessionResolveChallengeRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SessionResolveChallengeRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.token != null && message.hasOwnProperty("token"))
                if (!(message.token && typeof message.token.length === "number" || $util.isString(message.token)))
                    return "token: buffer expected";
            if (message.signature != null && message.hasOwnProperty("signature"))
                if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                    return "signature: buffer expected";
            if (message.salt != null && message.hasOwnProperty("salt"))
                if (!(message.salt && typeof message.salt.length === "number" || $util.isString(message.salt)))
                    return "salt: buffer expected";
            return null;
        };

        /**
         * Creates a SessionResolveChallengeRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.SessionResolveChallengeRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.SessionResolveChallengeRequest} SessionResolveChallengeRequest
         */
        SessionResolveChallengeRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.api.SessionResolveChallengeRequest)
                return object;
            var message = new $root.api.SessionResolveChallengeRequest();
            if (object.token != null)
                if (typeof object.token === "string")
                    $util.base64.decode(object.token, message.token = $util.newBuffer($util.base64.length(object.token)), 0);
                else if (object.token.length)
                    message.token = object.token;
            if (object.signature != null)
                if (typeof object.signature === "string")
                    $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                else if (object.signature.length)
                    message.signature = object.signature;
            if (object.salt != null)
                if (typeof object.salt === "string")
                    $util.base64.decode(object.salt, message.salt = $util.newBuffer($util.base64.length(object.salt)), 0);
                else if (object.salt.length)
                    message.salt = object.salt;
            return message;
        };

        /**
         * Creates a plain object from a SessionResolveChallengeRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.SessionResolveChallengeRequest
         * @static
         * @param {api.SessionResolveChallengeRequest} message SessionResolveChallengeRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SessionResolveChallengeRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.token = "";
                else {
                    object.token = [];
                    if (options.bytes !== Array)
                        object.token = $util.newBuffer(object.token);
                }
                if (options.bytes === String)
                    object.signature = "";
                else {
                    object.signature = [];
                    if (options.bytes !== Array)
                        object.signature = $util.newBuffer(object.signature);
                }
                if (options.bytes === String)
                    object.salt = "";
                else {
                    object.salt = [];
                    if (options.bytes !== Array)
                        object.salt = $util.newBuffer(object.salt);
                }
            }
            if (message.token != null && message.hasOwnProperty("token"))
                object.token = options.bytes === String ? $util.base64.encode(message.token, 0, message.token.length) : options.bytes === Array ? Array.prototype.slice.call(message.token) : message.token;
            if (message.signature != null && message.hasOwnProperty("signature"))
                object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
            if (message.salt != null && message.hasOwnProperty("salt"))
                object.salt = options.bytes === String ? $util.base64.encode(message.salt, 0, message.salt.length) : options.bytes === Array ? Array.prototype.slice.call(message.salt) : message.salt;
            return object;
        };

        /**
         * Converts this SessionResolveChallengeRequest to JSON.
         * @function toJSON
         * @memberof api.SessionResolveChallengeRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SessionResolveChallengeRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SessionResolveChallengeRequest;
    })();

    api.SessionResolveChallengeResponse = (function() {

        /**
         * Properties of a SessionResolveChallengeResponse.
         * @memberof api
         * @interface ISessionResolveChallengeResponse
         * @property {Uint8Array|null} [salt] SessionResolveChallengeResponse salt
         * @property {string|null} [login] SessionResolveChallengeResponse login
         */

        /**
         * Constructs a new SessionResolveChallengeResponse.
         * @memberof api
         * @classdesc Represents a SessionResolveChallengeResponse.
         * @implements ISessionResolveChallengeResponse
         * @constructor
         * @param {api.ISessionResolveChallengeResponse=} [properties] Properties to set
         */
        function SessionResolveChallengeResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SessionResolveChallengeResponse salt.
         * @member {Uint8Array} salt
         * @memberof api.SessionResolveChallengeResponse
         * @instance
         */
        SessionResolveChallengeResponse.prototype.salt = $util.newBuffer([]);

        /**
         * SessionResolveChallengeResponse login.
         * @member {string} login
         * @memberof api.SessionResolveChallengeResponse
         * @instance
         */
        SessionResolveChallengeResponse.prototype.login = "";

        /**
         * Creates a new SessionResolveChallengeResponse instance using the specified properties.
         * @function create
         * @memberof api.SessionResolveChallengeResponse
         * @static
         * @param {api.ISessionResolveChallengeResponse=} [properties] Properties to set
         * @returns {api.SessionResolveChallengeResponse} SessionResolveChallengeResponse instance
         */
        SessionResolveChallengeResponse.create = function create(properties) {
            return new SessionResolveChallengeResponse(properties);
        };

        /**
         * Encodes the specified SessionResolveChallengeResponse message. Does not implicitly {@link api.SessionResolveChallengeResponse.verify|verify} messages.
         * @function encode
         * @memberof api.SessionResolveChallengeResponse
         * @static
         * @param {api.ISessionResolveChallengeResponse} message SessionResolveChallengeResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SessionResolveChallengeResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.salt != null && message.hasOwnProperty("salt"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.salt);
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.login);
            return writer;
        };

        /**
         * Encodes the specified SessionResolveChallengeResponse message, length delimited. Does not implicitly {@link api.SessionResolveChallengeResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.SessionResolveChallengeResponse
         * @static
         * @param {api.ISessionResolveChallengeResponse} message SessionResolveChallengeResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SessionResolveChallengeResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SessionResolveChallengeResponse message from the specified reader or buffer.
         * @function decode
         * @memberof api.SessionResolveChallengeResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.SessionResolveChallengeResponse} SessionResolveChallengeResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SessionResolveChallengeResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.SessionResolveChallengeResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.salt = reader.bytes();
                    break;
                case 2:
                    message.login = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SessionResolveChallengeResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.SessionResolveChallengeResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.SessionResolveChallengeResponse} SessionResolveChallengeResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SessionResolveChallengeResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SessionResolveChallengeResponse message.
         * @function verify
         * @memberof api.SessionResolveChallengeResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SessionResolveChallengeResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.salt != null && message.hasOwnProperty("salt"))
                if (!(message.salt && typeof message.salt.length === "number" || $util.isString(message.salt)))
                    return "salt: buffer expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            return null;
        };

        /**
         * Creates a SessionResolveChallengeResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.SessionResolveChallengeResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.SessionResolveChallengeResponse} SessionResolveChallengeResponse
         */
        SessionResolveChallengeResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.api.SessionResolveChallengeResponse)
                return object;
            var message = new $root.api.SessionResolveChallengeResponse();
            if (object.salt != null)
                if (typeof object.salt === "string")
                    $util.base64.decode(object.salt, message.salt = $util.newBuffer($util.base64.length(object.salt)), 0);
                else if (object.salt.length)
                    message.salt = object.salt;
            if (object.login != null)
                message.login = String(object.login);
            return message;
        };

        /**
         * Creates a plain object from a SessionResolveChallengeResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.SessionResolveChallengeResponse
         * @static
         * @param {api.SessionResolveChallengeResponse} message SessionResolveChallengeResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SessionResolveChallengeResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.salt = "";
                else {
                    object.salt = [];
                    if (options.bytes !== Array)
                        object.salt = $util.newBuffer(object.salt);
                }
                object.login = "";
            }
            if (message.salt != null && message.hasOwnProperty("salt"))
                object.salt = options.bytes === String ? $util.base64.encode(message.salt, 0, message.salt.length) : options.bytes === Array ? Array.prototype.slice.call(message.salt) : message.salt;
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            return object;
        };

        /**
         * Converts this SessionResolveChallengeResponse to JSON.
         * @function toJSON
         * @memberof api.SessionResolveChallengeResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SessionResolveChallengeResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SessionResolveChallengeResponse;
    })();

    api.IdentitySession = (function() {

        /**
         * Properties of an IdentitySession.
         * @memberof api
         * @interface IIdentitySession
         * @property {string|null} [owner] IdentitySession owner
         * @property {Uint8Array|null} [token] IdentitySession token
         * @property {number|Long|null} [created] IdentitySession created
         * @property {number|Long|null} [expires] IdentitySession expires
         */

        /**
         * Constructs a new IdentitySession.
         * @memberof api
         * @classdesc Represents an IdentitySession.
         * @implements IIdentitySession
         * @constructor
         * @param {api.IIdentitySession=} [properties] Properties to set
         */
        function IdentitySession(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentitySession owner.
         * @member {string} owner
         * @memberof api.IdentitySession
         * @instance
         */
        IdentitySession.prototype.owner = "";

        /**
         * IdentitySession token.
         * @member {Uint8Array} token
         * @memberof api.IdentitySession
         * @instance
         */
        IdentitySession.prototype.token = $util.newBuffer([]);

        /**
         * IdentitySession created.
         * @member {number|Long} created
         * @memberof api.IdentitySession
         * @instance
         */
        IdentitySession.prototype.created = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * IdentitySession expires.
         * @member {number|Long} expires
         * @memberof api.IdentitySession
         * @instance
         */
        IdentitySession.prototype.expires = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new IdentitySession instance using the specified properties.
         * @function create
         * @memberof api.IdentitySession
         * @static
         * @param {api.IIdentitySession=} [properties] Properties to set
         * @returns {api.IdentitySession} IdentitySession instance
         */
        IdentitySession.create = function create(properties) {
            return new IdentitySession(properties);
        };

        /**
         * Encodes the specified IdentitySession message. Does not implicitly {@link api.IdentitySession.verify|verify} messages.
         * @function encode
         * @memberof api.IdentitySession
         * @static
         * @param {api.IIdentitySession} message IdentitySession message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentitySession.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.owner != null && message.hasOwnProperty("owner"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.owner);
            if (message.token != null && message.hasOwnProperty("token"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.token);
            if (message.created != null && message.hasOwnProperty("created"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.created);
            if (message.expires != null && message.hasOwnProperty("expires"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.expires);
            return writer;
        };

        /**
         * Encodes the specified IdentitySession message, length delimited. Does not implicitly {@link api.IdentitySession.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentitySession
         * @static
         * @param {api.IIdentitySession} message IdentitySession message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentitySession.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentitySession message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentitySession
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentitySession} IdentitySession
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentitySession.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentitySession();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.owner = reader.string();
                    break;
                case 2:
                    message.token = reader.bytes();
                    break;
                case 3:
                    message.created = reader.uint64();
                    break;
                case 4:
                    message.expires = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentitySession message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentitySession
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentitySession} IdentitySession
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentitySession.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentitySession message.
         * @function verify
         * @memberof api.IdentitySession
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentitySession.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.owner != null && message.hasOwnProperty("owner"))
                if (!$util.isString(message.owner))
                    return "owner: string expected";
            if (message.token != null && message.hasOwnProperty("token"))
                if (!(message.token && typeof message.token.length === "number" || $util.isString(message.token)))
                    return "token: buffer expected";
            if (message.created != null && message.hasOwnProperty("created"))
                if (!$util.isInteger(message.created) && !(message.created && $util.isInteger(message.created.low) && $util.isInteger(message.created.high)))
                    return "created: integer|Long expected";
            if (message.expires != null && message.hasOwnProperty("expires"))
                if (!$util.isInteger(message.expires) && !(message.expires && $util.isInteger(message.expires.low) && $util.isInteger(message.expires.high)))
                    return "expires: integer|Long expected";
            return null;
        };

        /**
         * Creates an IdentitySession message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentitySession
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentitySession} IdentitySession
         */
        IdentitySession.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentitySession)
                return object;
            var message = new $root.api.IdentitySession();
            if (object.owner != null)
                message.owner = String(object.owner);
            if (object.token != null)
                if (typeof object.token === "string")
                    $util.base64.decode(object.token, message.token = $util.newBuffer($util.base64.length(object.token)), 0);
                else if (object.token.length)
                    message.token = object.token;
            if (object.created != null)
                if ($util.Long)
                    (message.created = $util.Long.fromValue(object.created)).unsigned = true;
                else if (typeof object.created === "string")
                    message.created = parseInt(object.created, 10);
                else if (typeof object.created === "number")
                    message.created = object.created;
                else if (typeof object.created === "object")
                    message.created = new $util.LongBits(object.created.low >>> 0, object.created.high >>> 0).toNumber(true);
            if (object.expires != null)
                if ($util.Long)
                    (message.expires = $util.Long.fromValue(object.expires)).unsigned = true;
                else if (typeof object.expires === "string")
                    message.expires = parseInt(object.expires, 10);
                else if (typeof object.expires === "number")
                    message.expires = object.expires;
                else if (typeof object.expires === "object")
                    message.expires = new $util.LongBits(object.expires.low >>> 0, object.expires.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from an IdentitySession message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentitySession
         * @static
         * @param {api.IdentitySession} message IdentitySession
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentitySession.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.owner = "";
                if (options.bytes === String)
                    object.token = "";
                else {
                    object.token = [];
                    if (options.bytes !== Array)
                        object.token = $util.newBuffer(object.token);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.created = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.created = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.expires = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.expires = options.longs === String ? "0" : 0;
            }
            if (message.owner != null && message.hasOwnProperty("owner"))
                object.owner = message.owner;
            if (message.token != null && message.hasOwnProperty("token"))
                object.token = options.bytes === String ? $util.base64.encode(message.token, 0, message.token.length) : options.bytes === Array ? Array.prototype.slice.call(message.token) : message.token;
            if (message.created != null && message.hasOwnProperty("created"))
                if (typeof message.created === "number")
                    object.created = options.longs === String ? String(message.created) : message.created;
                else
                    object.created = options.longs === String ? $util.Long.prototype.toString.call(message.created) : options.longs === Number ? new $util.LongBits(message.created.low >>> 0, message.created.high >>> 0).toNumber(true) : message.created;
            if (message.expires != null && message.hasOwnProperty("expires"))
                if (typeof message.expires === "number")
                    object.expires = options.longs === String ? String(message.expires) : message.expires;
                else
                    object.expires = options.longs === String ? $util.Long.prototype.toString.call(message.expires) : options.longs === Number ? new $util.LongBits(message.expires.low >>> 0, message.expires.high >>> 0).toNumber(true) : message.expires;
            return object;
        };

        /**
         * Converts this IdentitySession to JSON.
         * @function toJSON
         * @memberof api.IdentitySession
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentitySession.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentitySession;
    })();

    api.ApplicationIdentitySessionListRequest = (function() {

        /**
         * Properties of an ApplicationIdentitySessionListRequest.
         * @memberof api
         * @interface IApplicationIdentitySessionListRequest
         * @property {string|null} [appID] ApplicationIdentitySessionListRequest appID
         * @property {number|Long|null} [since] ApplicationIdentitySessionListRequest since
         * @property {number|null} [offset] ApplicationIdentitySessionListRequest offset
         * @property {number|null} [limit] ApplicationIdentitySessionListRequest limit
         */

        /**
         * Constructs a new ApplicationIdentitySessionListRequest.
         * @memberof api
         * @classdesc Represents an ApplicationIdentitySessionListRequest.
         * @implements IApplicationIdentitySessionListRequest
         * @constructor
         * @param {api.IApplicationIdentitySessionListRequest=} [properties] Properties to set
         */
        function ApplicationIdentitySessionListRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ApplicationIdentitySessionListRequest appID.
         * @member {string} appID
         * @memberof api.ApplicationIdentitySessionListRequest
         * @instance
         */
        ApplicationIdentitySessionListRequest.prototype.appID = "";

        /**
         * ApplicationIdentitySessionListRequest since.
         * @member {number|Long} since
         * @memberof api.ApplicationIdentitySessionListRequest
         * @instance
         */
        ApplicationIdentitySessionListRequest.prototype.since = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ApplicationIdentitySessionListRequest offset.
         * @member {number} offset
         * @memberof api.ApplicationIdentitySessionListRequest
         * @instance
         */
        ApplicationIdentitySessionListRequest.prototype.offset = 0;

        /**
         * ApplicationIdentitySessionListRequest limit.
         * @member {number} limit
         * @memberof api.ApplicationIdentitySessionListRequest
         * @instance
         */
        ApplicationIdentitySessionListRequest.prototype.limit = 0;

        /**
         * Creates a new ApplicationIdentitySessionListRequest instance using the specified properties.
         * @function create
         * @memberof api.ApplicationIdentitySessionListRequest
         * @static
         * @param {api.IApplicationIdentitySessionListRequest=} [properties] Properties to set
         * @returns {api.ApplicationIdentitySessionListRequest} ApplicationIdentitySessionListRequest instance
         */
        ApplicationIdentitySessionListRequest.create = function create(properties) {
            return new ApplicationIdentitySessionListRequest(properties);
        };

        /**
         * Encodes the specified ApplicationIdentitySessionListRequest message. Does not implicitly {@link api.ApplicationIdentitySessionListRequest.verify|verify} messages.
         * @function encode
         * @memberof api.ApplicationIdentitySessionListRequest
         * @static
         * @param {api.IApplicationIdentitySessionListRequest} message ApplicationIdentitySessionListRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApplicationIdentitySessionListRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.appID != null && message.hasOwnProperty("appID"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.appID);
            if (message.since != null && message.hasOwnProperty("since"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.since);
            if (message.offset != null && message.hasOwnProperty("offset"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.offset);
            if (message.limit != null && message.hasOwnProperty("limit"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.limit);
            return writer;
        };

        /**
         * Encodes the specified ApplicationIdentitySessionListRequest message, length delimited. Does not implicitly {@link api.ApplicationIdentitySessionListRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.ApplicationIdentitySessionListRequest
         * @static
         * @param {api.IApplicationIdentitySessionListRequest} message ApplicationIdentitySessionListRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApplicationIdentitySessionListRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ApplicationIdentitySessionListRequest message from the specified reader or buffer.
         * @function decode
         * @memberof api.ApplicationIdentitySessionListRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.ApplicationIdentitySessionListRequest} ApplicationIdentitySessionListRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApplicationIdentitySessionListRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ApplicationIdentitySessionListRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.appID = reader.string();
                    break;
                case 2:
                    message.since = reader.uint64();
                    break;
                case 3:
                    message.offset = reader.uint32();
                    break;
                case 4:
                    message.limit = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ApplicationIdentitySessionListRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.ApplicationIdentitySessionListRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.ApplicationIdentitySessionListRequest} ApplicationIdentitySessionListRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApplicationIdentitySessionListRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ApplicationIdentitySessionListRequest message.
         * @function verify
         * @memberof api.ApplicationIdentitySessionListRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ApplicationIdentitySessionListRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.appID != null && message.hasOwnProperty("appID"))
                if (!$util.isString(message.appID))
                    return "appID: string expected";
            if (message.since != null && message.hasOwnProperty("since"))
                if (!$util.isInteger(message.since) && !(message.since && $util.isInteger(message.since.low) && $util.isInteger(message.since.high)))
                    return "since: integer|Long expected";
            if (message.offset != null && message.hasOwnProperty("offset"))
                if (!$util.isInteger(message.offset))
                    return "offset: integer expected";
            if (message.limit != null && message.hasOwnProperty("limit"))
                if (!$util.isInteger(message.limit))
                    return "limit: integer expected";
            return null;
        };

        /**
         * Creates an ApplicationIdentitySessionListRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.ApplicationIdentitySessionListRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.ApplicationIdentitySessionListRequest} ApplicationIdentitySessionListRequest
         */
        ApplicationIdentitySessionListRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.api.ApplicationIdentitySessionListRequest)
                return object;
            var message = new $root.api.ApplicationIdentitySessionListRequest();
            if (object.appID != null)
                message.appID = String(object.appID);
            if (object.since != null)
                if ($util.Long)
                    (message.since = $util.Long.fromValue(object.since)).unsigned = true;
                else if (typeof object.since === "string")
                    message.since = parseInt(object.since, 10);
                else if (typeof object.since === "number")
                    message.since = object.since;
                else if (typeof object.since === "object")
                    message.since = new $util.LongBits(object.since.low >>> 0, object.since.high >>> 0).toNumber(true);
            if (object.offset != null)
                message.offset = object.offset >>> 0;
            if (object.limit != null)
                message.limit = object.limit >>> 0;
            return message;
        };

        /**
         * Creates a plain object from an ApplicationIdentitySessionListRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.ApplicationIdentitySessionListRequest
         * @static
         * @param {api.ApplicationIdentitySessionListRequest} message ApplicationIdentitySessionListRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ApplicationIdentitySessionListRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.appID = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.since = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.since = options.longs === String ? "0" : 0;
                object.offset = 0;
                object.limit = 0;
            }
            if (message.appID != null && message.hasOwnProperty("appID"))
                object.appID = message.appID;
            if (message.since != null && message.hasOwnProperty("since"))
                if (typeof message.since === "number")
                    object.since = options.longs === String ? String(message.since) : message.since;
                else
                    object.since = options.longs === String ? $util.Long.prototype.toString.call(message.since) : options.longs === Number ? new $util.LongBits(message.since.low >>> 0, message.since.high >>> 0).toNumber(true) : message.since;
            if (message.offset != null && message.hasOwnProperty("offset"))
                object.offset = message.offset;
            if (message.limit != null && message.hasOwnProperty("limit"))
                object.limit = message.limit;
            return object;
        };

        /**
         * Converts this ApplicationIdentitySessionListRequest to JSON.
         * @function toJSON
         * @memberof api.ApplicationIdentitySessionListRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ApplicationIdentitySessionListRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ApplicationIdentitySessionListRequest;
    })();

    api.ApplicationIdentitySessionListResponse = (function() {

        /**
         * Properties of an ApplicationIdentitySessionListResponse.
         * @memberof api
         * @interface IApplicationIdentitySessionListResponse
         * @property {Array.<api.IIdentitySession>|null} [sessions] ApplicationIdentitySessionListResponse sessions
         */

        /**
         * Constructs a new ApplicationIdentitySessionListResponse.
         * @memberof api
         * @classdesc Represents an ApplicationIdentitySessionListResponse.
         * @implements IApplicationIdentitySessionListResponse
         * @constructor
         * @param {api.IApplicationIdentitySessionListResponse=} [properties] Properties to set
         */
        function ApplicationIdentitySessionListResponse(properties) {
            this.sessions = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ApplicationIdentitySessionListResponse sessions.
         * @member {Array.<api.IIdentitySession>} sessions
         * @memberof api.ApplicationIdentitySessionListResponse
         * @instance
         */
        ApplicationIdentitySessionListResponse.prototype.sessions = $util.emptyArray;

        /**
         * Creates a new ApplicationIdentitySessionListResponse instance using the specified properties.
         * @function create
         * @memberof api.ApplicationIdentitySessionListResponse
         * @static
         * @param {api.IApplicationIdentitySessionListResponse=} [properties] Properties to set
         * @returns {api.ApplicationIdentitySessionListResponse} ApplicationIdentitySessionListResponse instance
         */
        ApplicationIdentitySessionListResponse.create = function create(properties) {
            return new ApplicationIdentitySessionListResponse(properties);
        };

        /**
         * Encodes the specified ApplicationIdentitySessionListResponse message. Does not implicitly {@link api.ApplicationIdentitySessionListResponse.verify|verify} messages.
         * @function encode
         * @memberof api.ApplicationIdentitySessionListResponse
         * @static
         * @param {api.IApplicationIdentitySessionListResponse} message ApplicationIdentitySessionListResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApplicationIdentitySessionListResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.sessions != null && message.sessions.length)
                for (var i = 0; i < message.sessions.length; ++i)
                    $root.api.IdentitySession.encode(message.sessions[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ApplicationIdentitySessionListResponse message, length delimited. Does not implicitly {@link api.ApplicationIdentitySessionListResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.ApplicationIdentitySessionListResponse
         * @static
         * @param {api.IApplicationIdentitySessionListResponse} message ApplicationIdentitySessionListResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApplicationIdentitySessionListResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ApplicationIdentitySessionListResponse message from the specified reader or buffer.
         * @function decode
         * @memberof api.ApplicationIdentitySessionListResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.ApplicationIdentitySessionListResponse} ApplicationIdentitySessionListResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApplicationIdentitySessionListResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ApplicationIdentitySessionListResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.sessions && message.sessions.length))
                        message.sessions = [];
                    message.sessions.push($root.api.IdentitySession.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ApplicationIdentitySessionListResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.ApplicationIdentitySessionListResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.ApplicationIdentitySessionListResponse} ApplicationIdentitySessionListResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApplicationIdentitySessionListResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ApplicationIdentitySessionListResponse message.
         * @function verify
         * @memberof api.ApplicationIdentitySessionListResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ApplicationIdentitySessionListResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.sessions != null && message.hasOwnProperty("sessions")) {
                if (!Array.isArray(message.sessions))
                    return "sessions: array expected";
                for (var i = 0; i < message.sessions.length; ++i) {
                    var error = $root.api.IdentitySession.verify(message.sessions[i]);
                    if (error)
                        return "sessions." + error;
                }
            }
            return null;
        };

        /**
         * Creates an ApplicationIdentitySessionListResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.ApplicationIdentitySessionListResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.ApplicationIdentitySessionListResponse} ApplicationIdentitySessionListResponse
         */
        ApplicationIdentitySessionListResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.api.ApplicationIdentitySessionListResponse)
                return object;
            var message = new $root.api.ApplicationIdentitySessionListResponse();
            if (object.sessions) {
                if (!Array.isArray(object.sessions))
                    throw TypeError(".api.ApplicationIdentitySessionListResponse.sessions: array expected");
                message.sessions = [];
                for (var i = 0; i < object.sessions.length; ++i) {
                    if (typeof object.sessions[i] !== "object")
                        throw TypeError(".api.ApplicationIdentitySessionListResponse.sessions: object expected");
                    message.sessions[i] = $root.api.IdentitySession.fromObject(object.sessions[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an ApplicationIdentitySessionListResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.ApplicationIdentitySessionListResponse
         * @static
         * @param {api.ApplicationIdentitySessionListResponse} message ApplicationIdentitySessionListResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ApplicationIdentitySessionListResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.sessions = [];
            if (message.sessions && message.sessions.length) {
                object.sessions = [];
                for (var j = 0; j < message.sessions.length; ++j)
                    object.sessions[j] = $root.api.IdentitySession.toObject(message.sessions[j], options);
            }
            return object;
        };

        /**
         * Converts this ApplicationIdentitySessionListResponse to JSON.
         * @function toJSON
         * @memberof api.ApplicationIdentitySessionListResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ApplicationIdentitySessionListResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ApplicationIdentitySessionListResponse;
    })();

    /**
     * JwtAlgorithm enum.
     * @name api.JwtAlgorithm
     * @enum {string}
     * @property {number} HS256=0 HS256 value
     * @property {number} HS384=1 HS384 value
     * @property {number} HS512=2 HS512 value
     * @property {number} RS256=3 RS256 value
     * @property {number} RS384=4 RS384 value
     * @property {number} RS512=5 RS512 value
     * @property {number} ES256=6 ES256 value
     * @property {number} ES384=7 ES384 value
     * @property {number} ES512=8 ES512 value
     */
    api.JwtAlgorithm = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "HS256"] = 0;
        values[valuesById[1] = "HS384"] = 1;
        values[valuesById[2] = "HS512"] = 2;
        values[valuesById[3] = "RS256"] = 3;
        values[valuesById[4] = "RS384"] = 4;
        values[valuesById[5] = "RS512"] = 5;
        values[valuesById[6] = "ES256"] = 6;
        values[valuesById[7] = "ES384"] = 7;
        values[valuesById[8] = "ES512"] = 8;
        return values;
    })();

    api.IdentityConfigurationAsApplication = (function() {

        /**
         * Properties of an IdentityConfigurationAsApplication.
         * @memberof api
         * @interface IIdentityConfigurationAsApplication
         * @property {api.IdentityConfigurationAsApplication.IJWT|null} [jwt] IdentityConfigurationAsApplication jwt
         */

        /**
         * Constructs a new IdentityConfigurationAsApplication.
         * @memberof api
         * @classdesc Represents an IdentityConfigurationAsApplication.
         * @implements IIdentityConfigurationAsApplication
         * @constructor
         * @param {api.IIdentityConfigurationAsApplication=} [properties] Properties to set
         */
        function IdentityConfigurationAsApplication(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityConfigurationAsApplication jwt.
         * @member {api.IdentityConfigurationAsApplication.IJWT|null|undefined} jwt
         * @memberof api.IdentityConfigurationAsApplication
         * @instance
         */
        IdentityConfigurationAsApplication.prototype.jwt = null;

        /**
         * Creates a new IdentityConfigurationAsApplication instance using the specified properties.
         * @function create
         * @memberof api.IdentityConfigurationAsApplication
         * @static
         * @param {api.IIdentityConfigurationAsApplication=} [properties] Properties to set
         * @returns {api.IdentityConfigurationAsApplication} IdentityConfigurationAsApplication instance
         */
        IdentityConfigurationAsApplication.create = function create(properties) {
            return new IdentityConfigurationAsApplication(properties);
        };

        /**
         * Encodes the specified IdentityConfigurationAsApplication message. Does not implicitly {@link api.IdentityConfigurationAsApplication.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityConfigurationAsApplication
         * @static
         * @param {api.IIdentityConfigurationAsApplication} message IdentityConfigurationAsApplication message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityConfigurationAsApplication.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.jwt != null && message.hasOwnProperty("jwt"))
                $root.api.IdentityConfigurationAsApplication.JWT.encode(message.jwt, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IdentityConfigurationAsApplication message, length delimited. Does not implicitly {@link api.IdentityConfigurationAsApplication.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityConfigurationAsApplication
         * @static
         * @param {api.IIdentityConfigurationAsApplication} message IdentityConfigurationAsApplication message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityConfigurationAsApplication.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityConfigurationAsApplication message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityConfigurationAsApplication
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityConfigurationAsApplication} IdentityConfigurationAsApplication
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityConfigurationAsApplication.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityConfigurationAsApplication();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.jwt = $root.api.IdentityConfigurationAsApplication.JWT.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityConfigurationAsApplication message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityConfigurationAsApplication
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityConfigurationAsApplication} IdentityConfigurationAsApplication
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityConfigurationAsApplication.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityConfigurationAsApplication message.
         * @function verify
         * @memberof api.IdentityConfigurationAsApplication
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityConfigurationAsApplication.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.jwt != null && message.hasOwnProperty("jwt")) {
                var error = $root.api.IdentityConfigurationAsApplication.JWT.verify(message.jwt);
                if (error)
                    return "jwt." + error;
            }
            return null;
        };

        /**
         * Creates an IdentityConfigurationAsApplication message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityConfigurationAsApplication
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityConfigurationAsApplication} IdentityConfigurationAsApplication
         */
        IdentityConfigurationAsApplication.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityConfigurationAsApplication)
                return object;
            var message = new $root.api.IdentityConfigurationAsApplication();
            if (object.jwt != null) {
                if (typeof object.jwt !== "object")
                    throw TypeError(".api.IdentityConfigurationAsApplication.jwt: object expected");
                message.jwt = $root.api.IdentityConfigurationAsApplication.JWT.fromObject(object.jwt);
            }
            return message;
        };

        /**
         * Creates a plain object from an IdentityConfigurationAsApplication message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityConfigurationAsApplication
         * @static
         * @param {api.IdentityConfigurationAsApplication} message IdentityConfigurationAsApplication
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityConfigurationAsApplication.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.jwt = null;
            if (message.jwt != null && message.hasOwnProperty("jwt"))
                object.jwt = $root.api.IdentityConfigurationAsApplication.JWT.toObject(message.jwt, options);
            return object;
        };

        /**
         * Converts this IdentityConfigurationAsApplication to JSON.
         * @function toJSON
         * @memberof api.IdentityConfigurationAsApplication
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityConfigurationAsApplication.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        IdentityConfigurationAsApplication.JWT = (function() {

            /**
             * Properties of a JWT.
             * @memberof api.IdentityConfigurationAsApplication
             * @interface IJWT
             * @property {Uint8Array|null} [key] JWT key
             * @property {api.JwtAlgorithm|null} [signAlgorithm] JWT signAlgorithm
             * @property {string|null} [claimForLogin] JWT claimForLogin
             */

            /**
             * Constructs a new JWT.
             * @memberof api.IdentityConfigurationAsApplication
             * @classdesc Represents a JWT.
             * @implements IJWT
             * @constructor
             * @param {api.IdentityConfigurationAsApplication.IJWT=} [properties] Properties to set
             */
            function JWT(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * JWT key.
             * @member {Uint8Array} key
             * @memberof api.IdentityConfigurationAsApplication.JWT
             * @instance
             */
            JWT.prototype.key = $util.newBuffer([]);

            /**
             * JWT signAlgorithm.
             * @member {api.JwtAlgorithm} signAlgorithm
             * @memberof api.IdentityConfigurationAsApplication.JWT
             * @instance
             */
            JWT.prototype.signAlgorithm = 0;

            /**
             * JWT claimForLogin.
             * @member {string} claimForLogin
             * @memberof api.IdentityConfigurationAsApplication.JWT
             * @instance
             */
            JWT.prototype.claimForLogin = "";

            /**
             * Creates a new JWT instance using the specified properties.
             * @function create
             * @memberof api.IdentityConfigurationAsApplication.JWT
             * @static
             * @param {api.IdentityConfigurationAsApplication.IJWT=} [properties] Properties to set
             * @returns {api.IdentityConfigurationAsApplication.JWT} JWT instance
             */
            JWT.create = function create(properties) {
                return new JWT(properties);
            };

            /**
             * Encodes the specified JWT message. Does not implicitly {@link api.IdentityConfigurationAsApplication.JWT.verify|verify} messages.
             * @function encode
             * @memberof api.IdentityConfigurationAsApplication.JWT
             * @static
             * @param {api.IdentityConfigurationAsApplication.IJWT} message JWT message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            JWT.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.key != null && message.hasOwnProperty("key"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.key);
                if (message.signAlgorithm != null && message.hasOwnProperty("signAlgorithm"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.signAlgorithm);
                if (message.claimForLogin != null && message.hasOwnProperty("claimForLogin"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.claimForLogin);
                return writer;
            };

            /**
             * Encodes the specified JWT message, length delimited. Does not implicitly {@link api.IdentityConfigurationAsApplication.JWT.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.IdentityConfigurationAsApplication.JWT
             * @static
             * @param {api.IdentityConfigurationAsApplication.IJWT} message JWT message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            JWT.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a JWT message from the specified reader or buffer.
             * @function decode
             * @memberof api.IdentityConfigurationAsApplication.JWT
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.IdentityConfigurationAsApplication.JWT} JWT
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            JWT.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityConfigurationAsApplication.JWT();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.key = reader.bytes();
                        break;
                    case 2:
                        message.signAlgorithm = reader.int32();
                        break;
                    case 3:
                        message.claimForLogin = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a JWT message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.IdentityConfigurationAsApplication.JWT
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.IdentityConfigurationAsApplication.JWT} JWT
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            JWT.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a JWT message.
             * @function verify
             * @memberof api.IdentityConfigurationAsApplication.JWT
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            JWT.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
                        return "key: buffer expected";
                if (message.signAlgorithm != null && message.hasOwnProperty("signAlgorithm"))
                    switch (message.signAlgorithm) {
                    default:
                        return "signAlgorithm: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                        break;
                    }
                if (message.claimForLogin != null && message.hasOwnProperty("claimForLogin"))
                    if (!$util.isString(message.claimForLogin))
                        return "claimForLogin: string expected";
                return null;
            };

            /**
             * Creates a JWT message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.IdentityConfigurationAsApplication.JWT
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.IdentityConfigurationAsApplication.JWT} JWT
             */
            JWT.fromObject = function fromObject(object) {
                if (object instanceof $root.api.IdentityConfigurationAsApplication.JWT)
                    return object;
                var message = new $root.api.IdentityConfigurationAsApplication.JWT();
                if (object.key != null)
                    if (typeof object.key === "string")
                        $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
                    else if (object.key.length)
                        message.key = object.key;
                switch (object.signAlgorithm) {
                case "HS256":
                case 0:
                    message.signAlgorithm = 0;
                    break;
                case "HS384":
                case 1:
                    message.signAlgorithm = 1;
                    break;
                case "HS512":
                case 2:
                    message.signAlgorithm = 2;
                    break;
                case "RS256":
                case 3:
                    message.signAlgorithm = 3;
                    break;
                case "RS384":
                case 4:
                    message.signAlgorithm = 4;
                    break;
                case "RS512":
                case 5:
                    message.signAlgorithm = 5;
                    break;
                case "ES256":
                case 6:
                    message.signAlgorithm = 6;
                    break;
                case "ES384":
                case 7:
                    message.signAlgorithm = 7;
                    break;
                case "ES512":
                case 8:
                    message.signAlgorithm = 8;
                    break;
                }
                if (object.claimForLogin != null)
                    message.claimForLogin = String(object.claimForLogin);
                return message;
            };

            /**
             * Creates a plain object from a JWT message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.IdentityConfigurationAsApplication.JWT
             * @static
             * @param {api.IdentityConfigurationAsApplication.JWT} message JWT
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            JWT.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.key = "";
                    else {
                        object.key = [];
                        if (options.bytes !== Array)
                            object.key = $util.newBuffer(object.key);
                    }
                    object.signAlgorithm = options.enums === String ? "HS256" : 0;
                    object.claimForLogin = "";
                }
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
                if (message.signAlgorithm != null && message.hasOwnProperty("signAlgorithm"))
                    object.signAlgorithm = options.enums === String ? $root.api.JwtAlgorithm[message.signAlgorithm] : message.signAlgorithm;
                if (message.claimForLogin != null && message.hasOwnProperty("claimForLogin"))
                    object.claimForLogin = message.claimForLogin;
                return object;
            };

            /**
             * Converts this JWT to JSON.
             * @function toJSON
             * @memberof api.IdentityConfigurationAsApplication.JWT
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            JWT.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return JWT;
        })();

        return IdentityConfigurationAsApplication;
    })();

    api.ApplicationConfigID = (function() {

        /**
         * Properties of an ApplicationConfigID.
         * @memberof api
         * @interface IApplicationConfigID
         * @property {string|null} [appID] ApplicationConfigID appID
         * @property {number|null} [version] ApplicationConfigID version
         */

        /**
         * Constructs a new ApplicationConfigID.
         * @memberof api
         * @classdesc Represents an ApplicationConfigID.
         * @implements IApplicationConfigID
         * @constructor
         * @param {api.IApplicationConfigID=} [properties] Properties to set
         */
        function ApplicationConfigID(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ApplicationConfigID appID.
         * @member {string} appID
         * @memberof api.ApplicationConfigID
         * @instance
         */
        ApplicationConfigID.prototype.appID = "";

        /**
         * ApplicationConfigID version.
         * @member {number} version
         * @memberof api.ApplicationConfigID
         * @instance
         */
        ApplicationConfigID.prototype.version = 0;

        /**
         * Creates a new ApplicationConfigID instance using the specified properties.
         * @function create
         * @memberof api.ApplicationConfigID
         * @static
         * @param {api.IApplicationConfigID=} [properties] Properties to set
         * @returns {api.ApplicationConfigID} ApplicationConfigID instance
         */
        ApplicationConfigID.create = function create(properties) {
            return new ApplicationConfigID(properties);
        };

        /**
         * Encodes the specified ApplicationConfigID message. Does not implicitly {@link api.ApplicationConfigID.verify|verify} messages.
         * @function encode
         * @memberof api.ApplicationConfigID
         * @static
         * @param {api.IApplicationConfigID} message ApplicationConfigID message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApplicationConfigID.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.appID != null && message.hasOwnProperty("appID"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.appID);
            if (message.version != null && message.hasOwnProperty("version"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.version);
            return writer;
        };

        /**
         * Encodes the specified ApplicationConfigID message, length delimited. Does not implicitly {@link api.ApplicationConfigID.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.ApplicationConfigID
         * @static
         * @param {api.IApplicationConfigID} message ApplicationConfigID message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApplicationConfigID.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ApplicationConfigID message from the specified reader or buffer.
         * @function decode
         * @memberof api.ApplicationConfigID
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.ApplicationConfigID} ApplicationConfigID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApplicationConfigID.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ApplicationConfigID();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.appID = reader.string();
                    break;
                case 2:
                    message.version = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ApplicationConfigID message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.ApplicationConfigID
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.ApplicationConfigID} ApplicationConfigID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApplicationConfigID.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ApplicationConfigID message.
         * @function verify
         * @memberof api.ApplicationConfigID
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ApplicationConfigID.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.appID != null && message.hasOwnProperty("appID"))
                if (!$util.isString(message.appID))
                    return "appID: string expected";
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isInteger(message.version))
                    return "version: integer expected";
            return null;
        };

        /**
         * Creates an ApplicationConfigID message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.ApplicationConfigID
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.ApplicationConfigID} ApplicationConfigID
         */
        ApplicationConfigID.fromObject = function fromObject(object) {
            if (object instanceof $root.api.ApplicationConfigID)
                return object;
            var message = new $root.api.ApplicationConfigID();
            if (object.appID != null)
                message.appID = String(object.appID);
            if (object.version != null)
                message.version = object.version >>> 0;
            return message;
        };

        /**
         * Creates a plain object from an ApplicationConfigID message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.ApplicationConfigID
         * @static
         * @param {api.ApplicationConfigID} message ApplicationConfigID
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ApplicationConfigID.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.appID = "";
                object.version = 0;
            }
            if (message.appID != null && message.hasOwnProperty("appID"))
                object.appID = message.appID;
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            return object;
        };

        /**
         * Converts this ApplicationConfigID to JSON.
         * @function toJSON
         * @memberof api.ApplicationConfigID
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ApplicationConfigID.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ApplicationConfigID;
    })();

    api.IdentityConfigurationAsApplicationMetadata = (function() {

        /**
         * Properties of an IdentityConfigurationAsApplicationMetadata.
         * @memberof api
         * @interface IIdentityConfigurationAsApplicationMetadata
         * @property {api.IApplicationConfigID|null} [configID] IdentityConfigurationAsApplicationMetadata configID
         * @property {api.IIdentityKeyID|null} [creator] IdentityConfigurationAsApplicationMetadata creator
         * @property {number|Long|null} [created] IdentityConfigurationAsApplicationMetadata created
         */

        /**
         * Constructs a new IdentityConfigurationAsApplicationMetadata.
         * @memberof api
         * @classdesc Represents an IdentityConfigurationAsApplicationMetadata.
         * @implements IIdentityConfigurationAsApplicationMetadata
         * @constructor
         * @param {api.IIdentityConfigurationAsApplicationMetadata=} [properties] Properties to set
         */
        function IdentityConfigurationAsApplicationMetadata(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityConfigurationAsApplicationMetadata configID.
         * @member {api.IApplicationConfigID|null|undefined} configID
         * @memberof api.IdentityConfigurationAsApplicationMetadata
         * @instance
         */
        IdentityConfigurationAsApplicationMetadata.prototype.configID = null;

        /**
         * IdentityConfigurationAsApplicationMetadata creator.
         * @member {api.IIdentityKeyID|null|undefined} creator
         * @memberof api.IdentityConfigurationAsApplicationMetadata
         * @instance
         */
        IdentityConfigurationAsApplicationMetadata.prototype.creator = null;

        /**
         * IdentityConfigurationAsApplicationMetadata created.
         * @member {number|Long} created
         * @memberof api.IdentityConfigurationAsApplicationMetadata
         * @instance
         */
        IdentityConfigurationAsApplicationMetadata.prototype.created = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new IdentityConfigurationAsApplicationMetadata instance using the specified properties.
         * @function create
         * @memberof api.IdentityConfigurationAsApplicationMetadata
         * @static
         * @param {api.IIdentityConfigurationAsApplicationMetadata=} [properties] Properties to set
         * @returns {api.IdentityConfigurationAsApplicationMetadata} IdentityConfigurationAsApplicationMetadata instance
         */
        IdentityConfigurationAsApplicationMetadata.create = function create(properties) {
            return new IdentityConfigurationAsApplicationMetadata(properties);
        };

        /**
         * Encodes the specified IdentityConfigurationAsApplicationMetadata message. Does not implicitly {@link api.IdentityConfigurationAsApplicationMetadata.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityConfigurationAsApplicationMetadata
         * @static
         * @param {api.IIdentityConfigurationAsApplicationMetadata} message IdentityConfigurationAsApplicationMetadata message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityConfigurationAsApplicationMetadata.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.configID != null && message.hasOwnProperty("configID"))
                $root.api.ApplicationConfigID.encode(message.configID, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.creator != null && message.hasOwnProperty("creator"))
                $root.api.IdentityKeyID.encode(message.creator, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.created != null && message.hasOwnProperty("created"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.created);
            return writer;
        };

        /**
         * Encodes the specified IdentityConfigurationAsApplicationMetadata message, length delimited. Does not implicitly {@link api.IdentityConfigurationAsApplicationMetadata.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityConfigurationAsApplicationMetadata
         * @static
         * @param {api.IIdentityConfigurationAsApplicationMetadata} message IdentityConfigurationAsApplicationMetadata message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityConfigurationAsApplicationMetadata.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityConfigurationAsApplicationMetadata message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityConfigurationAsApplicationMetadata
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityConfigurationAsApplicationMetadata} IdentityConfigurationAsApplicationMetadata
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityConfigurationAsApplicationMetadata.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityConfigurationAsApplicationMetadata();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.configID = $root.api.ApplicationConfigID.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.creator = $root.api.IdentityKeyID.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.created = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityConfigurationAsApplicationMetadata message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityConfigurationAsApplicationMetadata
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityConfigurationAsApplicationMetadata} IdentityConfigurationAsApplicationMetadata
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityConfigurationAsApplicationMetadata.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityConfigurationAsApplicationMetadata message.
         * @function verify
         * @memberof api.IdentityConfigurationAsApplicationMetadata
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityConfigurationAsApplicationMetadata.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.configID != null && message.hasOwnProperty("configID")) {
                var error = $root.api.ApplicationConfigID.verify(message.configID);
                if (error)
                    return "configID." + error;
            }
            if (message.creator != null && message.hasOwnProperty("creator")) {
                var error = $root.api.IdentityKeyID.verify(message.creator);
                if (error)
                    return "creator." + error;
            }
            if (message.created != null && message.hasOwnProperty("created"))
                if (!$util.isInteger(message.created) && !(message.created && $util.isInteger(message.created.low) && $util.isInteger(message.created.high)))
                    return "created: integer|Long expected";
            return null;
        };

        /**
         * Creates an IdentityConfigurationAsApplicationMetadata message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityConfigurationAsApplicationMetadata
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityConfigurationAsApplicationMetadata} IdentityConfigurationAsApplicationMetadata
         */
        IdentityConfigurationAsApplicationMetadata.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityConfigurationAsApplicationMetadata)
                return object;
            var message = new $root.api.IdentityConfigurationAsApplicationMetadata();
            if (object.configID != null) {
                if (typeof object.configID !== "object")
                    throw TypeError(".api.IdentityConfigurationAsApplicationMetadata.configID: object expected");
                message.configID = $root.api.ApplicationConfigID.fromObject(object.configID);
            }
            if (object.creator != null) {
                if (typeof object.creator !== "object")
                    throw TypeError(".api.IdentityConfigurationAsApplicationMetadata.creator: object expected");
                message.creator = $root.api.IdentityKeyID.fromObject(object.creator);
            }
            if (object.created != null)
                if ($util.Long)
                    (message.created = $util.Long.fromValue(object.created)).unsigned = false;
                else if (typeof object.created === "string")
                    message.created = parseInt(object.created, 10);
                else if (typeof object.created === "number")
                    message.created = object.created;
                else if (typeof object.created === "object")
                    message.created = new $util.LongBits(object.created.low >>> 0, object.created.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an IdentityConfigurationAsApplicationMetadata message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityConfigurationAsApplicationMetadata
         * @static
         * @param {api.IdentityConfigurationAsApplicationMetadata} message IdentityConfigurationAsApplicationMetadata
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityConfigurationAsApplicationMetadata.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.configID = null;
                object.creator = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.created = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.created = options.longs === String ? "0" : 0;
            }
            if (message.configID != null && message.hasOwnProperty("configID"))
                object.configID = $root.api.ApplicationConfigID.toObject(message.configID, options);
            if (message.creator != null && message.hasOwnProperty("creator"))
                object.creator = $root.api.IdentityKeyID.toObject(message.creator, options);
            if (message.created != null && message.hasOwnProperty("created"))
                if (typeof message.created === "number")
                    object.created = options.longs === String ? String(message.created) : message.created;
                else
                    object.created = options.longs === String ? $util.Long.prototype.toString.call(message.created) : options.longs === Number ? new $util.LongBits(message.created.low >>> 0, message.created.high >>> 0).toNumber() : message.created;
            return object;
        };

        /**
         * Converts this IdentityConfigurationAsApplicationMetadata to JSON.
         * @function toJSON
         * @memberof api.IdentityConfigurationAsApplicationMetadata
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityConfigurationAsApplicationMetadata.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityConfigurationAsApplicationMetadata;
    })();

    api.IdentityConfigurationAsApplicationRequest = (function() {

        /**
         * Properties of an IdentityConfigurationAsApplicationRequest.
         * @memberof api
         * @interface IIdentityConfigurationAsApplicationRequest
         * @property {string|null} [login] IdentityConfigurationAsApplicationRequest login
         * @property {api.IIdentityConfigurationAsApplication|null} [config] IdentityConfigurationAsApplicationRequest config
         * @property {number|null} [customerID] IdentityConfigurationAsApplicationRequest customerID
         */

        /**
         * Constructs a new IdentityConfigurationAsApplicationRequest.
         * @memberof api
         * @classdesc Represents an IdentityConfigurationAsApplicationRequest.
         * @implements IIdentityConfigurationAsApplicationRequest
         * @constructor
         * @param {api.IIdentityConfigurationAsApplicationRequest=} [properties] Properties to set
         */
        function IdentityConfigurationAsApplicationRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityConfigurationAsApplicationRequest login.
         * @member {string} login
         * @memberof api.IdentityConfigurationAsApplicationRequest
         * @instance
         */
        IdentityConfigurationAsApplicationRequest.prototype.login = "";

        /**
         * IdentityConfigurationAsApplicationRequest config.
         * @member {api.IIdentityConfigurationAsApplication|null|undefined} config
         * @memberof api.IdentityConfigurationAsApplicationRequest
         * @instance
         */
        IdentityConfigurationAsApplicationRequest.prototype.config = null;

        /**
         * IdentityConfigurationAsApplicationRequest customerID.
         * @member {number} customerID
         * @memberof api.IdentityConfigurationAsApplicationRequest
         * @instance
         */
        IdentityConfigurationAsApplicationRequest.prototype.customerID = 0;

        /**
         * Creates a new IdentityConfigurationAsApplicationRequest instance using the specified properties.
         * @function create
         * @memberof api.IdentityConfigurationAsApplicationRequest
         * @static
         * @param {api.IIdentityConfigurationAsApplicationRequest=} [properties] Properties to set
         * @returns {api.IdentityConfigurationAsApplicationRequest} IdentityConfigurationAsApplicationRequest instance
         */
        IdentityConfigurationAsApplicationRequest.create = function create(properties) {
            return new IdentityConfigurationAsApplicationRequest(properties);
        };

        /**
         * Encodes the specified IdentityConfigurationAsApplicationRequest message. Does not implicitly {@link api.IdentityConfigurationAsApplicationRequest.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityConfigurationAsApplicationRequest
         * @static
         * @param {api.IIdentityConfigurationAsApplicationRequest} message IdentityConfigurationAsApplicationRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityConfigurationAsApplicationRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            if (message.config != null && message.hasOwnProperty("config"))
                $root.api.IdentityConfigurationAsApplication.encode(message.config, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.customerID != null && message.hasOwnProperty("customerID"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.customerID);
            return writer;
        };

        /**
         * Encodes the specified IdentityConfigurationAsApplicationRequest message, length delimited. Does not implicitly {@link api.IdentityConfigurationAsApplicationRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityConfigurationAsApplicationRequest
         * @static
         * @param {api.IIdentityConfigurationAsApplicationRequest} message IdentityConfigurationAsApplicationRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityConfigurationAsApplicationRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityConfigurationAsApplicationRequest message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityConfigurationAsApplicationRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityConfigurationAsApplicationRequest} IdentityConfigurationAsApplicationRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityConfigurationAsApplicationRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityConfigurationAsApplicationRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                case 2:
                    message.config = $root.api.IdentityConfigurationAsApplication.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.customerID = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityConfigurationAsApplicationRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityConfigurationAsApplicationRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityConfigurationAsApplicationRequest} IdentityConfigurationAsApplicationRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityConfigurationAsApplicationRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityConfigurationAsApplicationRequest message.
         * @function verify
         * @memberof api.IdentityConfigurationAsApplicationRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityConfigurationAsApplicationRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            if (message.config != null && message.hasOwnProperty("config")) {
                var error = $root.api.IdentityConfigurationAsApplication.verify(message.config);
                if (error)
                    return "config." + error;
            }
            if (message.customerID != null && message.hasOwnProperty("customerID"))
                if (!$util.isInteger(message.customerID))
                    return "customerID: integer expected";
            return null;
        };

        /**
         * Creates an IdentityConfigurationAsApplicationRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityConfigurationAsApplicationRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityConfigurationAsApplicationRequest} IdentityConfigurationAsApplicationRequest
         */
        IdentityConfigurationAsApplicationRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityConfigurationAsApplicationRequest)
                return object;
            var message = new $root.api.IdentityConfigurationAsApplicationRequest();
            if (object.login != null)
                message.login = String(object.login);
            if (object.config != null) {
                if (typeof object.config !== "object")
                    throw TypeError(".api.IdentityConfigurationAsApplicationRequest.config: object expected");
                message.config = $root.api.IdentityConfigurationAsApplication.fromObject(object.config);
            }
            if (object.customerID != null)
                message.customerID = object.customerID >>> 0;
            return message;
        };

        /**
         * Creates a plain object from an IdentityConfigurationAsApplicationRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityConfigurationAsApplicationRequest
         * @static
         * @param {api.IdentityConfigurationAsApplicationRequest} message IdentityConfigurationAsApplicationRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityConfigurationAsApplicationRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.login = "";
                object.config = null;
                object.customerID = 0;
            }
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            if (message.config != null && message.hasOwnProperty("config"))
                object.config = $root.api.IdentityConfigurationAsApplication.toObject(message.config, options);
            if (message.customerID != null && message.hasOwnProperty("customerID"))
                object.customerID = message.customerID;
            return object;
        };

        /**
         * Converts this IdentityConfigurationAsApplicationRequest to JSON.
         * @function toJSON
         * @memberof api.IdentityConfigurationAsApplicationRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityConfigurationAsApplicationRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityConfigurationAsApplicationRequest;
    })();

    api.IdentityGetConfigurationResponse = (function() {

        /**
         * Properties of an IdentityGetConfigurationResponse.
         * @memberof api
         * @interface IIdentityGetConfigurationResponse
         * @property {api.IIdentityConfigurationAsApplication|null} [config] IdentityGetConfigurationResponse config
         * @property {api.IIdentityConfigurationAsApplicationMetadata|null} [metadata] IdentityGetConfigurationResponse metadata
         */

        /**
         * Constructs a new IdentityGetConfigurationResponse.
         * @memberof api
         * @classdesc Represents an IdentityGetConfigurationResponse.
         * @implements IIdentityGetConfigurationResponse
         * @constructor
         * @param {api.IIdentityGetConfigurationResponse=} [properties] Properties to set
         */
        function IdentityGetConfigurationResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityGetConfigurationResponse config.
         * @member {api.IIdentityConfigurationAsApplication|null|undefined} config
         * @memberof api.IdentityGetConfigurationResponse
         * @instance
         */
        IdentityGetConfigurationResponse.prototype.config = null;

        /**
         * IdentityGetConfigurationResponse metadata.
         * @member {api.IIdentityConfigurationAsApplicationMetadata|null|undefined} metadata
         * @memberof api.IdentityGetConfigurationResponse
         * @instance
         */
        IdentityGetConfigurationResponse.prototype.metadata = null;

        /**
         * Creates a new IdentityGetConfigurationResponse instance using the specified properties.
         * @function create
         * @memberof api.IdentityGetConfigurationResponse
         * @static
         * @param {api.IIdentityGetConfigurationResponse=} [properties] Properties to set
         * @returns {api.IdentityGetConfigurationResponse} IdentityGetConfigurationResponse instance
         */
        IdentityGetConfigurationResponse.create = function create(properties) {
            return new IdentityGetConfigurationResponse(properties);
        };

        /**
         * Encodes the specified IdentityGetConfigurationResponse message. Does not implicitly {@link api.IdentityGetConfigurationResponse.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityGetConfigurationResponse
         * @static
         * @param {api.IIdentityGetConfigurationResponse} message IdentityGetConfigurationResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetConfigurationResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.config != null && message.hasOwnProperty("config"))
                $root.api.IdentityConfigurationAsApplication.encode(message.config, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.api.IdentityConfigurationAsApplicationMetadata.encode(message.metadata, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IdentityGetConfigurationResponse message, length delimited. Does not implicitly {@link api.IdentityGetConfigurationResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityGetConfigurationResponse
         * @static
         * @param {api.IIdentityGetConfigurationResponse} message IdentityGetConfigurationResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityGetConfigurationResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityGetConfigurationResponse message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityGetConfigurationResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityGetConfigurationResponse} IdentityGetConfigurationResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetConfigurationResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityGetConfigurationResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.config = $root.api.IdentityConfigurationAsApplication.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.metadata = $root.api.IdentityConfigurationAsApplicationMetadata.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityGetConfigurationResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityGetConfigurationResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityGetConfigurationResponse} IdentityGetConfigurationResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityGetConfigurationResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityGetConfigurationResponse message.
         * @function verify
         * @memberof api.IdentityGetConfigurationResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityGetConfigurationResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.config != null && message.hasOwnProperty("config")) {
                var error = $root.api.IdentityConfigurationAsApplication.verify(message.config);
                if (error)
                    return "config." + error;
            }
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.api.IdentityConfigurationAsApplicationMetadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            return null;
        };

        /**
         * Creates an IdentityGetConfigurationResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityGetConfigurationResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityGetConfigurationResponse} IdentityGetConfigurationResponse
         */
        IdentityGetConfigurationResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityGetConfigurationResponse)
                return object;
            var message = new $root.api.IdentityGetConfigurationResponse();
            if (object.config != null) {
                if (typeof object.config !== "object")
                    throw TypeError(".api.IdentityGetConfigurationResponse.config: object expected");
                message.config = $root.api.IdentityConfigurationAsApplication.fromObject(object.config);
            }
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".api.IdentityGetConfigurationResponse.metadata: object expected");
                message.metadata = $root.api.IdentityConfigurationAsApplicationMetadata.fromObject(object.metadata);
            }
            return message;
        };

        /**
         * Creates a plain object from an IdentityGetConfigurationResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityGetConfigurationResponse
         * @static
         * @param {api.IdentityGetConfigurationResponse} message IdentityGetConfigurationResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityGetConfigurationResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.config = null;
                object.metadata = null;
            }
            if (message.config != null && message.hasOwnProperty("config"))
                object.config = $root.api.IdentityConfigurationAsApplication.toObject(message.config, options);
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.api.IdentityConfigurationAsApplicationMetadata.toObject(message.metadata, options);
            return object;
        };

        /**
         * Converts this IdentityGetConfigurationResponse to JSON.
         * @function toJSON
         * @memberof api.IdentityGetConfigurationResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityGetConfigurationResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityGetConfigurationResponse;
    })();

    api.ApplicationUsageOverview = (function() {

        /**
         * Properties of an ApplicationUsageOverview.
         * @memberof api
         * @interface IApplicationUsageOverview
         * @property {api.ApplicationUsageOverview.IJWT|null} [jwt] ApplicationUsageOverview jwt
         * @property {api.ApplicationUsageOverview.IDelegatedAccess|null} [delegates] ApplicationUsageOverview delegates
         * @property {number|null} [start] ApplicationUsageOverview start
         */

        /**
         * Constructs a new ApplicationUsageOverview.
         * @memberof api
         * @classdesc Represents an ApplicationUsageOverview.
         * @implements IApplicationUsageOverview
         * @constructor
         * @param {api.IApplicationUsageOverview=} [properties] Properties to set
         */
        function ApplicationUsageOverview(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ApplicationUsageOverview jwt.
         * @member {api.ApplicationUsageOverview.IJWT|null|undefined} jwt
         * @memberof api.ApplicationUsageOverview
         * @instance
         */
        ApplicationUsageOverview.prototype.jwt = null;

        /**
         * ApplicationUsageOverview delegates.
         * @member {api.ApplicationUsageOverview.IDelegatedAccess|null|undefined} delegates
         * @memberof api.ApplicationUsageOverview
         * @instance
         */
        ApplicationUsageOverview.prototype.delegates = null;

        /**
         * ApplicationUsageOverview start.
         * @member {number} start
         * @memberof api.ApplicationUsageOverview
         * @instance
         */
        ApplicationUsageOverview.prototype.start = 0;

        /**
         * Creates a new ApplicationUsageOverview instance using the specified properties.
         * @function create
         * @memberof api.ApplicationUsageOverview
         * @static
         * @param {api.IApplicationUsageOverview=} [properties] Properties to set
         * @returns {api.ApplicationUsageOverview} ApplicationUsageOverview instance
         */
        ApplicationUsageOverview.create = function create(properties) {
            return new ApplicationUsageOverview(properties);
        };

        /**
         * Encodes the specified ApplicationUsageOverview message. Does not implicitly {@link api.ApplicationUsageOverview.verify|verify} messages.
         * @function encode
         * @memberof api.ApplicationUsageOverview
         * @static
         * @param {api.IApplicationUsageOverview} message ApplicationUsageOverview message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApplicationUsageOverview.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.jwt != null && message.hasOwnProperty("jwt"))
                $root.api.ApplicationUsageOverview.JWT.encode(message.jwt, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.delegates != null && message.hasOwnProperty("delegates"))
                $root.api.ApplicationUsageOverview.DelegatedAccess.encode(message.delegates, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.start != null && message.hasOwnProperty("start"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.start);
            return writer;
        };

        /**
         * Encodes the specified ApplicationUsageOverview message, length delimited. Does not implicitly {@link api.ApplicationUsageOverview.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.ApplicationUsageOverview
         * @static
         * @param {api.IApplicationUsageOverview} message ApplicationUsageOverview message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApplicationUsageOverview.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ApplicationUsageOverview message from the specified reader or buffer.
         * @function decode
         * @memberof api.ApplicationUsageOverview
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.ApplicationUsageOverview} ApplicationUsageOverview
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApplicationUsageOverview.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ApplicationUsageOverview();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.jwt = $root.api.ApplicationUsageOverview.JWT.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.delegates = $root.api.ApplicationUsageOverview.DelegatedAccess.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.start = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ApplicationUsageOverview message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.ApplicationUsageOverview
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.ApplicationUsageOverview} ApplicationUsageOverview
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApplicationUsageOverview.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ApplicationUsageOverview message.
         * @function verify
         * @memberof api.ApplicationUsageOverview
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ApplicationUsageOverview.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.jwt != null && message.hasOwnProperty("jwt")) {
                var error = $root.api.ApplicationUsageOverview.JWT.verify(message.jwt);
                if (error)
                    return "jwt." + error;
            }
            if (message.delegates != null && message.hasOwnProperty("delegates")) {
                var error = $root.api.ApplicationUsageOverview.DelegatedAccess.verify(message.delegates);
                if (error)
                    return "delegates." + error;
            }
            if (message.start != null && message.hasOwnProperty("start"))
                if (!$util.isInteger(message.start))
                    return "start: integer expected";
            return null;
        };

        /**
         * Creates an ApplicationUsageOverview message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.ApplicationUsageOverview
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.ApplicationUsageOverview} ApplicationUsageOverview
         */
        ApplicationUsageOverview.fromObject = function fromObject(object) {
            if (object instanceof $root.api.ApplicationUsageOverview)
                return object;
            var message = new $root.api.ApplicationUsageOverview();
            if (object.jwt != null) {
                if (typeof object.jwt !== "object")
                    throw TypeError(".api.ApplicationUsageOverview.jwt: object expected");
                message.jwt = $root.api.ApplicationUsageOverview.JWT.fromObject(object.jwt);
            }
            if (object.delegates != null) {
                if (typeof object.delegates !== "object")
                    throw TypeError(".api.ApplicationUsageOverview.delegates: object expected");
                message.delegates = $root.api.ApplicationUsageOverview.DelegatedAccess.fromObject(object.delegates);
            }
            if (object.start != null)
                message.start = object.start >>> 0;
            return message;
        };

        /**
         * Creates a plain object from an ApplicationUsageOverview message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.ApplicationUsageOverview
         * @static
         * @param {api.ApplicationUsageOverview} message ApplicationUsageOverview
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ApplicationUsageOverview.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.jwt = null;
                object.delegates = null;
                object.start = 0;
            }
            if (message.jwt != null && message.hasOwnProperty("jwt"))
                object.jwt = $root.api.ApplicationUsageOverview.JWT.toObject(message.jwt, options);
            if (message.delegates != null && message.hasOwnProperty("delegates"))
                object.delegates = $root.api.ApplicationUsageOverview.DelegatedAccess.toObject(message.delegates, options);
            if (message.start != null && message.hasOwnProperty("start"))
                object.start = message.start;
            return object;
        };

        /**
         * Converts this ApplicationUsageOverview to JSON.
         * @function toJSON
         * @memberof api.ApplicationUsageOverview
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ApplicationUsageOverview.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        ApplicationUsageOverview.JWT = (function() {

            /**
             * Properties of a JWT.
             * @memberof api.ApplicationUsageOverview
             * @interface IJWT
             * @property {number|null} [identities] JWT identities
             * @property {number|null} [sessions] JWT sessions
             */

            /**
             * Constructs a new JWT.
             * @memberof api.ApplicationUsageOverview
             * @classdesc Represents a JWT.
             * @implements IJWT
             * @constructor
             * @param {api.ApplicationUsageOverview.IJWT=} [properties] Properties to set
             */
            function JWT(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * JWT identities.
             * @member {number} identities
             * @memberof api.ApplicationUsageOverview.JWT
             * @instance
             */
            JWT.prototype.identities = 0;

            /**
             * JWT sessions.
             * @member {number} sessions
             * @memberof api.ApplicationUsageOverview.JWT
             * @instance
             */
            JWT.prototype.sessions = 0;

            /**
             * Creates a new JWT instance using the specified properties.
             * @function create
             * @memberof api.ApplicationUsageOverview.JWT
             * @static
             * @param {api.ApplicationUsageOverview.IJWT=} [properties] Properties to set
             * @returns {api.ApplicationUsageOverview.JWT} JWT instance
             */
            JWT.create = function create(properties) {
                return new JWT(properties);
            };

            /**
             * Encodes the specified JWT message. Does not implicitly {@link api.ApplicationUsageOverview.JWT.verify|verify} messages.
             * @function encode
             * @memberof api.ApplicationUsageOverview.JWT
             * @static
             * @param {api.ApplicationUsageOverview.IJWT} message JWT message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            JWT.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.identities != null && message.hasOwnProperty("identities"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.identities);
                if (message.sessions != null && message.hasOwnProperty("sessions"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.sessions);
                return writer;
            };

            /**
             * Encodes the specified JWT message, length delimited. Does not implicitly {@link api.ApplicationUsageOverview.JWT.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.ApplicationUsageOverview.JWT
             * @static
             * @param {api.ApplicationUsageOverview.IJWT} message JWT message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            JWT.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a JWT message from the specified reader or buffer.
             * @function decode
             * @memberof api.ApplicationUsageOverview.JWT
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.ApplicationUsageOverview.JWT} JWT
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            JWT.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ApplicationUsageOverview.JWT();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.identities = reader.uint32();
                        break;
                    case 2:
                        message.sessions = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a JWT message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.ApplicationUsageOverview.JWT
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.ApplicationUsageOverview.JWT} JWT
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            JWT.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a JWT message.
             * @function verify
             * @memberof api.ApplicationUsageOverview.JWT
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            JWT.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.identities != null && message.hasOwnProperty("identities"))
                    if (!$util.isInteger(message.identities))
                        return "identities: integer expected";
                if (message.sessions != null && message.hasOwnProperty("sessions"))
                    if (!$util.isInteger(message.sessions))
                        return "sessions: integer expected";
                return null;
            };

            /**
             * Creates a JWT message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.ApplicationUsageOverview.JWT
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.ApplicationUsageOverview.JWT} JWT
             */
            JWT.fromObject = function fromObject(object) {
                if (object instanceof $root.api.ApplicationUsageOverview.JWT)
                    return object;
                var message = new $root.api.ApplicationUsageOverview.JWT();
                if (object.identities != null)
                    message.identities = object.identities >>> 0;
                if (object.sessions != null)
                    message.sessions = object.sessions >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a JWT message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.ApplicationUsageOverview.JWT
             * @static
             * @param {api.ApplicationUsageOverview.JWT} message JWT
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            JWT.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.identities = 0;
                    object.sessions = 0;
                }
                if (message.identities != null && message.hasOwnProperty("identities"))
                    object.identities = message.identities;
                if (message.sessions != null && message.hasOwnProperty("sessions"))
                    object.sessions = message.sessions;
                return object;
            };

            /**
             * Converts this JWT to JSON.
             * @function toJSON
             * @memberof api.ApplicationUsageOverview.JWT
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            JWT.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return JWT;
        })();

        ApplicationUsageOverview.DelegatedAccess = (function() {

            /**
             * Properties of a DelegatedAccess.
             * @memberof api.ApplicationUsageOverview
             * @interface IDelegatedAccess
             * @property {number|null} [requested] DelegatedAccess requested
             * @property {number|null} [resolved] DelegatedAccess resolved
             * @property {number|null} [distinctRequested] DelegatedAccess distinctRequested
             * @property {number|null} [distinctResolved] DelegatedAccess distinctResolved
             */

            /**
             * Constructs a new DelegatedAccess.
             * @memberof api.ApplicationUsageOverview
             * @classdesc Represents a DelegatedAccess.
             * @implements IDelegatedAccess
             * @constructor
             * @param {api.ApplicationUsageOverview.IDelegatedAccess=} [properties] Properties to set
             */
            function DelegatedAccess(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DelegatedAccess requested.
             * @member {number} requested
             * @memberof api.ApplicationUsageOverview.DelegatedAccess
             * @instance
             */
            DelegatedAccess.prototype.requested = 0;

            /**
             * DelegatedAccess resolved.
             * @member {number} resolved
             * @memberof api.ApplicationUsageOverview.DelegatedAccess
             * @instance
             */
            DelegatedAccess.prototype.resolved = 0;

            /**
             * DelegatedAccess distinctRequested.
             * @member {number} distinctRequested
             * @memberof api.ApplicationUsageOverview.DelegatedAccess
             * @instance
             */
            DelegatedAccess.prototype.distinctRequested = 0;

            /**
             * DelegatedAccess distinctResolved.
             * @member {number} distinctResolved
             * @memberof api.ApplicationUsageOverview.DelegatedAccess
             * @instance
             */
            DelegatedAccess.prototype.distinctResolved = 0;

            /**
             * Creates a new DelegatedAccess instance using the specified properties.
             * @function create
             * @memberof api.ApplicationUsageOverview.DelegatedAccess
             * @static
             * @param {api.ApplicationUsageOverview.IDelegatedAccess=} [properties] Properties to set
             * @returns {api.ApplicationUsageOverview.DelegatedAccess} DelegatedAccess instance
             */
            DelegatedAccess.create = function create(properties) {
                return new DelegatedAccess(properties);
            };

            /**
             * Encodes the specified DelegatedAccess message. Does not implicitly {@link api.ApplicationUsageOverview.DelegatedAccess.verify|verify} messages.
             * @function encode
             * @memberof api.ApplicationUsageOverview.DelegatedAccess
             * @static
             * @param {api.ApplicationUsageOverview.IDelegatedAccess} message DelegatedAccess message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DelegatedAccess.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.requested != null && message.hasOwnProperty("requested"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.requested);
                if (message.resolved != null && message.hasOwnProperty("resolved"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.resolved);
                if (message.distinctRequested != null && message.hasOwnProperty("distinctRequested"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.distinctRequested);
                if (message.distinctResolved != null && message.hasOwnProperty("distinctResolved"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.distinctResolved);
                return writer;
            };

            /**
             * Encodes the specified DelegatedAccess message, length delimited. Does not implicitly {@link api.ApplicationUsageOverview.DelegatedAccess.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.ApplicationUsageOverview.DelegatedAccess
             * @static
             * @param {api.ApplicationUsageOverview.IDelegatedAccess} message DelegatedAccess message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DelegatedAccess.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DelegatedAccess message from the specified reader or buffer.
             * @function decode
             * @memberof api.ApplicationUsageOverview.DelegatedAccess
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.ApplicationUsageOverview.DelegatedAccess} DelegatedAccess
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DelegatedAccess.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ApplicationUsageOverview.DelegatedAccess();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.requested = reader.uint32();
                        break;
                    case 2:
                        message.resolved = reader.uint32();
                        break;
                    case 3:
                        message.distinctRequested = reader.uint32();
                        break;
                    case 4:
                        message.distinctResolved = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DelegatedAccess message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.ApplicationUsageOverview.DelegatedAccess
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.ApplicationUsageOverview.DelegatedAccess} DelegatedAccess
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DelegatedAccess.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DelegatedAccess message.
             * @function verify
             * @memberof api.ApplicationUsageOverview.DelegatedAccess
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DelegatedAccess.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.requested != null && message.hasOwnProperty("requested"))
                    if (!$util.isInteger(message.requested))
                        return "requested: integer expected";
                if (message.resolved != null && message.hasOwnProperty("resolved"))
                    if (!$util.isInteger(message.resolved))
                        return "resolved: integer expected";
                if (message.distinctRequested != null && message.hasOwnProperty("distinctRequested"))
                    if (!$util.isInteger(message.distinctRequested))
                        return "distinctRequested: integer expected";
                if (message.distinctResolved != null && message.hasOwnProperty("distinctResolved"))
                    if (!$util.isInteger(message.distinctResolved))
                        return "distinctResolved: integer expected";
                return null;
            };

            /**
             * Creates a DelegatedAccess message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.ApplicationUsageOverview.DelegatedAccess
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.ApplicationUsageOverview.DelegatedAccess} DelegatedAccess
             */
            DelegatedAccess.fromObject = function fromObject(object) {
                if (object instanceof $root.api.ApplicationUsageOverview.DelegatedAccess)
                    return object;
                var message = new $root.api.ApplicationUsageOverview.DelegatedAccess();
                if (object.requested != null)
                    message.requested = object.requested >>> 0;
                if (object.resolved != null)
                    message.resolved = object.resolved >>> 0;
                if (object.distinctRequested != null)
                    message.distinctRequested = object.distinctRequested >>> 0;
                if (object.distinctResolved != null)
                    message.distinctResolved = object.distinctResolved >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a DelegatedAccess message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.ApplicationUsageOverview.DelegatedAccess
             * @static
             * @param {api.ApplicationUsageOverview.DelegatedAccess} message DelegatedAccess
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DelegatedAccess.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.requested = 0;
                    object.resolved = 0;
                    object.distinctRequested = 0;
                    object.distinctResolved = 0;
                }
                if (message.requested != null && message.hasOwnProperty("requested"))
                    object.requested = message.requested;
                if (message.resolved != null && message.hasOwnProperty("resolved"))
                    object.resolved = message.resolved;
                if (message.distinctRequested != null && message.hasOwnProperty("distinctRequested"))
                    object.distinctRequested = message.distinctRequested;
                if (message.distinctResolved != null && message.hasOwnProperty("distinctResolved"))
                    object.distinctResolved = message.distinctResolved;
                return object;
            };

            /**
             * Converts this DelegatedAccess to JSON.
             * @function toJSON
             * @memberof api.ApplicationUsageOverview.DelegatedAccess
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DelegatedAccess.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DelegatedAccess;
        })();

        return ApplicationUsageOverview;
    })();

    /**
     * Period enum.
     * @name api.Period
     * @enum {string}
     * @property {number} DAY=0 DAY value
     * @property {number} MONTH=1 MONTH value
     * @property {number} YEAR=2 YEAR value
     */
    api.Period = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DAY"] = 0;
        values[valuesById[1] = "MONTH"] = 1;
        values[valuesById[2] = "YEAR"] = 2;
        return values;
    })();

    api.ApplicationUsageOverviewRequest = (function() {

        /**
         * Properties of an ApplicationUsageOverviewRequest.
         * @memberof api
         * @interface IApplicationUsageOverviewRequest
         * @property {string|null} [login] ApplicationUsageOverviewRequest login
         * @property {number|null} [from] ApplicationUsageOverviewRequest from
         * @property {number|null} [to] ApplicationUsageOverviewRequest to
         * @property {api.Period|null} [by] ApplicationUsageOverviewRequest by
         */

        /**
         * Constructs a new ApplicationUsageOverviewRequest.
         * @memberof api
         * @classdesc Represents an ApplicationUsageOverviewRequest.
         * @implements IApplicationUsageOverviewRequest
         * @constructor
         * @param {api.IApplicationUsageOverviewRequest=} [properties] Properties to set
         */
        function ApplicationUsageOverviewRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ApplicationUsageOverviewRequest login.
         * @member {string} login
         * @memberof api.ApplicationUsageOverviewRequest
         * @instance
         */
        ApplicationUsageOverviewRequest.prototype.login = "";

        /**
         * ApplicationUsageOverviewRequest from.
         * @member {number} from
         * @memberof api.ApplicationUsageOverviewRequest
         * @instance
         */
        ApplicationUsageOverviewRequest.prototype.from = 0;

        /**
         * ApplicationUsageOverviewRequest to.
         * @member {number} to
         * @memberof api.ApplicationUsageOverviewRequest
         * @instance
         */
        ApplicationUsageOverviewRequest.prototype.to = 0;

        /**
         * ApplicationUsageOverviewRequest by.
         * @member {api.Period} by
         * @memberof api.ApplicationUsageOverviewRequest
         * @instance
         */
        ApplicationUsageOverviewRequest.prototype.by = 0;

        /**
         * Creates a new ApplicationUsageOverviewRequest instance using the specified properties.
         * @function create
         * @memberof api.ApplicationUsageOverviewRequest
         * @static
         * @param {api.IApplicationUsageOverviewRequest=} [properties] Properties to set
         * @returns {api.ApplicationUsageOverviewRequest} ApplicationUsageOverviewRequest instance
         */
        ApplicationUsageOverviewRequest.create = function create(properties) {
            return new ApplicationUsageOverviewRequest(properties);
        };

        /**
         * Encodes the specified ApplicationUsageOverviewRequest message. Does not implicitly {@link api.ApplicationUsageOverviewRequest.verify|verify} messages.
         * @function encode
         * @memberof api.ApplicationUsageOverviewRequest
         * @static
         * @param {api.IApplicationUsageOverviewRequest} message ApplicationUsageOverviewRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApplicationUsageOverviewRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            if (message.from != null && message.hasOwnProperty("from"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.from);
            if (message.to != null && message.hasOwnProperty("to"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.to);
            if (message.by != null && message.hasOwnProperty("by"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.by);
            return writer;
        };

        /**
         * Encodes the specified ApplicationUsageOverviewRequest message, length delimited. Does not implicitly {@link api.ApplicationUsageOverviewRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.ApplicationUsageOverviewRequest
         * @static
         * @param {api.IApplicationUsageOverviewRequest} message ApplicationUsageOverviewRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApplicationUsageOverviewRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ApplicationUsageOverviewRequest message from the specified reader or buffer.
         * @function decode
         * @memberof api.ApplicationUsageOverviewRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.ApplicationUsageOverviewRequest} ApplicationUsageOverviewRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApplicationUsageOverviewRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ApplicationUsageOverviewRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                case 2:
                    message.from = reader.uint32();
                    break;
                case 3:
                    message.to = reader.uint32();
                    break;
                case 4:
                    message.by = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ApplicationUsageOverviewRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.ApplicationUsageOverviewRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.ApplicationUsageOverviewRequest} ApplicationUsageOverviewRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApplicationUsageOverviewRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ApplicationUsageOverviewRequest message.
         * @function verify
         * @memberof api.ApplicationUsageOverviewRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ApplicationUsageOverviewRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            if (message.from != null && message.hasOwnProperty("from"))
                if (!$util.isInteger(message.from))
                    return "from: integer expected";
            if (message.to != null && message.hasOwnProperty("to"))
                if (!$util.isInteger(message.to))
                    return "to: integer expected";
            if (message.by != null && message.hasOwnProperty("by"))
                switch (message.by) {
                default:
                    return "by: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            return null;
        };

        /**
         * Creates an ApplicationUsageOverviewRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.ApplicationUsageOverviewRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.ApplicationUsageOverviewRequest} ApplicationUsageOverviewRequest
         */
        ApplicationUsageOverviewRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.api.ApplicationUsageOverviewRequest)
                return object;
            var message = new $root.api.ApplicationUsageOverviewRequest();
            if (object.login != null)
                message.login = String(object.login);
            if (object.from != null)
                message.from = object.from >>> 0;
            if (object.to != null)
                message.to = object.to >>> 0;
            switch (object.by) {
            case "DAY":
            case 0:
                message.by = 0;
                break;
            case "MONTH":
            case 1:
                message.by = 1;
                break;
            case "YEAR":
            case 2:
                message.by = 2;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from an ApplicationUsageOverviewRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.ApplicationUsageOverviewRequest
         * @static
         * @param {api.ApplicationUsageOverviewRequest} message ApplicationUsageOverviewRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ApplicationUsageOverviewRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.login = "";
                object.from = 0;
                object.to = 0;
                object.by = options.enums === String ? "DAY" : 0;
            }
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            if (message.from != null && message.hasOwnProperty("from"))
                object.from = message.from;
            if (message.to != null && message.hasOwnProperty("to"))
                object.to = message.to;
            if (message.by != null && message.hasOwnProperty("by"))
                object.by = options.enums === String ? $root.api.Period[message.by] : message.by;
            return object;
        };

        /**
         * Converts this ApplicationUsageOverviewRequest to JSON.
         * @function toJSON
         * @memberof api.ApplicationUsageOverviewRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ApplicationUsageOverviewRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ApplicationUsageOverviewRequest;
    })();

    api.ApplicationUsageOverviewResponse = (function() {

        /**
         * Properties of an ApplicationUsageOverviewResponse.
         * @memberof api
         * @interface IApplicationUsageOverviewResponse
         * @property {Array.<api.IApplicationUsageOverview>|null} [overview] ApplicationUsageOverviewResponse overview
         */

        /**
         * Constructs a new ApplicationUsageOverviewResponse.
         * @memberof api
         * @classdesc Represents an ApplicationUsageOverviewResponse.
         * @implements IApplicationUsageOverviewResponse
         * @constructor
         * @param {api.IApplicationUsageOverviewResponse=} [properties] Properties to set
         */
        function ApplicationUsageOverviewResponse(properties) {
            this.overview = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ApplicationUsageOverviewResponse overview.
         * @member {Array.<api.IApplicationUsageOverview>} overview
         * @memberof api.ApplicationUsageOverviewResponse
         * @instance
         */
        ApplicationUsageOverviewResponse.prototype.overview = $util.emptyArray;

        /**
         * Creates a new ApplicationUsageOverviewResponse instance using the specified properties.
         * @function create
         * @memberof api.ApplicationUsageOverviewResponse
         * @static
         * @param {api.IApplicationUsageOverviewResponse=} [properties] Properties to set
         * @returns {api.ApplicationUsageOverviewResponse} ApplicationUsageOverviewResponse instance
         */
        ApplicationUsageOverviewResponse.create = function create(properties) {
            return new ApplicationUsageOverviewResponse(properties);
        };

        /**
         * Encodes the specified ApplicationUsageOverviewResponse message. Does not implicitly {@link api.ApplicationUsageOverviewResponse.verify|verify} messages.
         * @function encode
         * @memberof api.ApplicationUsageOverviewResponse
         * @static
         * @param {api.IApplicationUsageOverviewResponse} message ApplicationUsageOverviewResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApplicationUsageOverviewResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.overview != null && message.overview.length)
                for (var i = 0; i < message.overview.length; ++i)
                    $root.api.ApplicationUsageOverview.encode(message.overview[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ApplicationUsageOverviewResponse message, length delimited. Does not implicitly {@link api.ApplicationUsageOverviewResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.ApplicationUsageOverviewResponse
         * @static
         * @param {api.IApplicationUsageOverviewResponse} message ApplicationUsageOverviewResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApplicationUsageOverviewResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ApplicationUsageOverviewResponse message from the specified reader or buffer.
         * @function decode
         * @memberof api.ApplicationUsageOverviewResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.ApplicationUsageOverviewResponse} ApplicationUsageOverviewResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApplicationUsageOverviewResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ApplicationUsageOverviewResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.overview && message.overview.length))
                        message.overview = [];
                    message.overview.push($root.api.ApplicationUsageOverview.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ApplicationUsageOverviewResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.ApplicationUsageOverviewResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.ApplicationUsageOverviewResponse} ApplicationUsageOverviewResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApplicationUsageOverviewResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ApplicationUsageOverviewResponse message.
         * @function verify
         * @memberof api.ApplicationUsageOverviewResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ApplicationUsageOverviewResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.overview != null && message.hasOwnProperty("overview")) {
                if (!Array.isArray(message.overview))
                    return "overview: array expected";
                for (var i = 0; i < message.overview.length; ++i) {
                    var error = $root.api.ApplicationUsageOverview.verify(message.overview[i]);
                    if (error)
                        return "overview." + error;
                }
            }
            return null;
        };

        /**
         * Creates an ApplicationUsageOverviewResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.ApplicationUsageOverviewResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.ApplicationUsageOverviewResponse} ApplicationUsageOverviewResponse
         */
        ApplicationUsageOverviewResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.api.ApplicationUsageOverviewResponse)
                return object;
            var message = new $root.api.ApplicationUsageOverviewResponse();
            if (object.overview) {
                if (!Array.isArray(object.overview))
                    throw TypeError(".api.ApplicationUsageOverviewResponse.overview: array expected");
                message.overview = [];
                for (var i = 0; i < object.overview.length; ++i) {
                    if (typeof object.overview[i] !== "object")
                        throw TypeError(".api.ApplicationUsageOverviewResponse.overview: object expected");
                    message.overview[i] = $root.api.ApplicationUsageOverview.fromObject(object.overview[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an ApplicationUsageOverviewResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.ApplicationUsageOverviewResponse
         * @static
         * @param {api.ApplicationUsageOverviewResponse} message ApplicationUsageOverviewResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ApplicationUsageOverviewResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.overview = [];
            if (message.overview && message.overview.length) {
                object.overview = [];
                for (var j = 0; j < message.overview.length; ++j)
                    object.overview[j] = $root.api.ApplicationUsageOverview.toObject(message.overview[j], options);
            }
            return object;
        };

        /**
         * Converts this ApplicationUsageOverviewResponse to JSON.
         * @function toJSON
         * @memberof api.ApplicationUsageOverviewResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ApplicationUsageOverviewResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ApplicationUsageOverviewResponse;
    })();

    api.ApplicationGetIdentityAuthResponse = (function() {

        /**
         * Properties of an ApplicationGetIdentityAuthResponse.
         * @memberof api
         * @interface IApplicationGetIdentityAuthResponse
         * @property {api.IIdentityExternalAuth|null} [auth] ApplicationGetIdentityAuthResponse auth
         * @property {string|null} [login] ApplicationGetIdentityAuthResponse login
         * @property {api.IApplicationConfigID|null} [configID] ApplicationGetIdentityAuthResponse configID
         */

        /**
         * Constructs a new ApplicationGetIdentityAuthResponse.
         * @memberof api
         * @classdesc Represents an ApplicationGetIdentityAuthResponse.
         * @implements IApplicationGetIdentityAuthResponse
         * @constructor
         * @param {api.IApplicationGetIdentityAuthResponse=} [properties] Properties to set
         */
        function ApplicationGetIdentityAuthResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ApplicationGetIdentityAuthResponse auth.
         * @member {api.IIdentityExternalAuth|null|undefined} auth
         * @memberof api.ApplicationGetIdentityAuthResponse
         * @instance
         */
        ApplicationGetIdentityAuthResponse.prototype.auth = null;

        /**
         * ApplicationGetIdentityAuthResponse login.
         * @member {string} login
         * @memberof api.ApplicationGetIdentityAuthResponse
         * @instance
         */
        ApplicationGetIdentityAuthResponse.prototype.login = "";

        /**
         * ApplicationGetIdentityAuthResponse configID.
         * @member {api.IApplicationConfigID|null|undefined} configID
         * @memberof api.ApplicationGetIdentityAuthResponse
         * @instance
         */
        ApplicationGetIdentityAuthResponse.prototype.configID = null;

        /**
         * Creates a new ApplicationGetIdentityAuthResponse instance using the specified properties.
         * @function create
         * @memberof api.ApplicationGetIdentityAuthResponse
         * @static
         * @param {api.IApplicationGetIdentityAuthResponse=} [properties] Properties to set
         * @returns {api.ApplicationGetIdentityAuthResponse} ApplicationGetIdentityAuthResponse instance
         */
        ApplicationGetIdentityAuthResponse.create = function create(properties) {
            return new ApplicationGetIdentityAuthResponse(properties);
        };

        /**
         * Encodes the specified ApplicationGetIdentityAuthResponse message. Does not implicitly {@link api.ApplicationGetIdentityAuthResponse.verify|verify} messages.
         * @function encode
         * @memberof api.ApplicationGetIdentityAuthResponse
         * @static
         * @param {api.IApplicationGetIdentityAuthResponse} message ApplicationGetIdentityAuthResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApplicationGetIdentityAuthResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.auth != null && message.hasOwnProperty("auth"))
                $root.api.IdentityExternalAuth.encode(message.auth, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.login);
            if (message.configID != null && message.hasOwnProperty("configID"))
                $root.api.ApplicationConfigID.encode(message.configID, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ApplicationGetIdentityAuthResponse message, length delimited. Does not implicitly {@link api.ApplicationGetIdentityAuthResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.ApplicationGetIdentityAuthResponse
         * @static
         * @param {api.IApplicationGetIdentityAuthResponse} message ApplicationGetIdentityAuthResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApplicationGetIdentityAuthResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ApplicationGetIdentityAuthResponse message from the specified reader or buffer.
         * @function decode
         * @memberof api.ApplicationGetIdentityAuthResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.ApplicationGetIdentityAuthResponse} ApplicationGetIdentityAuthResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApplicationGetIdentityAuthResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ApplicationGetIdentityAuthResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.auth = $root.api.IdentityExternalAuth.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.login = reader.string();
                    break;
                case 3:
                    message.configID = $root.api.ApplicationConfigID.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ApplicationGetIdentityAuthResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.ApplicationGetIdentityAuthResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.ApplicationGetIdentityAuthResponse} ApplicationGetIdentityAuthResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApplicationGetIdentityAuthResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ApplicationGetIdentityAuthResponse message.
         * @function verify
         * @memberof api.ApplicationGetIdentityAuthResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ApplicationGetIdentityAuthResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.api.IdentityExternalAuth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            if (message.configID != null && message.hasOwnProperty("configID")) {
                var error = $root.api.ApplicationConfigID.verify(message.configID);
                if (error)
                    return "configID." + error;
            }
            return null;
        };

        /**
         * Creates an ApplicationGetIdentityAuthResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.ApplicationGetIdentityAuthResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.ApplicationGetIdentityAuthResponse} ApplicationGetIdentityAuthResponse
         */
        ApplicationGetIdentityAuthResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.api.ApplicationGetIdentityAuthResponse)
                return object;
            var message = new $root.api.ApplicationGetIdentityAuthResponse();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".api.ApplicationGetIdentityAuthResponse.auth: object expected");
                message.auth = $root.api.IdentityExternalAuth.fromObject(object.auth);
            }
            if (object.login != null)
                message.login = String(object.login);
            if (object.configID != null) {
                if (typeof object.configID !== "object")
                    throw TypeError(".api.ApplicationGetIdentityAuthResponse.configID: object expected");
                message.configID = $root.api.ApplicationConfigID.fromObject(object.configID);
            }
            return message;
        };

        /**
         * Creates a plain object from an ApplicationGetIdentityAuthResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.ApplicationGetIdentityAuthResponse
         * @static
         * @param {api.ApplicationGetIdentityAuthResponse} message ApplicationGetIdentityAuthResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ApplicationGetIdentityAuthResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.auth = null;
                object.login = "";
                object.configID = null;
            }
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.api.IdentityExternalAuth.toObject(message.auth, options);
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            if (message.configID != null && message.hasOwnProperty("configID"))
                object.configID = $root.api.ApplicationConfigID.toObject(message.configID, options);
            return object;
        };

        /**
         * Converts this ApplicationGetIdentityAuthResponse to JSON.
         * @function toJSON
         * @memberof api.ApplicationGetIdentityAuthResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ApplicationGetIdentityAuthResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ApplicationGetIdentityAuthResponse;
    })();

    api.ApplicationGetIdentityAuthRequest = (function() {

        /**
         * Properties of an ApplicationGetIdentityAuthRequest.
         * @memberof api
         * @interface IApplicationGetIdentityAuthRequest
         * @property {string|null} [login] ApplicationGetIdentityAuthRequest login
         */

        /**
         * Constructs a new ApplicationGetIdentityAuthRequest.
         * @memberof api
         * @classdesc Represents an ApplicationGetIdentityAuthRequest.
         * @implements IApplicationGetIdentityAuthRequest
         * @constructor
         * @param {api.IApplicationGetIdentityAuthRequest=} [properties] Properties to set
         */
        function ApplicationGetIdentityAuthRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ApplicationGetIdentityAuthRequest login.
         * @member {string} login
         * @memberof api.ApplicationGetIdentityAuthRequest
         * @instance
         */
        ApplicationGetIdentityAuthRequest.prototype.login = "";

        /**
         * Creates a new ApplicationGetIdentityAuthRequest instance using the specified properties.
         * @function create
         * @memberof api.ApplicationGetIdentityAuthRequest
         * @static
         * @param {api.IApplicationGetIdentityAuthRequest=} [properties] Properties to set
         * @returns {api.ApplicationGetIdentityAuthRequest} ApplicationGetIdentityAuthRequest instance
         */
        ApplicationGetIdentityAuthRequest.create = function create(properties) {
            return new ApplicationGetIdentityAuthRequest(properties);
        };

        /**
         * Encodes the specified ApplicationGetIdentityAuthRequest message. Does not implicitly {@link api.ApplicationGetIdentityAuthRequest.verify|verify} messages.
         * @function encode
         * @memberof api.ApplicationGetIdentityAuthRequest
         * @static
         * @param {api.IApplicationGetIdentityAuthRequest} message ApplicationGetIdentityAuthRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApplicationGetIdentityAuthRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            return writer;
        };

        /**
         * Encodes the specified ApplicationGetIdentityAuthRequest message, length delimited. Does not implicitly {@link api.ApplicationGetIdentityAuthRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.ApplicationGetIdentityAuthRequest
         * @static
         * @param {api.IApplicationGetIdentityAuthRequest} message ApplicationGetIdentityAuthRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApplicationGetIdentityAuthRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ApplicationGetIdentityAuthRequest message from the specified reader or buffer.
         * @function decode
         * @memberof api.ApplicationGetIdentityAuthRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.ApplicationGetIdentityAuthRequest} ApplicationGetIdentityAuthRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApplicationGetIdentityAuthRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ApplicationGetIdentityAuthRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ApplicationGetIdentityAuthRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.ApplicationGetIdentityAuthRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.ApplicationGetIdentityAuthRequest} ApplicationGetIdentityAuthRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApplicationGetIdentityAuthRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ApplicationGetIdentityAuthRequest message.
         * @function verify
         * @memberof api.ApplicationGetIdentityAuthRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ApplicationGetIdentityAuthRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            return null;
        };

        /**
         * Creates an ApplicationGetIdentityAuthRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.ApplicationGetIdentityAuthRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.ApplicationGetIdentityAuthRequest} ApplicationGetIdentityAuthRequest
         */
        ApplicationGetIdentityAuthRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.api.ApplicationGetIdentityAuthRequest)
                return object;
            var message = new $root.api.ApplicationGetIdentityAuthRequest();
            if (object.login != null)
                message.login = String(object.login);
            return message;
        };

        /**
         * Creates a plain object from an ApplicationGetIdentityAuthRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.ApplicationGetIdentityAuthRequest
         * @static
         * @param {api.ApplicationGetIdentityAuthRequest} message ApplicationGetIdentityAuthRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ApplicationGetIdentityAuthRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.login = "";
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            return object;
        };

        /**
         * Converts this ApplicationGetIdentityAuthRequest to JSON.
         * @function toJSON
         * @memberof api.ApplicationGetIdentityAuthRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ApplicationGetIdentityAuthRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ApplicationGetIdentityAuthRequest;
    })();

    api.ApplicationGetLatestConfigurationRequest = (function() {

        /**
         * Properties of an ApplicationGetLatestConfigurationRequest.
         * @memberof api
         * @interface IApplicationGetLatestConfigurationRequest
         * @property {string|null} [appID] ApplicationGetLatestConfigurationRequest appID
         */

        /**
         * Constructs a new ApplicationGetLatestConfigurationRequest.
         * @memberof api
         * @classdesc Represents an ApplicationGetLatestConfigurationRequest.
         * @implements IApplicationGetLatestConfigurationRequest
         * @constructor
         * @param {api.IApplicationGetLatestConfigurationRequest=} [properties] Properties to set
         */
        function ApplicationGetLatestConfigurationRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ApplicationGetLatestConfigurationRequest appID.
         * @member {string} appID
         * @memberof api.ApplicationGetLatestConfigurationRequest
         * @instance
         */
        ApplicationGetLatestConfigurationRequest.prototype.appID = "";

        /**
         * Creates a new ApplicationGetLatestConfigurationRequest instance using the specified properties.
         * @function create
         * @memberof api.ApplicationGetLatestConfigurationRequest
         * @static
         * @param {api.IApplicationGetLatestConfigurationRequest=} [properties] Properties to set
         * @returns {api.ApplicationGetLatestConfigurationRequest} ApplicationGetLatestConfigurationRequest instance
         */
        ApplicationGetLatestConfigurationRequest.create = function create(properties) {
            return new ApplicationGetLatestConfigurationRequest(properties);
        };

        /**
         * Encodes the specified ApplicationGetLatestConfigurationRequest message. Does not implicitly {@link api.ApplicationGetLatestConfigurationRequest.verify|verify} messages.
         * @function encode
         * @memberof api.ApplicationGetLatestConfigurationRequest
         * @static
         * @param {api.IApplicationGetLatestConfigurationRequest} message ApplicationGetLatestConfigurationRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApplicationGetLatestConfigurationRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.appID != null && message.hasOwnProperty("appID"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.appID);
            return writer;
        };

        /**
         * Encodes the specified ApplicationGetLatestConfigurationRequest message, length delimited. Does not implicitly {@link api.ApplicationGetLatestConfigurationRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.ApplicationGetLatestConfigurationRequest
         * @static
         * @param {api.IApplicationGetLatestConfigurationRequest} message ApplicationGetLatestConfigurationRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApplicationGetLatestConfigurationRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ApplicationGetLatestConfigurationRequest message from the specified reader or buffer.
         * @function decode
         * @memberof api.ApplicationGetLatestConfigurationRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.ApplicationGetLatestConfigurationRequest} ApplicationGetLatestConfigurationRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApplicationGetLatestConfigurationRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ApplicationGetLatestConfigurationRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.appID = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ApplicationGetLatestConfigurationRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.ApplicationGetLatestConfigurationRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.ApplicationGetLatestConfigurationRequest} ApplicationGetLatestConfigurationRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApplicationGetLatestConfigurationRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ApplicationGetLatestConfigurationRequest message.
         * @function verify
         * @memberof api.ApplicationGetLatestConfigurationRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ApplicationGetLatestConfigurationRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.appID != null && message.hasOwnProperty("appID"))
                if (!$util.isString(message.appID))
                    return "appID: string expected";
            return null;
        };

        /**
         * Creates an ApplicationGetLatestConfigurationRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.ApplicationGetLatestConfigurationRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.ApplicationGetLatestConfigurationRequest} ApplicationGetLatestConfigurationRequest
         */
        ApplicationGetLatestConfigurationRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.api.ApplicationGetLatestConfigurationRequest)
                return object;
            var message = new $root.api.ApplicationGetLatestConfigurationRequest();
            if (object.appID != null)
                message.appID = String(object.appID);
            return message;
        };

        /**
         * Creates a plain object from an ApplicationGetLatestConfigurationRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.ApplicationGetLatestConfigurationRequest
         * @static
         * @param {api.ApplicationGetLatestConfigurationRequest} message ApplicationGetLatestConfigurationRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ApplicationGetLatestConfigurationRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.appID = "";
            if (message.appID != null && message.hasOwnProperty("appID"))
                object.appID = message.appID;
            return object;
        };

        /**
         * Converts this ApplicationGetLatestConfigurationRequest to JSON.
         * @function toJSON
         * @memberof api.ApplicationGetLatestConfigurationRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ApplicationGetLatestConfigurationRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ApplicationGetLatestConfigurationRequest;
    })();

    api.IdentityUnlockVersionsRequest = (function() {

        /**
         * Properties of an IdentityUnlockVersionsRequest.
         * @memberof api
         * @interface IIdentityUnlockVersionsRequest
         * @property {string|null} [login] IdentityUnlockVersionsRequest login
         * @property {Array.<api.IdentityUnlockVersionsRequest.IUnlockedVersion>|null} [unlockedVersions] IdentityUnlockVersionsRequest unlockedVersions
         */

        /**
         * Constructs a new IdentityUnlockVersionsRequest.
         * @memberof api
         * @classdesc Represents an IdentityUnlockVersionsRequest.
         * @implements IIdentityUnlockVersionsRequest
         * @constructor
         * @param {api.IIdentityUnlockVersionsRequest=} [properties] Properties to set
         */
        function IdentityUnlockVersionsRequest(properties) {
            this.unlockedVersions = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityUnlockVersionsRequest login.
         * @member {string} login
         * @memberof api.IdentityUnlockVersionsRequest
         * @instance
         */
        IdentityUnlockVersionsRequest.prototype.login = "";

        /**
         * IdentityUnlockVersionsRequest unlockedVersions.
         * @member {Array.<api.IdentityUnlockVersionsRequest.IUnlockedVersion>} unlockedVersions
         * @memberof api.IdentityUnlockVersionsRequest
         * @instance
         */
        IdentityUnlockVersionsRequest.prototype.unlockedVersions = $util.emptyArray;

        /**
         * Creates a new IdentityUnlockVersionsRequest instance using the specified properties.
         * @function create
         * @memberof api.IdentityUnlockVersionsRequest
         * @static
         * @param {api.IIdentityUnlockVersionsRequest=} [properties] Properties to set
         * @returns {api.IdentityUnlockVersionsRequest} IdentityUnlockVersionsRequest instance
         */
        IdentityUnlockVersionsRequest.create = function create(properties) {
            return new IdentityUnlockVersionsRequest(properties);
        };

        /**
         * Encodes the specified IdentityUnlockVersionsRequest message. Does not implicitly {@link api.IdentityUnlockVersionsRequest.verify|verify} messages.
         * @function encode
         * @memberof api.IdentityUnlockVersionsRequest
         * @static
         * @param {api.IIdentityUnlockVersionsRequest} message IdentityUnlockVersionsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityUnlockVersionsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            if (message.unlockedVersions != null && message.unlockedVersions.length)
                for (var i = 0; i < message.unlockedVersions.length; ++i)
                    $root.api.IdentityUnlockVersionsRequest.UnlockedVersion.encode(message.unlockedVersions[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IdentityUnlockVersionsRequest message, length delimited. Does not implicitly {@link api.IdentityUnlockVersionsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.IdentityUnlockVersionsRequest
         * @static
         * @param {api.IIdentityUnlockVersionsRequest} message IdentityUnlockVersionsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityUnlockVersionsRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityUnlockVersionsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof api.IdentityUnlockVersionsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.IdentityUnlockVersionsRequest} IdentityUnlockVersionsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityUnlockVersionsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityUnlockVersionsRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                case 2:
                    if (!(message.unlockedVersions && message.unlockedVersions.length))
                        message.unlockedVersions = [];
                    message.unlockedVersions.push($root.api.IdentityUnlockVersionsRequest.UnlockedVersion.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityUnlockVersionsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.IdentityUnlockVersionsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.IdentityUnlockVersionsRequest} IdentityUnlockVersionsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityUnlockVersionsRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityUnlockVersionsRequest message.
         * @function verify
         * @memberof api.IdentityUnlockVersionsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityUnlockVersionsRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            if (message.unlockedVersions != null && message.hasOwnProperty("unlockedVersions")) {
                if (!Array.isArray(message.unlockedVersions))
                    return "unlockedVersions: array expected";
                for (var i = 0; i < message.unlockedVersions.length; ++i) {
                    var error = $root.api.IdentityUnlockVersionsRequest.UnlockedVersion.verify(message.unlockedVersions[i]);
                    if (error)
                        return "unlockedVersions." + error;
                }
            }
            return null;
        };

        /**
         * Creates an IdentityUnlockVersionsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.IdentityUnlockVersionsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.IdentityUnlockVersionsRequest} IdentityUnlockVersionsRequest
         */
        IdentityUnlockVersionsRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.api.IdentityUnlockVersionsRequest)
                return object;
            var message = new $root.api.IdentityUnlockVersionsRequest();
            if (object.login != null)
                message.login = String(object.login);
            if (object.unlockedVersions) {
                if (!Array.isArray(object.unlockedVersions))
                    throw TypeError(".api.IdentityUnlockVersionsRequest.unlockedVersions: array expected");
                message.unlockedVersions = [];
                for (var i = 0; i < object.unlockedVersions.length; ++i) {
                    if (typeof object.unlockedVersions[i] !== "object")
                        throw TypeError(".api.IdentityUnlockVersionsRequest.unlockedVersions: object expected");
                    message.unlockedVersions[i] = $root.api.IdentityUnlockVersionsRequest.UnlockedVersion.fromObject(object.unlockedVersions[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an IdentityUnlockVersionsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.IdentityUnlockVersionsRequest
         * @static
         * @param {api.IdentityUnlockVersionsRequest} message IdentityUnlockVersionsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityUnlockVersionsRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.unlockedVersions = [];
            if (options.defaults)
                object.login = "";
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            if (message.unlockedVersions && message.unlockedVersions.length) {
                object.unlockedVersions = [];
                for (var j = 0; j < message.unlockedVersions.length; ++j)
                    object.unlockedVersions[j] = $root.api.IdentityUnlockVersionsRequest.UnlockedVersion.toObject(message.unlockedVersions[j], options);
            }
            return object;
        };

        /**
         * Converts this IdentityUnlockVersionsRequest to JSON.
         * @function toJSON
         * @memberof api.IdentityUnlockVersionsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityUnlockVersionsRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        IdentityUnlockVersionsRequest.UnlockedVersion = (function() {

            /**
             * Properties of an UnlockedVersion.
             * @memberof api.IdentityUnlockVersionsRequest
             * @interface IUnlockedVersion
             * @property {api.ISessionResolveChallengeRequest|null} [resolvedChallenge] UnlockedVersion resolvedChallenge
             * @property {api.IIdentityBackwardKey|null} [backward] UnlockedVersion backward
             */

            /**
             * Constructs a new UnlockedVersion.
             * @memberof api.IdentityUnlockVersionsRequest
             * @classdesc Represents an UnlockedVersion.
             * @implements IUnlockedVersion
             * @constructor
             * @param {api.IdentityUnlockVersionsRequest.IUnlockedVersion=} [properties] Properties to set
             */
            function UnlockedVersion(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * UnlockedVersion resolvedChallenge.
             * @member {api.ISessionResolveChallengeRequest|null|undefined} resolvedChallenge
             * @memberof api.IdentityUnlockVersionsRequest.UnlockedVersion
             * @instance
             */
            UnlockedVersion.prototype.resolvedChallenge = null;

            /**
             * UnlockedVersion backward.
             * @member {api.IIdentityBackwardKey|null|undefined} backward
             * @memberof api.IdentityUnlockVersionsRequest.UnlockedVersion
             * @instance
             */
            UnlockedVersion.prototype.backward = null;

            /**
             * Creates a new UnlockedVersion instance using the specified properties.
             * @function create
             * @memberof api.IdentityUnlockVersionsRequest.UnlockedVersion
             * @static
             * @param {api.IdentityUnlockVersionsRequest.IUnlockedVersion=} [properties] Properties to set
             * @returns {api.IdentityUnlockVersionsRequest.UnlockedVersion} UnlockedVersion instance
             */
            UnlockedVersion.create = function create(properties) {
                return new UnlockedVersion(properties);
            };

            /**
             * Encodes the specified UnlockedVersion message. Does not implicitly {@link api.IdentityUnlockVersionsRequest.UnlockedVersion.verify|verify} messages.
             * @function encode
             * @memberof api.IdentityUnlockVersionsRequest.UnlockedVersion
             * @static
             * @param {api.IdentityUnlockVersionsRequest.IUnlockedVersion} message UnlockedVersion message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UnlockedVersion.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.resolvedChallenge != null && message.hasOwnProperty("resolvedChallenge"))
                    $root.api.SessionResolveChallengeRequest.encode(message.resolvedChallenge, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.backward != null && message.hasOwnProperty("backward"))
                    $root.api.IdentityBackwardKey.encode(message.backward, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified UnlockedVersion message, length delimited. Does not implicitly {@link api.IdentityUnlockVersionsRequest.UnlockedVersion.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.IdentityUnlockVersionsRequest.UnlockedVersion
             * @static
             * @param {api.IdentityUnlockVersionsRequest.IUnlockedVersion} message UnlockedVersion message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UnlockedVersion.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an UnlockedVersion message from the specified reader or buffer.
             * @function decode
             * @memberof api.IdentityUnlockVersionsRequest.UnlockedVersion
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.IdentityUnlockVersionsRequest.UnlockedVersion} UnlockedVersion
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UnlockedVersion.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.IdentityUnlockVersionsRequest.UnlockedVersion();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.resolvedChallenge = $root.api.SessionResolveChallengeRequest.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.backward = $root.api.IdentityBackwardKey.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an UnlockedVersion message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.IdentityUnlockVersionsRequest.UnlockedVersion
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.IdentityUnlockVersionsRequest.UnlockedVersion} UnlockedVersion
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UnlockedVersion.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an UnlockedVersion message.
             * @function verify
             * @memberof api.IdentityUnlockVersionsRequest.UnlockedVersion
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UnlockedVersion.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.resolvedChallenge != null && message.hasOwnProperty("resolvedChallenge")) {
                    var error = $root.api.SessionResolveChallengeRequest.verify(message.resolvedChallenge);
                    if (error)
                        return "resolvedChallenge." + error;
                }
                if (message.backward != null && message.hasOwnProperty("backward")) {
                    var error = $root.api.IdentityBackwardKey.verify(message.backward);
                    if (error)
                        return "backward." + error;
                }
                return null;
            };

            /**
             * Creates an UnlockedVersion message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.IdentityUnlockVersionsRequest.UnlockedVersion
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.IdentityUnlockVersionsRequest.UnlockedVersion} UnlockedVersion
             */
            UnlockedVersion.fromObject = function fromObject(object) {
                if (object instanceof $root.api.IdentityUnlockVersionsRequest.UnlockedVersion)
                    return object;
                var message = new $root.api.IdentityUnlockVersionsRequest.UnlockedVersion();
                if (object.resolvedChallenge != null) {
                    if (typeof object.resolvedChallenge !== "object")
                        throw TypeError(".api.IdentityUnlockVersionsRequest.UnlockedVersion.resolvedChallenge: object expected");
                    message.resolvedChallenge = $root.api.SessionResolveChallengeRequest.fromObject(object.resolvedChallenge);
                }
                if (object.backward != null) {
                    if (typeof object.backward !== "object")
                        throw TypeError(".api.IdentityUnlockVersionsRequest.UnlockedVersion.backward: object expected");
                    message.backward = $root.api.IdentityBackwardKey.fromObject(object.backward);
                }
                return message;
            };

            /**
             * Creates a plain object from an UnlockedVersion message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.IdentityUnlockVersionsRequest.UnlockedVersion
             * @static
             * @param {api.IdentityUnlockVersionsRequest.UnlockedVersion} message UnlockedVersion
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UnlockedVersion.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.resolvedChallenge = null;
                    object.backward = null;
                }
                if (message.resolvedChallenge != null && message.hasOwnProperty("resolvedChallenge"))
                    object.resolvedChallenge = $root.api.SessionResolveChallengeRequest.toObject(message.resolvedChallenge, options);
                if (message.backward != null && message.hasOwnProperty("backward"))
                    object.backward = $root.api.IdentityBackwardKey.toObject(message.backward, options);
                return object;
            };

            /**
             * Converts this UnlockedVersion to JSON.
             * @function toJSON
             * @memberof api.IdentityUnlockVersionsRequest.UnlockedVersion
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UnlockedVersion.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return UnlockedVersion;
        })();

        return IdentityUnlockVersionsRequest;
    })();

    api.SessionSetSecretRequest = (function() {

        /**
         * Properties of a SessionSetSecretRequest.
         * @memberof api
         * @interface ISessionSetSecretRequest
         * @property {Uint8Array|null} [masterSalt] SessionSetSecretRequest masterSalt
         * @property {api.IIdentityEncryptedKey|null} [sharingEncrypted] SessionSetSecretRequest sharingEncrypted
         */

        /**
         * Constructs a new SessionSetSecretRequest.
         * @memberof api
         * @classdesc Represents a SessionSetSecretRequest.
         * @implements ISessionSetSecretRequest
         * @constructor
         * @param {api.ISessionSetSecretRequest=} [properties] Properties to set
         */
        function SessionSetSecretRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SessionSetSecretRequest masterSalt.
         * @member {Uint8Array} masterSalt
         * @memberof api.SessionSetSecretRequest
         * @instance
         */
        SessionSetSecretRequest.prototype.masterSalt = $util.newBuffer([]);

        /**
         * SessionSetSecretRequest sharingEncrypted.
         * @member {api.IIdentityEncryptedKey|null|undefined} sharingEncrypted
         * @memberof api.SessionSetSecretRequest
         * @instance
         */
        SessionSetSecretRequest.prototype.sharingEncrypted = null;

        /**
         * Creates a new SessionSetSecretRequest instance using the specified properties.
         * @function create
         * @memberof api.SessionSetSecretRequest
         * @static
         * @param {api.ISessionSetSecretRequest=} [properties] Properties to set
         * @returns {api.SessionSetSecretRequest} SessionSetSecretRequest instance
         */
        SessionSetSecretRequest.create = function create(properties) {
            return new SessionSetSecretRequest(properties);
        };

        /**
         * Encodes the specified SessionSetSecretRequest message. Does not implicitly {@link api.SessionSetSecretRequest.verify|verify} messages.
         * @function encode
         * @memberof api.SessionSetSecretRequest
         * @static
         * @param {api.ISessionSetSecretRequest} message SessionSetSecretRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SessionSetSecretRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.masterSalt != null && message.hasOwnProperty("masterSalt"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.masterSalt);
            if (message.sharingEncrypted != null && message.hasOwnProperty("sharingEncrypted"))
                $root.api.IdentityEncryptedKey.encode(message.sharingEncrypted, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SessionSetSecretRequest message, length delimited. Does not implicitly {@link api.SessionSetSecretRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.SessionSetSecretRequest
         * @static
         * @param {api.ISessionSetSecretRequest} message SessionSetSecretRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SessionSetSecretRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SessionSetSecretRequest message from the specified reader or buffer.
         * @function decode
         * @memberof api.SessionSetSecretRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.SessionSetSecretRequest} SessionSetSecretRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SessionSetSecretRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.SessionSetSecretRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.masterSalt = reader.bytes();
                    break;
                case 2:
                    message.sharingEncrypted = $root.api.IdentityEncryptedKey.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SessionSetSecretRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.SessionSetSecretRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.SessionSetSecretRequest} SessionSetSecretRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SessionSetSecretRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SessionSetSecretRequest message.
         * @function verify
         * @memberof api.SessionSetSecretRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SessionSetSecretRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.masterSalt != null && message.hasOwnProperty("masterSalt"))
                if (!(message.masterSalt && typeof message.masterSalt.length === "number" || $util.isString(message.masterSalt)))
                    return "masterSalt: buffer expected";
            if (message.sharingEncrypted != null && message.hasOwnProperty("sharingEncrypted")) {
                var error = $root.api.IdentityEncryptedKey.verify(message.sharingEncrypted);
                if (error)
                    return "sharingEncrypted." + error;
            }
            return null;
        };

        /**
         * Creates a SessionSetSecretRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.SessionSetSecretRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.SessionSetSecretRequest} SessionSetSecretRequest
         */
        SessionSetSecretRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.api.SessionSetSecretRequest)
                return object;
            var message = new $root.api.SessionSetSecretRequest();
            if (object.masterSalt != null)
                if (typeof object.masterSalt === "string")
                    $util.base64.decode(object.masterSalt, message.masterSalt = $util.newBuffer($util.base64.length(object.masterSalt)), 0);
                else if (object.masterSalt.length)
                    message.masterSalt = object.masterSalt;
            if (object.sharingEncrypted != null) {
                if (typeof object.sharingEncrypted !== "object")
                    throw TypeError(".api.SessionSetSecretRequest.sharingEncrypted: object expected");
                message.sharingEncrypted = $root.api.IdentityEncryptedKey.fromObject(object.sharingEncrypted);
            }
            return message;
        };

        /**
         * Creates a plain object from a SessionSetSecretRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.SessionSetSecretRequest
         * @static
         * @param {api.SessionSetSecretRequest} message SessionSetSecretRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SessionSetSecretRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.masterSalt = "";
                else {
                    object.masterSalt = [];
                    if (options.bytes !== Array)
                        object.masterSalt = $util.newBuffer(object.masterSalt);
                }
                object.sharingEncrypted = null;
            }
            if (message.masterSalt != null && message.hasOwnProperty("masterSalt"))
                object.masterSalt = options.bytes === String ? $util.base64.encode(message.masterSalt, 0, message.masterSalt.length) : options.bytes === Array ? Array.prototype.slice.call(message.masterSalt) : message.masterSalt;
            if (message.sharingEncrypted != null && message.hasOwnProperty("sharingEncrypted"))
                object.sharingEncrypted = $root.api.IdentityEncryptedKey.toObject(message.sharingEncrypted, options);
            return object;
        };

        /**
         * Converts this SessionSetSecretRequest to JSON.
         * @function toJSON
         * @memberof api.SessionSetSecretRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SessionSetSecretRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SessionSetSecretRequest;
    })();

    api.SessionUnStaleResponse = (function() {

        /**
         * Properties of a SessionUnStaleResponse.
         * @memberof api
         * @interface ISessionUnStaleResponse
         * @property {api.IIdentityEncryptedKeySet|null} [encryption] SessionUnStaleResponse encryption
         */

        /**
         * Constructs a new SessionUnStaleResponse.
         * @memberof api
         * @classdesc Represents a SessionUnStaleResponse.
         * @implements ISessionUnStaleResponse
         * @constructor
         * @param {api.ISessionUnStaleResponse=} [properties] Properties to set
         */
        function SessionUnStaleResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SessionUnStaleResponse encryption.
         * @member {api.IIdentityEncryptedKeySet|null|undefined} encryption
         * @memberof api.SessionUnStaleResponse
         * @instance
         */
        SessionUnStaleResponse.prototype.encryption = null;

        /**
         * Creates a new SessionUnStaleResponse instance using the specified properties.
         * @function create
         * @memberof api.SessionUnStaleResponse
         * @static
         * @param {api.ISessionUnStaleResponse=} [properties] Properties to set
         * @returns {api.SessionUnStaleResponse} SessionUnStaleResponse instance
         */
        SessionUnStaleResponse.create = function create(properties) {
            return new SessionUnStaleResponse(properties);
        };

        /**
         * Encodes the specified SessionUnStaleResponse message. Does not implicitly {@link api.SessionUnStaleResponse.verify|verify} messages.
         * @function encode
         * @memberof api.SessionUnStaleResponse
         * @static
         * @param {api.ISessionUnStaleResponse} message SessionUnStaleResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SessionUnStaleResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.encryption != null && message.hasOwnProperty("encryption"))
                $root.api.IdentityEncryptedKeySet.encode(message.encryption, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SessionUnStaleResponse message, length delimited. Does not implicitly {@link api.SessionUnStaleResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.SessionUnStaleResponse
         * @static
         * @param {api.ISessionUnStaleResponse} message SessionUnStaleResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SessionUnStaleResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SessionUnStaleResponse message from the specified reader or buffer.
         * @function decode
         * @memberof api.SessionUnStaleResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.SessionUnStaleResponse} SessionUnStaleResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SessionUnStaleResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.SessionUnStaleResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.encryption = $root.api.IdentityEncryptedKeySet.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SessionUnStaleResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.SessionUnStaleResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.SessionUnStaleResponse} SessionUnStaleResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SessionUnStaleResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SessionUnStaleResponse message.
         * @function verify
         * @memberof api.SessionUnStaleResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SessionUnStaleResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.encryption != null && message.hasOwnProperty("encryption")) {
                var error = $root.api.IdentityEncryptedKeySet.verify(message.encryption);
                if (error)
                    return "encryption." + error;
            }
            return null;
        };

        /**
         * Creates a SessionUnStaleResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.SessionUnStaleResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.SessionUnStaleResponse} SessionUnStaleResponse
         */
        SessionUnStaleResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.api.SessionUnStaleResponse)
                return object;
            var message = new $root.api.SessionUnStaleResponse();
            if (object.encryption != null) {
                if (typeof object.encryption !== "object")
                    throw TypeError(".api.SessionUnStaleResponse.encryption: object expected");
                message.encryption = $root.api.IdentityEncryptedKeySet.fromObject(object.encryption);
            }
            return message;
        };

        /**
         * Creates a plain object from a SessionUnStaleResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.SessionUnStaleResponse
         * @static
         * @param {api.SessionUnStaleResponse} message SessionUnStaleResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SessionUnStaleResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.encryption = null;
            if (message.encryption != null && message.hasOwnProperty("encryption"))
                object.encryption = $root.api.IdentityEncryptedKeySet.toObject(message.encryption, options);
            return object;
        };

        /**
         * Converts this SessionUnStaleResponse to JSON.
         * @function toJSON
         * @memberof api.SessionUnStaleResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SessionUnStaleResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SessionUnStaleResponse;
    })();

    api.SessionAuthenticateResponse = (function() {

        /**
         * Properties of a SessionAuthenticateResponse.
         * @memberof api
         * @interface ISessionAuthenticateResponse
         * @property {string|null} [ownerLogin] SessionAuthenticateResponse ownerLogin
         * @property {string|null} [assumeLogin] SessionAuthenticateResponse assumeLogin
         * @property {api.IdentityAccessKeyKind|null} [assumeKind] SessionAuthenticateResponse assumeKind
         */

        /**
         * Constructs a new SessionAuthenticateResponse.
         * @memberof api
         * @classdesc Represents a SessionAuthenticateResponse.
         * @implements ISessionAuthenticateResponse
         * @constructor
         * @param {api.ISessionAuthenticateResponse=} [properties] Properties to set
         */
        function SessionAuthenticateResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SessionAuthenticateResponse ownerLogin.
         * @member {string} ownerLogin
         * @memberof api.SessionAuthenticateResponse
         * @instance
         */
        SessionAuthenticateResponse.prototype.ownerLogin = "";

        /**
         * SessionAuthenticateResponse assumeLogin.
         * @member {string} assumeLogin
         * @memberof api.SessionAuthenticateResponse
         * @instance
         */
        SessionAuthenticateResponse.prototype.assumeLogin = "";

        /**
         * SessionAuthenticateResponse assumeKind.
         * @member {api.IdentityAccessKeyKind} assumeKind
         * @memberof api.SessionAuthenticateResponse
         * @instance
         */
        SessionAuthenticateResponse.prototype.assumeKind = 0;

        /**
         * Creates a new SessionAuthenticateResponse instance using the specified properties.
         * @function create
         * @memberof api.SessionAuthenticateResponse
         * @static
         * @param {api.ISessionAuthenticateResponse=} [properties] Properties to set
         * @returns {api.SessionAuthenticateResponse} SessionAuthenticateResponse instance
         */
        SessionAuthenticateResponse.create = function create(properties) {
            return new SessionAuthenticateResponse(properties);
        };

        /**
         * Encodes the specified SessionAuthenticateResponse message. Does not implicitly {@link api.SessionAuthenticateResponse.verify|verify} messages.
         * @function encode
         * @memberof api.SessionAuthenticateResponse
         * @static
         * @param {api.ISessionAuthenticateResponse} message SessionAuthenticateResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SessionAuthenticateResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ownerLogin != null && message.hasOwnProperty("ownerLogin"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.ownerLogin);
            if (message.assumeLogin != null && message.hasOwnProperty("assumeLogin"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.assumeLogin);
            if (message.assumeKind != null && message.hasOwnProperty("assumeKind"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.assumeKind);
            return writer;
        };

        /**
         * Encodes the specified SessionAuthenticateResponse message, length delimited. Does not implicitly {@link api.SessionAuthenticateResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.SessionAuthenticateResponse
         * @static
         * @param {api.ISessionAuthenticateResponse} message SessionAuthenticateResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SessionAuthenticateResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SessionAuthenticateResponse message from the specified reader or buffer.
         * @function decode
         * @memberof api.SessionAuthenticateResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.SessionAuthenticateResponse} SessionAuthenticateResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SessionAuthenticateResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.SessionAuthenticateResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ownerLogin = reader.string();
                    break;
                case 2:
                    message.assumeLogin = reader.string();
                    break;
                case 3:
                    message.assumeKind = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SessionAuthenticateResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.SessionAuthenticateResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.SessionAuthenticateResponse} SessionAuthenticateResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SessionAuthenticateResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SessionAuthenticateResponse message.
         * @function verify
         * @memberof api.SessionAuthenticateResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SessionAuthenticateResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ownerLogin != null && message.hasOwnProperty("ownerLogin"))
                if (!$util.isString(message.ownerLogin))
                    return "ownerLogin: string expected";
            if (message.assumeLogin != null && message.hasOwnProperty("assumeLogin"))
                if (!$util.isString(message.assumeLogin))
                    return "assumeLogin: string expected";
            if (message.assumeKind != null && message.hasOwnProperty("assumeKind"))
                switch (message.assumeKind) {
                default:
                    return "assumeKind: enum value expected";
                case 0:
                case 1:
                    break;
                }
            return null;
        };

        /**
         * Creates a SessionAuthenticateResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.SessionAuthenticateResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.SessionAuthenticateResponse} SessionAuthenticateResponse
         */
        SessionAuthenticateResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.api.SessionAuthenticateResponse)
                return object;
            var message = new $root.api.SessionAuthenticateResponse();
            if (object.ownerLogin != null)
                message.ownerLogin = String(object.ownerLogin);
            if (object.assumeLogin != null)
                message.assumeLogin = String(object.assumeLogin);
            switch (object.assumeKind) {
            case "READ":
            case 0:
                message.assumeKind = 0;
                break;
            case "WRITE":
            case 1:
                message.assumeKind = 1;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a SessionAuthenticateResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.SessionAuthenticateResponse
         * @static
         * @param {api.SessionAuthenticateResponse} message SessionAuthenticateResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SessionAuthenticateResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.ownerLogin = "";
                object.assumeLogin = "";
                object.assumeKind = options.enums === String ? "READ" : 0;
            }
            if (message.ownerLogin != null && message.hasOwnProperty("ownerLogin"))
                object.ownerLogin = message.ownerLogin;
            if (message.assumeLogin != null && message.hasOwnProperty("assumeLogin"))
                object.assumeLogin = message.assumeLogin;
            if (message.assumeKind != null && message.hasOwnProperty("assumeKind"))
                object.assumeKind = options.enums === String ? $root.api.IdentityAccessKeyKind[message.assumeKind] : message.assumeKind;
            return object;
        };

        /**
         * Converts this SessionAuthenticateResponse to JSON.
         * @function toJSON
         * @memberof api.SessionAuthenticateResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SessionAuthenticateResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SessionAuthenticateResponse;
    })();

    /**
     * ResourceType enum.
     * @name api.ResourceType
     * @enum {string}
     * @property {number} ANONYMOUS=0 ANONYMOUS value
     * @property {number} SES=1 SES value
     */
    api.ResourceType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "ANONYMOUS"] = 0;
        values[valuesById[1] = "SES"] = 1;
        return values;
    })();

    /**
     * ResourceAccessReason enum.
     * @name api.ResourceAccessReason
     * @enum {string}
     * @property {number} UNKOWN=0 UNKOWN value
     * @property {number} READ_ACCESS=1 READ_ACCESS value
     * @property {number} SHARE_ACCESS=2 SHARE_ACCESS value
     * @property {number} CUSTOM_ACCESS=3 CUSTOM_ACCESS value
     */
    api.ResourceAccessReason = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "UNKOWN"] = 0;
        values[valuesById[1] = "READ_ACCESS"] = 1;
        values[valuesById[2] = "SHARE_ACCESS"] = 2;
        values[valuesById[3] = "CUSTOM_ACCESS"] = 3;
        return values;
    })();

    api.Resource = (function() {

        /**
         * Properties of a Resource.
         * @memberof api
         * @interface IResource
         * @property {number|Long|null} [id] Resource id
         * @property {string|null} [kind] Resource kind
         * @property {Uint8Array|null} [publicKey] Resource publicKey
         * @property {Uint8Array|null} [nonce] Resource nonce
         * @property {number|Long|null} [created] Resource created
         * @property {Uint8Array|null} [payload] Resource payload
         * @property {api.ResourceType|null} [type] Resource type
         */

        /**
         * Constructs a new Resource.
         * @memberof api
         * @classdesc Represents a Resource.
         * @implements IResource
         * @constructor
         * @param {api.IResource=} [properties] Properties to set
         */
        function Resource(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Resource id.
         * @member {number|Long} id
         * @memberof api.Resource
         * @instance
         */
        Resource.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Resource kind.
         * @member {string} kind
         * @memberof api.Resource
         * @instance
         */
        Resource.prototype.kind = "";

        /**
         * Resource publicKey.
         * @member {Uint8Array} publicKey
         * @memberof api.Resource
         * @instance
         */
        Resource.prototype.publicKey = $util.newBuffer([]);

        /**
         * Resource nonce.
         * @member {Uint8Array} nonce
         * @memberof api.Resource
         * @instance
         */
        Resource.prototype.nonce = $util.newBuffer([]);

        /**
         * Resource created.
         * @member {number|Long} created
         * @memberof api.Resource
         * @instance
         */
        Resource.prototype.created = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Resource payload.
         * @member {Uint8Array} payload
         * @memberof api.Resource
         * @instance
         */
        Resource.prototype.payload = $util.newBuffer([]);

        /**
         * Resource type.
         * @member {api.ResourceType} type
         * @memberof api.Resource
         * @instance
         */
        Resource.prototype.type = 0;

        /**
         * Creates a new Resource instance using the specified properties.
         * @function create
         * @memberof api.Resource
         * @static
         * @param {api.IResource=} [properties] Properties to set
         * @returns {api.Resource} Resource instance
         */
        Resource.create = function create(properties) {
            return new Resource(properties);
        };

        /**
         * Encodes the specified Resource message. Does not implicitly {@link api.Resource.verify|verify} messages.
         * @function encode
         * @memberof api.Resource
         * @static
         * @param {api.IResource} message Resource message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Resource.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
            if (message.kind != null && message.hasOwnProperty("kind"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.kind);
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.publicKey);
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.nonce);
            if (message.created != null && message.hasOwnProperty("created"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.created);
            if (message.payload != null && message.hasOwnProperty("payload"))
                writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.payload);
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.type);
            return writer;
        };

        /**
         * Encodes the specified Resource message, length delimited. Does not implicitly {@link api.Resource.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.Resource
         * @static
         * @param {api.IResource} message Resource message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Resource.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Resource message from the specified reader or buffer.
         * @function decode
         * @memberof api.Resource
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.Resource} Resource
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Resource.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.Resource();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.uint64();
                    break;
                case 2:
                    message.kind = reader.string();
                    break;
                case 3:
                    message.publicKey = reader.bytes();
                    break;
                case 4:
                    message.nonce = reader.bytes();
                    break;
                case 5:
                    message.created = reader.int64();
                    break;
                case 6:
                    message.payload = reader.bytes();
                    break;
                case 7:
                    message.type = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Resource message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.Resource
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.Resource} Resource
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Resource.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Resource message.
         * @function verify
         * @memberof api.Resource
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Resource.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                    return "id: integer|Long expected";
            if (message.kind != null && message.hasOwnProperty("kind"))
                if (!$util.isString(message.kind))
                    return "kind: string expected";
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                if (!(message.publicKey && typeof message.publicKey.length === "number" || $util.isString(message.publicKey)))
                    return "publicKey: buffer expected";
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                if (!(message.nonce && typeof message.nonce.length === "number" || $util.isString(message.nonce)))
                    return "nonce: buffer expected";
            if (message.created != null && message.hasOwnProperty("created"))
                if (!$util.isInteger(message.created) && !(message.created && $util.isInteger(message.created.low) && $util.isInteger(message.created.high)))
                    return "created: integer|Long expected";
            if (message.payload != null && message.hasOwnProperty("payload"))
                if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                    return "payload: buffer expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                    break;
                }
            return null;
        };

        /**
         * Creates a Resource message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.Resource
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.Resource} Resource
         */
        Resource.fromObject = function fromObject(object) {
            if (object instanceof $root.api.Resource)
                return object;
            var message = new $root.api.Resource();
            if (object.id != null)
                if ($util.Long)
                    (message.id = $util.Long.fromValue(object.id)).unsigned = true;
                else if (typeof object.id === "string")
                    message.id = parseInt(object.id, 10);
                else if (typeof object.id === "number")
                    message.id = object.id;
                else if (typeof object.id === "object")
                    message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
            if (object.kind != null)
                message.kind = String(object.kind);
            if (object.publicKey != null)
                if (typeof object.publicKey === "string")
                    $util.base64.decode(object.publicKey, message.publicKey = $util.newBuffer($util.base64.length(object.publicKey)), 0);
                else if (object.publicKey.length)
                    message.publicKey = object.publicKey;
            if (object.nonce != null)
                if (typeof object.nonce === "string")
                    $util.base64.decode(object.nonce, message.nonce = $util.newBuffer($util.base64.length(object.nonce)), 0);
                else if (object.nonce.length)
                    message.nonce = object.nonce;
            if (object.created != null)
                if ($util.Long)
                    (message.created = $util.Long.fromValue(object.created)).unsigned = false;
                else if (typeof object.created === "string")
                    message.created = parseInt(object.created, 10);
                else if (typeof object.created === "number")
                    message.created = object.created;
                else if (typeof object.created === "object")
                    message.created = new $util.LongBits(object.created.low >>> 0, object.created.high >>> 0).toNumber();
            if (object.payload != null)
                if (typeof object.payload === "string")
                    $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                else if (object.payload.length)
                    message.payload = object.payload;
            switch (object.type) {
            case "ANONYMOUS":
            case 0:
                message.type = 0;
                break;
            case "SES":
            case 1:
                message.type = 1;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a Resource message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.Resource
         * @static
         * @param {api.Resource} message Resource
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Resource.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.id = options.longs === String ? "0" : 0;
                object.kind = "";
                if (options.bytes === String)
                    object.publicKey = "";
                else {
                    object.publicKey = [];
                    if (options.bytes !== Array)
                        object.publicKey = $util.newBuffer(object.publicKey);
                }
                if (options.bytes === String)
                    object.nonce = "";
                else {
                    object.nonce = [];
                    if (options.bytes !== Array)
                        object.nonce = $util.newBuffer(object.nonce);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.created = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.created = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.payload = "";
                else {
                    object.payload = [];
                    if (options.bytes !== Array)
                        object.payload = $util.newBuffer(object.payload);
                }
                object.type = options.enums === String ? "ANONYMOUS" : 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                if (typeof message.id === "number")
                    object.id = options.longs === String ? String(message.id) : message.id;
                else
                    object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
            if (message.kind != null && message.hasOwnProperty("kind"))
                object.kind = message.kind;
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                object.publicKey = options.bytes === String ? $util.base64.encode(message.publicKey, 0, message.publicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.publicKey) : message.publicKey;
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                object.nonce = options.bytes === String ? $util.base64.encode(message.nonce, 0, message.nonce.length) : options.bytes === Array ? Array.prototype.slice.call(message.nonce) : message.nonce;
            if (message.created != null && message.hasOwnProperty("created"))
                if (typeof message.created === "number")
                    object.created = options.longs === String ? String(message.created) : message.created;
                else
                    object.created = options.longs === String ? $util.Long.prototype.toString.call(message.created) : options.longs === Number ? new $util.LongBits(message.created.low >>> 0, message.created.high >>> 0).toNumber() : message.created;
            if (message.payload != null && message.hasOwnProperty("payload"))
                object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.api.ResourceType[message.type] : message.type;
            return object;
        };

        /**
         * Converts this Resource to JSON.
         * @function toJSON
         * @memberof api.Resource
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Resource.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Resource;
    })();

    api.ResourceGetRequest = (function() {

        /**
         * Properties of a ResourceGetRequest.
         * @memberof api
         * @interface IResourceGetRequest
         * @property {number|Long|null} [id] ResourceGetRequest id
         * @property {string|null} [accessReason] ResourceGetRequest accessReason
         */

        /**
         * Constructs a new ResourceGetRequest.
         * @memberof api
         * @classdesc Represents a ResourceGetRequest.
         * @implements IResourceGetRequest
         * @constructor
         * @param {api.IResourceGetRequest=} [properties] Properties to set
         */
        function ResourceGetRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResourceGetRequest id.
         * @member {number|Long} id
         * @memberof api.ResourceGetRequest
         * @instance
         */
        ResourceGetRequest.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ResourceGetRequest accessReason.
         * @member {string} accessReason
         * @memberof api.ResourceGetRequest
         * @instance
         */
        ResourceGetRequest.prototype.accessReason = "";

        /**
         * Creates a new ResourceGetRequest instance using the specified properties.
         * @function create
         * @memberof api.ResourceGetRequest
         * @static
         * @param {api.IResourceGetRequest=} [properties] Properties to set
         * @returns {api.ResourceGetRequest} ResourceGetRequest instance
         */
        ResourceGetRequest.create = function create(properties) {
            return new ResourceGetRequest(properties);
        };

        /**
         * Encodes the specified ResourceGetRequest message. Does not implicitly {@link api.ResourceGetRequest.verify|verify} messages.
         * @function encode
         * @memberof api.ResourceGetRequest
         * @static
         * @param {api.IResourceGetRequest} message ResourceGetRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourceGetRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
            if (message.accessReason != null && message.hasOwnProperty("accessReason"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.accessReason);
            return writer;
        };

        /**
         * Encodes the specified ResourceGetRequest message, length delimited. Does not implicitly {@link api.ResourceGetRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.ResourceGetRequest
         * @static
         * @param {api.IResourceGetRequest} message ResourceGetRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourceGetRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResourceGetRequest message from the specified reader or buffer.
         * @function decode
         * @memberof api.ResourceGetRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.ResourceGetRequest} ResourceGetRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourceGetRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ResourceGetRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.uint64();
                    break;
                case 2:
                    message.accessReason = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ResourceGetRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.ResourceGetRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.ResourceGetRequest} ResourceGetRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourceGetRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResourceGetRequest message.
         * @function verify
         * @memberof api.ResourceGetRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResourceGetRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                    return "id: integer|Long expected";
            if (message.accessReason != null && message.hasOwnProperty("accessReason"))
                if (!$util.isString(message.accessReason))
                    return "accessReason: string expected";
            return null;
        };

        /**
         * Creates a ResourceGetRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.ResourceGetRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.ResourceGetRequest} ResourceGetRequest
         */
        ResourceGetRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.api.ResourceGetRequest)
                return object;
            var message = new $root.api.ResourceGetRequest();
            if (object.id != null)
                if ($util.Long)
                    (message.id = $util.Long.fromValue(object.id)).unsigned = true;
                else if (typeof object.id === "string")
                    message.id = parseInt(object.id, 10);
                else if (typeof object.id === "number")
                    message.id = object.id;
                else if (typeof object.id === "object")
                    message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
            if (object.accessReason != null)
                message.accessReason = String(object.accessReason);
            return message;
        };

        /**
         * Creates a plain object from a ResourceGetRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.ResourceGetRequest
         * @static
         * @param {api.ResourceGetRequest} message ResourceGetRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResourceGetRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.id = options.longs === String ? "0" : 0;
                object.accessReason = "";
            }
            if (message.id != null && message.hasOwnProperty("id"))
                if (typeof message.id === "number")
                    object.id = options.longs === String ? String(message.id) : message.id;
                else
                    object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
            if (message.accessReason != null && message.hasOwnProperty("accessReason"))
                object.accessReason = message.accessReason;
            return object;
        };

        /**
         * Converts this ResourceGetRequest to JSON.
         * @function toJSON
         * @memberof api.ResourceGetRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResourceGetRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ResourceGetRequest;
    })();

    api.ResourceGetResponse = (function() {

        /**
         * Properties of a ResourceGetResponse.
         * @memberof api
         * @interface IResourceGetResponse
         * @property {api.IResource|null} [resource] ResourceGetResponse resource
         * @property {api.IIdentityKeyID|null} [owner] ResourceGetResponse owner
         * @property {api.IIdentityKeyID|null} [creator] ResourceGetResponse creator
         * @property {api.ICipher|null} [encryptedKey] ResourceGetResponse encryptedKey
         */

        /**
         * Constructs a new ResourceGetResponse.
         * @memberof api
         * @classdesc Represents a ResourceGetResponse.
         * @implements IResourceGetResponse
         * @constructor
         * @param {api.IResourceGetResponse=} [properties] Properties to set
         */
        function ResourceGetResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResourceGetResponse resource.
         * @member {api.IResource|null|undefined} resource
         * @memberof api.ResourceGetResponse
         * @instance
         */
        ResourceGetResponse.prototype.resource = null;

        /**
         * ResourceGetResponse owner.
         * @member {api.IIdentityKeyID|null|undefined} owner
         * @memberof api.ResourceGetResponse
         * @instance
         */
        ResourceGetResponse.prototype.owner = null;

        /**
         * ResourceGetResponse creator.
         * @member {api.IIdentityKeyID|null|undefined} creator
         * @memberof api.ResourceGetResponse
         * @instance
         */
        ResourceGetResponse.prototype.creator = null;

        /**
         * ResourceGetResponse encryptedKey.
         * @member {api.ICipher|null|undefined} encryptedKey
         * @memberof api.ResourceGetResponse
         * @instance
         */
        ResourceGetResponse.prototype.encryptedKey = null;

        /**
         * Creates a new ResourceGetResponse instance using the specified properties.
         * @function create
         * @memberof api.ResourceGetResponse
         * @static
         * @param {api.IResourceGetResponse=} [properties] Properties to set
         * @returns {api.ResourceGetResponse} ResourceGetResponse instance
         */
        ResourceGetResponse.create = function create(properties) {
            return new ResourceGetResponse(properties);
        };

        /**
         * Encodes the specified ResourceGetResponse message. Does not implicitly {@link api.ResourceGetResponse.verify|verify} messages.
         * @function encode
         * @memberof api.ResourceGetResponse
         * @static
         * @param {api.IResourceGetResponse} message ResourceGetResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourceGetResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.resource != null && message.hasOwnProperty("resource"))
                $root.api.Resource.encode(message.resource, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.owner != null && message.hasOwnProperty("owner"))
                $root.api.IdentityKeyID.encode(message.owner, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.creator != null && message.hasOwnProperty("creator"))
                $root.api.IdentityKeyID.encode(message.creator, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.encryptedKey != null && message.hasOwnProperty("encryptedKey"))
                $root.api.Cipher.encode(message.encryptedKey, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ResourceGetResponse message, length delimited. Does not implicitly {@link api.ResourceGetResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.ResourceGetResponse
         * @static
         * @param {api.IResourceGetResponse} message ResourceGetResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourceGetResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResourceGetResponse message from the specified reader or buffer.
         * @function decode
         * @memberof api.ResourceGetResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.ResourceGetResponse} ResourceGetResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourceGetResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ResourceGetResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.resource = $root.api.Resource.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.owner = $root.api.IdentityKeyID.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.creator = $root.api.IdentityKeyID.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.encryptedKey = $root.api.Cipher.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ResourceGetResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.ResourceGetResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.ResourceGetResponse} ResourceGetResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourceGetResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResourceGetResponse message.
         * @function verify
         * @memberof api.ResourceGetResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResourceGetResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.resource != null && message.hasOwnProperty("resource")) {
                var error = $root.api.Resource.verify(message.resource);
                if (error)
                    return "resource." + error;
            }
            if (message.owner != null && message.hasOwnProperty("owner")) {
                var error = $root.api.IdentityKeyID.verify(message.owner);
                if (error)
                    return "owner." + error;
            }
            if (message.creator != null && message.hasOwnProperty("creator")) {
                var error = $root.api.IdentityKeyID.verify(message.creator);
                if (error)
                    return "creator." + error;
            }
            if (message.encryptedKey != null && message.hasOwnProperty("encryptedKey")) {
                var error = $root.api.Cipher.verify(message.encryptedKey);
                if (error)
                    return "encryptedKey." + error;
            }
            return null;
        };

        /**
         * Creates a ResourceGetResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.ResourceGetResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.ResourceGetResponse} ResourceGetResponse
         */
        ResourceGetResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.api.ResourceGetResponse)
                return object;
            var message = new $root.api.ResourceGetResponse();
            if (object.resource != null) {
                if (typeof object.resource !== "object")
                    throw TypeError(".api.ResourceGetResponse.resource: object expected");
                message.resource = $root.api.Resource.fromObject(object.resource);
            }
            if (object.owner != null) {
                if (typeof object.owner !== "object")
                    throw TypeError(".api.ResourceGetResponse.owner: object expected");
                message.owner = $root.api.IdentityKeyID.fromObject(object.owner);
            }
            if (object.creator != null) {
                if (typeof object.creator !== "object")
                    throw TypeError(".api.ResourceGetResponse.creator: object expected");
                message.creator = $root.api.IdentityKeyID.fromObject(object.creator);
            }
            if (object.encryptedKey != null) {
                if (typeof object.encryptedKey !== "object")
                    throw TypeError(".api.ResourceGetResponse.encryptedKey: object expected");
                message.encryptedKey = $root.api.Cipher.fromObject(object.encryptedKey);
            }
            return message;
        };

        /**
         * Creates a plain object from a ResourceGetResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.ResourceGetResponse
         * @static
         * @param {api.ResourceGetResponse} message ResourceGetResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResourceGetResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.resource = null;
                object.owner = null;
                object.creator = null;
                object.encryptedKey = null;
            }
            if (message.resource != null && message.hasOwnProperty("resource"))
                object.resource = $root.api.Resource.toObject(message.resource, options);
            if (message.owner != null && message.hasOwnProperty("owner"))
                object.owner = $root.api.IdentityKeyID.toObject(message.owner, options);
            if (message.creator != null && message.hasOwnProperty("creator"))
                object.creator = $root.api.IdentityKeyID.toObject(message.creator, options);
            if (message.encryptedKey != null && message.hasOwnProperty("encryptedKey"))
                object.encryptedKey = $root.api.Cipher.toObject(message.encryptedKey, options);
            return object;
        };

        /**
         * Converts this ResourceGetResponse to JSON.
         * @function toJSON
         * @memberof api.ResourceGetResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResourceGetResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ResourceGetResponse;
    })();

    api.ResourceDeleteRequest = (function() {

        /**
         * Properties of a ResourceDeleteRequest.
         * @memberof api
         * @interface IResourceDeleteRequest
         * @property {number|Long|null} [id] ResourceDeleteRequest id
         * @property {boolean|null} [soft] ResourceDeleteRequest soft
         */

        /**
         * Constructs a new ResourceDeleteRequest.
         * @memberof api
         * @classdesc Represents a ResourceDeleteRequest.
         * @implements IResourceDeleteRequest
         * @constructor
         * @param {api.IResourceDeleteRequest=} [properties] Properties to set
         */
        function ResourceDeleteRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResourceDeleteRequest id.
         * @member {number|Long} id
         * @memberof api.ResourceDeleteRequest
         * @instance
         */
        ResourceDeleteRequest.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ResourceDeleteRequest soft.
         * @member {boolean} soft
         * @memberof api.ResourceDeleteRequest
         * @instance
         */
        ResourceDeleteRequest.prototype.soft = false;

        /**
         * Creates a new ResourceDeleteRequest instance using the specified properties.
         * @function create
         * @memberof api.ResourceDeleteRequest
         * @static
         * @param {api.IResourceDeleteRequest=} [properties] Properties to set
         * @returns {api.ResourceDeleteRequest} ResourceDeleteRequest instance
         */
        ResourceDeleteRequest.create = function create(properties) {
            return new ResourceDeleteRequest(properties);
        };

        /**
         * Encodes the specified ResourceDeleteRequest message. Does not implicitly {@link api.ResourceDeleteRequest.verify|verify} messages.
         * @function encode
         * @memberof api.ResourceDeleteRequest
         * @static
         * @param {api.IResourceDeleteRequest} message ResourceDeleteRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourceDeleteRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
            if (message.soft != null && message.hasOwnProperty("soft"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.soft);
            return writer;
        };

        /**
         * Encodes the specified ResourceDeleteRequest message, length delimited. Does not implicitly {@link api.ResourceDeleteRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.ResourceDeleteRequest
         * @static
         * @param {api.IResourceDeleteRequest} message ResourceDeleteRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourceDeleteRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResourceDeleteRequest message from the specified reader or buffer.
         * @function decode
         * @memberof api.ResourceDeleteRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.ResourceDeleteRequest} ResourceDeleteRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourceDeleteRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ResourceDeleteRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.uint64();
                    break;
                case 2:
                    message.soft = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ResourceDeleteRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.ResourceDeleteRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.ResourceDeleteRequest} ResourceDeleteRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourceDeleteRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResourceDeleteRequest message.
         * @function verify
         * @memberof api.ResourceDeleteRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResourceDeleteRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                    return "id: integer|Long expected";
            if (message.soft != null && message.hasOwnProperty("soft"))
                if (typeof message.soft !== "boolean")
                    return "soft: boolean expected";
            return null;
        };

        /**
         * Creates a ResourceDeleteRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.ResourceDeleteRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.ResourceDeleteRequest} ResourceDeleteRequest
         */
        ResourceDeleteRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.api.ResourceDeleteRequest)
                return object;
            var message = new $root.api.ResourceDeleteRequest();
            if (object.id != null)
                if ($util.Long)
                    (message.id = $util.Long.fromValue(object.id)).unsigned = true;
                else if (typeof object.id === "string")
                    message.id = parseInt(object.id, 10);
                else if (typeof object.id === "number")
                    message.id = object.id;
                else if (typeof object.id === "object")
                    message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
            if (object.soft != null)
                message.soft = Boolean(object.soft);
            return message;
        };

        /**
         * Creates a plain object from a ResourceDeleteRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.ResourceDeleteRequest
         * @static
         * @param {api.ResourceDeleteRequest} message ResourceDeleteRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResourceDeleteRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.id = options.longs === String ? "0" : 0;
                object.soft = false;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                if (typeof message.id === "number")
                    object.id = options.longs === String ? String(message.id) : message.id;
                else
                    object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
            if (message.soft != null && message.hasOwnProperty("soft"))
                object.soft = message.soft;
            return object;
        };

        /**
         * Converts this ResourceDeleteRequest to JSON.
         * @function toJSON
         * @memberof api.ResourceDeleteRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResourceDeleteRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ResourceDeleteRequest;
    })();

    api.ResourceGetKeyRequest = (function() {

        /**
         * Properties of a ResourceGetKeyRequest.
         * @memberof api
         * @interface IResourceGetKeyRequest
         * @property {number|Long|null} [id] ResourceGetKeyRequest id
         * @property {string|null} [accessReason] ResourceGetKeyRequest accessReason
         */

        /**
         * Constructs a new ResourceGetKeyRequest.
         * @memberof api
         * @classdesc Represents a ResourceGetKeyRequest.
         * @implements IResourceGetKeyRequest
         * @constructor
         * @param {api.IResourceGetKeyRequest=} [properties] Properties to set
         */
        function ResourceGetKeyRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResourceGetKeyRequest id.
         * @member {number|Long} id
         * @memberof api.ResourceGetKeyRequest
         * @instance
         */
        ResourceGetKeyRequest.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ResourceGetKeyRequest accessReason.
         * @member {string} accessReason
         * @memberof api.ResourceGetKeyRequest
         * @instance
         */
        ResourceGetKeyRequest.prototype.accessReason = "";

        /**
         * Creates a new ResourceGetKeyRequest instance using the specified properties.
         * @function create
         * @memberof api.ResourceGetKeyRequest
         * @static
         * @param {api.IResourceGetKeyRequest=} [properties] Properties to set
         * @returns {api.ResourceGetKeyRequest} ResourceGetKeyRequest instance
         */
        ResourceGetKeyRequest.create = function create(properties) {
            return new ResourceGetKeyRequest(properties);
        };

        /**
         * Encodes the specified ResourceGetKeyRequest message. Does not implicitly {@link api.ResourceGetKeyRequest.verify|verify} messages.
         * @function encode
         * @memberof api.ResourceGetKeyRequest
         * @static
         * @param {api.IResourceGetKeyRequest} message ResourceGetKeyRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourceGetKeyRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
            if (message.accessReason != null && message.hasOwnProperty("accessReason"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.accessReason);
            return writer;
        };

        /**
         * Encodes the specified ResourceGetKeyRequest message, length delimited. Does not implicitly {@link api.ResourceGetKeyRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.ResourceGetKeyRequest
         * @static
         * @param {api.IResourceGetKeyRequest} message ResourceGetKeyRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourceGetKeyRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResourceGetKeyRequest message from the specified reader or buffer.
         * @function decode
         * @memberof api.ResourceGetKeyRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.ResourceGetKeyRequest} ResourceGetKeyRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourceGetKeyRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ResourceGetKeyRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.uint64();
                    break;
                case 2:
                    message.accessReason = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ResourceGetKeyRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.ResourceGetKeyRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.ResourceGetKeyRequest} ResourceGetKeyRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourceGetKeyRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResourceGetKeyRequest message.
         * @function verify
         * @memberof api.ResourceGetKeyRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResourceGetKeyRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                    return "id: integer|Long expected";
            if (message.accessReason != null && message.hasOwnProperty("accessReason"))
                if (!$util.isString(message.accessReason))
                    return "accessReason: string expected";
            return null;
        };

        /**
         * Creates a ResourceGetKeyRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.ResourceGetKeyRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.ResourceGetKeyRequest} ResourceGetKeyRequest
         */
        ResourceGetKeyRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.api.ResourceGetKeyRequest)
                return object;
            var message = new $root.api.ResourceGetKeyRequest();
            if (object.id != null)
                if ($util.Long)
                    (message.id = $util.Long.fromValue(object.id)).unsigned = true;
                else if (typeof object.id === "string")
                    message.id = parseInt(object.id, 10);
                else if (typeof object.id === "number")
                    message.id = object.id;
                else if (typeof object.id === "object")
                    message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
            if (object.accessReason != null)
                message.accessReason = String(object.accessReason);
            return message;
        };

        /**
         * Creates a plain object from a ResourceGetKeyRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.ResourceGetKeyRequest
         * @static
         * @param {api.ResourceGetKeyRequest} message ResourceGetKeyRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResourceGetKeyRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.id = options.longs === String ? "0" : 0;
                object.accessReason = "";
            }
            if (message.id != null && message.hasOwnProperty("id"))
                if (typeof message.id === "number")
                    object.id = options.longs === String ? String(message.id) : message.id;
                else
                    object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
            if (message.accessReason != null && message.hasOwnProperty("accessReason"))
                object.accessReason = message.accessReason;
            return object;
        };

        /**
         * Converts this ResourceGetKeyRequest to JSON.
         * @function toJSON
         * @memberof api.ResourceGetKeyRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResourceGetKeyRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ResourceGetKeyRequest;
    })();

    api.ResourceGetSharingGroupRequest = (function() {

        /**
         * Properties of a ResourceGetSharingGroupRequest.
         * @memberof api
         * @interface IResourceGetSharingGroupRequest
         * @property {number|Long|null} [id] ResourceGetSharingGroupRequest id
         */

        /**
         * Constructs a new ResourceGetSharingGroupRequest.
         * @memberof api
         * @classdesc Represents a ResourceGetSharingGroupRequest.
         * @implements IResourceGetSharingGroupRequest
         * @constructor
         * @param {api.IResourceGetSharingGroupRequest=} [properties] Properties to set
         */
        function ResourceGetSharingGroupRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResourceGetSharingGroupRequest id.
         * @member {number|Long} id
         * @memberof api.ResourceGetSharingGroupRequest
         * @instance
         */
        ResourceGetSharingGroupRequest.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new ResourceGetSharingGroupRequest instance using the specified properties.
         * @function create
         * @memberof api.ResourceGetSharingGroupRequest
         * @static
         * @param {api.IResourceGetSharingGroupRequest=} [properties] Properties to set
         * @returns {api.ResourceGetSharingGroupRequest} ResourceGetSharingGroupRequest instance
         */
        ResourceGetSharingGroupRequest.create = function create(properties) {
            return new ResourceGetSharingGroupRequest(properties);
        };

        /**
         * Encodes the specified ResourceGetSharingGroupRequest message. Does not implicitly {@link api.ResourceGetSharingGroupRequest.verify|verify} messages.
         * @function encode
         * @memberof api.ResourceGetSharingGroupRequest
         * @static
         * @param {api.IResourceGetSharingGroupRequest} message ResourceGetSharingGroupRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourceGetSharingGroupRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
            return writer;
        };

        /**
         * Encodes the specified ResourceGetSharingGroupRequest message, length delimited. Does not implicitly {@link api.ResourceGetSharingGroupRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.ResourceGetSharingGroupRequest
         * @static
         * @param {api.IResourceGetSharingGroupRequest} message ResourceGetSharingGroupRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourceGetSharingGroupRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResourceGetSharingGroupRequest message from the specified reader or buffer.
         * @function decode
         * @memberof api.ResourceGetSharingGroupRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.ResourceGetSharingGroupRequest} ResourceGetSharingGroupRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourceGetSharingGroupRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ResourceGetSharingGroupRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ResourceGetSharingGroupRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.ResourceGetSharingGroupRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.ResourceGetSharingGroupRequest} ResourceGetSharingGroupRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourceGetSharingGroupRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResourceGetSharingGroupRequest message.
         * @function verify
         * @memberof api.ResourceGetSharingGroupRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResourceGetSharingGroupRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                    return "id: integer|Long expected";
            return null;
        };

        /**
         * Creates a ResourceGetSharingGroupRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.ResourceGetSharingGroupRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.ResourceGetSharingGroupRequest} ResourceGetSharingGroupRequest
         */
        ResourceGetSharingGroupRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.api.ResourceGetSharingGroupRequest)
                return object;
            var message = new $root.api.ResourceGetSharingGroupRequest();
            if (object.id != null)
                if ($util.Long)
                    (message.id = $util.Long.fromValue(object.id)).unsigned = true;
                else if (typeof object.id === "string")
                    message.id = parseInt(object.id, 10);
                else if (typeof object.id === "number")
                    message.id = object.id;
                else if (typeof object.id === "object")
                    message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a ResourceGetSharingGroupRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.ResourceGetSharingGroupRequest
         * @static
         * @param {api.ResourceGetSharingGroupRequest} message ResourceGetSharingGroupRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResourceGetSharingGroupRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.id = options.longs === String ? "0" : 0;
            if (message.id != null && message.hasOwnProperty("id"))
                if (typeof message.id === "number")
                    object.id = options.longs === String ? String(message.id) : message.id;
                else
                    object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
            return object;
        };

        /**
         * Converts this ResourceGetSharingGroupRequest to JSON.
         * @function toJSON
         * @memberof api.ResourceGetSharingGroupRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResourceGetSharingGroupRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ResourceGetSharingGroupRequest;
    })();

    api.ResourceGetKeyResponse = (function() {

        /**
         * Properties of a ResourceGetKeyResponse.
         * @memberof api
         * @interface IResourceGetKeyResponse
         * @property {api.ICipher|null} [encryptedKey] ResourceGetKeyResponse encryptedKey
         * @property {api.ResourceType|null} [type] ResourceGetKeyResponse type
         * @property {api.IIdentityKeyID|null} [owner] ResourceGetKeyResponse owner
         */

        /**
         * Constructs a new ResourceGetKeyResponse.
         * @memberof api
         * @classdesc Represents a ResourceGetKeyResponse.
         * @implements IResourceGetKeyResponse
         * @constructor
         * @param {api.IResourceGetKeyResponse=} [properties] Properties to set
         */
        function ResourceGetKeyResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResourceGetKeyResponse encryptedKey.
         * @member {api.ICipher|null|undefined} encryptedKey
         * @memberof api.ResourceGetKeyResponse
         * @instance
         */
        ResourceGetKeyResponse.prototype.encryptedKey = null;

        /**
         * ResourceGetKeyResponse type.
         * @member {api.ResourceType} type
         * @memberof api.ResourceGetKeyResponse
         * @instance
         */
        ResourceGetKeyResponse.prototype.type = 0;

        /**
         * ResourceGetKeyResponse owner.
         * @member {api.IIdentityKeyID|null|undefined} owner
         * @memberof api.ResourceGetKeyResponse
         * @instance
         */
        ResourceGetKeyResponse.prototype.owner = null;

        /**
         * Creates a new ResourceGetKeyResponse instance using the specified properties.
         * @function create
         * @memberof api.ResourceGetKeyResponse
         * @static
         * @param {api.IResourceGetKeyResponse=} [properties] Properties to set
         * @returns {api.ResourceGetKeyResponse} ResourceGetKeyResponse instance
         */
        ResourceGetKeyResponse.create = function create(properties) {
            return new ResourceGetKeyResponse(properties);
        };

        /**
         * Encodes the specified ResourceGetKeyResponse message. Does not implicitly {@link api.ResourceGetKeyResponse.verify|verify} messages.
         * @function encode
         * @memberof api.ResourceGetKeyResponse
         * @static
         * @param {api.IResourceGetKeyResponse} message ResourceGetKeyResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourceGetKeyResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.encryptedKey != null && message.hasOwnProperty("encryptedKey"))
                $root.api.Cipher.encode(message.encryptedKey, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
            if (message.owner != null && message.hasOwnProperty("owner"))
                $root.api.IdentityKeyID.encode(message.owner, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ResourceGetKeyResponse message, length delimited. Does not implicitly {@link api.ResourceGetKeyResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.ResourceGetKeyResponse
         * @static
         * @param {api.IResourceGetKeyResponse} message ResourceGetKeyResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourceGetKeyResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResourceGetKeyResponse message from the specified reader or buffer.
         * @function decode
         * @memberof api.ResourceGetKeyResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.ResourceGetKeyResponse} ResourceGetKeyResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourceGetKeyResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ResourceGetKeyResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.encryptedKey = $root.api.Cipher.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.type = reader.int32();
                    break;
                case 3:
                    message.owner = $root.api.IdentityKeyID.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ResourceGetKeyResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.ResourceGetKeyResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.ResourceGetKeyResponse} ResourceGetKeyResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourceGetKeyResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResourceGetKeyResponse message.
         * @function verify
         * @memberof api.ResourceGetKeyResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResourceGetKeyResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.encryptedKey != null && message.hasOwnProperty("encryptedKey")) {
                var error = $root.api.Cipher.verify(message.encryptedKey);
                if (error)
                    return "encryptedKey." + error;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.owner != null && message.hasOwnProperty("owner")) {
                var error = $root.api.IdentityKeyID.verify(message.owner);
                if (error)
                    return "owner." + error;
            }
            return null;
        };

        /**
         * Creates a ResourceGetKeyResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.ResourceGetKeyResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.ResourceGetKeyResponse} ResourceGetKeyResponse
         */
        ResourceGetKeyResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.api.ResourceGetKeyResponse)
                return object;
            var message = new $root.api.ResourceGetKeyResponse();
            if (object.encryptedKey != null) {
                if (typeof object.encryptedKey !== "object")
                    throw TypeError(".api.ResourceGetKeyResponse.encryptedKey: object expected");
                message.encryptedKey = $root.api.Cipher.fromObject(object.encryptedKey);
            }
            switch (object.type) {
            case "ANONYMOUS":
            case 0:
                message.type = 0;
                break;
            case "SES":
            case 1:
                message.type = 1;
                break;
            }
            if (object.owner != null) {
                if (typeof object.owner !== "object")
                    throw TypeError(".api.ResourceGetKeyResponse.owner: object expected");
                message.owner = $root.api.IdentityKeyID.fromObject(object.owner);
            }
            return message;
        };

        /**
         * Creates a plain object from a ResourceGetKeyResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.ResourceGetKeyResponse
         * @static
         * @param {api.ResourceGetKeyResponse} message ResourceGetKeyResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResourceGetKeyResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.encryptedKey = null;
                object.type = options.enums === String ? "ANONYMOUS" : 0;
                object.owner = null;
            }
            if (message.encryptedKey != null && message.hasOwnProperty("encryptedKey"))
                object.encryptedKey = $root.api.Cipher.toObject(message.encryptedKey, options);
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.api.ResourceType[message.type] : message.type;
            if (message.owner != null && message.hasOwnProperty("owner"))
                object.owner = $root.api.IdentityKeyID.toObject(message.owner, options);
            return object;
        };

        /**
         * Converts this ResourceGetKeyResponse to JSON.
         * @function toJSON
         * @memberof api.ResourceGetKeyResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResourceGetKeyResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ResourceGetKeyResponse;
    })();

    api.ResourceShareEntry = (function() {

        /**
         * Properties of a ResourceShareEntry.
         * @memberof api
         * @interface IResourceShareEntry
         * @property {string|null} [login] ResourceShareEntry login
         * @property {number|null} [version] ResourceShareEntry version
         * @property {Uint8Array|null} [nonce] ResourceShareEntry nonce
         * @property {Uint8Array|null} [encryptedKey] ResourceShareEntry encryptedKey
         */

        /**
         * Constructs a new ResourceShareEntry.
         * @memberof api
         * @classdesc Represents a ResourceShareEntry.
         * @implements IResourceShareEntry
         * @constructor
         * @param {api.IResourceShareEntry=} [properties] Properties to set
         */
        function ResourceShareEntry(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResourceShareEntry login.
         * @member {string} login
         * @memberof api.ResourceShareEntry
         * @instance
         */
        ResourceShareEntry.prototype.login = "";

        /**
         * ResourceShareEntry version.
         * @member {number} version
         * @memberof api.ResourceShareEntry
         * @instance
         */
        ResourceShareEntry.prototype.version = 0;

        /**
         * ResourceShareEntry nonce.
         * @member {Uint8Array} nonce
         * @memberof api.ResourceShareEntry
         * @instance
         */
        ResourceShareEntry.prototype.nonce = $util.newBuffer([]);

        /**
         * ResourceShareEntry encryptedKey.
         * @member {Uint8Array} encryptedKey
         * @memberof api.ResourceShareEntry
         * @instance
         */
        ResourceShareEntry.prototype.encryptedKey = $util.newBuffer([]);

        /**
         * Creates a new ResourceShareEntry instance using the specified properties.
         * @function create
         * @memberof api.ResourceShareEntry
         * @static
         * @param {api.IResourceShareEntry=} [properties] Properties to set
         * @returns {api.ResourceShareEntry} ResourceShareEntry instance
         */
        ResourceShareEntry.create = function create(properties) {
            return new ResourceShareEntry(properties);
        };

        /**
         * Encodes the specified ResourceShareEntry message. Does not implicitly {@link api.ResourceShareEntry.verify|verify} messages.
         * @function encode
         * @memberof api.ResourceShareEntry
         * @static
         * @param {api.IResourceShareEntry} message ResourceShareEntry message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourceShareEntry.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            if (message.version != null && message.hasOwnProperty("version"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.version);
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.nonce);
            if (message.encryptedKey != null && message.hasOwnProperty("encryptedKey"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.encryptedKey);
            return writer;
        };

        /**
         * Encodes the specified ResourceShareEntry message, length delimited. Does not implicitly {@link api.ResourceShareEntry.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.ResourceShareEntry
         * @static
         * @param {api.IResourceShareEntry} message ResourceShareEntry message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourceShareEntry.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResourceShareEntry message from the specified reader or buffer.
         * @function decode
         * @memberof api.ResourceShareEntry
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.ResourceShareEntry} ResourceShareEntry
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourceShareEntry.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ResourceShareEntry();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                case 2:
                    message.version = reader.uint32();
                    break;
                case 3:
                    message.nonce = reader.bytes();
                    break;
                case 4:
                    message.encryptedKey = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ResourceShareEntry message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.ResourceShareEntry
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.ResourceShareEntry} ResourceShareEntry
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourceShareEntry.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResourceShareEntry message.
         * @function verify
         * @memberof api.ResourceShareEntry
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResourceShareEntry.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isInteger(message.version))
                    return "version: integer expected";
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                if (!(message.nonce && typeof message.nonce.length === "number" || $util.isString(message.nonce)))
                    return "nonce: buffer expected";
            if (message.encryptedKey != null && message.hasOwnProperty("encryptedKey"))
                if (!(message.encryptedKey && typeof message.encryptedKey.length === "number" || $util.isString(message.encryptedKey)))
                    return "encryptedKey: buffer expected";
            return null;
        };

        /**
         * Creates a ResourceShareEntry message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.ResourceShareEntry
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.ResourceShareEntry} ResourceShareEntry
         */
        ResourceShareEntry.fromObject = function fromObject(object) {
            if (object instanceof $root.api.ResourceShareEntry)
                return object;
            var message = new $root.api.ResourceShareEntry();
            if (object.login != null)
                message.login = String(object.login);
            if (object.version != null)
                message.version = object.version >>> 0;
            if (object.nonce != null)
                if (typeof object.nonce === "string")
                    $util.base64.decode(object.nonce, message.nonce = $util.newBuffer($util.base64.length(object.nonce)), 0);
                else if (object.nonce.length)
                    message.nonce = object.nonce;
            if (object.encryptedKey != null)
                if (typeof object.encryptedKey === "string")
                    $util.base64.decode(object.encryptedKey, message.encryptedKey = $util.newBuffer($util.base64.length(object.encryptedKey)), 0);
                else if (object.encryptedKey.length)
                    message.encryptedKey = object.encryptedKey;
            return message;
        };

        /**
         * Creates a plain object from a ResourceShareEntry message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.ResourceShareEntry
         * @static
         * @param {api.ResourceShareEntry} message ResourceShareEntry
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResourceShareEntry.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.login = "";
                object.version = 0;
                if (options.bytes === String)
                    object.nonce = "";
                else {
                    object.nonce = [];
                    if (options.bytes !== Array)
                        object.nonce = $util.newBuffer(object.nonce);
                }
                if (options.bytes === String)
                    object.encryptedKey = "";
                else {
                    object.encryptedKey = [];
                    if (options.bytes !== Array)
                        object.encryptedKey = $util.newBuffer(object.encryptedKey);
                }
            }
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                object.nonce = options.bytes === String ? $util.base64.encode(message.nonce, 0, message.nonce.length) : options.bytes === Array ? Array.prototype.slice.call(message.nonce) : message.nonce;
            if (message.encryptedKey != null && message.hasOwnProperty("encryptedKey"))
                object.encryptedKey = options.bytes === String ? $util.base64.encode(message.encryptedKey, 0, message.encryptedKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedKey) : message.encryptedKey;
            return object;
        };

        /**
         * Converts this ResourceShareEntry to JSON.
         * @function toJSON
         * @memberof api.ResourceShareEntry
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResourceShareEntry.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ResourceShareEntry;
    })();

    api.ResourcePostRequest = (function() {

        /**
         * Properties of a ResourcePostRequest.
         * @memberof api
         * @interface IResourcePostRequest
         * @property {string|null} [kind] ResourcePostRequest kind
         * @property {Uint8Array|null} [publicKey] ResourcePostRequest publicKey
         * @property {Uint8Array|null} [nonce] ResourcePostRequest nonce
         * @property {Uint8Array|null} [payload] ResourcePostRequest payload
         * @property {Array.<api.IResourceShareEntry>|null} [sharingGroup] ResourcePostRequest sharingGroup
         * @property {api.ResourceType|null} [type] ResourcePostRequest type
         */

        /**
         * Constructs a new ResourcePostRequest.
         * @memberof api
         * @classdesc Represents a ResourcePostRequest.
         * @implements IResourcePostRequest
         * @constructor
         * @param {api.IResourcePostRequest=} [properties] Properties to set
         */
        function ResourcePostRequest(properties) {
            this.sharingGroup = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResourcePostRequest kind.
         * @member {string} kind
         * @memberof api.ResourcePostRequest
         * @instance
         */
        ResourcePostRequest.prototype.kind = "";

        /**
         * ResourcePostRequest publicKey.
         * @member {Uint8Array} publicKey
         * @memberof api.ResourcePostRequest
         * @instance
         */
        ResourcePostRequest.prototype.publicKey = $util.newBuffer([]);

        /**
         * ResourcePostRequest nonce.
         * @member {Uint8Array} nonce
         * @memberof api.ResourcePostRequest
         * @instance
         */
        ResourcePostRequest.prototype.nonce = $util.newBuffer([]);

        /**
         * ResourcePostRequest payload.
         * @member {Uint8Array} payload
         * @memberof api.ResourcePostRequest
         * @instance
         */
        ResourcePostRequest.prototype.payload = $util.newBuffer([]);

        /**
         * ResourcePostRequest sharingGroup.
         * @member {Array.<api.IResourceShareEntry>} sharingGroup
         * @memberof api.ResourcePostRequest
         * @instance
         */
        ResourcePostRequest.prototype.sharingGroup = $util.emptyArray;

        /**
         * ResourcePostRequest type.
         * @member {api.ResourceType} type
         * @memberof api.ResourcePostRequest
         * @instance
         */
        ResourcePostRequest.prototype.type = 0;

        /**
         * Creates a new ResourcePostRequest instance using the specified properties.
         * @function create
         * @memberof api.ResourcePostRequest
         * @static
         * @param {api.IResourcePostRequest=} [properties] Properties to set
         * @returns {api.ResourcePostRequest} ResourcePostRequest instance
         */
        ResourcePostRequest.create = function create(properties) {
            return new ResourcePostRequest(properties);
        };

        /**
         * Encodes the specified ResourcePostRequest message. Does not implicitly {@link api.ResourcePostRequest.verify|verify} messages.
         * @function encode
         * @memberof api.ResourcePostRequest
         * @static
         * @param {api.IResourcePostRequest} message ResourcePostRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourcePostRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.kind != null && message.hasOwnProperty("kind"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.kind);
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.publicKey);
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.nonce);
            if (message.payload != null && message.hasOwnProperty("payload"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.payload);
            if (message.sharingGroup != null && message.sharingGroup.length)
                for (var i = 0; i < message.sharingGroup.length; ++i)
                    $root.api.ResourceShareEntry.encode(message.sharingGroup[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.type);
            return writer;
        };

        /**
         * Encodes the specified ResourcePostRequest message, length delimited. Does not implicitly {@link api.ResourcePostRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.ResourcePostRequest
         * @static
         * @param {api.IResourcePostRequest} message ResourcePostRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourcePostRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResourcePostRequest message from the specified reader or buffer.
         * @function decode
         * @memberof api.ResourcePostRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.ResourcePostRequest} ResourcePostRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourcePostRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ResourcePostRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.kind = reader.string();
                    break;
                case 2:
                    message.publicKey = reader.bytes();
                    break;
                case 3:
                    message.nonce = reader.bytes();
                    break;
                case 4:
                    message.payload = reader.bytes();
                    break;
                case 5:
                    if (!(message.sharingGroup && message.sharingGroup.length))
                        message.sharingGroup = [];
                    message.sharingGroup.push($root.api.ResourceShareEntry.decode(reader, reader.uint32()));
                    break;
                case 6:
                    message.type = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ResourcePostRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.ResourcePostRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.ResourcePostRequest} ResourcePostRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourcePostRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResourcePostRequest message.
         * @function verify
         * @memberof api.ResourcePostRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResourcePostRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.kind != null && message.hasOwnProperty("kind"))
                if (!$util.isString(message.kind))
                    return "kind: string expected";
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                if (!(message.publicKey && typeof message.publicKey.length === "number" || $util.isString(message.publicKey)))
                    return "publicKey: buffer expected";
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                if (!(message.nonce && typeof message.nonce.length === "number" || $util.isString(message.nonce)))
                    return "nonce: buffer expected";
            if (message.payload != null && message.hasOwnProperty("payload"))
                if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                    return "payload: buffer expected";
            if (message.sharingGroup != null && message.hasOwnProperty("sharingGroup")) {
                if (!Array.isArray(message.sharingGroup))
                    return "sharingGroup: array expected";
                for (var i = 0; i < message.sharingGroup.length; ++i) {
                    var error = $root.api.ResourceShareEntry.verify(message.sharingGroup[i]);
                    if (error)
                        return "sharingGroup." + error;
                }
            }
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                    break;
                }
            return null;
        };

        /**
         * Creates a ResourcePostRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.ResourcePostRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.ResourcePostRequest} ResourcePostRequest
         */
        ResourcePostRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.api.ResourcePostRequest)
                return object;
            var message = new $root.api.ResourcePostRequest();
            if (object.kind != null)
                message.kind = String(object.kind);
            if (object.publicKey != null)
                if (typeof object.publicKey === "string")
                    $util.base64.decode(object.publicKey, message.publicKey = $util.newBuffer($util.base64.length(object.publicKey)), 0);
                else if (object.publicKey.length)
                    message.publicKey = object.publicKey;
            if (object.nonce != null)
                if (typeof object.nonce === "string")
                    $util.base64.decode(object.nonce, message.nonce = $util.newBuffer($util.base64.length(object.nonce)), 0);
                else if (object.nonce.length)
                    message.nonce = object.nonce;
            if (object.payload != null)
                if (typeof object.payload === "string")
                    $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                else if (object.payload.length)
                    message.payload = object.payload;
            if (object.sharingGroup) {
                if (!Array.isArray(object.sharingGroup))
                    throw TypeError(".api.ResourcePostRequest.sharingGroup: array expected");
                message.sharingGroup = [];
                for (var i = 0; i < object.sharingGroup.length; ++i) {
                    if (typeof object.sharingGroup[i] !== "object")
                        throw TypeError(".api.ResourcePostRequest.sharingGroup: object expected");
                    message.sharingGroup[i] = $root.api.ResourceShareEntry.fromObject(object.sharingGroup[i]);
                }
            }
            switch (object.type) {
            case "ANONYMOUS":
            case 0:
                message.type = 0;
                break;
            case "SES":
            case 1:
                message.type = 1;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a ResourcePostRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.ResourcePostRequest
         * @static
         * @param {api.ResourcePostRequest} message ResourcePostRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResourcePostRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.sharingGroup = [];
            if (options.defaults) {
                object.kind = "";
                if (options.bytes === String)
                    object.publicKey = "";
                else {
                    object.publicKey = [];
                    if (options.bytes !== Array)
                        object.publicKey = $util.newBuffer(object.publicKey);
                }
                if (options.bytes === String)
                    object.nonce = "";
                else {
                    object.nonce = [];
                    if (options.bytes !== Array)
                        object.nonce = $util.newBuffer(object.nonce);
                }
                if (options.bytes === String)
                    object.payload = "";
                else {
                    object.payload = [];
                    if (options.bytes !== Array)
                        object.payload = $util.newBuffer(object.payload);
                }
                object.type = options.enums === String ? "ANONYMOUS" : 0;
            }
            if (message.kind != null && message.hasOwnProperty("kind"))
                object.kind = message.kind;
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                object.publicKey = options.bytes === String ? $util.base64.encode(message.publicKey, 0, message.publicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.publicKey) : message.publicKey;
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                object.nonce = options.bytes === String ? $util.base64.encode(message.nonce, 0, message.nonce.length) : options.bytes === Array ? Array.prototype.slice.call(message.nonce) : message.nonce;
            if (message.payload != null && message.hasOwnProperty("payload"))
                object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
            if (message.sharingGroup && message.sharingGroup.length) {
                object.sharingGroup = [];
                for (var j = 0; j < message.sharingGroup.length; ++j)
                    object.sharingGroup[j] = $root.api.ResourceShareEntry.toObject(message.sharingGroup[j], options);
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.api.ResourceType[message.type] : message.type;
            return object;
        };

        /**
         * Converts this ResourcePostRequest to JSON.
         * @function toJSON
         * @memberof api.ResourcePostRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResourcePostRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ResourcePostRequest;
    })();

    api.ResourcePostResponse = (function() {

        /**
         * Properties of a ResourcePostResponse.
         * @memberof api
         * @interface IResourcePostResponse
         * @property {number|Long|null} [id] ResourcePostResponse id
         */

        /**
         * Constructs a new ResourcePostResponse.
         * @memberof api
         * @classdesc Represents a ResourcePostResponse.
         * @implements IResourcePostResponse
         * @constructor
         * @param {api.IResourcePostResponse=} [properties] Properties to set
         */
        function ResourcePostResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResourcePostResponse id.
         * @member {number|Long} id
         * @memberof api.ResourcePostResponse
         * @instance
         */
        ResourcePostResponse.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new ResourcePostResponse instance using the specified properties.
         * @function create
         * @memberof api.ResourcePostResponse
         * @static
         * @param {api.IResourcePostResponse=} [properties] Properties to set
         * @returns {api.ResourcePostResponse} ResourcePostResponse instance
         */
        ResourcePostResponse.create = function create(properties) {
            return new ResourcePostResponse(properties);
        };

        /**
         * Encodes the specified ResourcePostResponse message. Does not implicitly {@link api.ResourcePostResponse.verify|verify} messages.
         * @function encode
         * @memberof api.ResourcePostResponse
         * @static
         * @param {api.IResourcePostResponse} message ResourcePostResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourcePostResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
            return writer;
        };

        /**
         * Encodes the specified ResourcePostResponse message, length delimited. Does not implicitly {@link api.ResourcePostResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.ResourcePostResponse
         * @static
         * @param {api.IResourcePostResponse} message ResourcePostResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourcePostResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResourcePostResponse message from the specified reader or buffer.
         * @function decode
         * @memberof api.ResourcePostResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.ResourcePostResponse} ResourcePostResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourcePostResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ResourcePostResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ResourcePostResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.ResourcePostResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.ResourcePostResponse} ResourcePostResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourcePostResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResourcePostResponse message.
         * @function verify
         * @memberof api.ResourcePostResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResourcePostResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                    return "id: integer|Long expected";
            return null;
        };

        /**
         * Creates a ResourcePostResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.ResourcePostResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.ResourcePostResponse} ResourcePostResponse
         */
        ResourcePostResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.api.ResourcePostResponse)
                return object;
            var message = new $root.api.ResourcePostResponse();
            if (object.id != null)
                if ($util.Long)
                    (message.id = $util.Long.fromValue(object.id)).unsigned = true;
                else if (typeof object.id === "string")
                    message.id = parseInt(object.id, 10);
                else if (typeof object.id === "number")
                    message.id = object.id;
                else if (typeof object.id === "object")
                    message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a ResourcePostResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.ResourcePostResponse
         * @static
         * @param {api.ResourcePostResponse} message ResourcePostResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResourcePostResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.id = options.longs === String ? "0" : 0;
            if (message.id != null && message.hasOwnProperty("id"))
                if (typeof message.id === "number")
                    object.id = options.longs === String ? String(message.id) : message.id;
                else
                    object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
            return object;
        };

        /**
         * Converts this ResourcePostResponse to JSON.
         * @function toJSON
         * @memberof api.ResourcePostResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResourcePostResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ResourcePostResponse;
    })();

    api.ResourceExtendSharingGroupRequest = (function() {

        /**
         * Properties of a ResourceExtendSharingGroupRequest.
         * @memberof api
         * @interface IResourceExtendSharingGroupRequest
         * @property {number|Long|null} [id] ResourceExtendSharingGroupRequest id
         * @property {Array.<api.IResourceShareEntry>|null} [sharingGroup] ResourceExtendSharingGroupRequest sharingGroup
         */

        /**
         * Constructs a new ResourceExtendSharingGroupRequest.
         * @memberof api
         * @classdesc Represents a ResourceExtendSharingGroupRequest.
         * @implements IResourceExtendSharingGroupRequest
         * @constructor
         * @param {api.IResourceExtendSharingGroupRequest=} [properties] Properties to set
         */
        function ResourceExtendSharingGroupRequest(properties) {
            this.sharingGroup = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResourceExtendSharingGroupRequest id.
         * @member {number|Long} id
         * @memberof api.ResourceExtendSharingGroupRequest
         * @instance
         */
        ResourceExtendSharingGroupRequest.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ResourceExtendSharingGroupRequest sharingGroup.
         * @member {Array.<api.IResourceShareEntry>} sharingGroup
         * @memberof api.ResourceExtendSharingGroupRequest
         * @instance
         */
        ResourceExtendSharingGroupRequest.prototype.sharingGroup = $util.emptyArray;

        /**
         * Creates a new ResourceExtendSharingGroupRequest instance using the specified properties.
         * @function create
         * @memberof api.ResourceExtendSharingGroupRequest
         * @static
         * @param {api.IResourceExtendSharingGroupRequest=} [properties] Properties to set
         * @returns {api.ResourceExtendSharingGroupRequest} ResourceExtendSharingGroupRequest instance
         */
        ResourceExtendSharingGroupRequest.create = function create(properties) {
            return new ResourceExtendSharingGroupRequest(properties);
        };

        /**
         * Encodes the specified ResourceExtendSharingGroupRequest message. Does not implicitly {@link api.ResourceExtendSharingGroupRequest.verify|verify} messages.
         * @function encode
         * @memberof api.ResourceExtendSharingGroupRequest
         * @static
         * @param {api.IResourceExtendSharingGroupRequest} message ResourceExtendSharingGroupRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourceExtendSharingGroupRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
            if (message.sharingGroup != null && message.sharingGroup.length)
                for (var i = 0; i < message.sharingGroup.length; ++i)
                    $root.api.ResourceShareEntry.encode(message.sharingGroup[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ResourceExtendSharingGroupRequest message, length delimited. Does not implicitly {@link api.ResourceExtendSharingGroupRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.ResourceExtendSharingGroupRequest
         * @static
         * @param {api.IResourceExtendSharingGroupRequest} message ResourceExtendSharingGroupRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourceExtendSharingGroupRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResourceExtendSharingGroupRequest message from the specified reader or buffer.
         * @function decode
         * @memberof api.ResourceExtendSharingGroupRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.ResourceExtendSharingGroupRequest} ResourceExtendSharingGroupRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourceExtendSharingGroupRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ResourceExtendSharingGroupRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.uint64();
                    break;
                case 2:
                    if (!(message.sharingGroup && message.sharingGroup.length))
                        message.sharingGroup = [];
                    message.sharingGroup.push($root.api.ResourceShareEntry.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ResourceExtendSharingGroupRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.ResourceExtendSharingGroupRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.ResourceExtendSharingGroupRequest} ResourceExtendSharingGroupRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourceExtendSharingGroupRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResourceExtendSharingGroupRequest message.
         * @function verify
         * @memberof api.ResourceExtendSharingGroupRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResourceExtendSharingGroupRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                    return "id: integer|Long expected";
            if (message.sharingGroup != null && message.hasOwnProperty("sharingGroup")) {
                if (!Array.isArray(message.sharingGroup))
                    return "sharingGroup: array expected";
                for (var i = 0; i < message.sharingGroup.length; ++i) {
                    var error = $root.api.ResourceShareEntry.verify(message.sharingGroup[i]);
                    if (error)
                        return "sharingGroup." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ResourceExtendSharingGroupRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.ResourceExtendSharingGroupRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.ResourceExtendSharingGroupRequest} ResourceExtendSharingGroupRequest
         */
        ResourceExtendSharingGroupRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.api.ResourceExtendSharingGroupRequest)
                return object;
            var message = new $root.api.ResourceExtendSharingGroupRequest();
            if (object.id != null)
                if ($util.Long)
                    (message.id = $util.Long.fromValue(object.id)).unsigned = true;
                else if (typeof object.id === "string")
                    message.id = parseInt(object.id, 10);
                else if (typeof object.id === "number")
                    message.id = object.id;
                else if (typeof object.id === "object")
                    message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
            if (object.sharingGroup) {
                if (!Array.isArray(object.sharingGroup))
                    throw TypeError(".api.ResourceExtendSharingGroupRequest.sharingGroup: array expected");
                message.sharingGroup = [];
                for (var i = 0; i < object.sharingGroup.length; ++i) {
                    if (typeof object.sharingGroup[i] !== "object")
                        throw TypeError(".api.ResourceExtendSharingGroupRequest.sharingGroup: object expected");
                    message.sharingGroup[i] = $root.api.ResourceShareEntry.fromObject(object.sharingGroup[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ResourceExtendSharingGroupRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.ResourceExtendSharingGroupRequest
         * @static
         * @param {api.ResourceExtendSharingGroupRequest} message ResourceExtendSharingGroupRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResourceExtendSharingGroupRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.sharingGroup = [];
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.id = options.longs === String ? "0" : 0;
            if (message.id != null && message.hasOwnProperty("id"))
                if (typeof message.id === "number")
                    object.id = options.longs === String ? String(message.id) : message.id;
                else
                    object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
            if (message.sharingGroup && message.sharingGroup.length) {
                object.sharingGroup = [];
                for (var j = 0; j < message.sharingGroup.length; ++j)
                    object.sharingGroup[j] = $root.api.ResourceShareEntry.toObject(message.sharingGroup[j], options);
            }
            return object;
        };

        /**
         * Converts this ResourceExtendSharingGroupRequest to JSON.
         * @function toJSON
         * @memberof api.ResourceExtendSharingGroupRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResourceExtendSharingGroupRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ResourceExtendSharingGroupRequest;
    })();

    api.ResourceListRequest = (function() {

        /**
         * Properties of a ResourceListRequest.
         * @memberof api
         * @interface IResourceListRequest
         * @property {number|null} [limit] ResourceListRequest limit
         * @property {number|null} [offset] ResourceListRequest offset
         * @property {string|null} [accessReason] ResourceListRequest accessReason
         */

        /**
         * Constructs a new ResourceListRequest.
         * @memberof api
         * @classdesc Represents a ResourceListRequest.
         * @implements IResourceListRequest
         * @constructor
         * @param {api.IResourceListRequest=} [properties] Properties to set
         */
        function ResourceListRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResourceListRequest limit.
         * @member {number} limit
         * @memberof api.ResourceListRequest
         * @instance
         */
        ResourceListRequest.prototype.limit = 0;

        /**
         * ResourceListRequest offset.
         * @member {number} offset
         * @memberof api.ResourceListRequest
         * @instance
         */
        ResourceListRequest.prototype.offset = 0;

        /**
         * ResourceListRequest accessReason.
         * @member {string} accessReason
         * @memberof api.ResourceListRequest
         * @instance
         */
        ResourceListRequest.prototype.accessReason = "";

        /**
         * Creates a new ResourceListRequest instance using the specified properties.
         * @function create
         * @memberof api.ResourceListRequest
         * @static
         * @param {api.IResourceListRequest=} [properties] Properties to set
         * @returns {api.ResourceListRequest} ResourceListRequest instance
         */
        ResourceListRequest.create = function create(properties) {
            return new ResourceListRequest(properties);
        };

        /**
         * Encodes the specified ResourceListRequest message. Does not implicitly {@link api.ResourceListRequest.verify|verify} messages.
         * @function encode
         * @memberof api.ResourceListRequest
         * @static
         * @param {api.IResourceListRequest} message ResourceListRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourceListRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.limit != null && message.hasOwnProperty("limit"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.limit);
            if (message.offset != null && message.hasOwnProperty("offset"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.offset);
            if (message.accessReason != null && message.hasOwnProperty("accessReason"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.accessReason);
            return writer;
        };

        /**
         * Encodes the specified ResourceListRequest message, length delimited. Does not implicitly {@link api.ResourceListRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.ResourceListRequest
         * @static
         * @param {api.IResourceListRequest} message ResourceListRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourceListRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResourceListRequest message from the specified reader or buffer.
         * @function decode
         * @memberof api.ResourceListRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.ResourceListRequest} ResourceListRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourceListRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ResourceListRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.limit = reader.uint32();
                    break;
                case 2:
                    message.offset = reader.uint32();
                    break;
                case 3:
                    message.accessReason = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ResourceListRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.ResourceListRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.ResourceListRequest} ResourceListRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourceListRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResourceListRequest message.
         * @function verify
         * @memberof api.ResourceListRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResourceListRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.limit != null && message.hasOwnProperty("limit"))
                if (!$util.isInteger(message.limit))
                    return "limit: integer expected";
            if (message.offset != null && message.hasOwnProperty("offset"))
                if (!$util.isInteger(message.offset))
                    return "offset: integer expected";
            if (message.accessReason != null && message.hasOwnProperty("accessReason"))
                if (!$util.isString(message.accessReason))
                    return "accessReason: string expected";
            return null;
        };

        /**
         * Creates a ResourceListRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.ResourceListRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.ResourceListRequest} ResourceListRequest
         */
        ResourceListRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.api.ResourceListRequest)
                return object;
            var message = new $root.api.ResourceListRequest();
            if (object.limit != null)
                message.limit = object.limit >>> 0;
            if (object.offset != null)
                message.offset = object.offset >>> 0;
            if (object.accessReason != null)
                message.accessReason = String(object.accessReason);
            return message;
        };

        /**
         * Creates a plain object from a ResourceListRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.ResourceListRequest
         * @static
         * @param {api.ResourceListRequest} message ResourceListRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResourceListRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.limit = 0;
                object.offset = 0;
                object.accessReason = "";
            }
            if (message.limit != null && message.hasOwnProperty("limit"))
                object.limit = message.limit;
            if (message.offset != null && message.hasOwnProperty("offset"))
                object.offset = message.offset;
            if (message.accessReason != null && message.hasOwnProperty("accessReason"))
                object.accessReason = message.accessReason;
            return object;
        };

        /**
         * Converts this ResourceListRequest to JSON.
         * @function toJSON
         * @memberof api.ResourceListRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResourceListRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ResourceListRequest;
    })();

    api.ResourceListResponse = (function() {

        /**
         * Properties of a ResourceListResponse.
         * @memberof api
         * @interface IResourceListResponse
         * @property {Array.<api.IResourceGetResponse>|null} [resources] ResourceListResponse resources
         */

        /**
         * Constructs a new ResourceListResponse.
         * @memberof api
         * @classdesc Represents a ResourceListResponse.
         * @implements IResourceListResponse
         * @constructor
         * @param {api.IResourceListResponse=} [properties] Properties to set
         */
        function ResourceListResponse(properties) {
            this.resources = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResourceListResponse resources.
         * @member {Array.<api.IResourceGetResponse>} resources
         * @memberof api.ResourceListResponse
         * @instance
         */
        ResourceListResponse.prototype.resources = $util.emptyArray;

        /**
         * Creates a new ResourceListResponse instance using the specified properties.
         * @function create
         * @memberof api.ResourceListResponse
         * @static
         * @param {api.IResourceListResponse=} [properties] Properties to set
         * @returns {api.ResourceListResponse} ResourceListResponse instance
         */
        ResourceListResponse.create = function create(properties) {
            return new ResourceListResponse(properties);
        };

        /**
         * Encodes the specified ResourceListResponse message. Does not implicitly {@link api.ResourceListResponse.verify|verify} messages.
         * @function encode
         * @memberof api.ResourceListResponse
         * @static
         * @param {api.IResourceListResponse} message ResourceListResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourceListResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.resources != null && message.resources.length)
                for (var i = 0; i < message.resources.length; ++i)
                    $root.api.ResourceGetResponse.encode(message.resources[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ResourceListResponse message, length delimited. Does not implicitly {@link api.ResourceListResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.ResourceListResponse
         * @static
         * @param {api.IResourceListResponse} message ResourceListResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourceListResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResourceListResponse message from the specified reader or buffer.
         * @function decode
         * @memberof api.ResourceListResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.ResourceListResponse} ResourceListResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourceListResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ResourceListResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.resources && message.resources.length))
                        message.resources = [];
                    message.resources.push($root.api.ResourceGetResponse.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ResourceListResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.ResourceListResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.ResourceListResponse} ResourceListResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourceListResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResourceListResponse message.
         * @function verify
         * @memberof api.ResourceListResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResourceListResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.resources != null && message.hasOwnProperty("resources")) {
                if (!Array.isArray(message.resources))
                    return "resources: array expected";
                for (var i = 0; i < message.resources.length; ++i) {
                    var error = $root.api.ResourceGetResponse.verify(message.resources[i]);
                    if (error)
                        return "resources." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ResourceListResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.ResourceListResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.ResourceListResponse} ResourceListResponse
         */
        ResourceListResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.api.ResourceListResponse)
                return object;
            var message = new $root.api.ResourceListResponse();
            if (object.resources) {
                if (!Array.isArray(object.resources))
                    throw TypeError(".api.ResourceListResponse.resources: array expected");
                message.resources = [];
                for (var i = 0; i < object.resources.length; ++i) {
                    if (typeof object.resources[i] !== "object")
                        throw TypeError(".api.ResourceListResponse.resources: object expected");
                    message.resources[i] = $root.api.ResourceGetResponse.fromObject(object.resources[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ResourceListResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.ResourceListResponse
         * @static
         * @param {api.ResourceListResponse} message ResourceListResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResourceListResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.resources = [];
            if (message.resources && message.resources.length) {
                object.resources = [];
                for (var j = 0; j < message.resources.length; ++j)
                    object.resources[j] = $root.api.ResourceGetResponse.toObject(message.resources[j], options);
            }
            return object;
        };

        /**
         * Converts this ResourceListResponse to JSON.
         * @function toJSON
         * @memberof api.ResourceListResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResourceListResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ResourceListResponse;
    })();

    api.ResourceGetSharingGroupResponse = (function() {

        /**
         * Properties of a ResourceGetSharingGroupResponse.
         * @memberof api
         * @interface IResourceGetSharingGroupResponse
         * @property {Array.<api.IResourceShareLink>|null} [sharingGroup] ResourceGetSharingGroupResponse sharingGroup
         */

        /**
         * Constructs a new ResourceGetSharingGroupResponse.
         * @memberof api
         * @classdesc Represents a ResourceGetSharingGroupResponse.
         * @implements IResourceGetSharingGroupResponse
         * @constructor
         * @param {api.IResourceGetSharingGroupResponse=} [properties] Properties to set
         */
        function ResourceGetSharingGroupResponse(properties) {
            this.sharingGroup = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResourceGetSharingGroupResponse sharingGroup.
         * @member {Array.<api.IResourceShareLink>} sharingGroup
         * @memberof api.ResourceGetSharingGroupResponse
         * @instance
         */
        ResourceGetSharingGroupResponse.prototype.sharingGroup = $util.emptyArray;

        /**
         * Creates a new ResourceGetSharingGroupResponse instance using the specified properties.
         * @function create
         * @memberof api.ResourceGetSharingGroupResponse
         * @static
         * @param {api.IResourceGetSharingGroupResponse=} [properties] Properties to set
         * @returns {api.ResourceGetSharingGroupResponse} ResourceGetSharingGroupResponse instance
         */
        ResourceGetSharingGroupResponse.create = function create(properties) {
            return new ResourceGetSharingGroupResponse(properties);
        };

        /**
         * Encodes the specified ResourceGetSharingGroupResponse message. Does not implicitly {@link api.ResourceGetSharingGroupResponse.verify|verify} messages.
         * @function encode
         * @memberof api.ResourceGetSharingGroupResponse
         * @static
         * @param {api.IResourceGetSharingGroupResponse} message ResourceGetSharingGroupResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourceGetSharingGroupResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.sharingGroup != null && message.sharingGroup.length)
                for (var i = 0; i < message.sharingGroup.length; ++i)
                    $root.api.ResourceShareLink.encode(message.sharingGroup[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ResourceGetSharingGroupResponse message, length delimited. Does not implicitly {@link api.ResourceGetSharingGroupResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.ResourceGetSharingGroupResponse
         * @static
         * @param {api.IResourceGetSharingGroupResponse} message ResourceGetSharingGroupResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourceGetSharingGroupResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResourceGetSharingGroupResponse message from the specified reader or buffer.
         * @function decode
         * @memberof api.ResourceGetSharingGroupResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.ResourceGetSharingGroupResponse} ResourceGetSharingGroupResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourceGetSharingGroupResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ResourceGetSharingGroupResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.sharingGroup && message.sharingGroup.length))
                        message.sharingGroup = [];
                    message.sharingGroup.push($root.api.ResourceShareLink.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ResourceGetSharingGroupResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.ResourceGetSharingGroupResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.ResourceGetSharingGroupResponse} ResourceGetSharingGroupResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourceGetSharingGroupResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResourceGetSharingGroupResponse message.
         * @function verify
         * @memberof api.ResourceGetSharingGroupResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResourceGetSharingGroupResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.sharingGroup != null && message.hasOwnProperty("sharingGroup")) {
                if (!Array.isArray(message.sharingGroup))
                    return "sharingGroup: array expected";
                for (var i = 0; i < message.sharingGroup.length; ++i) {
                    var error = $root.api.ResourceShareLink.verify(message.sharingGroup[i]);
                    if (error)
                        return "sharingGroup." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ResourceGetSharingGroupResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.ResourceGetSharingGroupResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.ResourceGetSharingGroupResponse} ResourceGetSharingGroupResponse
         */
        ResourceGetSharingGroupResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.api.ResourceGetSharingGroupResponse)
                return object;
            var message = new $root.api.ResourceGetSharingGroupResponse();
            if (object.sharingGroup) {
                if (!Array.isArray(object.sharingGroup))
                    throw TypeError(".api.ResourceGetSharingGroupResponse.sharingGroup: array expected");
                message.sharingGroup = [];
                for (var i = 0; i < object.sharingGroup.length; ++i) {
                    if (typeof object.sharingGroup[i] !== "object")
                        throw TypeError(".api.ResourceGetSharingGroupResponse.sharingGroup: object expected");
                    message.sharingGroup[i] = $root.api.ResourceShareLink.fromObject(object.sharingGroup[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ResourceGetSharingGroupResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.ResourceGetSharingGroupResponse
         * @static
         * @param {api.ResourceGetSharingGroupResponse} message ResourceGetSharingGroupResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResourceGetSharingGroupResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.sharingGroup = [];
            if (message.sharingGroup && message.sharingGroup.length) {
                object.sharingGroup = [];
                for (var j = 0; j < message.sharingGroup.length; ++j)
                    object.sharingGroup[j] = $root.api.ResourceShareLink.toObject(message.sharingGroup[j], options);
            }
            return object;
        };

        /**
         * Converts this ResourceGetSharingGroupResponse to JSON.
         * @function toJSON
         * @memberof api.ResourceGetSharingGroupResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResourceGetSharingGroupResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ResourceGetSharingGroupResponse;
    })();

    api.ResourceShareLink = (function() {

        /**
         * Properties of a ResourceShareLink.
         * @memberof api
         * @interface IResourceShareLink
         * @property {api.IIdentityKeyID|null} [identityID] ResourceShareLink identityID
         */

        /**
         * Constructs a new ResourceShareLink.
         * @memberof api
         * @classdesc Represents a ResourceShareLink.
         * @implements IResourceShareLink
         * @constructor
         * @param {api.IResourceShareLink=} [properties] Properties to set
         */
        function ResourceShareLink(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResourceShareLink identityID.
         * @member {api.IIdentityKeyID|null|undefined} identityID
         * @memberof api.ResourceShareLink
         * @instance
         */
        ResourceShareLink.prototype.identityID = null;

        /**
         * Creates a new ResourceShareLink instance using the specified properties.
         * @function create
         * @memberof api.ResourceShareLink
         * @static
         * @param {api.IResourceShareLink=} [properties] Properties to set
         * @returns {api.ResourceShareLink} ResourceShareLink instance
         */
        ResourceShareLink.create = function create(properties) {
            return new ResourceShareLink(properties);
        };

        /**
         * Encodes the specified ResourceShareLink message. Does not implicitly {@link api.ResourceShareLink.verify|verify} messages.
         * @function encode
         * @memberof api.ResourceShareLink
         * @static
         * @param {api.IResourceShareLink} message ResourceShareLink message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourceShareLink.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.identityID != null && message.hasOwnProperty("identityID"))
                $root.api.IdentityKeyID.encode(message.identityID, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ResourceShareLink message, length delimited. Does not implicitly {@link api.ResourceShareLink.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.ResourceShareLink
         * @static
         * @param {api.IResourceShareLink} message ResourceShareLink message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourceShareLink.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResourceShareLink message from the specified reader or buffer.
         * @function decode
         * @memberof api.ResourceShareLink
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.ResourceShareLink} ResourceShareLink
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourceShareLink.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ResourceShareLink();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.identityID = $root.api.IdentityKeyID.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ResourceShareLink message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.ResourceShareLink
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.ResourceShareLink} ResourceShareLink
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourceShareLink.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResourceShareLink message.
         * @function verify
         * @memberof api.ResourceShareLink
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResourceShareLink.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.identityID != null && message.hasOwnProperty("identityID")) {
                var error = $root.api.IdentityKeyID.verify(message.identityID);
                if (error)
                    return "identityID." + error;
            }
            return null;
        };

        /**
         * Creates a ResourceShareLink message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.ResourceShareLink
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.ResourceShareLink} ResourceShareLink
         */
        ResourceShareLink.fromObject = function fromObject(object) {
            if (object instanceof $root.api.ResourceShareLink)
                return object;
            var message = new $root.api.ResourceShareLink();
            if (object.identityID != null) {
                if (typeof object.identityID !== "object")
                    throw TypeError(".api.ResourceShareLink.identityID: object expected");
                message.identityID = $root.api.IdentityKeyID.fromObject(object.identityID);
            }
            return message;
        };

        /**
         * Creates a plain object from a ResourceShareLink message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.ResourceShareLink
         * @static
         * @param {api.ResourceShareLink} message ResourceShareLink
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResourceShareLink.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.identityID = null;
            if (message.identityID != null && message.hasOwnProperty("identityID"))
                object.identityID = $root.api.IdentityKeyID.toObject(message.identityID, options);
            return object;
        };

        /**
         * Converts this ResourceShareLink to JSON.
         * @function toJSON
         * @memberof api.ResourceShareLink
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResourceShareLink.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ResourceShareLink;
    })();

    api.ResourceAccessLog = (function() {

        /**
         * Properties of a ResourceAccessLog.
         * @memberof api
         * @interface IResourceAccessLog
         * @property {number|Long|null} [resourceID] ResourceAccessLog resourceID
         * @property {api.IIdentityKeyID|null} [owner] ResourceAccessLog owner
         * @property {api.IIdentityKeyID|null} [assume] ResourceAccessLog assume
         * @property {number|Long|null} [timestamp] ResourceAccessLog timestamp
         * @property {string|null} [reason] ResourceAccessLog reason
         */

        /**
         * Constructs a new ResourceAccessLog.
         * @memberof api
         * @classdesc Represents a ResourceAccessLog.
         * @implements IResourceAccessLog
         * @constructor
         * @param {api.IResourceAccessLog=} [properties] Properties to set
         */
        function ResourceAccessLog(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResourceAccessLog resourceID.
         * @member {number|Long} resourceID
         * @memberof api.ResourceAccessLog
         * @instance
         */
        ResourceAccessLog.prototype.resourceID = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ResourceAccessLog owner.
         * @member {api.IIdentityKeyID|null|undefined} owner
         * @memberof api.ResourceAccessLog
         * @instance
         */
        ResourceAccessLog.prototype.owner = null;

        /**
         * ResourceAccessLog assume.
         * @member {api.IIdentityKeyID|null|undefined} assume
         * @memberof api.ResourceAccessLog
         * @instance
         */
        ResourceAccessLog.prototype.assume = null;

        /**
         * ResourceAccessLog timestamp.
         * @member {number|Long} timestamp
         * @memberof api.ResourceAccessLog
         * @instance
         */
        ResourceAccessLog.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ResourceAccessLog reason.
         * @member {string} reason
         * @memberof api.ResourceAccessLog
         * @instance
         */
        ResourceAccessLog.prototype.reason = "";

        /**
         * Creates a new ResourceAccessLog instance using the specified properties.
         * @function create
         * @memberof api.ResourceAccessLog
         * @static
         * @param {api.IResourceAccessLog=} [properties] Properties to set
         * @returns {api.ResourceAccessLog} ResourceAccessLog instance
         */
        ResourceAccessLog.create = function create(properties) {
            return new ResourceAccessLog(properties);
        };

        /**
         * Encodes the specified ResourceAccessLog message. Does not implicitly {@link api.ResourceAccessLog.verify|verify} messages.
         * @function encode
         * @memberof api.ResourceAccessLog
         * @static
         * @param {api.IResourceAccessLog} message ResourceAccessLog message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourceAccessLog.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.resourceID != null && message.hasOwnProperty("resourceID"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.resourceID);
            if (message.owner != null && message.hasOwnProperty("owner"))
                $root.api.IdentityKeyID.encode(message.owner, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.assume != null && message.hasOwnProperty("assume"))
                $root.api.IdentityKeyID.encode(message.assume, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.timestamp);
            if (message.reason != null && message.hasOwnProperty("reason"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.reason);
            return writer;
        };

        /**
         * Encodes the specified ResourceAccessLog message, length delimited. Does not implicitly {@link api.ResourceAccessLog.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.ResourceAccessLog
         * @static
         * @param {api.IResourceAccessLog} message ResourceAccessLog message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourceAccessLog.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResourceAccessLog message from the specified reader or buffer.
         * @function decode
         * @memberof api.ResourceAccessLog
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.ResourceAccessLog} ResourceAccessLog
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourceAccessLog.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ResourceAccessLog();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.resourceID = reader.uint64();
                    break;
                case 2:
                    message.owner = $root.api.IdentityKeyID.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.assume = $root.api.IdentityKeyID.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.timestamp = reader.uint64();
                    break;
                case 5:
                    message.reason = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ResourceAccessLog message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.ResourceAccessLog
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.ResourceAccessLog} ResourceAccessLog
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourceAccessLog.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResourceAccessLog message.
         * @function verify
         * @memberof api.ResourceAccessLog
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResourceAccessLog.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.resourceID != null && message.hasOwnProperty("resourceID"))
                if (!$util.isInteger(message.resourceID) && !(message.resourceID && $util.isInteger(message.resourceID.low) && $util.isInteger(message.resourceID.high)))
                    return "resourceID: integer|Long expected";
            if (message.owner != null && message.hasOwnProperty("owner")) {
                var error = $root.api.IdentityKeyID.verify(message.owner);
                if (error)
                    return "owner." + error;
            }
            if (message.assume != null && message.hasOwnProperty("assume")) {
                var error = $root.api.IdentityKeyID.verify(message.assume);
                if (error)
                    return "assume." + error;
            }
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            if (message.reason != null && message.hasOwnProperty("reason"))
                if (!$util.isString(message.reason))
                    return "reason: string expected";
            return null;
        };

        /**
         * Creates a ResourceAccessLog message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.ResourceAccessLog
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.ResourceAccessLog} ResourceAccessLog
         */
        ResourceAccessLog.fromObject = function fromObject(object) {
            if (object instanceof $root.api.ResourceAccessLog)
                return object;
            var message = new $root.api.ResourceAccessLog();
            if (object.resourceID != null)
                if ($util.Long)
                    (message.resourceID = $util.Long.fromValue(object.resourceID)).unsigned = true;
                else if (typeof object.resourceID === "string")
                    message.resourceID = parseInt(object.resourceID, 10);
                else if (typeof object.resourceID === "number")
                    message.resourceID = object.resourceID;
                else if (typeof object.resourceID === "object")
                    message.resourceID = new $util.LongBits(object.resourceID.low >>> 0, object.resourceID.high >>> 0).toNumber(true);
            if (object.owner != null) {
                if (typeof object.owner !== "object")
                    throw TypeError(".api.ResourceAccessLog.owner: object expected");
                message.owner = $root.api.IdentityKeyID.fromObject(object.owner);
            }
            if (object.assume != null) {
                if (typeof object.assume !== "object")
                    throw TypeError(".api.ResourceAccessLog.assume: object expected");
                message.assume = $root.api.IdentityKeyID.fromObject(object.assume);
            }
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = true;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber(true);
            if (object.reason != null)
                message.reason = String(object.reason);
            return message;
        };

        /**
         * Creates a plain object from a ResourceAccessLog message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.ResourceAccessLog
         * @static
         * @param {api.ResourceAccessLog} message ResourceAccessLog
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResourceAccessLog.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.resourceID = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.resourceID = options.longs === String ? "0" : 0;
                object.owner = null;
                object.assume = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
                object.reason = "";
            }
            if (message.resourceID != null && message.hasOwnProperty("resourceID"))
                if (typeof message.resourceID === "number")
                    object.resourceID = options.longs === String ? String(message.resourceID) : message.resourceID;
                else
                    object.resourceID = options.longs === String ? $util.Long.prototype.toString.call(message.resourceID) : options.longs === Number ? new $util.LongBits(message.resourceID.low >>> 0, message.resourceID.high >>> 0).toNumber(true) : message.resourceID;
            if (message.owner != null && message.hasOwnProperty("owner"))
                object.owner = $root.api.IdentityKeyID.toObject(message.owner, options);
            if (message.assume != null && message.hasOwnProperty("assume"))
                object.assume = $root.api.IdentityKeyID.toObject(message.assume, options);
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber(true) : message.timestamp;
            if (message.reason != null && message.hasOwnProperty("reason"))
                object.reason = message.reason;
            return object;
        };

        /**
         * Converts this ResourceAccessLog to JSON.
         * @function toJSON
         * @memberof api.ResourceAccessLog
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResourceAccessLog.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ResourceAccessLog;
    })();

    api.ResourceGetAccessLogsRequest = (function() {

        /**
         * Properties of a ResourceGetAccessLogsRequest.
         * @memberof api
         * @interface IResourceGetAccessLogsRequest
         * @property {Array.<number|Long>|null} [resourceIDs] ResourceGetAccessLogsRequest resourceIDs
         * @property {number|null} [limit] ResourceGetAccessLogsRequest limit
         * @property {number|null} [offset] ResourceGetAccessLogsRequest offset
         */

        /**
         * Constructs a new ResourceGetAccessLogsRequest.
         * @memberof api
         * @classdesc Represents a ResourceGetAccessLogsRequest.
         * @implements IResourceGetAccessLogsRequest
         * @constructor
         * @param {api.IResourceGetAccessLogsRequest=} [properties] Properties to set
         */
        function ResourceGetAccessLogsRequest(properties) {
            this.resourceIDs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResourceGetAccessLogsRequest resourceIDs.
         * @member {Array.<number|Long>} resourceIDs
         * @memberof api.ResourceGetAccessLogsRequest
         * @instance
         */
        ResourceGetAccessLogsRequest.prototype.resourceIDs = $util.emptyArray;

        /**
         * ResourceGetAccessLogsRequest limit.
         * @member {number} limit
         * @memberof api.ResourceGetAccessLogsRequest
         * @instance
         */
        ResourceGetAccessLogsRequest.prototype.limit = 0;

        /**
         * ResourceGetAccessLogsRequest offset.
         * @member {number} offset
         * @memberof api.ResourceGetAccessLogsRequest
         * @instance
         */
        ResourceGetAccessLogsRequest.prototype.offset = 0;

        /**
         * Creates a new ResourceGetAccessLogsRequest instance using the specified properties.
         * @function create
         * @memberof api.ResourceGetAccessLogsRequest
         * @static
         * @param {api.IResourceGetAccessLogsRequest=} [properties] Properties to set
         * @returns {api.ResourceGetAccessLogsRequest} ResourceGetAccessLogsRequest instance
         */
        ResourceGetAccessLogsRequest.create = function create(properties) {
            return new ResourceGetAccessLogsRequest(properties);
        };

        /**
         * Encodes the specified ResourceGetAccessLogsRequest message. Does not implicitly {@link api.ResourceGetAccessLogsRequest.verify|verify} messages.
         * @function encode
         * @memberof api.ResourceGetAccessLogsRequest
         * @static
         * @param {api.IResourceGetAccessLogsRequest} message ResourceGetAccessLogsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourceGetAccessLogsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.resourceIDs != null && message.resourceIDs.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (var i = 0; i < message.resourceIDs.length; ++i)
                    writer.uint64(message.resourceIDs[i]);
                writer.ldelim();
            }
            if (message.limit != null && message.hasOwnProperty("limit"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.limit);
            if (message.offset != null && message.hasOwnProperty("offset"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.offset);
            return writer;
        };

        /**
         * Encodes the specified ResourceGetAccessLogsRequest message, length delimited. Does not implicitly {@link api.ResourceGetAccessLogsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.ResourceGetAccessLogsRequest
         * @static
         * @param {api.IResourceGetAccessLogsRequest} message ResourceGetAccessLogsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourceGetAccessLogsRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResourceGetAccessLogsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof api.ResourceGetAccessLogsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.ResourceGetAccessLogsRequest} ResourceGetAccessLogsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourceGetAccessLogsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ResourceGetAccessLogsRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.resourceIDs && message.resourceIDs.length))
                        message.resourceIDs = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.resourceIDs.push(reader.uint64());
                    } else
                        message.resourceIDs.push(reader.uint64());
                    break;
                case 2:
                    message.limit = reader.uint32();
                    break;
                case 3:
                    message.offset = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ResourceGetAccessLogsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.ResourceGetAccessLogsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.ResourceGetAccessLogsRequest} ResourceGetAccessLogsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourceGetAccessLogsRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResourceGetAccessLogsRequest message.
         * @function verify
         * @memberof api.ResourceGetAccessLogsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResourceGetAccessLogsRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.resourceIDs != null && message.hasOwnProperty("resourceIDs")) {
                if (!Array.isArray(message.resourceIDs))
                    return "resourceIDs: array expected";
                for (var i = 0; i < message.resourceIDs.length; ++i)
                    if (!$util.isInteger(message.resourceIDs[i]) && !(message.resourceIDs[i] && $util.isInteger(message.resourceIDs[i].low) && $util.isInteger(message.resourceIDs[i].high)))
                        return "resourceIDs: integer|Long[] expected";
            }
            if (message.limit != null && message.hasOwnProperty("limit"))
                if (!$util.isInteger(message.limit))
                    return "limit: integer expected";
            if (message.offset != null && message.hasOwnProperty("offset"))
                if (!$util.isInteger(message.offset))
                    return "offset: integer expected";
            return null;
        };

        /**
         * Creates a ResourceGetAccessLogsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.ResourceGetAccessLogsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.ResourceGetAccessLogsRequest} ResourceGetAccessLogsRequest
         */
        ResourceGetAccessLogsRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.api.ResourceGetAccessLogsRequest)
                return object;
            var message = new $root.api.ResourceGetAccessLogsRequest();
            if (object.resourceIDs) {
                if (!Array.isArray(object.resourceIDs))
                    throw TypeError(".api.ResourceGetAccessLogsRequest.resourceIDs: array expected");
                message.resourceIDs = [];
                for (var i = 0; i < object.resourceIDs.length; ++i)
                    if ($util.Long)
                        (message.resourceIDs[i] = $util.Long.fromValue(object.resourceIDs[i])).unsigned = true;
                    else if (typeof object.resourceIDs[i] === "string")
                        message.resourceIDs[i] = parseInt(object.resourceIDs[i], 10);
                    else if (typeof object.resourceIDs[i] === "number")
                        message.resourceIDs[i] = object.resourceIDs[i];
                    else if (typeof object.resourceIDs[i] === "object")
                        message.resourceIDs[i] = new $util.LongBits(object.resourceIDs[i].low >>> 0, object.resourceIDs[i].high >>> 0).toNumber(true);
            }
            if (object.limit != null)
                message.limit = object.limit >>> 0;
            if (object.offset != null)
                message.offset = object.offset >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ResourceGetAccessLogsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.ResourceGetAccessLogsRequest
         * @static
         * @param {api.ResourceGetAccessLogsRequest} message ResourceGetAccessLogsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResourceGetAccessLogsRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.resourceIDs = [];
            if (options.defaults) {
                object.limit = 0;
                object.offset = 0;
            }
            if (message.resourceIDs && message.resourceIDs.length) {
                object.resourceIDs = [];
                for (var j = 0; j < message.resourceIDs.length; ++j)
                    if (typeof message.resourceIDs[j] === "number")
                        object.resourceIDs[j] = options.longs === String ? String(message.resourceIDs[j]) : message.resourceIDs[j];
                    else
                        object.resourceIDs[j] = options.longs === String ? $util.Long.prototype.toString.call(message.resourceIDs[j]) : options.longs === Number ? new $util.LongBits(message.resourceIDs[j].low >>> 0, message.resourceIDs[j].high >>> 0).toNumber(true) : message.resourceIDs[j];
            }
            if (message.limit != null && message.hasOwnProperty("limit"))
                object.limit = message.limit;
            if (message.offset != null && message.hasOwnProperty("offset"))
                object.offset = message.offset;
            return object;
        };

        /**
         * Converts this ResourceGetAccessLogsRequest to JSON.
         * @function toJSON
         * @memberof api.ResourceGetAccessLogsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResourceGetAccessLogsRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ResourceGetAccessLogsRequest;
    })();

    api.ResourceGetAccessLogsResponse = (function() {

        /**
         * Properties of a ResourceGetAccessLogsResponse.
         * @memberof api
         * @interface IResourceGetAccessLogsResponse
         * @property {Array.<api.IResourceAccessLog>|null} [logs] ResourceGetAccessLogsResponse logs
         */

        /**
         * Constructs a new ResourceGetAccessLogsResponse.
         * @memberof api
         * @classdesc Represents a ResourceGetAccessLogsResponse.
         * @implements IResourceGetAccessLogsResponse
         * @constructor
         * @param {api.IResourceGetAccessLogsResponse=} [properties] Properties to set
         */
        function ResourceGetAccessLogsResponse(properties) {
            this.logs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResourceGetAccessLogsResponse logs.
         * @member {Array.<api.IResourceAccessLog>} logs
         * @memberof api.ResourceGetAccessLogsResponse
         * @instance
         */
        ResourceGetAccessLogsResponse.prototype.logs = $util.emptyArray;

        /**
         * Creates a new ResourceGetAccessLogsResponse instance using the specified properties.
         * @function create
         * @memberof api.ResourceGetAccessLogsResponse
         * @static
         * @param {api.IResourceGetAccessLogsResponse=} [properties] Properties to set
         * @returns {api.ResourceGetAccessLogsResponse} ResourceGetAccessLogsResponse instance
         */
        ResourceGetAccessLogsResponse.create = function create(properties) {
            return new ResourceGetAccessLogsResponse(properties);
        };

        /**
         * Encodes the specified ResourceGetAccessLogsResponse message. Does not implicitly {@link api.ResourceGetAccessLogsResponse.verify|verify} messages.
         * @function encode
         * @memberof api.ResourceGetAccessLogsResponse
         * @static
         * @param {api.IResourceGetAccessLogsResponse} message ResourceGetAccessLogsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourceGetAccessLogsResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.logs != null && message.logs.length)
                for (var i = 0; i < message.logs.length; ++i)
                    $root.api.ResourceAccessLog.encode(message.logs[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ResourceGetAccessLogsResponse message, length delimited. Does not implicitly {@link api.ResourceGetAccessLogsResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.ResourceGetAccessLogsResponse
         * @static
         * @param {api.IResourceGetAccessLogsResponse} message ResourceGetAccessLogsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourceGetAccessLogsResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResourceGetAccessLogsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof api.ResourceGetAccessLogsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.ResourceGetAccessLogsResponse} ResourceGetAccessLogsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourceGetAccessLogsResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ResourceGetAccessLogsResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.logs && message.logs.length))
                        message.logs = [];
                    message.logs.push($root.api.ResourceAccessLog.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ResourceGetAccessLogsResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.ResourceGetAccessLogsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.ResourceGetAccessLogsResponse} ResourceGetAccessLogsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourceGetAccessLogsResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResourceGetAccessLogsResponse message.
         * @function verify
         * @memberof api.ResourceGetAccessLogsResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResourceGetAccessLogsResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.logs != null && message.hasOwnProperty("logs")) {
                if (!Array.isArray(message.logs))
                    return "logs: array expected";
                for (var i = 0; i < message.logs.length; ++i) {
                    var error = $root.api.ResourceAccessLog.verify(message.logs[i]);
                    if (error)
                        return "logs." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ResourceGetAccessLogsResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.ResourceGetAccessLogsResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.ResourceGetAccessLogsResponse} ResourceGetAccessLogsResponse
         */
        ResourceGetAccessLogsResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.api.ResourceGetAccessLogsResponse)
                return object;
            var message = new $root.api.ResourceGetAccessLogsResponse();
            if (object.logs) {
                if (!Array.isArray(object.logs))
                    throw TypeError(".api.ResourceGetAccessLogsResponse.logs: array expected");
                message.logs = [];
                for (var i = 0; i < object.logs.length; ++i) {
                    if (typeof object.logs[i] !== "object")
                        throw TypeError(".api.ResourceGetAccessLogsResponse.logs: object expected");
                    message.logs[i] = $root.api.ResourceAccessLog.fromObject(object.logs[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ResourceGetAccessLogsResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.ResourceGetAccessLogsResponse
         * @static
         * @param {api.ResourceGetAccessLogsResponse} message ResourceGetAccessLogsResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResourceGetAccessLogsResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.logs = [];
            if (message.logs && message.logs.length) {
                object.logs = [];
                for (var j = 0; j < message.logs.length; ++j)
                    object.logs[j] = $root.api.ResourceAccessLog.toObject(message.logs[j], options);
            }
            return object;
        };

        /**
         * Converts this ResourceGetAccessLogsResponse to JSON.
         * @function toJSON
         * @memberof api.ResourceGetAccessLogsResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResourceGetAccessLogsResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ResourceGetAccessLogsResponse;
    })();

    api.Event = (function() {

        /**
         * Properties of an Event.
         * @memberof api
         * @interface IEvent
         * @property {google.protobuf.IAny|null} [payload] Event payload
         */

        /**
         * Constructs a new Event.
         * @memberof api
         * @classdesc Represents an Event.
         * @implements IEvent
         * @constructor
         * @param {api.IEvent=} [properties] Properties to set
         */
        function Event(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Event payload.
         * @member {google.protobuf.IAny|null|undefined} payload
         * @memberof api.Event
         * @instance
         */
        Event.prototype.payload = null;

        /**
         * Creates a new Event instance using the specified properties.
         * @function create
         * @memberof api.Event
         * @static
         * @param {api.IEvent=} [properties] Properties to set
         * @returns {api.Event} Event instance
         */
        Event.create = function create(properties) {
            return new Event(properties);
        };

        /**
         * Encodes the specified Event message. Does not implicitly {@link api.Event.verify|verify} messages.
         * @function encode
         * @memberof api.Event
         * @static
         * @param {api.IEvent} message Event message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Event.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.payload != null && message.hasOwnProperty("payload"))
                $root.google.protobuf.Any.encode(message.payload, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Event message, length delimited. Does not implicitly {@link api.Event.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.Event
         * @static
         * @param {api.IEvent} message Event message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Event.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Event message from the specified reader or buffer.
         * @function decode
         * @memberof api.Event
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.Event} Event
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Event.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.Event();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.payload = $root.google.protobuf.Any.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Event message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.Event
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.Event} Event
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Event.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Event message.
         * @function verify
         * @memberof api.Event
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Event.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.payload != null && message.hasOwnProperty("payload")) {
                var error = $root.google.protobuf.Any.verify(message.payload);
                if (error)
                    return "payload." + error;
            }
            return null;
        };

        /**
         * Creates an Event message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.Event
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.Event} Event
         */
        Event.fromObject = function fromObject(object) {
            if (object instanceof $root.api.Event)
                return object;
            var message = new $root.api.Event();
            if (object.payload != null) {
                if (typeof object.payload !== "object")
                    throw TypeError(".api.Event.payload: object expected");
                message.payload = $root.google.protobuf.Any.fromObject(object.payload);
            }
            return message;
        };

        /**
         * Creates a plain object from an Event message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.Event
         * @static
         * @param {api.Event} message Event
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Event.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.payload = null;
            if (message.payload != null && message.hasOwnProperty("payload"))
                object.payload = $root.google.protobuf.Any.toObject(message.payload, options);
            return object;
        };

        /**
         * Converts this Event to JSON.
         * @function toJSON
         * @memberof api.Event
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Event.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Event;
    })();

    api.EventChannelMessage = (function() {

        /**
         * Properties of an EventChannelMessage.
         * @memberof api
         * @interface IEventChannelMessage
         * @property {number|Long|null} [channelId] EventChannelMessage channelId
         * @property {Uint8Array|null} [content] EventChannelMessage content
         */

        /**
         * Constructs a new EventChannelMessage.
         * @memberof api
         * @classdesc Represents an EventChannelMessage.
         * @implements IEventChannelMessage
         * @constructor
         * @param {api.IEventChannelMessage=} [properties] Properties to set
         */
        function EventChannelMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EventChannelMessage channelId.
         * @member {number|Long} channelId
         * @memberof api.EventChannelMessage
         * @instance
         */
        EventChannelMessage.prototype.channelId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * EventChannelMessage content.
         * @member {Uint8Array} content
         * @memberof api.EventChannelMessage
         * @instance
         */
        EventChannelMessage.prototype.content = $util.newBuffer([]);

        /**
         * Creates a new EventChannelMessage instance using the specified properties.
         * @function create
         * @memberof api.EventChannelMessage
         * @static
         * @param {api.IEventChannelMessage=} [properties] Properties to set
         * @returns {api.EventChannelMessage} EventChannelMessage instance
         */
        EventChannelMessage.create = function create(properties) {
            return new EventChannelMessage(properties);
        };

        /**
         * Encodes the specified EventChannelMessage message. Does not implicitly {@link api.EventChannelMessage.verify|verify} messages.
         * @function encode
         * @memberof api.EventChannelMessage
         * @static
         * @param {api.IEventChannelMessage} message EventChannelMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EventChannelMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.channelId != null && message.hasOwnProperty("channelId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.channelId);
            if (message.content != null && message.hasOwnProperty("content"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.content);
            return writer;
        };

        /**
         * Encodes the specified EventChannelMessage message, length delimited. Does not implicitly {@link api.EventChannelMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.EventChannelMessage
         * @static
         * @param {api.IEventChannelMessage} message EventChannelMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EventChannelMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EventChannelMessage message from the specified reader or buffer.
         * @function decode
         * @memberof api.EventChannelMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.EventChannelMessage} EventChannelMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EventChannelMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.EventChannelMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.channelId = reader.uint64();
                    break;
                case 2:
                    message.content = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an EventChannelMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.EventChannelMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.EventChannelMessage} EventChannelMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EventChannelMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EventChannelMessage message.
         * @function verify
         * @memberof api.EventChannelMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EventChannelMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.channelId != null && message.hasOwnProperty("channelId"))
                if (!$util.isInteger(message.channelId) && !(message.channelId && $util.isInteger(message.channelId.low) && $util.isInteger(message.channelId.high)))
                    return "channelId: integer|Long expected";
            if (message.content != null && message.hasOwnProperty("content"))
                if (!(message.content && typeof message.content.length === "number" || $util.isString(message.content)))
                    return "content: buffer expected";
            return null;
        };

        /**
         * Creates an EventChannelMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.EventChannelMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.EventChannelMessage} EventChannelMessage
         */
        EventChannelMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.api.EventChannelMessage)
                return object;
            var message = new $root.api.EventChannelMessage();
            if (object.channelId != null)
                if ($util.Long)
                    (message.channelId = $util.Long.fromValue(object.channelId)).unsigned = true;
                else if (typeof object.channelId === "string")
                    message.channelId = parseInt(object.channelId, 10);
                else if (typeof object.channelId === "number")
                    message.channelId = object.channelId;
                else if (typeof object.channelId === "object")
                    message.channelId = new $util.LongBits(object.channelId.low >>> 0, object.channelId.high >>> 0).toNumber(true);
            if (object.content != null)
                if (typeof object.content === "string")
                    $util.base64.decode(object.content, message.content = $util.newBuffer($util.base64.length(object.content)), 0);
                else if (object.content.length)
                    message.content = object.content;
            return message;
        };

        /**
         * Creates a plain object from an EventChannelMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.EventChannelMessage
         * @static
         * @param {api.EventChannelMessage} message EventChannelMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EventChannelMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.channelId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.channelId = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.content = "";
                else {
                    object.content = [];
                    if (options.bytes !== Array)
                        object.content = $util.newBuffer(object.content);
                }
            }
            if (message.channelId != null && message.hasOwnProperty("channelId"))
                if (typeof message.channelId === "number")
                    object.channelId = options.longs === String ? String(message.channelId) : message.channelId;
                else
                    object.channelId = options.longs === String ? $util.Long.prototype.toString.call(message.channelId) : options.longs === Number ? new $util.LongBits(message.channelId.low >>> 0, message.channelId.high >>> 0).toNumber(true) : message.channelId;
            if (message.content != null && message.hasOwnProperty("content"))
                object.content = options.bytes === String ? $util.base64.encode(message.content, 0, message.content.length) : options.bytes === Array ? Array.prototype.slice.call(message.content) : message.content;
            return object;
        };

        /**
         * Converts this EventChannelMessage to JSON.
         * @function toJSON
         * @memberof api.EventChannelMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EventChannelMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EventChannelMessage;
    })();

    api.ChannelGetResponse = (function() {

        /**
         * Properties of a ChannelGetResponse.
         * @memberof api
         * @interface IChannelGetResponse
         * @property {number|Long|null} [id] ChannelGetResponse id
         * @property {api.IResourceGetResponse|null} [resource] ChannelGetResponse resource
         */

        /**
         * Constructs a new ChannelGetResponse.
         * @memberof api
         * @classdesc Represents a ChannelGetResponse.
         * @implements IChannelGetResponse
         * @constructor
         * @param {api.IChannelGetResponse=} [properties] Properties to set
         */
        function ChannelGetResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChannelGetResponse id.
         * @member {number|Long} id
         * @memberof api.ChannelGetResponse
         * @instance
         */
        ChannelGetResponse.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ChannelGetResponse resource.
         * @member {api.IResourceGetResponse|null|undefined} resource
         * @memberof api.ChannelGetResponse
         * @instance
         */
        ChannelGetResponse.prototype.resource = null;

        /**
         * Creates a new ChannelGetResponse instance using the specified properties.
         * @function create
         * @memberof api.ChannelGetResponse
         * @static
         * @param {api.IChannelGetResponse=} [properties] Properties to set
         * @returns {api.ChannelGetResponse} ChannelGetResponse instance
         */
        ChannelGetResponse.create = function create(properties) {
            return new ChannelGetResponse(properties);
        };

        /**
         * Encodes the specified ChannelGetResponse message. Does not implicitly {@link api.ChannelGetResponse.verify|verify} messages.
         * @function encode
         * @memberof api.ChannelGetResponse
         * @static
         * @param {api.IChannelGetResponse} message ChannelGetResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelGetResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
            if (message.resource != null && message.hasOwnProperty("resource"))
                $root.api.ResourceGetResponse.encode(message.resource, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ChannelGetResponse message, length delimited. Does not implicitly {@link api.ChannelGetResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.ChannelGetResponse
         * @static
         * @param {api.IChannelGetResponse} message ChannelGetResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelGetResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChannelGetResponse message from the specified reader or buffer.
         * @function decode
         * @memberof api.ChannelGetResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.ChannelGetResponse} ChannelGetResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelGetResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ChannelGetResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.uint64();
                    break;
                case 2:
                    message.resource = $root.api.ResourceGetResponse.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChannelGetResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.ChannelGetResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.ChannelGetResponse} ChannelGetResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelGetResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChannelGetResponse message.
         * @function verify
         * @memberof api.ChannelGetResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChannelGetResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                    return "id: integer|Long expected";
            if (message.resource != null && message.hasOwnProperty("resource")) {
                var error = $root.api.ResourceGetResponse.verify(message.resource);
                if (error)
                    return "resource." + error;
            }
            return null;
        };

        /**
         * Creates a ChannelGetResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.ChannelGetResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.ChannelGetResponse} ChannelGetResponse
         */
        ChannelGetResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.api.ChannelGetResponse)
                return object;
            var message = new $root.api.ChannelGetResponse();
            if (object.id != null)
                if ($util.Long)
                    (message.id = $util.Long.fromValue(object.id)).unsigned = true;
                else if (typeof object.id === "string")
                    message.id = parseInt(object.id, 10);
                else if (typeof object.id === "number")
                    message.id = object.id;
                else if (typeof object.id === "object")
                    message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
            if (object.resource != null) {
                if (typeof object.resource !== "object")
                    throw TypeError(".api.ChannelGetResponse.resource: object expected");
                message.resource = $root.api.ResourceGetResponse.fromObject(object.resource);
            }
            return message;
        };

        /**
         * Creates a plain object from a ChannelGetResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.ChannelGetResponse
         * @static
         * @param {api.ChannelGetResponse} message ChannelGetResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChannelGetResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.id = options.longs === String ? "0" : 0;
                object.resource = null;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                if (typeof message.id === "number")
                    object.id = options.longs === String ? String(message.id) : message.id;
                else
                    object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
            if (message.resource != null && message.hasOwnProperty("resource"))
                object.resource = $root.api.ResourceGetResponse.toObject(message.resource, options);
            return object;
        };

        /**
         * Converts this ChannelGetResponse to JSON.
         * @function toJSON
         * @memberof api.ChannelGetResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChannelGetResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChannelGetResponse;
    })();

    api.ChannelPostRequest = (function() {

        /**
         * Properties of a ChannelPostRequest.
         * @memberof api
         * @interface IChannelPostRequest
         * @property {Uint8Array|null} [publicKey] ChannelPostRequest publicKey
         * @property {Uint8Array|null} [nonce] ChannelPostRequest nonce
         * @property {Uint8Array|null} [payload] ChannelPostRequest payload
         * @property {Array.<api.IResourceShareEntry>|null} [sharingGroup] ChannelPostRequest sharingGroup
         * @property {api.ResourceType|null} [type] ChannelPostRequest type
         */

        /**
         * Constructs a new ChannelPostRequest.
         * @memberof api
         * @classdesc Represents a ChannelPostRequest.
         * @implements IChannelPostRequest
         * @constructor
         * @param {api.IChannelPostRequest=} [properties] Properties to set
         */
        function ChannelPostRequest(properties) {
            this.sharingGroup = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChannelPostRequest publicKey.
         * @member {Uint8Array} publicKey
         * @memberof api.ChannelPostRequest
         * @instance
         */
        ChannelPostRequest.prototype.publicKey = $util.newBuffer([]);

        /**
         * ChannelPostRequest nonce.
         * @member {Uint8Array} nonce
         * @memberof api.ChannelPostRequest
         * @instance
         */
        ChannelPostRequest.prototype.nonce = $util.newBuffer([]);

        /**
         * ChannelPostRequest payload.
         * @member {Uint8Array} payload
         * @memberof api.ChannelPostRequest
         * @instance
         */
        ChannelPostRequest.prototype.payload = $util.newBuffer([]);

        /**
         * ChannelPostRequest sharingGroup.
         * @member {Array.<api.IResourceShareEntry>} sharingGroup
         * @memberof api.ChannelPostRequest
         * @instance
         */
        ChannelPostRequest.prototype.sharingGroup = $util.emptyArray;

        /**
         * ChannelPostRequest type.
         * @member {api.ResourceType} type
         * @memberof api.ChannelPostRequest
         * @instance
         */
        ChannelPostRequest.prototype.type = 0;

        /**
         * Creates a new ChannelPostRequest instance using the specified properties.
         * @function create
         * @memberof api.ChannelPostRequest
         * @static
         * @param {api.IChannelPostRequest=} [properties] Properties to set
         * @returns {api.ChannelPostRequest} ChannelPostRequest instance
         */
        ChannelPostRequest.create = function create(properties) {
            return new ChannelPostRequest(properties);
        };

        /**
         * Encodes the specified ChannelPostRequest message. Does not implicitly {@link api.ChannelPostRequest.verify|verify} messages.
         * @function encode
         * @memberof api.ChannelPostRequest
         * @static
         * @param {api.IChannelPostRequest} message ChannelPostRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelPostRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.publicKey);
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.nonce);
            if (message.payload != null && message.hasOwnProperty("payload"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.payload);
            if (message.sharingGroup != null && message.sharingGroup.length)
                for (var i = 0; i < message.sharingGroup.length; ++i)
                    $root.api.ResourceShareEntry.encode(message.sharingGroup[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.type);
            return writer;
        };

        /**
         * Encodes the specified ChannelPostRequest message, length delimited. Does not implicitly {@link api.ChannelPostRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.ChannelPostRequest
         * @static
         * @param {api.IChannelPostRequest} message ChannelPostRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelPostRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChannelPostRequest message from the specified reader or buffer.
         * @function decode
         * @memberof api.ChannelPostRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.ChannelPostRequest} ChannelPostRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelPostRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ChannelPostRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.publicKey = reader.bytes();
                    break;
                case 2:
                    message.nonce = reader.bytes();
                    break;
                case 3:
                    message.payload = reader.bytes();
                    break;
                case 4:
                    if (!(message.sharingGroup && message.sharingGroup.length))
                        message.sharingGroup = [];
                    message.sharingGroup.push($root.api.ResourceShareEntry.decode(reader, reader.uint32()));
                    break;
                case 5:
                    message.type = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChannelPostRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.ChannelPostRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.ChannelPostRequest} ChannelPostRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelPostRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChannelPostRequest message.
         * @function verify
         * @memberof api.ChannelPostRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChannelPostRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                if (!(message.publicKey && typeof message.publicKey.length === "number" || $util.isString(message.publicKey)))
                    return "publicKey: buffer expected";
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                if (!(message.nonce && typeof message.nonce.length === "number" || $util.isString(message.nonce)))
                    return "nonce: buffer expected";
            if (message.payload != null && message.hasOwnProperty("payload"))
                if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                    return "payload: buffer expected";
            if (message.sharingGroup != null && message.hasOwnProperty("sharingGroup")) {
                if (!Array.isArray(message.sharingGroup))
                    return "sharingGroup: array expected";
                for (var i = 0; i < message.sharingGroup.length; ++i) {
                    var error = $root.api.ResourceShareEntry.verify(message.sharingGroup[i]);
                    if (error)
                        return "sharingGroup." + error;
                }
            }
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                    break;
                }
            return null;
        };

        /**
         * Creates a ChannelPostRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.ChannelPostRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.ChannelPostRequest} ChannelPostRequest
         */
        ChannelPostRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.api.ChannelPostRequest)
                return object;
            var message = new $root.api.ChannelPostRequest();
            if (object.publicKey != null)
                if (typeof object.publicKey === "string")
                    $util.base64.decode(object.publicKey, message.publicKey = $util.newBuffer($util.base64.length(object.publicKey)), 0);
                else if (object.publicKey.length)
                    message.publicKey = object.publicKey;
            if (object.nonce != null)
                if (typeof object.nonce === "string")
                    $util.base64.decode(object.nonce, message.nonce = $util.newBuffer($util.base64.length(object.nonce)), 0);
                else if (object.nonce.length)
                    message.nonce = object.nonce;
            if (object.payload != null)
                if (typeof object.payload === "string")
                    $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                else if (object.payload.length)
                    message.payload = object.payload;
            if (object.sharingGroup) {
                if (!Array.isArray(object.sharingGroup))
                    throw TypeError(".api.ChannelPostRequest.sharingGroup: array expected");
                message.sharingGroup = [];
                for (var i = 0; i < object.sharingGroup.length; ++i) {
                    if (typeof object.sharingGroup[i] !== "object")
                        throw TypeError(".api.ChannelPostRequest.sharingGroup: object expected");
                    message.sharingGroup[i] = $root.api.ResourceShareEntry.fromObject(object.sharingGroup[i]);
                }
            }
            switch (object.type) {
            case "ANONYMOUS":
            case 0:
                message.type = 0;
                break;
            case "SES":
            case 1:
                message.type = 1;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a ChannelPostRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.ChannelPostRequest
         * @static
         * @param {api.ChannelPostRequest} message ChannelPostRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChannelPostRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.sharingGroup = [];
            if (options.defaults) {
                if (options.bytes === String)
                    object.publicKey = "";
                else {
                    object.publicKey = [];
                    if (options.bytes !== Array)
                        object.publicKey = $util.newBuffer(object.publicKey);
                }
                if (options.bytes === String)
                    object.nonce = "";
                else {
                    object.nonce = [];
                    if (options.bytes !== Array)
                        object.nonce = $util.newBuffer(object.nonce);
                }
                if (options.bytes === String)
                    object.payload = "";
                else {
                    object.payload = [];
                    if (options.bytes !== Array)
                        object.payload = $util.newBuffer(object.payload);
                }
                object.type = options.enums === String ? "ANONYMOUS" : 0;
            }
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                object.publicKey = options.bytes === String ? $util.base64.encode(message.publicKey, 0, message.publicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.publicKey) : message.publicKey;
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                object.nonce = options.bytes === String ? $util.base64.encode(message.nonce, 0, message.nonce.length) : options.bytes === Array ? Array.prototype.slice.call(message.nonce) : message.nonce;
            if (message.payload != null && message.hasOwnProperty("payload"))
                object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
            if (message.sharingGroup && message.sharingGroup.length) {
                object.sharingGroup = [];
                for (var j = 0; j < message.sharingGroup.length; ++j)
                    object.sharingGroup[j] = $root.api.ResourceShareEntry.toObject(message.sharingGroup[j], options);
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.api.ResourceType[message.type] : message.type;
            return object;
        };

        /**
         * Converts this ChannelPostRequest to JSON.
         * @function toJSON
         * @memberof api.ChannelPostRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChannelPostRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChannelPostRequest;
    })();

    api.ChannelPostResponse = (function() {

        /**
         * Properties of a ChannelPostResponse.
         * @memberof api
         * @interface IChannelPostResponse
         * @property {number|Long|null} [id] ChannelPostResponse id
         */

        /**
         * Constructs a new ChannelPostResponse.
         * @memberof api
         * @classdesc Represents a ChannelPostResponse.
         * @implements IChannelPostResponse
         * @constructor
         * @param {api.IChannelPostResponse=} [properties] Properties to set
         */
        function ChannelPostResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChannelPostResponse id.
         * @member {number|Long} id
         * @memberof api.ChannelPostResponse
         * @instance
         */
        ChannelPostResponse.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new ChannelPostResponse instance using the specified properties.
         * @function create
         * @memberof api.ChannelPostResponse
         * @static
         * @param {api.IChannelPostResponse=} [properties] Properties to set
         * @returns {api.ChannelPostResponse} ChannelPostResponse instance
         */
        ChannelPostResponse.create = function create(properties) {
            return new ChannelPostResponse(properties);
        };

        /**
         * Encodes the specified ChannelPostResponse message. Does not implicitly {@link api.ChannelPostResponse.verify|verify} messages.
         * @function encode
         * @memberof api.ChannelPostResponse
         * @static
         * @param {api.IChannelPostResponse} message ChannelPostResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelPostResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
            return writer;
        };

        /**
         * Encodes the specified ChannelPostResponse message, length delimited. Does not implicitly {@link api.ChannelPostResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.ChannelPostResponse
         * @static
         * @param {api.IChannelPostResponse} message ChannelPostResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelPostResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChannelPostResponse message from the specified reader or buffer.
         * @function decode
         * @memberof api.ChannelPostResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.ChannelPostResponse} ChannelPostResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelPostResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ChannelPostResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChannelPostResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.ChannelPostResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.ChannelPostResponse} ChannelPostResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelPostResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChannelPostResponse message.
         * @function verify
         * @memberof api.ChannelPostResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChannelPostResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                    return "id: integer|Long expected";
            return null;
        };

        /**
         * Creates a ChannelPostResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.ChannelPostResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.ChannelPostResponse} ChannelPostResponse
         */
        ChannelPostResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.api.ChannelPostResponse)
                return object;
            var message = new $root.api.ChannelPostResponse();
            if (object.id != null)
                if ($util.Long)
                    (message.id = $util.Long.fromValue(object.id)).unsigned = true;
                else if (typeof object.id === "string")
                    message.id = parseInt(object.id, 10);
                else if (typeof object.id === "number")
                    message.id = object.id;
                else if (typeof object.id === "object")
                    message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a ChannelPostResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.ChannelPostResponse
         * @static
         * @param {api.ChannelPostResponse} message ChannelPostResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChannelPostResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.id = options.longs === String ? "0" : 0;
            if (message.id != null && message.hasOwnProperty("id"))
                if (typeof message.id === "number")
                    object.id = options.longs === String ? String(message.id) : message.id;
                else
                    object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
            return object;
        };

        /**
         * Converts this ChannelPostResponse to JSON.
         * @function toJSON
         * @memberof api.ChannelPostResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChannelPostResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChannelPostResponse;
    })();

    api.ChannelPostMessageRequest = (function() {

        /**
         * Properties of a ChannelPostMessageRequest.
         * @memberof api
         * @interface IChannelPostMessageRequest
         * @property {number|Long|null} [channelId] ChannelPostMessageRequest channelId
         * @property {Uint8Array|null} [content] ChannelPostMessageRequest content
         */

        /**
         * Constructs a new ChannelPostMessageRequest.
         * @memberof api
         * @classdesc Represents a ChannelPostMessageRequest.
         * @implements IChannelPostMessageRequest
         * @constructor
         * @param {api.IChannelPostMessageRequest=} [properties] Properties to set
         */
        function ChannelPostMessageRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChannelPostMessageRequest channelId.
         * @member {number|Long} channelId
         * @memberof api.ChannelPostMessageRequest
         * @instance
         */
        ChannelPostMessageRequest.prototype.channelId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ChannelPostMessageRequest content.
         * @member {Uint8Array} content
         * @memberof api.ChannelPostMessageRequest
         * @instance
         */
        ChannelPostMessageRequest.prototype.content = $util.newBuffer([]);

        /**
         * Creates a new ChannelPostMessageRequest instance using the specified properties.
         * @function create
         * @memberof api.ChannelPostMessageRequest
         * @static
         * @param {api.IChannelPostMessageRequest=} [properties] Properties to set
         * @returns {api.ChannelPostMessageRequest} ChannelPostMessageRequest instance
         */
        ChannelPostMessageRequest.create = function create(properties) {
            return new ChannelPostMessageRequest(properties);
        };

        /**
         * Encodes the specified ChannelPostMessageRequest message. Does not implicitly {@link api.ChannelPostMessageRequest.verify|verify} messages.
         * @function encode
         * @memberof api.ChannelPostMessageRequest
         * @static
         * @param {api.IChannelPostMessageRequest} message ChannelPostMessageRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelPostMessageRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.channelId != null && message.hasOwnProperty("channelId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.channelId);
            if (message.content != null && message.hasOwnProperty("content"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.content);
            return writer;
        };

        /**
         * Encodes the specified ChannelPostMessageRequest message, length delimited. Does not implicitly {@link api.ChannelPostMessageRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.ChannelPostMessageRequest
         * @static
         * @param {api.IChannelPostMessageRequest} message ChannelPostMessageRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelPostMessageRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChannelPostMessageRequest message from the specified reader or buffer.
         * @function decode
         * @memberof api.ChannelPostMessageRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.ChannelPostMessageRequest} ChannelPostMessageRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelPostMessageRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ChannelPostMessageRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.channelId = reader.uint64();
                    break;
                case 2:
                    message.content = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChannelPostMessageRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.ChannelPostMessageRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.ChannelPostMessageRequest} ChannelPostMessageRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelPostMessageRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChannelPostMessageRequest message.
         * @function verify
         * @memberof api.ChannelPostMessageRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChannelPostMessageRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.channelId != null && message.hasOwnProperty("channelId"))
                if (!$util.isInteger(message.channelId) && !(message.channelId && $util.isInteger(message.channelId.low) && $util.isInteger(message.channelId.high)))
                    return "channelId: integer|Long expected";
            if (message.content != null && message.hasOwnProperty("content"))
                if (!(message.content && typeof message.content.length === "number" || $util.isString(message.content)))
                    return "content: buffer expected";
            return null;
        };

        /**
         * Creates a ChannelPostMessageRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.ChannelPostMessageRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.ChannelPostMessageRequest} ChannelPostMessageRequest
         */
        ChannelPostMessageRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.api.ChannelPostMessageRequest)
                return object;
            var message = new $root.api.ChannelPostMessageRequest();
            if (object.channelId != null)
                if ($util.Long)
                    (message.channelId = $util.Long.fromValue(object.channelId)).unsigned = true;
                else if (typeof object.channelId === "string")
                    message.channelId = parseInt(object.channelId, 10);
                else if (typeof object.channelId === "number")
                    message.channelId = object.channelId;
                else if (typeof object.channelId === "object")
                    message.channelId = new $util.LongBits(object.channelId.low >>> 0, object.channelId.high >>> 0).toNumber(true);
            if (object.content != null)
                if (typeof object.content === "string")
                    $util.base64.decode(object.content, message.content = $util.newBuffer($util.base64.length(object.content)), 0);
                else if (object.content.length)
                    message.content = object.content;
            return message;
        };

        /**
         * Creates a plain object from a ChannelPostMessageRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.ChannelPostMessageRequest
         * @static
         * @param {api.ChannelPostMessageRequest} message ChannelPostMessageRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChannelPostMessageRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.channelId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.channelId = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.content = "";
                else {
                    object.content = [];
                    if (options.bytes !== Array)
                        object.content = $util.newBuffer(object.content);
                }
            }
            if (message.channelId != null && message.hasOwnProperty("channelId"))
                if (typeof message.channelId === "number")
                    object.channelId = options.longs === String ? String(message.channelId) : message.channelId;
                else
                    object.channelId = options.longs === String ? $util.Long.prototype.toString.call(message.channelId) : options.longs === Number ? new $util.LongBits(message.channelId.low >>> 0, message.channelId.high >>> 0).toNumber(true) : message.channelId;
            if (message.content != null && message.hasOwnProperty("content"))
                object.content = options.bytes === String ? $util.base64.encode(message.content, 0, message.content.length) : options.bytes === Array ? Array.prototype.slice.call(message.content) : message.content;
            return object;
        };

        /**
         * Converts this ChannelPostMessageRequest to JSON.
         * @function toJSON
         * @memberof api.ChannelPostMessageRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChannelPostMessageRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChannelPostMessageRequest;
    })();

    api.DelegatedAccessPostRequest = (function() {

        /**
         * Properties of a DelegatedAccessPostRequest.
         * @memberof api
         * @interface IDelegatedAccessPostRequest
         * @property {Uint8Array|null} [publicKey] DelegatedAccessPostRequest publicKey
         * @property {Uint8Array|null} [sign] DelegatedAccessPostRequest sign
         * @property {string|null} [requester] DelegatedAccessPostRequest requester
         * @property {api.IResourceShareEntry|null} [sharing] DelegatedAccessPostRequest sharing
         */

        /**
         * Constructs a new DelegatedAccessPostRequest.
         * @memberof api
         * @classdesc Represents a DelegatedAccessPostRequest.
         * @implements IDelegatedAccessPostRequest
         * @constructor
         * @param {api.IDelegatedAccessPostRequest=} [properties] Properties to set
         */
        function DelegatedAccessPostRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DelegatedAccessPostRequest publicKey.
         * @member {Uint8Array} publicKey
         * @memberof api.DelegatedAccessPostRequest
         * @instance
         */
        DelegatedAccessPostRequest.prototype.publicKey = $util.newBuffer([]);

        /**
         * DelegatedAccessPostRequest sign.
         * @member {Uint8Array} sign
         * @memberof api.DelegatedAccessPostRequest
         * @instance
         */
        DelegatedAccessPostRequest.prototype.sign = $util.newBuffer([]);

        /**
         * DelegatedAccessPostRequest requester.
         * @member {string} requester
         * @memberof api.DelegatedAccessPostRequest
         * @instance
         */
        DelegatedAccessPostRequest.prototype.requester = "";

        /**
         * DelegatedAccessPostRequest sharing.
         * @member {api.IResourceShareEntry|null|undefined} sharing
         * @memberof api.DelegatedAccessPostRequest
         * @instance
         */
        DelegatedAccessPostRequest.prototype.sharing = null;

        /**
         * Creates a new DelegatedAccessPostRequest instance using the specified properties.
         * @function create
         * @memberof api.DelegatedAccessPostRequest
         * @static
         * @param {api.IDelegatedAccessPostRequest=} [properties] Properties to set
         * @returns {api.DelegatedAccessPostRequest} DelegatedAccessPostRequest instance
         */
        DelegatedAccessPostRequest.create = function create(properties) {
            return new DelegatedAccessPostRequest(properties);
        };

        /**
         * Encodes the specified DelegatedAccessPostRequest message. Does not implicitly {@link api.DelegatedAccessPostRequest.verify|verify} messages.
         * @function encode
         * @memberof api.DelegatedAccessPostRequest
         * @static
         * @param {api.IDelegatedAccessPostRequest} message DelegatedAccessPostRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DelegatedAccessPostRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.publicKey);
            if (message.sign != null && message.hasOwnProperty("sign"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.sign);
            if (message.requester != null && message.hasOwnProperty("requester"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.requester);
            if (message.sharing != null && message.hasOwnProperty("sharing"))
                $root.api.ResourceShareEntry.encode(message.sharing, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified DelegatedAccessPostRequest message, length delimited. Does not implicitly {@link api.DelegatedAccessPostRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.DelegatedAccessPostRequest
         * @static
         * @param {api.IDelegatedAccessPostRequest} message DelegatedAccessPostRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DelegatedAccessPostRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DelegatedAccessPostRequest message from the specified reader or buffer.
         * @function decode
         * @memberof api.DelegatedAccessPostRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.DelegatedAccessPostRequest} DelegatedAccessPostRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DelegatedAccessPostRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.DelegatedAccessPostRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.publicKey = reader.bytes();
                    break;
                case 2:
                    message.sign = reader.bytes();
                    break;
                case 3:
                    message.requester = reader.string();
                    break;
                case 4:
                    message.sharing = $root.api.ResourceShareEntry.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DelegatedAccessPostRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.DelegatedAccessPostRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.DelegatedAccessPostRequest} DelegatedAccessPostRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DelegatedAccessPostRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DelegatedAccessPostRequest message.
         * @function verify
         * @memberof api.DelegatedAccessPostRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DelegatedAccessPostRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                if (!(message.publicKey && typeof message.publicKey.length === "number" || $util.isString(message.publicKey)))
                    return "publicKey: buffer expected";
            if (message.sign != null && message.hasOwnProperty("sign"))
                if (!(message.sign && typeof message.sign.length === "number" || $util.isString(message.sign)))
                    return "sign: buffer expected";
            if (message.requester != null && message.hasOwnProperty("requester"))
                if (!$util.isString(message.requester))
                    return "requester: string expected";
            if (message.sharing != null && message.hasOwnProperty("sharing")) {
                var error = $root.api.ResourceShareEntry.verify(message.sharing);
                if (error)
                    return "sharing." + error;
            }
            return null;
        };

        /**
         * Creates a DelegatedAccessPostRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.DelegatedAccessPostRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.DelegatedAccessPostRequest} DelegatedAccessPostRequest
         */
        DelegatedAccessPostRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.api.DelegatedAccessPostRequest)
                return object;
            var message = new $root.api.DelegatedAccessPostRequest();
            if (object.publicKey != null)
                if (typeof object.publicKey === "string")
                    $util.base64.decode(object.publicKey, message.publicKey = $util.newBuffer($util.base64.length(object.publicKey)), 0);
                else if (object.publicKey.length)
                    message.publicKey = object.publicKey;
            if (object.sign != null)
                if (typeof object.sign === "string")
                    $util.base64.decode(object.sign, message.sign = $util.newBuffer($util.base64.length(object.sign)), 0);
                else if (object.sign.length)
                    message.sign = object.sign;
            if (object.requester != null)
                message.requester = String(object.requester);
            if (object.sharing != null) {
                if (typeof object.sharing !== "object")
                    throw TypeError(".api.DelegatedAccessPostRequest.sharing: object expected");
                message.sharing = $root.api.ResourceShareEntry.fromObject(object.sharing);
            }
            return message;
        };

        /**
         * Creates a plain object from a DelegatedAccessPostRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.DelegatedAccessPostRequest
         * @static
         * @param {api.DelegatedAccessPostRequest} message DelegatedAccessPostRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DelegatedAccessPostRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.publicKey = "";
                else {
                    object.publicKey = [];
                    if (options.bytes !== Array)
                        object.publicKey = $util.newBuffer(object.publicKey);
                }
                if (options.bytes === String)
                    object.sign = "";
                else {
                    object.sign = [];
                    if (options.bytes !== Array)
                        object.sign = $util.newBuffer(object.sign);
                }
                object.requester = "";
                object.sharing = null;
            }
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                object.publicKey = options.bytes === String ? $util.base64.encode(message.publicKey, 0, message.publicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.publicKey) : message.publicKey;
            if (message.sign != null && message.hasOwnProperty("sign"))
                object.sign = options.bytes === String ? $util.base64.encode(message.sign, 0, message.sign.length) : options.bytes === Array ? Array.prototype.slice.call(message.sign) : message.sign;
            if (message.requester != null && message.hasOwnProperty("requester"))
                object.requester = message.requester;
            if (message.sharing != null && message.hasOwnProperty("sharing"))
                object.sharing = $root.api.ResourceShareEntry.toObject(message.sharing, options);
            return object;
        };

        /**
         * Converts this DelegatedAccessPostRequest to JSON.
         * @function toJSON
         * @memberof api.DelegatedAccessPostRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DelegatedAccessPostRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DelegatedAccessPostRequest;
    })();

    api.DelegatedAccessPostResponse = (function() {

        /**
         * Properties of a DelegatedAccessPostResponse.
         * @memberof api
         * @interface IDelegatedAccessPostResponse
         * @property {number|Long|null} [id] DelegatedAccessPostResponse id
         */

        /**
         * Constructs a new DelegatedAccessPostResponse.
         * @memberof api
         * @classdesc Represents a DelegatedAccessPostResponse.
         * @implements IDelegatedAccessPostResponse
         * @constructor
         * @param {api.IDelegatedAccessPostResponse=} [properties] Properties to set
         */
        function DelegatedAccessPostResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DelegatedAccessPostResponse id.
         * @member {number|Long} id
         * @memberof api.DelegatedAccessPostResponse
         * @instance
         */
        DelegatedAccessPostResponse.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new DelegatedAccessPostResponse instance using the specified properties.
         * @function create
         * @memberof api.DelegatedAccessPostResponse
         * @static
         * @param {api.IDelegatedAccessPostResponse=} [properties] Properties to set
         * @returns {api.DelegatedAccessPostResponse} DelegatedAccessPostResponse instance
         */
        DelegatedAccessPostResponse.create = function create(properties) {
            return new DelegatedAccessPostResponse(properties);
        };

        /**
         * Encodes the specified DelegatedAccessPostResponse message. Does not implicitly {@link api.DelegatedAccessPostResponse.verify|verify} messages.
         * @function encode
         * @memberof api.DelegatedAccessPostResponse
         * @static
         * @param {api.IDelegatedAccessPostResponse} message DelegatedAccessPostResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DelegatedAccessPostResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
            return writer;
        };

        /**
         * Encodes the specified DelegatedAccessPostResponse message, length delimited. Does not implicitly {@link api.DelegatedAccessPostResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.DelegatedAccessPostResponse
         * @static
         * @param {api.IDelegatedAccessPostResponse} message DelegatedAccessPostResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DelegatedAccessPostResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DelegatedAccessPostResponse message from the specified reader or buffer.
         * @function decode
         * @memberof api.DelegatedAccessPostResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.DelegatedAccessPostResponse} DelegatedAccessPostResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DelegatedAccessPostResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.DelegatedAccessPostResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DelegatedAccessPostResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.DelegatedAccessPostResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.DelegatedAccessPostResponse} DelegatedAccessPostResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DelegatedAccessPostResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DelegatedAccessPostResponse message.
         * @function verify
         * @memberof api.DelegatedAccessPostResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DelegatedAccessPostResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                    return "id: integer|Long expected";
            return null;
        };

        /**
         * Creates a DelegatedAccessPostResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.DelegatedAccessPostResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.DelegatedAccessPostResponse} DelegatedAccessPostResponse
         */
        DelegatedAccessPostResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.api.DelegatedAccessPostResponse)
                return object;
            var message = new $root.api.DelegatedAccessPostResponse();
            if (object.id != null)
                if ($util.Long)
                    (message.id = $util.Long.fromValue(object.id)).unsigned = true;
                else if (typeof object.id === "string")
                    message.id = parseInt(object.id, 10);
                else if (typeof object.id === "number")
                    message.id = object.id;
                else if (typeof object.id === "object")
                    message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a DelegatedAccessPostResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.DelegatedAccessPostResponse
         * @static
         * @param {api.DelegatedAccessPostResponse} message DelegatedAccessPostResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DelegatedAccessPostResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.id = options.longs === String ? "0" : 0;
            if (message.id != null && message.hasOwnProperty("id"))
                if (typeof message.id === "number")
                    object.id = options.longs === String ? String(message.id) : message.id;
                else
                    object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
            return object;
        };

        /**
         * Converts this DelegatedAccessPostResponse to JSON.
         * @function toJSON
         * @memberof api.DelegatedAccessPostResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DelegatedAccessPostResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DelegatedAccessPostResponse;
    })();

    api.DelegatedAccessGetRequest = (function() {

        /**
         * Properties of a DelegatedAccessGetRequest.
         * @memberof api
         * @interface IDelegatedAccessGetRequest
         * @property {number|Long|null} [delegatedID] DelegatedAccessGetRequest delegatedID
         */

        /**
         * Constructs a new DelegatedAccessGetRequest.
         * @memberof api
         * @classdesc Represents a DelegatedAccessGetRequest.
         * @implements IDelegatedAccessGetRequest
         * @constructor
         * @param {api.IDelegatedAccessGetRequest=} [properties] Properties to set
         */
        function DelegatedAccessGetRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DelegatedAccessGetRequest delegatedID.
         * @member {number|Long} delegatedID
         * @memberof api.DelegatedAccessGetRequest
         * @instance
         */
        DelegatedAccessGetRequest.prototype.delegatedID = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new DelegatedAccessGetRequest instance using the specified properties.
         * @function create
         * @memberof api.DelegatedAccessGetRequest
         * @static
         * @param {api.IDelegatedAccessGetRequest=} [properties] Properties to set
         * @returns {api.DelegatedAccessGetRequest} DelegatedAccessGetRequest instance
         */
        DelegatedAccessGetRequest.create = function create(properties) {
            return new DelegatedAccessGetRequest(properties);
        };

        /**
         * Encodes the specified DelegatedAccessGetRequest message. Does not implicitly {@link api.DelegatedAccessGetRequest.verify|verify} messages.
         * @function encode
         * @memberof api.DelegatedAccessGetRequest
         * @static
         * @param {api.IDelegatedAccessGetRequest} message DelegatedAccessGetRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DelegatedAccessGetRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.delegatedID != null && message.hasOwnProperty("delegatedID"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.delegatedID);
            return writer;
        };

        /**
         * Encodes the specified DelegatedAccessGetRequest message, length delimited. Does not implicitly {@link api.DelegatedAccessGetRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.DelegatedAccessGetRequest
         * @static
         * @param {api.IDelegatedAccessGetRequest} message DelegatedAccessGetRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DelegatedAccessGetRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DelegatedAccessGetRequest message from the specified reader or buffer.
         * @function decode
         * @memberof api.DelegatedAccessGetRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.DelegatedAccessGetRequest} DelegatedAccessGetRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DelegatedAccessGetRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.DelegatedAccessGetRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.delegatedID = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DelegatedAccessGetRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.DelegatedAccessGetRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.DelegatedAccessGetRequest} DelegatedAccessGetRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DelegatedAccessGetRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DelegatedAccessGetRequest message.
         * @function verify
         * @memberof api.DelegatedAccessGetRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DelegatedAccessGetRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.delegatedID != null && message.hasOwnProperty("delegatedID"))
                if (!$util.isInteger(message.delegatedID) && !(message.delegatedID && $util.isInteger(message.delegatedID.low) && $util.isInteger(message.delegatedID.high)))
                    return "delegatedID: integer|Long expected";
            return null;
        };

        /**
         * Creates a DelegatedAccessGetRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.DelegatedAccessGetRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.DelegatedAccessGetRequest} DelegatedAccessGetRequest
         */
        DelegatedAccessGetRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.api.DelegatedAccessGetRequest)
                return object;
            var message = new $root.api.DelegatedAccessGetRequest();
            if (object.delegatedID != null)
                if ($util.Long)
                    (message.delegatedID = $util.Long.fromValue(object.delegatedID)).unsigned = true;
                else if (typeof object.delegatedID === "string")
                    message.delegatedID = parseInt(object.delegatedID, 10);
                else if (typeof object.delegatedID === "number")
                    message.delegatedID = object.delegatedID;
                else if (typeof object.delegatedID === "object")
                    message.delegatedID = new $util.LongBits(object.delegatedID.low >>> 0, object.delegatedID.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a DelegatedAccessGetRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.DelegatedAccessGetRequest
         * @static
         * @param {api.DelegatedAccessGetRequest} message DelegatedAccessGetRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DelegatedAccessGetRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.delegatedID = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.delegatedID = options.longs === String ? "0" : 0;
            if (message.delegatedID != null && message.hasOwnProperty("delegatedID"))
                if (typeof message.delegatedID === "number")
                    object.delegatedID = options.longs === String ? String(message.delegatedID) : message.delegatedID;
                else
                    object.delegatedID = options.longs === String ? $util.Long.prototype.toString.call(message.delegatedID) : options.longs === Number ? new $util.LongBits(message.delegatedID.low >>> 0, message.delegatedID.high >>> 0).toNumber(true) : message.delegatedID;
            return object;
        };

        /**
         * Converts this DelegatedAccessGetRequest to JSON.
         * @function toJSON
         * @memberof api.DelegatedAccessGetRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DelegatedAccessGetRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DelegatedAccessGetRequest;
    })();

    api.DelegatedAccessGetKeysRequest = (function() {

        /**
         * Properties of a DelegatedAccessGetKeysRequest.
         * @memberof api
         * @interface IDelegatedAccessGetKeysRequest
         * @property {number|Long|null} [delegatedID] DelegatedAccessGetKeysRequest delegatedID
         */

        /**
         * Constructs a new DelegatedAccessGetKeysRequest.
         * @memberof api
         * @classdesc Represents a DelegatedAccessGetKeysRequest.
         * @implements IDelegatedAccessGetKeysRequest
         * @constructor
         * @param {api.IDelegatedAccessGetKeysRequest=} [properties] Properties to set
         */
        function DelegatedAccessGetKeysRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DelegatedAccessGetKeysRequest delegatedID.
         * @member {number|Long} delegatedID
         * @memberof api.DelegatedAccessGetKeysRequest
         * @instance
         */
        DelegatedAccessGetKeysRequest.prototype.delegatedID = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new DelegatedAccessGetKeysRequest instance using the specified properties.
         * @function create
         * @memberof api.DelegatedAccessGetKeysRequest
         * @static
         * @param {api.IDelegatedAccessGetKeysRequest=} [properties] Properties to set
         * @returns {api.DelegatedAccessGetKeysRequest} DelegatedAccessGetKeysRequest instance
         */
        DelegatedAccessGetKeysRequest.create = function create(properties) {
            return new DelegatedAccessGetKeysRequest(properties);
        };

        /**
         * Encodes the specified DelegatedAccessGetKeysRequest message. Does not implicitly {@link api.DelegatedAccessGetKeysRequest.verify|verify} messages.
         * @function encode
         * @memberof api.DelegatedAccessGetKeysRequest
         * @static
         * @param {api.IDelegatedAccessGetKeysRequest} message DelegatedAccessGetKeysRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DelegatedAccessGetKeysRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.delegatedID != null && message.hasOwnProperty("delegatedID"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.delegatedID);
            return writer;
        };

        /**
         * Encodes the specified DelegatedAccessGetKeysRequest message, length delimited. Does not implicitly {@link api.DelegatedAccessGetKeysRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.DelegatedAccessGetKeysRequest
         * @static
         * @param {api.IDelegatedAccessGetKeysRequest} message DelegatedAccessGetKeysRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DelegatedAccessGetKeysRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DelegatedAccessGetKeysRequest message from the specified reader or buffer.
         * @function decode
         * @memberof api.DelegatedAccessGetKeysRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.DelegatedAccessGetKeysRequest} DelegatedAccessGetKeysRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DelegatedAccessGetKeysRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.DelegatedAccessGetKeysRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.delegatedID = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DelegatedAccessGetKeysRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.DelegatedAccessGetKeysRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.DelegatedAccessGetKeysRequest} DelegatedAccessGetKeysRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DelegatedAccessGetKeysRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DelegatedAccessGetKeysRequest message.
         * @function verify
         * @memberof api.DelegatedAccessGetKeysRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DelegatedAccessGetKeysRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.delegatedID != null && message.hasOwnProperty("delegatedID"))
                if (!$util.isInteger(message.delegatedID) && !(message.delegatedID && $util.isInteger(message.delegatedID.low) && $util.isInteger(message.delegatedID.high)))
                    return "delegatedID: integer|Long expected";
            return null;
        };

        /**
         * Creates a DelegatedAccessGetKeysRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.DelegatedAccessGetKeysRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.DelegatedAccessGetKeysRequest} DelegatedAccessGetKeysRequest
         */
        DelegatedAccessGetKeysRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.api.DelegatedAccessGetKeysRequest)
                return object;
            var message = new $root.api.DelegatedAccessGetKeysRequest();
            if (object.delegatedID != null)
                if ($util.Long)
                    (message.delegatedID = $util.Long.fromValue(object.delegatedID)).unsigned = true;
                else if (typeof object.delegatedID === "string")
                    message.delegatedID = parseInt(object.delegatedID, 10);
                else if (typeof object.delegatedID === "number")
                    message.delegatedID = object.delegatedID;
                else if (typeof object.delegatedID === "object")
                    message.delegatedID = new $util.LongBits(object.delegatedID.low >>> 0, object.delegatedID.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a DelegatedAccessGetKeysRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.DelegatedAccessGetKeysRequest
         * @static
         * @param {api.DelegatedAccessGetKeysRequest} message DelegatedAccessGetKeysRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DelegatedAccessGetKeysRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.delegatedID = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.delegatedID = options.longs === String ? "0" : 0;
            if (message.delegatedID != null && message.hasOwnProperty("delegatedID"))
                if (typeof message.delegatedID === "number")
                    object.delegatedID = options.longs === String ? String(message.delegatedID) : message.delegatedID;
                else
                    object.delegatedID = options.longs === String ? $util.Long.prototype.toString.call(message.delegatedID) : options.longs === Number ? new $util.LongBits(message.delegatedID.low >>> 0, message.delegatedID.high >>> 0).toNumber(true) : message.delegatedID;
            return object;
        };

        /**
         * Converts this DelegatedAccessGetKeysRequest to JSON.
         * @function toJSON
         * @memberof api.DelegatedAccessGetKeysRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DelegatedAccessGetKeysRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DelegatedAccessGetKeysRequest;
    })();

    api.DelegatedAccessGetResponse = (function() {

        /**
         * Properties of a DelegatedAccessGetResponse.
         * @memberof api
         * @interface IDelegatedAccessGetResponse
         * @property {api.IResourceGetResponse|null} [resource] DelegatedAccessGetResponse resource
         * @property {Uint8Array|null} [sign] DelegatedAccessGetResponse sign
         */

        /**
         * Constructs a new DelegatedAccessGetResponse.
         * @memberof api
         * @classdesc Represents a DelegatedAccessGetResponse.
         * @implements IDelegatedAccessGetResponse
         * @constructor
         * @param {api.IDelegatedAccessGetResponse=} [properties] Properties to set
         */
        function DelegatedAccessGetResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DelegatedAccessGetResponse resource.
         * @member {api.IResourceGetResponse|null|undefined} resource
         * @memberof api.DelegatedAccessGetResponse
         * @instance
         */
        DelegatedAccessGetResponse.prototype.resource = null;

        /**
         * DelegatedAccessGetResponse sign.
         * @member {Uint8Array} sign
         * @memberof api.DelegatedAccessGetResponse
         * @instance
         */
        DelegatedAccessGetResponse.prototype.sign = $util.newBuffer([]);

        /**
         * Creates a new DelegatedAccessGetResponse instance using the specified properties.
         * @function create
         * @memberof api.DelegatedAccessGetResponse
         * @static
         * @param {api.IDelegatedAccessGetResponse=} [properties] Properties to set
         * @returns {api.DelegatedAccessGetResponse} DelegatedAccessGetResponse instance
         */
        DelegatedAccessGetResponse.create = function create(properties) {
            return new DelegatedAccessGetResponse(properties);
        };

        /**
         * Encodes the specified DelegatedAccessGetResponse message. Does not implicitly {@link api.DelegatedAccessGetResponse.verify|verify} messages.
         * @function encode
         * @memberof api.DelegatedAccessGetResponse
         * @static
         * @param {api.IDelegatedAccessGetResponse} message DelegatedAccessGetResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DelegatedAccessGetResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.resource != null && message.hasOwnProperty("resource"))
                $root.api.ResourceGetResponse.encode(message.resource, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.sign != null && message.hasOwnProperty("sign"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.sign);
            return writer;
        };

        /**
         * Encodes the specified DelegatedAccessGetResponse message, length delimited. Does not implicitly {@link api.DelegatedAccessGetResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.DelegatedAccessGetResponse
         * @static
         * @param {api.IDelegatedAccessGetResponse} message DelegatedAccessGetResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DelegatedAccessGetResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DelegatedAccessGetResponse message from the specified reader or buffer.
         * @function decode
         * @memberof api.DelegatedAccessGetResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.DelegatedAccessGetResponse} DelegatedAccessGetResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DelegatedAccessGetResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.DelegatedAccessGetResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.resource = $root.api.ResourceGetResponse.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.sign = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DelegatedAccessGetResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.DelegatedAccessGetResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.DelegatedAccessGetResponse} DelegatedAccessGetResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DelegatedAccessGetResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DelegatedAccessGetResponse message.
         * @function verify
         * @memberof api.DelegatedAccessGetResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DelegatedAccessGetResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.resource != null && message.hasOwnProperty("resource")) {
                var error = $root.api.ResourceGetResponse.verify(message.resource);
                if (error)
                    return "resource." + error;
            }
            if (message.sign != null && message.hasOwnProperty("sign"))
                if (!(message.sign && typeof message.sign.length === "number" || $util.isString(message.sign)))
                    return "sign: buffer expected";
            return null;
        };

        /**
         * Creates a DelegatedAccessGetResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.DelegatedAccessGetResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.DelegatedAccessGetResponse} DelegatedAccessGetResponse
         */
        DelegatedAccessGetResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.api.DelegatedAccessGetResponse)
                return object;
            var message = new $root.api.DelegatedAccessGetResponse();
            if (object.resource != null) {
                if (typeof object.resource !== "object")
                    throw TypeError(".api.DelegatedAccessGetResponse.resource: object expected");
                message.resource = $root.api.ResourceGetResponse.fromObject(object.resource);
            }
            if (object.sign != null)
                if (typeof object.sign === "string")
                    $util.base64.decode(object.sign, message.sign = $util.newBuffer($util.base64.length(object.sign)), 0);
                else if (object.sign.length)
                    message.sign = object.sign;
            return message;
        };

        /**
         * Creates a plain object from a DelegatedAccessGetResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.DelegatedAccessGetResponse
         * @static
         * @param {api.DelegatedAccessGetResponse} message DelegatedAccessGetResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DelegatedAccessGetResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.resource = null;
                if (options.bytes === String)
                    object.sign = "";
                else {
                    object.sign = [];
                    if (options.bytes !== Array)
                        object.sign = $util.newBuffer(object.sign);
                }
            }
            if (message.resource != null && message.hasOwnProperty("resource"))
                object.resource = $root.api.ResourceGetResponse.toObject(message.resource, options);
            if (message.sign != null && message.hasOwnProperty("sign"))
                object.sign = options.bytes === String ? $util.base64.encode(message.sign, 0, message.sign.length) : options.bytes === Array ? Array.prototype.slice.call(message.sign) : message.sign;
            return object;
        };

        /**
         * Converts this DelegatedAccessGetResponse to JSON.
         * @function toJSON
         * @memberof api.DelegatedAccessGetResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DelegatedAccessGetResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DelegatedAccessGetResponse;
    })();

    api.DelegatedKeys = (function() {

        /**
         * Properties of a DelegatedKeys.
         * @memberof api
         * @interface IDelegatedKeys
         * @property {string|null} [login] DelegatedKeys login
         * @property {number|null} [version] DelegatedKeys version
         * @property {Uint8Array|null} [signKey] DelegatedKeys signKey
         * @property {Uint8Array|null} [readKey] DelegatedKeys readKey
         * @property {Uint8Array|null} [sharingKey] DelegatedKeys sharingKey
         * @property {Uint8Array|null} [boxKey] DelegatedKeys boxKey
         */

        /**
         * Constructs a new DelegatedKeys.
         * @memberof api
         * @classdesc Represents a DelegatedKeys.
         * @implements IDelegatedKeys
         * @constructor
         * @param {api.IDelegatedKeys=} [properties] Properties to set
         */
        function DelegatedKeys(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DelegatedKeys login.
         * @member {string} login
         * @memberof api.DelegatedKeys
         * @instance
         */
        DelegatedKeys.prototype.login = "";

        /**
         * DelegatedKeys version.
         * @member {number} version
         * @memberof api.DelegatedKeys
         * @instance
         */
        DelegatedKeys.prototype.version = 0;

        /**
         * DelegatedKeys signKey.
         * @member {Uint8Array} signKey
         * @memberof api.DelegatedKeys
         * @instance
         */
        DelegatedKeys.prototype.signKey = $util.newBuffer([]);

        /**
         * DelegatedKeys readKey.
         * @member {Uint8Array} readKey
         * @memberof api.DelegatedKeys
         * @instance
         */
        DelegatedKeys.prototype.readKey = $util.newBuffer([]);

        /**
         * DelegatedKeys sharingKey.
         * @member {Uint8Array} sharingKey
         * @memberof api.DelegatedKeys
         * @instance
         */
        DelegatedKeys.prototype.sharingKey = $util.newBuffer([]);

        /**
         * DelegatedKeys boxKey.
         * @member {Uint8Array} boxKey
         * @memberof api.DelegatedKeys
         * @instance
         */
        DelegatedKeys.prototype.boxKey = $util.newBuffer([]);

        /**
         * Creates a new DelegatedKeys instance using the specified properties.
         * @function create
         * @memberof api.DelegatedKeys
         * @static
         * @param {api.IDelegatedKeys=} [properties] Properties to set
         * @returns {api.DelegatedKeys} DelegatedKeys instance
         */
        DelegatedKeys.create = function create(properties) {
            return new DelegatedKeys(properties);
        };

        /**
         * Encodes the specified DelegatedKeys message. Does not implicitly {@link api.DelegatedKeys.verify|verify} messages.
         * @function encode
         * @memberof api.DelegatedKeys
         * @static
         * @param {api.IDelegatedKeys} message DelegatedKeys message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DelegatedKeys.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            if (message.version != null && message.hasOwnProperty("version"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.version);
            if (message.signKey != null && message.hasOwnProperty("signKey"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.signKey);
            if (message.readKey != null && message.hasOwnProperty("readKey"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.readKey);
            if (message.sharingKey != null && message.hasOwnProperty("sharingKey"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.sharingKey);
            if (message.boxKey != null && message.hasOwnProperty("boxKey"))
                writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.boxKey);
            return writer;
        };

        /**
         * Encodes the specified DelegatedKeys message, length delimited. Does not implicitly {@link api.DelegatedKeys.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.DelegatedKeys
         * @static
         * @param {api.IDelegatedKeys} message DelegatedKeys message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DelegatedKeys.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DelegatedKeys message from the specified reader or buffer.
         * @function decode
         * @memberof api.DelegatedKeys
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.DelegatedKeys} DelegatedKeys
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DelegatedKeys.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.DelegatedKeys();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                case 2:
                    message.version = reader.uint32();
                    break;
                case 3:
                    message.signKey = reader.bytes();
                    break;
                case 4:
                    message.readKey = reader.bytes();
                    break;
                case 5:
                    message.sharingKey = reader.bytes();
                    break;
                case 6:
                    message.boxKey = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DelegatedKeys message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.DelegatedKeys
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.DelegatedKeys} DelegatedKeys
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DelegatedKeys.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DelegatedKeys message.
         * @function verify
         * @memberof api.DelegatedKeys
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DelegatedKeys.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isInteger(message.version))
                    return "version: integer expected";
            if (message.signKey != null && message.hasOwnProperty("signKey"))
                if (!(message.signKey && typeof message.signKey.length === "number" || $util.isString(message.signKey)))
                    return "signKey: buffer expected";
            if (message.readKey != null && message.hasOwnProperty("readKey"))
                if (!(message.readKey && typeof message.readKey.length === "number" || $util.isString(message.readKey)))
                    return "readKey: buffer expected";
            if (message.sharingKey != null && message.hasOwnProperty("sharingKey"))
                if (!(message.sharingKey && typeof message.sharingKey.length === "number" || $util.isString(message.sharingKey)))
                    return "sharingKey: buffer expected";
            if (message.boxKey != null && message.hasOwnProperty("boxKey"))
                if (!(message.boxKey && typeof message.boxKey.length === "number" || $util.isString(message.boxKey)))
                    return "boxKey: buffer expected";
            return null;
        };

        /**
         * Creates a DelegatedKeys message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.DelegatedKeys
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.DelegatedKeys} DelegatedKeys
         */
        DelegatedKeys.fromObject = function fromObject(object) {
            if (object instanceof $root.api.DelegatedKeys)
                return object;
            var message = new $root.api.DelegatedKeys();
            if (object.login != null)
                message.login = String(object.login);
            if (object.version != null)
                message.version = object.version >>> 0;
            if (object.signKey != null)
                if (typeof object.signKey === "string")
                    $util.base64.decode(object.signKey, message.signKey = $util.newBuffer($util.base64.length(object.signKey)), 0);
                else if (object.signKey.length)
                    message.signKey = object.signKey;
            if (object.readKey != null)
                if (typeof object.readKey === "string")
                    $util.base64.decode(object.readKey, message.readKey = $util.newBuffer($util.base64.length(object.readKey)), 0);
                else if (object.readKey.length)
                    message.readKey = object.readKey;
            if (object.sharingKey != null)
                if (typeof object.sharingKey === "string")
                    $util.base64.decode(object.sharingKey, message.sharingKey = $util.newBuffer($util.base64.length(object.sharingKey)), 0);
                else if (object.sharingKey.length)
                    message.sharingKey = object.sharingKey;
            if (object.boxKey != null)
                if (typeof object.boxKey === "string")
                    $util.base64.decode(object.boxKey, message.boxKey = $util.newBuffer($util.base64.length(object.boxKey)), 0);
                else if (object.boxKey.length)
                    message.boxKey = object.boxKey;
            return message;
        };

        /**
         * Creates a plain object from a DelegatedKeys message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.DelegatedKeys
         * @static
         * @param {api.DelegatedKeys} message DelegatedKeys
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DelegatedKeys.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.login = "";
                object.version = 0;
                if (options.bytes === String)
                    object.signKey = "";
                else {
                    object.signKey = [];
                    if (options.bytes !== Array)
                        object.signKey = $util.newBuffer(object.signKey);
                }
                if (options.bytes === String)
                    object.readKey = "";
                else {
                    object.readKey = [];
                    if (options.bytes !== Array)
                        object.readKey = $util.newBuffer(object.readKey);
                }
                if (options.bytes === String)
                    object.sharingKey = "";
                else {
                    object.sharingKey = [];
                    if (options.bytes !== Array)
                        object.sharingKey = $util.newBuffer(object.sharingKey);
                }
                if (options.bytes === String)
                    object.boxKey = "";
                else {
                    object.boxKey = [];
                    if (options.bytes !== Array)
                        object.boxKey = $util.newBuffer(object.boxKey);
                }
            }
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            if (message.signKey != null && message.hasOwnProperty("signKey"))
                object.signKey = options.bytes === String ? $util.base64.encode(message.signKey, 0, message.signKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.signKey) : message.signKey;
            if (message.readKey != null && message.hasOwnProperty("readKey"))
                object.readKey = options.bytes === String ? $util.base64.encode(message.readKey, 0, message.readKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.readKey) : message.readKey;
            if (message.sharingKey != null && message.hasOwnProperty("sharingKey"))
                object.sharingKey = options.bytes === String ? $util.base64.encode(message.sharingKey, 0, message.sharingKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.sharingKey) : message.sharingKey;
            if (message.boxKey != null && message.hasOwnProperty("boxKey"))
                object.boxKey = options.bytes === String ? $util.base64.encode(message.boxKey, 0, message.boxKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.boxKey) : message.boxKey;
            return object;
        };

        /**
         * Converts this DelegatedKeys to JSON.
         * @function toJSON
         * @memberof api.DelegatedKeys
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DelegatedKeys.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DelegatedKeys;
    })();

    api.DelegatedAccessGetKeysResponse = (function() {

        /**
         * Properties of a DelegatedAccessGetKeysResponse.
         * @memberof api
         * @interface IDelegatedAccessGetKeysResponse
         * @property {Uint8Array|null} [keys] DelegatedAccessGetKeysResponse keys
         */

        /**
         * Constructs a new DelegatedAccessGetKeysResponse.
         * @memberof api
         * @classdesc Represents a DelegatedAccessGetKeysResponse.
         * @implements IDelegatedAccessGetKeysResponse
         * @constructor
         * @param {api.IDelegatedAccessGetKeysResponse=} [properties] Properties to set
         */
        function DelegatedAccessGetKeysResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DelegatedAccessGetKeysResponse keys.
         * @member {Uint8Array} keys
         * @memberof api.DelegatedAccessGetKeysResponse
         * @instance
         */
        DelegatedAccessGetKeysResponse.prototype.keys = $util.newBuffer([]);

        /**
         * Creates a new DelegatedAccessGetKeysResponse instance using the specified properties.
         * @function create
         * @memberof api.DelegatedAccessGetKeysResponse
         * @static
         * @param {api.IDelegatedAccessGetKeysResponse=} [properties] Properties to set
         * @returns {api.DelegatedAccessGetKeysResponse} DelegatedAccessGetKeysResponse instance
         */
        DelegatedAccessGetKeysResponse.create = function create(properties) {
            return new DelegatedAccessGetKeysResponse(properties);
        };

        /**
         * Encodes the specified DelegatedAccessGetKeysResponse message. Does not implicitly {@link api.DelegatedAccessGetKeysResponse.verify|verify} messages.
         * @function encode
         * @memberof api.DelegatedAccessGetKeysResponse
         * @static
         * @param {api.IDelegatedAccessGetKeysResponse} message DelegatedAccessGetKeysResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DelegatedAccessGetKeysResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.keys != null && message.hasOwnProperty("keys"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.keys);
            return writer;
        };

        /**
         * Encodes the specified DelegatedAccessGetKeysResponse message, length delimited. Does not implicitly {@link api.DelegatedAccessGetKeysResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.DelegatedAccessGetKeysResponse
         * @static
         * @param {api.IDelegatedAccessGetKeysResponse} message DelegatedAccessGetKeysResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DelegatedAccessGetKeysResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DelegatedAccessGetKeysResponse message from the specified reader or buffer.
         * @function decode
         * @memberof api.DelegatedAccessGetKeysResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.DelegatedAccessGetKeysResponse} DelegatedAccessGetKeysResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DelegatedAccessGetKeysResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.DelegatedAccessGetKeysResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.keys = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DelegatedAccessGetKeysResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.DelegatedAccessGetKeysResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.DelegatedAccessGetKeysResponse} DelegatedAccessGetKeysResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DelegatedAccessGetKeysResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DelegatedAccessGetKeysResponse message.
         * @function verify
         * @memberof api.DelegatedAccessGetKeysResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DelegatedAccessGetKeysResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.keys != null && message.hasOwnProperty("keys"))
                if (!(message.keys && typeof message.keys.length === "number" || $util.isString(message.keys)))
                    return "keys: buffer expected";
            return null;
        };

        /**
         * Creates a DelegatedAccessGetKeysResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.DelegatedAccessGetKeysResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.DelegatedAccessGetKeysResponse} DelegatedAccessGetKeysResponse
         */
        DelegatedAccessGetKeysResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.api.DelegatedAccessGetKeysResponse)
                return object;
            var message = new $root.api.DelegatedAccessGetKeysResponse();
            if (object.keys != null)
                if (typeof object.keys === "string")
                    $util.base64.decode(object.keys, message.keys = $util.newBuffer($util.base64.length(object.keys)), 0);
                else if (object.keys.length)
                    message.keys = object.keys;
            return message;
        };

        /**
         * Creates a plain object from a DelegatedAccessGetKeysResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.DelegatedAccessGetKeysResponse
         * @static
         * @param {api.DelegatedAccessGetKeysResponse} message DelegatedAccessGetKeysResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DelegatedAccessGetKeysResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.keys = "";
                else {
                    object.keys = [];
                    if (options.bytes !== Array)
                        object.keys = $util.newBuffer(object.keys);
                }
            if (message.keys != null && message.hasOwnProperty("keys"))
                object.keys = options.bytes === String ? $util.base64.encode(message.keys, 0, message.keys.length) : options.bytes === Array ? Array.prototype.slice.call(message.keys) : message.keys;
            return object;
        };

        /**
         * Converts this DelegatedAccessGetKeysResponse to JSON.
         * @function toJSON
         * @memberof api.DelegatedAccessGetKeysResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DelegatedAccessGetKeysResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DelegatedAccessGetKeysResponse;
    })();

    api.DelegatedAccessPostKeysRequest = (function() {

        /**
         * Properties of a DelegatedAccessPostKeysRequest.
         * @memberof api
         * @interface IDelegatedAccessPostKeysRequest
         * @property {number|Long|null} [delegatedID] DelegatedAccessPostKeysRequest delegatedID
         * @property {Uint8Array|null} [keys] DelegatedAccessPostKeysRequest keys
         */

        /**
         * Constructs a new DelegatedAccessPostKeysRequest.
         * @memberof api
         * @classdesc Represents a DelegatedAccessPostKeysRequest.
         * @implements IDelegatedAccessPostKeysRequest
         * @constructor
         * @param {api.IDelegatedAccessPostKeysRequest=} [properties] Properties to set
         */
        function DelegatedAccessPostKeysRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DelegatedAccessPostKeysRequest delegatedID.
         * @member {number|Long} delegatedID
         * @memberof api.DelegatedAccessPostKeysRequest
         * @instance
         */
        DelegatedAccessPostKeysRequest.prototype.delegatedID = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * DelegatedAccessPostKeysRequest keys.
         * @member {Uint8Array} keys
         * @memberof api.DelegatedAccessPostKeysRequest
         * @instance
         */
        DelegatedAccessPostKeysRequest.prototype.keys = $util.newBuffer([]);

        /**
         * Creates a new DelegatedAccessPostKeysRequest instance using the specified properties.
         * @function create
         * @memberof api.DelegatedAccessPostKeysRequest
         * @static
         * @param {api.IDelegatedAccessPostKeysRequest=} [properties] Properties to set
         * @returns {api.DelegatedAccessPostKeysRequest} DelegatedAccessPostKeysRequest instance
         */
        DelegatedAccessPostKeysRequest.create = function create(properties) {
            return new DelegatedAccessPostKeysRequest(properties);
        };

        /**
         * Encodes the specified DelegatedAccessPostKeysRequest message. Does not implicitly {@link api.DelegatedAccessPostKeysRequest.verify|verify} messages.
         * @function encode
         * @memberof api.DelegatedAccessPostKeysRequest
         * @static
         * @param {api.IDelegatedAccessPostKeysRequest} message DelegatedAccessPostKeysRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DelegatedAccessPostKeysRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.delegatedID != null && message.hasOwnProperty("delegatedID"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.delegatedID);
            if (message.keys != null && message.hasOwnProperty("keys"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.keys);
            return writer;
        };

        /**
         * Encodes the specified DelegatedAccessPostKeysRequest message, length delimited. Does not implicitly {@link api.DelegatedAccessPostKeysRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.DelegatedAccessPostKeysRequest
         * @static
         * @param {api.IDelegatedAccessPostKeysRequest} message DelegatedAccessPostKeysRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DelegatedAccessPostKeysRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DelegatedAccessPostKeysRequest message from the specified reader or buffer.
         * @function decode
         * @memberof api.DelegatedAccessPostKeysRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.DelegatedAccessPostKeysRequest} DelegatedAccessPostKeysRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DelegatedAccessPostKeysRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.DelegatedAccessPostKeysRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.delegatedID = reader.uint64();
                    break;
                case 2:
                    message.keys = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DelegatedAccessPostKeysRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.DelegatedAccessPostKeysRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.DelegatedAccessPostKeysRequest} DelegatedAccessPostKeysRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DelegatedAccessPostKeysRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DelegatedAccessPostKeysRequest message.
         * @function verify
         * @memberof api.DelegatedAccessPostKeysRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DelegatedAccessPostKeysRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.delegatedID != null && message.hasOwnProperty("delegatedID"))
                if (!$util.isInteger(message.delegatedID) && !(message.delegatedID && $util.isInteger(message.delegatedID.low) && $util.isInteger(message.delegatedID.high)))
                    return "delegatedID: integer|Long expected";
            if (message.keys != null && message.hasOwnProperty("keys"))
                if (!(message.keys && typeof message.keys.length === "number" || $util.isString(message.keys)))
                    return "keys: buffer expected";
            return null;
        };

        /**
         * Creates a DelegatedAccessPostKeysRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.DelegatedAccessPostKeysRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.DelegatedAccessPostKeysRequest} DelegatedAccessPostKeysRequest
         */
        DelegatedAccessPostKeysRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.api.DelegatedAccessPostKeysRequest)
                return object;
            var message = new $root.api.DelegatedAccessPostKeysRequest();
            if (object.delegatedID != null)
                if ($util.Long)
                    (message.delegatedID = $util.Long.fromValue(object.delegatedID)).unsigned = true;
                else if (typeof object.delegatedID === "string")
                    message.delegatedID = parseInt(object.delegatedID, 10);
                else if (typeof object.delegatedID === "number")
                    message.delegatedID = object.delegatedID;
                else if (typeof object.delegatedID === "object")
                    message.delegatedID = new $util.LongBits(object.delegatedID.low >>> 0, object.delegatedID.high >>> 0).toNumber(true);
            if (object.keys != null)
                if (typeof object.keys === "string")
                    $util.base64.decode(object.keys, message.keys = $util.newBuffer($util.base64.length(object.keys)), 0);
                else if (object.keys.length)
                    message.keys = object.keys;
            return message;
        };

        /**
         * Creates a plain object from a DelegatedAccessPostKeysRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.DelegatedAccessPostKeysRequest
         * @static
         * @param {api.DelegatedAccessPostKeysRequest} message DelegatedAccessPostKeysRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DelegatedAccessPostKeysRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.delegatedID = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.delegatedID = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.keys = "";
                else {
                    object.keys = [];
                    if (options.bytes !== Array)
                        object.keys = $util.newBuffer(object.keys);
                }
            }
            if (message.delegatedID != null && message.hasOwnProperty("delegatedID"))
                if (typeof message.delegatedID === "number")
                    object.delegatedID = options.longs === String ? String(message.delegatedID) : message.delegatedID;
                else
                    object.delegatedID = options.longs === String ? $util.Long.prototype.toString.call(message.delegatedID) : options.longs === Number ? new $util.LongBits(message.delegatedID.low >>> 0, message.delegatedID.high >>> 0).toNumber(true) : message.delegatedID;
            if (message.keys != null && message.hasOwnProperty("keys"))
                object.keys = options.bytes === String ? $util.base64.encode(message.keys, 0, message.keys.length) : options.bytes === Array ? Array.prototype.slice.call(message.keys) : message.keys;
            return object;
        };

        /**
         * Converts this DelegatedAccessPostKeysRequest to JSON.
         * @function toJSON
         * @memberof api.DelegatedAccessPostKeysRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DelegatedAccessPostKeysRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DelegatedAccessPostKeysRequest;
    })();

    api.DelegatedAccess = (function() {

        /**
         * Properties of a DelegatedAccess.
         * @memberof api
         * @interface IDelegatedAccess
         * @property {number|Long|null} [id] DelegatedAccess id
         * @property {Uint8Array|null} [publicKey] DelegatedAccess publicKey
         * @property {Uint8Array|null} [sign] DelegatedAccess sign
         * @property {api.IIdentityKeyID|null} [requester] DelegatedAccess requester
         * @property {api.IIdentityKeyID|null} [target] DelegatedAccess target
         * @property {number|Long|null} [created] DelegatedAccess created
         * @property {boolean|null} [resolved] DelegatedAccess resolved
         */

        /**
         * Constructs a new DelegatedAccess.
         * @memberof api
         * @classdesc Represents a DelegatedAccess.
         * @implements IDelegatedAccess
         * @constructor
         * @param {api.IDelegatedAccess=} [properties] Properties to set
         */
        function DelegatedAccess(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DelegatedAccess id.
         * @member {number|Long} id
         * @memberof api.DelegatedAccess
         * @instance
         */
        DelegatedAccess.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * DelegatedAccess publicKey.
         * @member {Uint8Array} publicKey
         * @memberof api.DelegatedAccess
         * @instance
         */
        DelegatedAccess.prototype.publicKey = $util.newBuffer([]);

        /**
         * DelegatedAccess sign.
         * @member {Uint8Array} sign
         * @memberof api.DelegatedAccess
         * @instance
         */
        DelegatedAccess.prototype.sign = $util.newBuffer([]);

        /**
         * DelegatedAccess requester.
         * @member {api.IIdentityKeyID|null|undefined} requester
         * @memberof api.DelegatedAccess
         * @instance
         */
        DelegatedAccess.prototype.requester = null;

        /**
         * DelegatedAccess target.
         * @member {api.IIdentityKeyID|null|undefined} target
         * @memberof api.DelegatedAccess
         * @instance
         */
        DelegatedAccess.prototype.target = null;

        /**
         * DelegatedAccess created.
         * @member {number|Long} created
         * @memberof api.DelegatedAccess
         * @instance
         */
        DelegatedAccess.prototype.created = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * DelegatedAccess resolved.
         * @member {boolean} resolved
         * @memberof api.DelegatedAccess
         * @instance
         */
        DelegatedAccess.prototype.resolved = false;

        /**
         * Creates a new DelegatedAccess instance using the specified properties.
         * @function create
         * @memberof api.DelegatedAccess
         * @static
         * @param {api.IDelegatedAccess=} [properties] Properties to set
         * @returns {api.DelegatedAccess} DelegatedAccess instance
         */
        DelegatedAccess.create = function create(properties) {
            return new DelegatedAccess(properties);
        };

        /**
         * Encodes the specified DelegatedAccess message. Does not implicitly {@link api.DelegatedAccess.verify|verify} messages.
         * @function encode
         * @memberof api.DelegatedAccess
         * @static
         * @param {api.IDelegatedAccess} message DelegatedAccess message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DelegatedAccess.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.publicKey);
            if (message.sign != null && message.hasOwnProperty("sign"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.sign);
            if (message.requester != null && message.hasOwnProperty("requester"))
                $root.api.IdentityKeyID.encode(message.requester, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.target != null && message.hasOwnProperty("target"))
                $root.api.IdentityKeyID.encode(message.target, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.created != null && message.hasOwnProperty("created"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.created);
            if (message.resolved != null && message.hasOwnProperty("resolved"))
                writer.uint32(/* id 7, wireType 0 =*/56).bool(message.resolved);
            return writer;
        };

        /**
         * Encodes the specified DelegatedAccess message, length delimited. Does not implicitly {@link api.DelegatedAccess.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.DelegatedAccess
         * @static
         * @param {api.IDelegatedAccess} message DelegatedAccess message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DelegatedAccess.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DelegatedAccess message from the specified reader or buffer.
         * @function decode
         * @memberof api.DelegatedAccess
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.DelegatedAccess} DelegatedAccess
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DelegatedAccess.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.DelegatedAccess();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.uint64();
                    break;
                case 2:
                    message.publicKey = reader.bytes();
                    break;
                case 3:
                    message.sign = reader.bytes();
                    break;
                case 4:
                    message.requester = $root.api.IdentityKeyID.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.target = $root.api.IdentityKeyID.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.created = reader.int64();
                    break;
                case 7:
                    message.resolved = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DelegatedAccess message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.DelegatedAccess
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.DelegatedAccess} DelegatedAccess
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DelegatedAccess.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DelegatedAccess message.
         * @function verify
         * @memberof api.DelegatedAccess
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DelegatedAccess.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                    return "id: integer|Long expected";
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                if (!(message.publicKey && typeof message.publicKey.length === "number" || $util.isString(message.publicKey)))
                    return "publicKey: buffer expected";
            if (message.sign != null && message.hasOwnProperty("sign"))
                if (!(message.sign && typeof message.sign.length === "number" || $util.isString(message.sign)))
                    return "sign: buffer expected";
            if (message.requester != null && message.hasOwnProperty("requester")) {
                var error = $root.api.IdentityKeyID.verify(message.requester);
                if (error)
                    return "requester." + error;
            }
            if (message.target != null && message.hasOwnProperty("target")) {
                var error = $root.api.IdentityKeyID.verify(message.target);
                if (error)
                    return "target." + error;
            }
            if (message.created != null && message.hasOwnProperty("created"))
                if (!$util.isInteger(message.created) && !(message.created && $util.isInteger(message.created.low) && $util.isInteger(message.created.high)))
                    return "created: integer|Long expected";
            if (message.resolved != null && message.hasOwnProperty("resolved"))
                if (typeof message.resolved !== "boolean")
                    return "resolved: boolean expected";
            return null;
        };

        /**
         * Creates a DelegatedAccess message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.DelegatedAccess
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.DelegatedAccess} DelegatedAccess
         */
        DelegatedAccess.fromObject = function fromObject(object) {
            if (object instanceof $root.api.DelegatedAccess)
                return object;
            var message = new $root.api.DelegatedAccess();
            if (object.id != null)
                if ($util.Long)
                    (message.id = $util.Long.fromValue(object.id)).unsigned = true;
                else if (typeof object.id === "string")
                    message.id = parseInt(object.id, 10);
                else if (typeof object.id === "number")
                    message.id = object.id;
                else if (typeof object.id === "object")
                    message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
            if (object.publicKey != null)
                if (typeof object.publicKey === "string")
                    $util.base64.decode(object.publicKey, message.publicKey = $util.newBuffer($util.base64.length(object.publicKey)), 0);
                else if (object.publicKey.length)
                    message.publicKey = object.publicKey;
            if (object.sign != null)
                if (typeof object.sign === "string")
                    $util.base64.decode(object.sign, message.sign = $util.newBuffer($util.base64.length(object.sign)), 0);
                else if (object.sign.length)
                    message.sign = object.sign;
            if (object.requester != null) {
                if (typeof object.requester !== "object")
                    throw TypeError(".api.DelegatedAccess.requester: object expected");
                message.requester = $root.api.IdentityKeyID.fromObject(object.requester);
            }
            if (object.target != null) {
                if (typeof object.target !== "object")
                    throw TypeError(".api.DelegatedAccess.target: object expected");
                message.target = $root.api.IdentityKeyID.fromObject(object.target);
            }
            if (object.created != null)
                if ($util.Long)
                    (message.created = $util.Long.fromValue(object.created)).unsigned = false;
                else if (typeof object.created === "string")
                    message.created = parseInt(object.created, 10);
                else if (typeof object.created === "number")
                    message.created = object.created;
                else if (typeof object.created === "object")
                    message.created = new $util.LongBits(object.created.low >>> 0, object.created.high >>> 0).toNumber();
            if (object.resolved != null)
                message.resolved = Boolean(object.resolved);
            return message;
        };

        /**
         * Creates a plain object from a DelegatedAccess message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.DelegatedAccess
         * @static
         * @param {api.DelegatedAccess} message DelegatedAccess
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DelegatedAccess.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.id = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.publicKey = "";
                else {
                    object.publicKey = [];
                    if (options.bytes !== Array)
                        object.publicKey = $util.newBuffer(object.publicKey);
                }
                if (options.bytes === String)
                    object.sign = "";
                else {
                    object.sign = [];
                    if (options.bytes !== Array)
                        object.sign = $util.newBuffer(object.sign);
                }
                object.requester = null;
                object.target = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.created = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.created = options.longs === String ? "0" : 0;
                object.resolved = false;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                if (typeof message.id === "number")
                    object.id = options.longs === String ? String(message.id) : message.id;
                else
                    object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                object.publicKey = options.bytes === String ? $util.base64.encode(message.publicKey, 0, message.publicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.publicKey) : message.publicKey;
            if (message.sign != null && message.hasOwnProperty("sign"))
                object.sign = options.bytes === String ? $util.base64.encode(message.sign, 0, message.sign.length) : options.bytes === Array ? Array.prototype.slice.call(message.sign) : message.sign;
            if (message.requester != null && message.hasOwnProperty("requester"))
                object.requester = $root.api.IdentityKeyID.toObject(message.requester, options);
            if (message.target != null && message.hasOwnProperty("target"))
                object.target = $root.api.IdentityKeyID.toObject(message.target, options);
            if (message.created != null && message.hasOwnProperty("created"))
                if (typeof message.created === "number")
                    object.created = options.longs === String ? String(message.created) : message.created;
                else
                    object.created = options.longs === String ? $util.Long.prototype.toString.call(message.created) : options.longs === Number ? new $util.LongBits(message.created.low >>> 0, message.created.high >>> 0).toNumber() : message.created;
            if (message.resolved != null && message.hasOwnProperty("resolved"))
                object.resolved = message.resolved;
            return object;
        };

        /**
         * Converts this DelegatedAccess to JSON.
         * @function toJSON
         * @memberof api.DelegatedAccess
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DelegatedAccess.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DelegatedAccess;
    })();

    api.DelegatedAccessListRequest = (function() {

        /**
         * Properties of a DelegatedAccessListRequest.
         * @memberof api
         * @interface IDelegatedAccessListRequest
         * @property {number|null} [limit] DelegatedAccessListRequest limit
         * @property {number|Long|null} [maxID] DelegatedAccessListRequest maxID
         * @property {number|Long|null} [sinceID] DelegatedAccessListRequest sinceID
         */

        /**
         * Constructs a new DelegatedAccessListRequest.
         * @memberof api
         * @classdesc Represents a DelegatedAccessListRequest.
         * @implements IDelegatedAccessListRequest
         * @constructor
         * @param {api.IDelegatedAccessListRequest=} [properties] Properties to set
         */
        function DelegatedAccessListRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DelegatedAccessListRequest limit.
         * @member {number} limit
         * @memberof api.DelegatedAccessListRequest
         * @instance
         */
        DelegatedAccessListRequest.prototype.limit = 0;

        /**
         * DelegatedAccessListRequest maxID.
         * @member {number|Long} maxID
         * @memberof api.DelegatedAccessListRequest
         * @instance
         */
        DelegatedAccessListRequest.prototype.maxID = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * DelegatedAccessListRequest sinceID.
         * @member {number|Long} sinceID
         * @memberof api.DelegatedAccessListRequest
         * @instance
         */
        DelegatedAccessListRequest.prototype.sinceID = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new DelegatedAccessListRequest instance using the specified properties.
         * @function create
         * @memberof api.DelegatedAccessListRequest
         * @static
         * @param {api.IDelegatedAccessListRequest=} [properties] Properties to set
         * @returns {api.DelegatedAccessListRequest} DelegatedAccessListRequest instance
         */
        DelegatedAccessListRequest.create = function create(properties) {
            return new DelegatedAccessListRequest(properties);
        };

        /**
         * Encodes the specified DelegatedAccessListRequest message. Does not implicitly {@link api.DelegatedAccessListRequest.verify|verify} messages.
         * @function encode
         * @memberof api.DelegatedAccessListRequest
         * @static
         * @param {api.IDelegatedAccessListRequest} message DelegatedAccessListRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DelegatedAccessListRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.limit != null && message.hasOwnProperty("limit"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.limit);
            if (message.maxID != null && message.hasOwnProperty("maxID"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.maxID);
            if (message.sinceID != null && message.hasOwnProperty("sinceID"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.sinceID);
            return writer;
        };

        /**
         * Encodes the specified DelegatedAccessListRequest message, length delimited. Does not implicitly {@link api.DelegatedAccessListRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.DelegatedAccessListRequest
         * @static
         * @param {api.IDelegatedAccessListRequest} message DelegatedAccessListRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DelegatedAccessListRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DelegatedAccessListRequest message from the specified reader or buffer.
         * @function decode
         * @memberof api.DelegatedAccessListRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.DelegatedAccessListRequest} DelegatedAccessListRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DelegatedAccessListRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.DelegatedAccessListRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.limit = reader.uint32();
                    break;
                case 2:
                    message.maxID = reader.uint64();
                    break;
                case 3:
                    message.sinceID = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DelegatedAccessListRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.DelegatedAccessListRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.DelegatedAccessListRequest} DelegatedAccessListRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DelegatedAccessListRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DelegatedAccessListRequest message.
         * @function verify
         * @memberof api.DelegatedAccessListRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DelegatedAccessListRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.limit != null && message.hasOwnProperty("limit"))
                if (!$util.isInteger(message.limit))
                    return "limit: integer expected";
            if (message.maxID != null && message.hasOwnProperty("maxID"))
                if (!$util.isInteger(message.maxID) && !(message.maxID && $util.isInteger(message.maxID.low) && $util.isInteger(message.maxID.high)))
                    return "maxID: integer|Long expected";
            if (message.sinceID != null && message.hasOwnProperty("sinceID"))
                if (!$util.isInteger(message.sinceID) && !(message.sinceID && $util.isInteger(message.sinceID.low) && $util.isInteger(message.sinceID.high)))
                    return "sinceID: integer|Long expected";
            return null;
        };

        /**
         * Creates a DelegatedAccessListRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.DelegatedAccessListRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.DelegatedAccessListRequest} DelegatedAccessListRequest
         */
        DelegatedAccessListRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.api.DelegatedAccessListRequest)
                return object;
            var message = new $root.api.DelegatedAccessListRequest();
            if (object.limit != null)
                message.limit = object.limit >>> 0;
            if (object.maxID != null)
                if ($util.Long)
                    (message.maxID = $util.Long.fromValue(object.maxID)).unsigned = true;
                else if (typeof object.maxID === "string")
                    message.maxID = parseInt(object.maxID, 10);
                else if (typeof object.maxID === "number")
                    message.maxID = object.maxID;
                else if (typeof object.maxID === "object")
                    message.maxID = new $util.LongBits(object.maxID.low >>> 0, object.maxID.high >>> 0).toNumber(true);
            if (object.sinceID != null)
                if ($util.Long)
                    (message.sinceID = $util.Long.fromValue(object.sinceID)).unsigned = true;
                else if (typeof object.sinceID === "string")
                    message.sinceID = parseInt(object.sinceID, 10);
                else if (typeof object.sinceID === "number")
                    message.sinceID = object.sinceID;
                else if (typeof object.sinceID === "object")
                    message.sinceID = new $util.LongBits(object.sinceID.low >>> 0, object.sinceID.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a DelegatedAccessListRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.DelegatedAccessListRequest
         * @static
         * @param {api.DelegatedAccessListRequest} message DelegatedAccessListRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DelegatedAccessListRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.limit = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.maxID = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.maxID = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.sinceID = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.sinceID = options.longs === String ? "0" : 0;
            }
            if (message.limit != null && message.hasOwnProperty("limit"))
                object.limit = message.limit;
            if (message.maxID != null && message.hasOwnProperty("maxID"))
                if (typeof message.maxID === "number")
                    object.maxID = options.longs === String ? String(message.maxID) : message.maxID;
                else
                    object.maxID = options.longs === String ? $util.Long.prototype.toString.call(message.maxID) : options.longs === Number ? new $util.LongBits(message.maxID.low >>> 0, message.maxID.high >>> 0).toNumber(true) : message.maxID;
            if (message.sinceID != null && message.hasOwnProperty("sinceID"))
                if (typeof message.sinceID === "number")
                    object.sinceID = options.longs === String ? String(message.sinceID) : message.sinceID;
                else
                    object.sinceID = options.longs === String ? $util.Long.prototype.toString.call(message.sinceID) : options.longs === Number ? new $util.LongBits(message.sinceID.low >>> 0, message.sinceID.high >>> 0).toNumber(true) : message.sinceID;
            return object;
        };

        /**
         * Converts this DelegatedAccessListRequest to JSON.
         * @function toJSON
         * @memberof api.DelegatedAccessListRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DelegatedAccessListRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DelegatedAccessListRequest;
    })();

    api.DelegatedAccessListResponse = (function() {

        /**
         * Properties of a DelegatedAccessListResponse.
         * @memberof api
         * @interface IDelegatedAccessListResponse
         * @property {Array.<api.IDelegatedAccess>|null} [accesses] DelegatedAccessListResponse accesses
         */

        /**
         * Constructs a new DelegatedAccessListResponse.
         * @memberof api
         * @classdesc Represents a DelegatedAccessListResponse.
         * @implements IDelegatedAccessListResponse
         * @constructor
         * @param {api.IDelegatedAccessListResponse=} [properties] Properties to set
         */
        function DelegatedAccessListResponse(properties) {
            this.accesses = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DelegatedAccessListResponse accesses.
         * @member {Array.<api.IDelegatedAccess>} accesses
         * @memberof api.DelegatedAccessListResponse
         * @instance
         */
        DelegatedAccessListResponse.prototype.accesses = $util.emptyArray;

        /**
         * Creates a new DelegatedAccessListResponse instance using the specified properties.
         * @function create
         * @memberof api.DelegatedAccessListResponse
         * @static
         * @param {api.IDelegatedAccessListResponse=} [properties] Properties to set
         * @returns {api.DelegatedAccessListResponse} DelegatedAccessListResponse instance
         */
        DelegatedAccessListResponse.create = function create(properties) {
            return new DelegatedAccessListResponse(properties);
        };

        /**
         * Encodes the specified DelegatedAccessListResponse message. Does not implicitly {@link api.DelegatedAccessListResponse.verify|verify} messages.
         * @function encode
         * @memberof api.DelegatedAccessListResponse
         * @static
         * @param {api.IDelegatedAccessListResponse} message DelegatedAccessListResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DelegatedAccessListResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.accesses != null && message.accesses.length)
                for (var i = 0; i < message.accesses.length; ++i)
                    $root.api.DelegatedAccess.encode(message.accesses[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified DelegatedAccessListResponse message, length delimited. Does not implicitly {@link api.DelegatedAccessListResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.DelegatedAccessListResponse
         * @static
         * @param {api.IDelegatedAccessListResponse} message DelegatedAccessListResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DelegatedAccessListResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DelegatedAccessListResponse message from the specified reader or buffer.
         * @function decode
         * @memberof api.DelegatedAccessListResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.DelegatedAccessListResponse} DelegatedAccessListResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DelegatedAccessListResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.DelegatedAccessListResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.accesses && message.accesses.length))
                        message.accesses = [];
                    message.accesses.push($root.api.DelegatedAccess.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DelegatedAccessListResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.DelegatedAccessListResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.DelegatedAccessListResponse} DelegatedAccessListResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DelegatedAccessListResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DelegatedAccessListResponse message.
         * @function verify
         * @memberof api.DelegatedAccessListResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DelegatedAccessListResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.accesses != null && message.hasOwnProperty("accesses")) {
                if (!Array.isArray(message.accesses))
                    return "accesses: array expected";
                for (var i = 0; i < message.accesses.length; ++i) {
                    var error = $root.api.DelegatedAccess.verify(message.accesses[i]);
                    if (error)
                        return "accesses." + error;
                }
            }
            return null;
        };

        /**
         * Creates a DelegatedAccessListResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.DelegatedAccessListResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.DelegatedAccessListResponse} DelegatedAccessListResponse
         */
        DelegatedAccessListResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.api.DelegatedAccessListResponse)
                return object;
            var message = new $root.api.DelegatedAccessListResponse();
            if (object.accesses) {
                if (!Array.isArray(object.accesses))
                    throw TypeError(".api.DelegatedAccessListResponse.accesses: array expected");
                message.accesses = [];
                for (var i = 0; i < object.accesses.length; ++i) {
                    if (typeof object.accesses[i] !== "object")
                        throw TypeError(".api.DelegatedAccessListResponse.accesses: object expected");
                    message.accesses[i] = $root.api.DelegatedAccess.fromObject(object.accesses[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a DelegatedAccessListResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.DelegatedAccessListResponse
         * @static
         * @param {api.DelegatedAccessListResponse} message DelegatedAccessListResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DelegatedAccessListResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.accesses = [];
            if (message.accesses && message.accesses.length) {
                object.accesses = [];
                for (var j = 0; j < message.accesses.length; ++j)
                    object.accesses[j] = $root.api.DelegatedAccess.toObject(message.accesses[j], options);
            }
            return object;
        };

        /**
         * Converts this DelegatedAccessListResponse to JSON.
         * @function toJSON
         * @memberof api.DelegatedAccessListResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DelegatedAccessListResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DelegatedAccessListResponse;
    })();

    /**
     * RegisterTokenStatus enum.
     * @name api.RegisterTokenStatus
     * @enum {string}
     * @property {number} PENDING=0 PENDING value
     * @property {number} SENT=1 SENT value
     * @property {number} RECEIVED=2 RECEIVED value
     */
    api.RegisterTokenStatus = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "PENDING"] = 0;
        values[valuesById[1] = "SENT"] = 1;
        values[valuesById[2] = "RECEIVED"] = 2;
        return values;
    })();

    api.RegisterEmailValidationToken = (function() {

        /**
         * Properties of a RegisterEmailValidationToken.
         * @memberof api
         * @interface IRegisterEmailValidationToken
         * @property {Uint8Array|null} [token] RegisterEmailValidationToken token
         * @property {string|null} [email] RegisterEmailValidationToken email
         * @property {number|Long|null} [created] RegisterEmailValidationToken created
         * @property {api.RegisterTokenStatus|null} [status] RegisterEmailValidationToken status
         */

        /**
         * Constructs a new RegisterEmailValidationToken.
         * @memberof api
         * @classdesc Represents a RegisterEmailValidationToken.
         * @implements IRegisterEmailValidationToken
         * @constructor
         * @param {api.IRegisterEmailValidationToken=} [properties] Properties to set
         */
        function RegisterEmailValidationToken(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RegisterEmailValidationToken token.
         * @member {Uint8Array} token
         * @memberof api.RegisterEmailValidationToken
         * @instance
         */
        RegisterEmailValidationToken.prototype.token = $util.newBuffer([]);

        /**
         * RegisterEmailValidationToken email.
         * @member {string} email
         * @memberof api.RegisterEmailValidationToken
         * @instance
         */
        RegisterEmailValidationToken.prototype.email = "";

        /**
         * RegisterEmailValidationToken created.
         * @member {number|Long} created
         * @memberof api.RegisterEmailValidationToken
         * @instance
         */
        RegisterEmailValidationToken.prototype.created = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * RegisterEmailValidationToken status.
         * @member {api.RegisterTokenStatus} status
         * @memberof api.RegisterEmailValidationToken
         * @instance
         */
        RegisterEmailValidationToken.prototype.status = 0;

        /**
         * Creates a new RegisterEmailValidationToken instance using the specified properties.
         * @function create
         * @memberof api.RegisterEmailValidationToken
         * @static
         * @param {api.IRegisterEmailValidationToken=} [properties] Properties to set
         * @returns {api.RegisterEmailValidationToken} RegisterEmailValidationToken instance
         */
        RegisterEmailValidationToken.create = function create(properties) {
            return new RegisterEmailValidationToken(properties);
        };

        /**
         * Encodes the specified RegisterEmailValidationToken message. Does not implicitly {@link api.RegisterEmailValidationToken.verify|verify} messages.
         * @function encode
         * @memberof api.RegisterEmailValidationToken
         * @static
         * @param {api.IRegisterEmailValidationToken} message RegisterEmailValidationToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RegisterEmailValidationToken.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.token != null && message.hasOwnProperty("token"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.token);
            if (message.email != null && message.hasOwnProperty("email"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.email);
            if (message.created != null && message.hasOwnProperty("created"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.created);
            if (message.status != null && message.hasOwnProperty("status"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.status);
            return writer;
        };

        /**
         * Encodes the specified RegisterEmailValidationToken message, length delimited. Does not implicitly {@link api.RegisterEmailValidationToken.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.RegisterEmailValidationToken
         * @static
         * @param {api.IRegisterEmailValidationToken} message RegisterEmailValidationToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RegisterEmailValidationToken.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RegisterEmailValidationToken message from the specified reader or buffer.
         * @function decode
         * @memberof api.RegisterEmailValidationToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.RegisterEmailValidationToken} RegisterEmailValidationToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RegisterEmailValidationToken.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.RegisterEmailValidationToken();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.token = reader.bytes();
                    break;
                case 2:
                    message.email = reader.string();
                    break;
                case 3:
                    message.created = reader.int64();
                    break;
                case 4:
                    message.status = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RegisterEmailValidationToken message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.RegisterEmailValidationToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.RegisterEmailValidationToken} RegisterEmailValidationToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RegisterEmailValidationToken.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RegisterEmailValidationToken message.
         * @function verify
         * @memberof api.RegisterEmailValidationToken
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RegisterEmailValidationToken.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.token != null && message.hasOwnProperty("token"))
                if (!(message.token && typeof message.token.length === "number" || $util.isString(message.token)))
                    return "token: buffer expected";
            if (message.email != null && message.hasOwnProperty("email"))
                if (!$util.isString(message.email))
                    return "email: string expected";
            if (message.created != null && message.hasOwnProperty("created"))
                if (!$util.isInteger(message.created) && !(message.created && $util.isInteger(message.created.low) && $util.isInteger(message.created.high)))
                    return "created: integer|Long expected";
            if (message.status != null && message.hasOwnProperty("status"))
                switch (message.status) {
                default:
                    return "status: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            return null;
        };

        /**
         * Creates a RegisterEmailValidationToken message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.RegisterEmailValidationToken
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.RegisterEmailValidationToken} RegisterEmailValidationToken
         */
        RegisterEmailValidationToken.fromObject = function fromObject(object) {
            if (object instanceof $root.api.RegisterEmailValidationToken)
                return object;
            var message = new $root.api.RegisterEmailValidationToken();
            if (object.token != null)
                if (typeof object.token === "string")
                    $util.base64.decode(object.token, message.token = $util.newBuffer($util.base64.length(object.token)), 0);
                else if (object.token.length)
                    message.token = object.token;
            if (object.email != null)
                message.email = String(object.email);
            if (object.created != null)
                if ($util.Long)
                    (message.created = $util.Long.fromValue(object.created)).unsigned = false;
                else if (typeof object.created === "string")
                    message.created = parseInt(object.created, 10);
                else if (typeof object.created === "number")
                    message.created = object.created;
                else if (typeof object.created === "object")
                    message.created = new $util.LongBits(object.created.low >>> 0, object.created.high >>> 0).toNumber();
            switch (object.status) {
            case "PENDING":
            case 0:
                message.status = 0;
                break;
            case "SENT":
            case 1:
                message.status = 1;
                break;
            case "RECEIVED":
            case 2:
                message.status = 2;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a RegisterEmailValidationToken message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.RegisterEmailValidationToken
         * @static
         * @param {api.RegisterEmailValidationToken} message RegisterEmailValidationToken
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RegisterEmailValidationToken.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.token = "";
                else {
                    object.token = [];
                    if (options.bytes !== Array)
                        object.token = $util.newBuffer(object.token);
                }
                object.email = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.created = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.created = options.longs === String ? "0" : 0;
                object.status = options.enums === String ? "PENDING" : 0;
            }
            if (message.token != null && message.hasOwnProperty("token"))
                object.token = options.bytes === String ? $util.base64.encode(message.token, 0, message.token.length) : options.bytes === Array ? Array.prototype.slice.call(message.token) : message.token;
            if (message.email != null && message.hasOwnProperty("email"))
                object.email = message.email;
            if (message.created != null && message.hasOwnProperty("created"))
                if (typeof message.created === "number")
                    object.created = options.longs === String ? String(message.created) : message.created;
                else
                    object.created = options.longs === String ? $util.Long.prototype.toString.call(message.created) : options.longs === Number ? new $util.LongBits(message.created.low >>> 0, message.created.high >>> 0).toNumber() : message.created;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = options.enums === String ? $root.api.RegisterTokenStatus[message.status] : message.status;
            return object;
        };

        /**
         * Converts this RegisterEmailValidationToken to JSON.
         * @function toJSON
         * @memberof api.RegisterEmailValidationToken
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RegisterEmailValidationToken.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RegisterEmailValidationToken;
    })();

    api.RegisterLinkRequest = (function() {

        /**
         * Properties of a RegisterLinkRequest.
         * @memberof api
         * @interface IRegisterLinkRequest
         * @property {string|null} [email] RegisterLinkRequest email
         */

        /**
         * Constructs a new RegisterLinkRequest.
         * @memberof api
         * @classdesc Represents a RegisterLinkRequest.
         * @implements IRegisterLinkRequest
         * @constructor
         * @param {api.IRegisterLinkRequest=} [properties] Properties to set
         */
        function RegisterLinkRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RegisterLinkRequest email.
         * @member {string} email
         * @memberof api.RegisterLinkRequest
         * @instance
         */
        RegisterLinkRequest.prototype.email = "";

        /**
         * Creates a new RegisterLinkRequest instance using the specified properties.
         * @function create
         * @memberof api.RegisterLinkRequest
         * @static
         * @param {api.IRegisterLinkRequest=} [properties] Properties to set
         * @returns {api.RegisterLinkRequest} RegisterLinkRequest instance
         */
        RegisterLinkRequest.create = function create(properties) {
            return new RegisterLinkRequest(properties);
        };

        /**
         * Encodes the specified RegisterLinkRequest message. Does not implicitly {@link api.RegisterLinkRequest.verify|verify} messages.
         * @function encode
         * @memberof api.RegisterLinkRequest
         * @static
         * @param {api.IRegisterLinkRequest} message RegisterLinkRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RegisterLinkRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.email != null && message.hasOwnProperty("email"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.email);
            return writer;
        };

        /**
         * Encodes the specified RegisterLinkRequest message, length delimited. Does not implicitly {@link api.RegisterLinkRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.RegisterLinkRequest
         * @static
         * @param {api.IRegisterLinkRequest} message RegisterLinkRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RegisterLinkRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RegisterLinkRequest message from the specified reader or buffer.
         * @function decode
         * @memberof api.RegisterLinkRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.RegisterLinkRequest} RegisterLinkRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RegisterLinkRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.RegisterLinkRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.email = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RegisterLinkRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.RegisterLinkRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.RegisterLinkRequest} RegisterLinkRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RegisterLinkRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RegisterLinkRequest message.
         * @function verify
         * @memberof api.RegisterLinkRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RegisterLinkRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.email != null && message.hasOwnProperty("email"))
                if (!$util.isString(message.email))
                    return "email: string expected";
            return null;
        };

        /**
         * Creates a RegisterLinkRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.RegisterLinkRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.RegisterLinkRequest} RegisterLinkRequest
         */
        RegisterLinkRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.api.RegisterLinkRequest)
                return object;
            var message = new $root.api.RegisterLinkRequest();
            if (object.email != null)
                message.email = String(object.email);
            return message;
        };

        /**
         * Creates a plain object from a RegisterLinkRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.RegisterLinkRequest
         * @static
         * @param {api.RegisterLinkRequest} message RegisterLinkRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RegisterLinkRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.email = "";
            if (message.email != null && message.hasOwnProperty("email"))
                object.email = message.email;
            return object;
        };

        /**
         * Converts this RegisterLinkRequest to JSON.
         * @function toJSON
         * @memberof api.RegisterLinkRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RegisterLinkRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RegisterLinkRequest;
    })();

    api.LinksGetResponse = (function() {

        /**
         * Properties of a LinksGetResponse.
         * @memberof api
         * @interface ILinksGetResponse
         * @property {Array.<api.IRegisterEmailValidationToken>|null} [links] LinksGetResponse links
         */

        /**
         * Constructs a new LinksGetResponse.
         * @memberof api
         * @classdesc Represents a LinksGetResponse.
         * @implements ILinksGetResponse
         * @constructor
         * @param {api.ILinksGetResponse=} [properties] Properties to set
         */
        function LinksGetResponse(properties) {
            this.links = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LinksGetResponse links.
         * @member {Array.<api.IRegisterEmailValidationToken>} links
         * @memberof api.LinksGetResponse
         * @instance
         */
        LinksGetResponse.prototype.links = $util.emptyArray;

        /**
         * Creates a new LinksGetResponse instance using the specified properties.
         * @function create
         * @memberof api.LinksGetResponse
         * @static
         * @param {api.ILinksGetResponse=} [properties] Properties to set
         * @returns {api.LinksGetResponse} LinksGetResponse instance
         */
        LinksGetResponse.create = function create(properties) {
            return new LinksGetResponse(properties);
        };

        /**
         * Encodes the specified LinksGetResponse message. Does not implicitly {@link api.LinksGetResponse.verify|verify} messages.
         * @function encode
         * @memberof api.LinksGetResponse
         * @static
         * @param {api.ILinksGetResponse} message LinksGetResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LinksGetResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.links != null && message.links.length)
                for (var i = 0; i < message.links.length; ++i)
                    $root.api.RegisterEmailValidationToken.encode(message.links[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified LinksGetResponse message, length delimited. Does not implicitly {@link api.LinksGetResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.LinksGetResponse
         * @static
         * @param {api.ILinksGetResponse} message LinksGetResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LinksGetResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LinksGetResponse message from the specified reader or buffer.
         * @function decode
         * @memberof api.LinksGetResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.LinksGetResponse} LinksGetResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LinksGetResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.LinksGetResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.links && message.links.length))
                        message.links = [];
                    message.links.push($root.api.RegisterEmailValidationToken.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LinksGetResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.LinksGetResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.LinksGetResponse} LinksGetResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LinksGetResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LinksGetResponse message.
         * @function verify
         * @memberof api.LinksGetResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LinksGetResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.links != null && message.hasOwnProperty("links")) {
                if (!Array.isArray(message.links))
                    return "links: array expected";
                for (var i = 0; i < message.links.length; ++i) {
                    var error = $root.api.RegisterEmailValidationToken.verify(message.links[i]);
                    if (error)
                        return "links." + error;
                }
            }
            return null;
        };

        /**
         * Creates a LinksGetResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.LinksGetResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.LinksGetResponse} LinksGetResponse
         */
        LinksGetResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.api.LinksGetResponse)
                return object;
            var message = new $root.api.LinksGetResponse();
            if (object.links) {
                if (!Array.isArray(object.links))
                    throw TypeError(".api.LinksGetResponse.links: array expected");
                message.links = [];
                for (var i = 0; i < object.links.length; ++i) {
                    if (typeof object.links[i] !== "object")
                        throw TypeError(".api.LinksGetResponse.links: object expected");
                    message.links[i] = $root.api.RegisterEmailValidationToken.fromObject(object.links[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a LinksGetResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.LinksGetResponse
         * @static
         * @param {api.LinksGetResponse} message LinksGetResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LinksGetResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.links = [];
            if (message.links && message.links.length) {
                object.links = [];
                for (var j = 0; j < message.links.length; ++j)
                    object.links[j] = $root.api.RegisterEmailValidationToken.toObject(message.links[j], options);
            }
            return object;
        };

        /**
         * Converts this LinksGetResponse to JSON.
         * @function toJSON
         * @memberof api.LinksGetResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LinksGetResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return LinksGetResponse;
    })();

    api.LinkTokenGetResponse = (function() {

        /**
         * Properties of a LinkTokenGetResponse.
         * @memberof api
         * @interface ILinkTokenGetResponse
         * @property {string|null} [email] LinkTokenGetResponse email
         */

        /**
         * Constructs a new LinkTokenGetResponse.
         * @memberof api
         * @classdesc Represents a LinkTokenGetResponse.
         * @implements ILinkTokenGetResponse
         * @constructor
         * @param {api.ILinkTokenGetResponse=} [properties] Properties to set
         */
        function LinkTokenGetResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LinkTokenGetResponse email.
         * @member {string} email
         * @memberof api.LinkTokenGetResponse
         * @instance
         */
        LinkTokenGetResponse.prototype.email = "";

        /**
         * Creates a new LinkTokenGetResponse instance using the specified properties.
         * @function create
         * @memberof api.LinkTokenGetResponse
         * @static
         * @param {api.ILinkTokenGetResponse=} [properties] Properties to set
         * @returns {api.LinkTokenGetResponse} LinkTokenGetResponse instance
         */
        LinkTokenGetResponse.create = function create(properties) {
            return new LinkTokenGetResponse(properties);
        };

        /**
         * Encodes the specified LinkTokenGetResponse message. Does not implicitly {@link api.LinkTokenGetResponse.verify|verify} messages.
         * @function encode
         * @memberof api.LinkTokenGetResponse
         * @static
         * @param {api.ILinkTokenGetResponse} message LinkTokenGetResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LinkTokenGetResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.email != null && message.hasOwnProperty("email"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.email);
            return writer;
        };

        /**
         * Encodes the specified LinkTokenGetResponse message, length delimited. Does not implicitly {@link api.LinkTokenGetResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.LinkTokenGetResponse
         * @static
         * @param {api.ILinkTokenGetResponse} message LinkTokenGetResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LinkTokenGetResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LinkTokenGetResponse message from the specified reader or buffer.
         * @function decode
         * @memberof api.LinkTokenGetResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.LinkTokenGetResponse} LinkTokenGetResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LinkTokenGetResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.LinkTokenGetResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.email = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LinkTokenGetResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.LinkTokenGetResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.LinkTokenGetResponse} LinkTokenGetResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LinkTokenGetResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LinkTokenGetResponse message.
         * @function verify
         * @memberof api.LinkTokenGetResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LinkTokenGetResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.email != null && message.hasOwnProperty("email"))
                if (!$util.isString(message.email))
                    return "email: string expected";
            return null;
        };

        /**
         * Creates a LinkTokenGetResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.LinkTokenGetResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.LinkTokenGetResponse} LinkTokenGetResponse
         */
        LinkTokenGetResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.api.LinkTokenGetResponse)
                return object;
            var message = new $root.api.LinkTokenGetResponse();
            if (object.email != null)
                message.email = String(object.email);
            return message;
        };

        /**
         * Creates a plain object from a LinkTokenGetResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.LinkTokenGetResponse
         * @static
         * @param {api.LinkTokenGetResponse} message LinkTokenGetResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LinkTokenGetResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.email = "";
            if (message.email != null && message.hasOwnProperty("email"))
                object.email = message.email;
            return object;
        };

        /**
         * Converts this LinkTokenGetResponse to JSON.
         * @function toJSON
         * @memberof api.LinkTokenGetResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LinkTokenGetResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return LinkTokenGetResponse;
    })();

    api.RegisterPostLinkTokenRequest = (function() {

        /**
         * Properties of a RegisterPostLinkTokenRequest.
         * @memberof api
         * @interface IRegisterPostLinkTokenRequest
         * @property {string|null} [token] RegisterPostLinkTokenRequest token
         * @property {api.IIdentityFields|null} [identity] RegisterPostLinkTokenRequest identity
         * @property {api.IIdentityEncryptedKeySet|null} [encryption] RegisterPostLinkTokenRequest encryption
         */

        /**
         * Constructs a new RegisterPostLinkTokenRequest.
         * @memberof api
         * @classdesc Represents a RegisterPostLinkTokenRequest.
         * @implements IRegisterPostLinkTokenRequest
         * @constructor
         * @param {api.IRegisterPostLinkTokenRequest=} [properties] Properties to set
         */
        function RegisterPostLinkTokenRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RegisterPostLinkTokenRequest token.
         * @member {string} token
         * @memberof api.RegisterPostLinkTokenRequest
         * @instance
         */
        RegisterPostLinkTokenRequest.prototype.token = "";

        /**
         * RegisterPostLinkTokenRequest identity.
         * @member {api.IIdentityFields|null|undefined} identity
         * @memberof api.RegisterPostLinkTokenRequest
         * @instance
         */
        RegisterPostLinkTokenRequest.prototype.identity = null;

        /**
         * RegisterPostLinkTokenRequest encryption.
         * @member {api.IIdentityEncryptedKeySet|null|undefined} encryption
         * @memberof api.RegisterPostLinkTokenRequest
         * @instance
         */
        RegisterPostLinkTokenRequest.prototype.encryption = null;

        /**
         * Creates a new RegisterPostLinkTokenRequest instance using the specified properties.
         * @function create
         * @memberof api.RegisterPostLinkTokenRequest
         * @static
         * @param {api.IRegisterPostLinkTokenRequest=} [properties] Properties to set
         * @returns {api.RegisterPostLinkTokenRequest} RegisterPostLinkTokenRequest instance
         */
        RegisterPostLinkTokenRequest.create = function create(properties) {
            return new RegisterPostLinkTokenRequest(properties);
        };

        /**
         * Encodes the specified RegisterPostLinkTokenRequest message. Does not implicitly {@link api.RegisterPostLinkTokenRequest.verify|verify} messages.
         * @function encode
         * @memberof api.RegisterPostLinkTokenRequest
         * @static
         * @param {api.IRegisterPostLinkTokenRequest} message RegisterPostLinkTokenRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RegisterPostLinkTokenRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.token != null && message.hasOwnProperty("token"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.token);
            if (message.identity != null && message.hasOwnProperty("identity"))
                $root.api.IdentityFields.encode(message.identity, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.encryption != null && message.hasOwnProperty("encryption"))
                $root.api.IdentityEncryptedKeySet.encode(message.encryption, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified RegisterPostLinkTokenRequest message, length delimited. Does not implicitly {@link api.RegisterPostLinkTokenRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.RegisterPostLinkTokenRequest
         * @static
         * @param {api.IRegisterPostLinkTokenRequest} message RegisterPostLinkTokenRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RegisterPostLinkTokenRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RegisterPostLinkTokenRequest message from the specified reader or buffer.
         * @function decode
         * @memberof api.RegisterPostLinkTokenRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.RegisterPostLinkTokenRequest} RegisterPostLinkTokenRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RegisterPostLinkTokenRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.RegisterPostLinkTokenRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.token = reader.string();
                    break;
                case 2:
                    message.identity = $root.api.IdentityFields.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.encryption = $root.api.IdentityEncryptedKeySet.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RegisterPostLinkTokenRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.RegisterPostLinkTokenRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.RegisterPostLinkTokenRequest} RegisterPostLinkTokenRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RegisterPostLinkTokenRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RegisterPostLinkTokenRequest message.
         * @function verify
         * @memberof api.RegisterPostLinkTokenRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RegisterPostLinkTokenRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.token != null && message.hasOwnProperty("token"))
                if (!$util.isString(message.token))
                    return "token: string expected";
            if (message.identity != null && message.hasOwnProperty("identity")) {
                var error = $root.api.IdentityFields.verify(message.identity);
                if (error)
                    return "identity." + error;
            }
            if (message.encryption != null && message.hasOwnProperty("encryption")) {
                var error = $root.api.IdentityEncryptedKeySet.verify(message.encryption);
                if (error)
                    return "encryption." + error;
            }
            return null;
        };

        /**
         * Creates a RegisterPostLinkTokenRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.RegisterPostLinkTokenRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.RegisterPostLinkTokenRequest} RegisterPostLinkTokenRequest
         */
        RegisterPostLinkTokenRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.api.RegisterPostLinkTokenRequest)
                return object;
            var message = new $root.api.RegisterPostLinkTokenRequest();
            if (object.token != null)
                message.token = String(object.token);
            if (object.identity != null) {
                if (typeof object.identity !== "object")
                    throw TypeError(".api.RegisterPostLinkTokenRequest.identity: object expected");
                message.identity = $root.api.IdentityFields.fromObject(object.identity);
            }
            if (object.encryption != null) {
                if (typeof object.encryption !== "object")
                    throw TypeError(".api.RegisterPostLinkTokenRequest.encryption: object expected");
                message.encryption = $root.api.IdentityEncryptedKeySet.fromObject(object.encryption);
            }
            return message;
        };

        /**
         * Creates a plain object from a RegisterPostLinkTokenRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.RegisterPostLinkTokenRequest
         * @static
         * @param {api.RegisterPostLinkTokenRequest} message RegisterPostLinkTokenRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RegisterPostLinkTokenRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.token = "";
                object.identity = null;
                object.encryption = null;
            }
            if (message.token != null && message.hasOwnProperty("token"))
                object.token = message.token;
            if (message.identity != null && message.hasOwnProperty("identity"))
                object.identity = $root.api.IdentityFields.toObject(message.identity, options);
            if (message.encryption != null && message.hasOwnProperty("encryption"))
                object.encryption = $root.api.IdentityEncryptedKeySet.toObject(message.encryption, options);
            return object;
        };

        /**
         * Converts this RegisterPostLinkTokenRequest to JSON.
         * @function toJSON
         * @memberof api.RegisterPostLinkTokenRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RegisterPostLinkTokenRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RegisterPostLinkTokenRequest;
    })();

    api.ProtoError = (function() {

        /**
         * Properties of a ProtoError.
         * @memberof api
         * @interface IProtoError
         * @property {number|null} [code] ProtoError code
         * @property {api.PepsErrorKind|null} [kind] ProtoError kind
         * @property {google.protobuf.IAny|null} [payload] ProtoError payload
         */

        /**
         * Constructs a new ProtoError.
         * @memberof api
         * @classdesc Represents a ProtoError.
         * @implements IProtoError
         * @constructor
         * @param {api.IProtoError=} [properties] Properties to set
         */
        function ProtoError(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtoError code.
         * @member {number} code
         * @memberof api.ProtoError
         * @instance
         */
        ProtoError.prototype.code = 0;

        /**
         * ProtoError kind.
         * @member {api.PepsErrorKind} kind
         * @memberof api.ProtoError
         * @instance
         */
        ProtoError.prototype.kind = 0;

        /**
         * ProtoError payload.
         * @member {google.protobuf.IAny|null|undefined} payload
         * @memberof api.ProtoError
         * @instance
         */
        ProtoError.prototype.payload = null;

        /**
         * Creates a new ProtoError instance using the specified properties.
         * @function create
         * @memberof api.ProtoError
         * @static
         * @param {api.IProtoError=} [properties] Properties to set
         * @returns {api.ProtoError} ProtoError instance
         */
        ProtoError.create = function create(properties) {
            return new ProtoError(properties);
        };

        /**
         * Encodes the specified ProtoError message. Does not implicitly {@link api.ProtoError.verify|verify} messages.
         * @function encode
         * @memberof api.ProtoError
         * @static
         * @param {api.IProtoError} message ProtoError message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoError.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.code != null && message.hasOwnProperty("code"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.code);
            if (message.kind != null && message.hasOwnProperty("kind"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.kind);
            if (message.payload != null && message.hasOwnProperty("payload"))
                $root.google.protobuf.Any.encode(message.payload, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ProtoError message, length delimited. Does not implicitly {@link api.ProtoError.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.ProtoError
         * @static
         * @param {api.IProtoError} message ProtoError message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoError.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoError message from the specified reader or buffer.
         * @function decode
         * @memberof api.ProtoError
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.ProtoError} ProtoError
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoError.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ProtoError();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.code = reader.uint32();
                    break;
                case 2:
                    message.kind = reader.int32();
                    break;
                case 3:
                    message.payload = $root.google.protobuf.Any.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoError message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.ProtoError
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.ProtoError} ProtoError
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoError.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoError message.
         * @function verify
         * @memberof api.ProtoError
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoError.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.code != null && message.hasOwnProperty("code"))
                if (!$util.isInteger(message.code))
                    return "code: integer expected";
            if (message.kind != null && message.hasOwnProperty("kind"))
                switch (message.kind) {
                default:
                    return "kind: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 24:
                case 25:
                case 26:
                case 27:
                case 28:
                case 29:
                case 33:
                case 34:
                case 35:
                case 36:
                case 37:
                case 38:
                case 39:
                    break;
                }
            if (message.payload != null && message.hasOwnProperty("payload")) {
                var error = $root.google.protobuf.Any.verify(message.payload);
                if (error)
                    return "payload." + error;
            }
            return null;
        };

        /**
         * Creates a ProtoError message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.ProtoError
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.ProtoError} ProtoError
         */
        ProtoError.fromObject = function fromObject(object) {
            if (object instanceof $root.api.ProtoError)
                return object;
            var message = new $root.api.ProtoError();
            if (object.code != null)
                message.code = object.code >>> 0;
            switch (object.kind) {
            case "ServerInternalError":
            case 0:
                message.kind = 0;
                break;
            case "SessionExpired":
            case 1:
                message.kind = 1;
                break;
            case "SessionStale":
            case 2:
                message.kind = 2;
                break;
            case "SessionInvalidSalt":
            case 3:
                message.kind = 3;
                break;
            case "AssumeStale":
            case 4:
                message.kind = 4;
                break;
            case "RequestBadUriParams":
            case 6:
                message.kind = 6;
                break;
            case "RequestMissingHeader":
            case 7:
                message.kind = 7;
                break;
            case "RequestDecodeHeader":
            case 8:
                message.kind = 8;
                break;
            case "RequestBadRequest":
            case 9:
                message.kind = 9;
                break;
            case "IdentityCannotAssumeOwnership":
            case 10:
                message.kind = 10;
                break;
            case "IdentityCannotAssumeAccess":
            case 11:
                message.kind = 11;
                break;
            case "IdentitySignatureMismatch":
            case 12:
                message.kind = 12;
                break;
            case "IdentityInvalidLogin":
            case 13:
                message.kind = 13;
                break;
            case "IdentityAlreadyExists":
            case 14:
                message.kind = 14;
                break;
            case "IdentityNotFound":
            case 15:
                message.kind = 15;
                break;
            case "IdentityVersionMismatch":
            case 16:
                message.kind = 16;
                break;
            case "IdentityNotAdmin":
            case 17:
                message.kind = 17;
                break;
            case "IdentitiesNotFound":
            case 18:
                message.kind = 18;
                break;
            case "IdentitySharingKindMismatch":
            case 19:
                message.kind = 19;
                break;
            case "ResourceNotFound":
            case 24:
                message.kind = 24;
                break;
            case "RegisterInvalidEmail":
            case 25:
                message.kind = 25;
                break;
            case "RegisterTokenNotFound":
            case 26:
                message.kind = 26;
                break;
            case "ChannelNotFound":
            case 27:
                message.kind = 27;
                break;
            case "DelegatedAccessNotFound":
            case 28:
                message.kind = 28;
                break;
            case "InvalidToken":
            case 29:
                message.kind = 29;
                break;
            case "ApplicationConfigNotFound":
            case 33:
                message.kind = 33;
                break;
            case "ApplicationConfigInvalid":
            case 34:
                message.kind = 34;
                break;
            case "NamedResourceNotFound":
            case 35:
                message.kind = 35;
                break;
            case "ApplicationInvalidToken":
            case 36:
                message.kind = 36;
                break;
            case "TenantCustomerNotFound":
            case 37:
                message.kind = 37;
                break;
            case "TenantPackNotFound":
            case 38:
                message.kind = 38;
                break;
            case "TenantQuotasReached":
            case 39:
                message.kind = 39;
                break;
            }
            if (object.payload != null) {
                if (typeof object.payload !== "object")
                    throw TypeError(".api.ProtoError.payload: object expected");
                message.payload = $root.google.protobuf.Any.fromObject(object.payload);
            }
            return message;
        };

        /**
         * Creates a plain object from a ProtoError message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.ProtoError
         * @static
         * @param {api.ProtoError} message ProtoError
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoError.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.code = 0;
                object.kind = options.enums === String ? "ServerInternalError" : 0;
                object.payload = null;
            }
            if (message.code != null && message.hasOwnProperty("code"))
                object.code = message.code;
            if (message.kind != null && message.hasOwnProperty("kind"))
                object.kind = options.enums === String ? $root.api.PepsErrorKind[message.kind] : message.kind;
            if (message.payload != null && message.hasOwnProperty("payload"))
                object.payload = $root.google.protobuf.Any.toObject(message.payload, options);
            return object;
        };

        /**
         * Converts this ProtoError to JSON.
         * @function toJSON
         * @memberof api.ProtoError
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoError.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoError;
    })();

    /**
     * PepsErrorKind enum.
     * @name api.PepsErrorKind
     * @enum {string}
     * @property {number} ServerInternalError=0 ServerInternalError value
     * @property {number} SessionExpired=1 SessionExpired value
     * @property {number} SessionStale=2 SessionStale value
     * @property {number} SessionInvalidSalt=3 SessionInvalidSalt value
     * @property {number} AssumeStale=4 AssumeStale value
     * @property {number} RequestBadUriParams=6 RequestBadUriParams value
     * @property {number} RequestMissingHeader=7 RequestMissingHeader value
     * @property {number} RequestDecodeHeader=8 RequestDecodeHeader value
     * @property {number} RequestBadRequest=9 RequestBadRequest value
     * @property {number} IdentityCannotAssumeOwnership=10 IdentityCannotAssumeOwnership value
     * @property {number} IdentityCannotAssumeAccess=11 IdentityCannotAssumeAccess value
     * @property {number} IdentitySignatureMismatch=12 IdentitySignatureMismatch value
     * @property {number} IdentityInvalidLogin=13 IdentityInvalidLogin value
     * @property {number} IdentityAlreadyExists=14 IdentityAlreadyExists value
     * @property {number} IdentityNotFound=15 IdentityNotFound value
     * @property {number} IdentityVersionMismatch=16 IdentityVersionMismatch value
     * @property {number} IdentityNotAdmin=17 IdentityNotAdmin value
     * @property {number} IdentitiesNotFound=18 IdentitiesNotFound value
     * @property {number} IdentitySharingKindMismatch=19 IdentitySharingKindMismatch value
     * @property {number} ResourceNotFound=24 ResourceNotFound value
     * @property {number} RegisterInvalidEmail=25 RegisterInvalidEmail value
     * @property {number} RegisterTokenNotFound=26 RegisterTokenNotFound value
     * @property {number} ChannelNotFound=27 ChannelNotFound value
     * @property {number} DelegatedAccessNotFound=28 DelegatedAccessNotFound value
     * @property {number} InvalidToken=29 InvalidToken value
     * @property {number} ApplicationConfigNotFound=33 ApplicationConfigNotFound value
     * @property {number} ApplicationConfigInvalid=34 ApplicationConfigInvalid value
     * @property {number} NamedResourceNotFound=35 NamedResourceNotFound value
     * @property {number} ApplicationInvalidToken=36 ApplicationInvalidToken value
     * @property {number} TenantCustomerNotFound=37 TenantCustomerNotFound value
     * @property {number} TenantPackNotFound=38 TenantPackNotFound value
     * @property {number} TenantQuotasReached=39 TenantQuotasReached value
     */
    api.PepsErrorKind = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "ServerInternalError"] = 0;
        values[valuesById[1] = "SessionExpired"] = 1;
        values[valuesById[2] = "SessionStale"] = 2;
        values[valuesById[3] = "SessionInvalidSalt"] = 3;
        values[valuesById[4] = "AssumeStale"] = 4;
        values[valuesById[6] = "RequestBadUriParams"] = 6;
        values[valuesById[7] = "RequestMissingHeader"] = 7;
        values[valuesById[8] = "RequestDecodeHeader"] = 8;
        values[valuesById[9] = "RequestBadRequest"] = 9;
        values[valuesById[10] = "IdentityCannotAssumeOwnership"] = 10;
        values[valuesById[11] = "IdentityCannotAssumeAccess"] = 11;
        values[valuesById[12] = "IdentitySignatureMismatch"] = 12;
        values[valuesById[13] = "IdentityInvalidLogin"] = 13;
        values[valuesById[14] = "IdentityAlreadyExists"] = 14;
        values[valuesById[15] = "IdentityNotFound"] = 15;
        values[valuesById[16] = "IdentityVersionMismatch"] = 16;
        values[valuesById[17] = "IdentityNotAdmin"] = 17;
        values[valuesById[18] = "IdentitiesNotFound"] = 18;
        values[valuesById[19] = "IdentitySharingKindMismatch"] = 19;
        values[valuesById[24] = "ResourceNotFound"] = 24;
        values[valuesById[25] = "RegisterInvalidEmail"] = 25;
        values[valuesById[26] = "RegisterTokenNotFound"] = 26;
        values[valuesById[27] = "ChannelNotFound"] = 27;
        values[valuesById[28] = "DelegatedAccessNotFound"] = 28;
        values[valuesById[29] = "InvalidToken"] = 29;
        values[valuesById[33] = "ApplicationConfigNotFound"] = 33;
        values[valuesById[34] = "ApplicationConfigInvalid"] = 34;
        values[valuesById[35] = "NamedResourceNotFound"] = 35;
        values[valuesById[36] = "ApplicationInvalidToken"] = 36;
        values[valuesById[37] = "TenantCustomerNotFound"] = 37;
        values[valuesById[38] = "TenantPackNotFound"] = 38;
        values[valuesById[39] = "TenantQuotasReached"] = 39;
        return values;
    })();

    api.PayloadServerInternalError = (function() {

        /**
         * Properties of a PayloadServerInternalError.
         * @memberof api
         * @interface IPayloadServerInternalError
         * @property {string|null} [reason] PayloadServerInternalError reason
         */

        /**
         * Constructs a new PayloadServerInternalError.
         * @memberof api
         * @classdesc Represents a PayloadServerInternalError.
         * @implements IPayloadServerInternalError
         * @constructor
         * @param {api.IPayloadServerInternalError=} [properties] Properties to set
         */
        function PayloadServerInternalError(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PayloadServerInternalError reason.
         * @member {string} reason
         * @memberof api.PayloadServerInternalError
         * @instance
         */
        PayloadServerInternalError.prototype.reason = "";

        /**
         * Creates a new PayloadServerInternalError instance using the specified properties.
         * @function create
         * @memberof api.PayloadServerInternalError
         * @static
         * @param {api.IPayloadServerInternalError=} [properties] Properties to set
         * @returns {api.PayloadServerInternalError} PayloadServerInternalError instance
         */
        PayloadServerInternalError.create = function create(properties) {
            return new PayloadServerInternalError(properties);
        };

        /**
         * Encodes the specified PayloadServerInternalError message. Does not implicitly {@link api.PayloadServerInternalError.verify|verify} messages.
         * @function encode
         * @memberof api.PayloadServerInternalError
         * @static
         * @param {api.IPayloadServerInternalError} message PayloadServerInternalError message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadServerInternalError.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.reason != null && message.hasOwnProperty("reason"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.reason);
            return writer;
        };

        /**
         * Encodes the specified PayloadServerInternalError message, length delimited. Does not implicitly {@link api.PayloadServerInternalError.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.PayloadServerInternalError
         * @static
         * @param {api.IPayloadServerInternalError} message PayloadServerInternalError message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadServerInternalError.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PayloadServerInternalError message from the specified reader or buffer.
         * @function decode
         * @memberof api.PayloadServerInternalError
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.PayloadServerInternalError} PayloadServerInternalError
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadServerInternalError.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.PayloadServerInternalError();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.reason = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PayloadServerInternalError message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.PayloadServerInternalError
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.PayloadServerInternalError} PayloadServerInternalError
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadServerInternalError.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PayloadServerInternalError message.
         * @function verify
         * @memberof api.PayloadServerInternalError
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PayloadServerInternalError.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.reason != null && message.hasOwnProperty("reason"))
                if (!$util.isString(message.reason))
                    return "reason: string expected";
            return null;
        };

        /**
         * Creates a PayloadServerInternalError message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.PayloadServerInternalError
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.PayloadServerInternalError} PayloadServerInternalError
         */
        PayloadServerInternalError.fromObject = function fromObject(object) {
            if (object instanceof $root.api.PayloadServerInternalError)
                return object;
            var message = new $root.api.PayloadServerInternalError();
            if (object.reason != null)
                message.reason = String(object.reason);
            return message;
        };

        /**
         * Creates a plain object from a PayloadServerInternalError message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.PayloadServerInternalError
         * @static
         * @param {api.PayloadServerInternalError} message PayloadServerInternalError
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PayloadServerInternalError.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.reason = "";
            if (message.reason != null && message.hasOwnProperty("reason"))
                object.reason = message.reason;
            return object;
        };

        /**
         * Converts this PayloadServerInternalError to JSON.
         * @function toJSON
         * @memberof api.PayloadServerInternalError
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PayloadServerInternalError.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PayloadServerInternalError;
    })();

    api.PayloadRequestBadUriParams = (function() {

        /**
         * Properties of a PayloadRequestBadUriParams.
         * @memberof api
         * @interface IPayloadRequestBadUriParams
         * @property {string|null} [key] PayloadRequestBadUriParams key
         * @property {string|null} [value] PayloadRequestBadUriParams value
         * @property {string|null} [expected] PayloadRequestBadUriParams expected
         */

        /**
         * Constructs a new PayloadRequestBadUriParams.
         * @memberof api
         * @classdesc Represents a PayloadRequestBadUriParams.
         * @implements IPayloadRequestBadUriParams
         * @constructor
         * @param {api.IPayloadRequestBadUriParams=} [properties] Properties to set
         */
        function PayloadRequestBadUriParams(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PayloadRequestBadUriParams key.
         * @member {string} key
         * @memberof api.PayloadRequestBadUriParams
         * @instance
         */
        PayloadRequestBadUriParams.prototype.key = "";

        /**
         * PayloadRequestBadUriParams value.
         * @member {string} value
         * @memberof api.PayloadRequestBadUriParams
         * @instance
         */
        PayloadRequestBadUriParams.prototype.value = "";

        /**
         * PayloadRequestBadUriParams expected.
         * @member {string} expected
         * @memberof api.PayloadRequestBadUriParams
         * @instance
         */
        PayloadRequestBadUriParams.prototype.expected = "";

        /**
         * Creates a new PayloadRequestBadUriParams instance using the specified properties.
         * @function create
         * @memberof api.PayloadRequestBadUriParams
         * @static
         * @param {api.IPayloadRequestBadUriParams=} [properties] Properties to set
         * @returns {api.PayloadRequestBadUriParams} PayloadRequestBadUriParams instance
         */
        PayloadRequestBadUriParams.create = function create(properties) {
            return new PayloadRequestBadUriParams(properties);
        };

        /**
         * Encodes the specified PayloadRequestBadUriParams message. Does not implicitly {@link api.PayloadRequestBadUriParams.verify|verify} messages.
         * @function encode
         * @memberof api.PayloadRequestBadUriParams
         * @static
         * @param {api.IPayloadRequestBadUriParams} message PayloadRequestBadUriParams message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadRequestBadUriParams.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.key != null && message.hasOwnProperty("key"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.key);
            if (message.value != null && message.hasOwnProperty("value"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.value);
            if (message.expected != null && message.hasOwnProperty("expected"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.expected);
            return writer;
        };

        /**
         * Encodes the specified PayloadRequestBadUriParams message, length delimited. Does not implicitly {@link api.PayloadRequestBadUriParams.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.PayloadRequestBadUriParams
         * @static
         * @param {api.IPayloadRequestBadUriParams} message PayloadRequestBadUriParams message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadRequestBadUriParams.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PayloadRequestBadUriParams message from the specified reader or buffer.
         * @function decode
         * @memberof api.PayloadRequestBadUriParams
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.PayloadRequestBadUriParams} PayloadRequestBadUriParams
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadRequestBadUriParams.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.PayloadRequestBadUriParams();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = reader.string();
                    break;
                case 3:
                    message.expected = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PayloadRequestBadUriParams message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.PayloadRequestBadUriParams
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.PayloadRequestBadUriParams} PayloadRequestBadUriParams
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadRequestBadUriParams.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PayloadRequestBadUriParams message.
         * @function verify
         * @memberof api.PayloadRequestBadUriParams
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PayloadRequestBadUriParams.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.key != null && message.hasOwnProperty("key"))
                if (!$util.isString(message.key))
                    return "key: string expected";
            if (message.value != null && message.hasOwnProperty("value"))
                if (!$util.isString(message.value))
                    return "value: string expected";
            if (message.expected != null && message.hasOwnProperty("expected"))
                if (!$util.isString(message.expected))
                    return "expected: string expected";
            return null;
        };

        /**
         * Creates a PayloadRequestBadUriParams message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.PayloadRequestBadUriParams
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.PayloadRequestBadUriParams} PayloadRequestBadUriParams
         */
        PayloadRequestBadUriParams.fromObject = function fromObject(object) {
            if (object instanceof $root.api.PayloadRequestBadUriParams)
                return object;
            var message = new $root.api.PayloadRequestBadUriParams();
            if (object.key != null)
                message.key = String(object.key);
            if (object.value != null)
                message.value = String(object.value);
            if (object.expected != null)
                message.expected = String(object.expected);
            return message;
        };

        /**
         * Creates a plain object from a PayloadRequestBadUriParams message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.PayloadRequestBadUriParams
         * @static
         * @param {api.PayloadRequestBadUriParams} message PayloadRequestBadUriParams
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PayloadRequestBadUriParams.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.key = "";
                object.value = "";
                object.expected = "";
            }
            if (message.key != null && message.hasOwnProperty("key"))
                object.key = message.key;
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = message.value;
            if (message.expected != null && message.hasOwnProperty("expected"))
                object.expected = message.expected;
            return object;
        };

        /**
         * Converts this PayloadRequestBadUriParams to JSON.
         * @function toJSON
         * @memberof api.PayloadRequestBadUriParams
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PayloadRequestBadUriParams.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PayloadRequestBadUriParams;
    })();

    api.PayloadRequestMissingHeader = (function() {

        /**
         * Properties of a PayloadRequestMissingHeader.
         * @memberof api
         * @interface IPayloadRequestMissingHeader
         * @property {string|null} [name] PayloadRequestMissingHeader name
         */

        /**
         * Constructs a new PayloadRequestMissingHeader.
         * @memberof api
         * @classdesc Represents a PayloadRequestMissingHeader.
         * @implements IPayloadRequestMissingHeader
         * @constructor
         * @param {api.IPayloadRequestMissingHeader=} [properties] Properties to set
         */
        function PayloadRequestMissingHeader(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PayloadRequestMissingHeader name.
         * @member {string} name
         * @memberof api.PayloadRequestMissingHeader
         * @instance
         */
        PayloadRequestMissingHeader.prototype.name = "";

        /**
         * Creates a new PayloadRequestMissingHeader instance using the specified properties.
         * @function create
         * @memberof api.PayloadRequestMissingHeader
         * @static
         * @param {api.IPayloadRequestMissingHeader=} [properties] Properties to set
         * @returns {api.PayloadRequestMissingHeader} PayloadRequestMissingHeader instance
         */
        PayloadRequestMissingHeader.create = function create(properties) {
            return new PayloadRequestMissingHeader(properties);
        };

        /**
         * Encodes the specified PayloadRequestMissingHeader message. Does not implicitly {@link api.PayloadRequestMissingHeader.verify|verify} messages.
         * @function encode
         * @memberof api.PayloadRequestMissingHeader
         * @static
         * @param {api.IPayloadRequestMissingHeader} message PayloadRequestMissingHeader message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadRequestMissingHeader.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            return writer;
        };

        /**
         * Encodes the specified PayloadRequestMissingHeader message, length delimited. Does not implicitly {@link api.PayloadRequestMissingHeader.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.PayloadRequestMissingHeader
         * @static
         * @param {api.IPayloadRequestMissingHeader} message PayloadRequestMissingHeader message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadRequestMissingHeader.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PayloadRequestMissingHeader message from the specified reader or buffer.
         * @function decode
         * @memberof api.PayloadRequestMissingHeader
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.PayloadRequestMissingHeader} PayloadRequestMissingHeader
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadRequestMissingHeader.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.PayloadRequestMissingHeader();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PayloadRequestMissingHeader message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.PayloadRequestMissingHeader
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.PayloadRequestMissingHeader} PayloadRequestMissingHeader
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadRequestMissingHeader.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PayloadRequestMissingHeader message.
         * @function verify
         * @memberof api.PayloadRequestMissingHeader
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PayloadRequestMissingHeader.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            return null;
        };

        /**
         * Creates a PayloadRequestMissingHeader message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.PayloadRequestMissingHeader
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.PayloadRequestMissingHeader} PayloadRequestMissingHeader
         */
        PayloadRequestMissingHeader.fromObject = function fromObject(object) {
            if (object instanceof $root.api.PayloadRequestMissingHeader)
                return object;
            var message = new $root.api.PayloadRequestMissingHeader();
            if (object.name != null)
                message.name = String(object.name);
            return message;
        };

        /**
         * Creates a plain object from a PayloadRequestMissingHeader message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.PayloadRequestMissingHeader
         * @static
         * @param {api.PayloadRequestMissingHeader} message PayloadRequestMissingHeader
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PayloadRequestMissingHeader.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.name = "";
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            return object;
        };

        /**
         * Converts this PayloadRequestMissingHeader to JSON.
         * @function toJSON
         * @memberof api.PayloadRequestMissingHeader
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PayloadRequestMissingHeader.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PayloadRequestMissingHeader;
    })();

    api.PayloadRequestDecodeHeader = (function() {

        /**
         * Properties of a PayloadRequestDecodeHeader.
         * @memberof api
         * @interface IPayloadRequestDecodeHeader
         * @property {string|null} [name] PayloadRequestDecodeHeader name
         * @property {string|null} [value] PayloadRequestDecodeHeader value
         */

        /**
         * Constructs a new PayloadRequestDecodeHeader.
         * @memberof api
         * @classdesc Represents a PayloadRequestDecodeHeader.
         * @implements IPayloadRequestDecodeHeader
         * @constructor
         * @param {api.IPayloadRequestDecodeHeader=} [properties] Properties to set
         */
        function PayloadRequestDecodeHeader(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PayloadRequestDecodeHeader name.
         * @member {string} name
         * @memberof api.PayloadRequestDecodeHeader
         * @instance
         */
        PayloadRequestDecodeHeader.prototype.name = "";

        /**
         * PayloadRequestDecodeHeader value.
         * @member {string} value
         * @memberof api.PayloadRequestDecodeHeader
         * @instance
         */
        PayloadRequestDecodeHeader.prototype.value = "";

        /**
         * Creates a new PayloadRequestDecodeHeader instance using the specified properties.
         * @function create
         * @memberof api.PayloadRequestDecodeHeader
         * @static
         * @param {api.IPayloadRequestDecodeHeader=} [properties] Properties to set
         * @returns {api.PayloadRequestDecodeHeader} PayloadRequestDecodeHeader instance
         */
        PayloadRequestDecodeHeader.create = function create(properties) {
            return new PayloadRequestDecodeHeader(properties);
        };

        /**
         * Encodes the specified PayloadRequestDecodeHeader message. Does not implicitly {@link api.PayloadRequestDecodeHeader.verify|verify} messages.
         * @function encode
         * @memberof api.PayloadRequestDecodeHeader
         * @static
         * @param {api.IPayloadRequestDecodeHeader} message PayloadRequestDecodeHeader message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadRequestDecodeHeader.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.value != null && message.hasOwnProperty("value"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.value);
            return writer;
        };

        /**
         * Encodes the specified PayloadRequestDecodeHeader message, length delimited. Does not implicitly {@link api.PayloadRequestDecodeHeader.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.PayloadRequestDecodeHeader
         * @static
         * @param {api.IPayloadRequestDecodeHeader} message PayloadRequestDecodeHeader message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadRequestDecodeHeader.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PayloadRequestDecodeHeader message from the specified reader or buffer.
         * @function decode
         * @memberof api.PayloadRequestDecodeHeader
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.PayloadRequestDecodeHeader} PayloadRequestDecodeHeader
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadRequestDecodeHeader.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.PayloadRequestDecodeHeader();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.value = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PayloadRequestDecodeHeader message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.PayloadRequestDecodeHeader
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.PayloadRequestDecodeHeader} PayloadRequestDecodeHeader
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadRequestDecodeHeader.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PayloadRequestDecodeHeader message.
         * @function verify
         * @memberof api.PayloadRequestDecodeHeader
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PayloadRequestDecodeHeader.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.value != null && message.hasOwnProperty("value"))
                if (!$util.isString(message.value))
                    return "value: string expected";
            return null;
        };

        /**
         * Creates a PayloadRequestDecodeHeader message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.PayloadRequestDecodeHeader
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.PayloadRequestDecodeHeader} PayloadRequestDecodeHeader
         */
        PayloadRequestDecodeHeader.fromObject = function fromObject(object) {
            if (object instanceof $root.api.PayloadRequestDecodeHeader)
                return object;
            var message = new $root.api.PayloadRequestDecodeHeader();
            if (object.name != null)
                message.name = String(object.name);
            if (object.value != null)
                message.value = String(object.value);
            return message;
        };

        /**
         * Creates a plain object from a PayloadRequestDecodeHeader message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.PayloadRequestDecodeHeader
         * @static
         * @param {api.PayloadRequestDecodeHeader} message PayloadRequestDecodeHeader
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PayloadRequestDecodeHeader.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.name = "";
                object.value = "";
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = message.value;
            return object;
        };

        /**
         * Converts this PayloadRequestDecodeHeader to JSON.
         * @function toJSON
         * @memberof api.PayloadRequestDecodeHeader
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PayloadRequestDecodeHeader.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PayloadRequestDecodeHeader;
    })();

    api.PayloadRequestBadRequest = (function() {

        /**
         * Properties of a PayloadRequestBadRequest.
         * @memberof api
         * @interface IPayloadRequestBadRequest
         * @property {string|null} [hint] PayloadRequestBadRequest hint
         */

        /**
         * Constructs a new PayloadRequestBadRequest.
         * @memberof api
         * @classdesc Represents a PayloadRequestBadRequest.
         * @implements IPayloadRequestBadRequest
         * @constructor
         * @param {api.IPayloadRequestBadRequest=} [properties] Properties to set
         */
        function PayloadRequestBadRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PayloadRequestBadRequest hint.
         * @member {string} hint
         * @memberof api.PayloadRequestBadRequest
         * @instance
         */
        PayloadRequestBadRequest.prototype.hint = "";

        /**
         * Creates a new PayloadRequestBadRequest instance using the specified properties.
         * @function create
         * @memberof api.PayloadRequestBadRequest
         * @static
         * @param {api.IPayloadRequestBadRequest=} [properties] Properties to set
         * @returns {api.PayloadRequestBadRequest} PayloadRequestBadRequest instance
         */
        PayloadRequestBadRequest.create = function create(properties) {
            return new PayloadRequestBadRequest(properties);
        };

        /**
         * Encodes the specified PayloadRequestBadRequest message. Does not implicitly {@link api.PayloadRequestBadRequest.verify|verify} messages.
         * @function encode
         * @memberof api.PayloadRequestBadRequest
         * @static
         * @param {api.IPayloadRequestBadRequest} message PayloadRequestBadRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadRequestBadRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.hint != null && message.hasOwnProperty("hint"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.hint);
            return writer;
        };

        /**
         * Encodes the specified PayloadRequestBadRequest message, length delimited. Does not implicitly {@link api.PayloadRequestBadRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.PayloadRequestBadRequest
         * @static
         * @param {api.IPayloadRequestBadRequest} message PayloadRequestBadRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadRequestBadRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PayloadRequestBadRequest message from the specified reader or buffer.
         * @function decode
         * @memberof api.PayloadRequestBadRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.PayloadRequestBadRequest} PayloadRequestBadRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadRequestBadRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.PayloadRequestBadRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.hint = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PayloadRequestBadRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.PayloadRequestBadRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.PayloadRequestBadRequest} PayloadRequestBadRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadRequestBadRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PayloadRequestBadRequest message.
         * @function verify
         * @memberof api.PayloadRequestBadRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PayloadRequestBadRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.hint != null && message.hasOwnProperty("hint"))
                if (!$util.isString(message.hint))
                    return "hint: string expected";
            return null;
        };

        /**
         * Creates a PayloadRequestBadRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.PayloadRequestBadRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.PayloadRequestBadRequest} PayloadRequestBadRequest
         */
        PayloadRequestBadRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.api.PayloadRequestBadRequest)
                return object;
            var message = new $root.api.PayloadRequestBadRequest();
            if (object.hint != null)
                message.hint = String(object.hint);
            return message;
        };

        /**
         * Creates a plain object from a PayloadRequestBadRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.PayloadRequestBadRequest
         * @static
         * @param {api.PayloadRequestBadRequest} message PayloadRequestBadRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PayloadRequestBadRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.hint = "";
            if (message.hint != null && message.hasOwnProperty("hint"))
                object.hint = message.hint;
            return object;
        };

        /**
         * Converts this PayloadRequestBadRequest to JSON.
         * @function toJSON
         * @memberof api.PayloadRequestBadRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PayloadRequestBadRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PayloadRequestBadRequest;
    })();

    api.PayloadIdentityCannotAssumeOwnership = (function() {

        /**
         * Properties of a PayloadIdentityCannotAssumeOwnership.
         * @memberof api
         * @interface IPayloadIdentityCannotAssumeOwnership
         * @property {string|null} [owner] PayloadIdentityCannotAssumeOwnership owner
         */

        /**
         * Constructs a new PayloadIdentityCannotAssumeOwnership.
         * @memberof api
         * @classdesc Represents a PayloadIdentityCannotAssumeOwnership.
         * @implements IPayloadIdentityCannotAssumeOwnership
         * @constructor
         * @param {api.IPayloadIdentityCannotAssumeOwnership=} [properties] Properties to set
         */
        function PayloadIdentityCannotAssumeOwnership(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PayloadIdentityCannotAssumeOwnership owner.
         * @member {string} owner
         * @memberof api.PayloadIdentityCannotAssumeOwnership
         * @instance
         */
        PayloadIdentityCannotAssumeOwnership.prototype.owner = "";

        /**
         * Creates a new PayloadIdentityCannotAssumeOwnership instance using the specified properties.
         * @function create
         * @memberof api.PayloadIdentityCannotAssumeOwnership
         * @static
         * @param {api.IPayloadIdentityCannotAssumeOwnership=} [properties] Properties to set
         * @returns {api.PayloadIdentityCannotAssumeOwnership} PayloadIdentityCannotAssumeOwnership instance
         */
        PayloadIdentityCannotAssumeOwnership.create = function create(properties) {
            return new PayloadIdentityCannotAssumeOwnership(properties);
        };

        /**
         * Encodes the specified PayloadIdentityCannotAssumeOwnership message. Does not implicitly {@link api.PayloadIdentityCannotAssumeOwnership.verify|verify} messages.
         * @function encode
         * @memberof api.PayloadIdentityCannotAssumeOwnership
         * @static
         * @param {api.IPayloadIdentityCannotAssumeOwnership} message PayloadIdentityCannotAssumeOwnership message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadIdentityCannotAssumeOwnership.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.owner != null && message.hasOwnProperty("owner"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.owner);
            return writer;
        };

        /**
         * Encodes the specified PayloadIdentityCannotAssumeOwnership message, length delimited. Does not implicitly {@link api.PayloadIdentityCannotAssumeOwnership.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.PayloadIdentityCannotAssumeOwnership
         * @static
         * @param {api.IPayloadIdentityCannotAssumeOwnership} message PayloadIdentityCannotAssumeOwnership message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadIdentityCannotAssumeOwnership.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PayloadIdentityCannotAssumeOwnership message from the specified reader or buffer.
         * @function decode
         * @memberof api.PayloadIdentityCannotAssumeOwnership
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.PayloadIdentityCannotAssumeOwnership} PayloadIdentityCannotAssumeOwnership
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadIdentityCannotAssumeOwnership.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.PayloadIdentityCannotAssumeOwnership();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.owner = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PayloadIdentityCannotAssumeOwnership message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.PayloadIdentityCannotAssumeOwnership
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.PayloadIdentityCannotAssumeOwnership} PayloadIdentityCannotAssumeOwnership
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadIdentityCannotAssumeOwnership.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PayloadIdentityCannotAssumeOwnership message.
         * @function verify
         * @memberof api.PayloadIdentityCannotAssumeOwnership
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PayloadIdentityCannotAssumeOwnership.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.owner != null && message.hasOwnProperty("owner"))
                if (!$util.isString(message.owner))
                    return "owner: string expected";
            return null;
        };

        /**
         * Creates a PayloadIdentityCannotAssumeOwnership message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.PayloadIdentityCannotAssumeOwnership
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.PayloadIdentityCannotAssumeOwnership} PayloadIdentityCannotAssumeOwnership
         */
        PayloadIdentityCannotAssumeOwnership.fromObject = function fromObject(object) {
            if (object instanceof $root.api.PayloadIdentityCannotAssumeOwnership)
                return object;
            var message = new $root.api.PayloadIdentityCannotAssumeOwnership();
            if (object.owner != null)
                message.owner = String(object.owner);
            return message;
        };

        /**
         * Creates a plain object from a PayloadIdentityCannotAssumeOwnership message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.PayloadIdentityCannotAssumeOwnership
         * @static
         * @param {api.PayloadIdentityCannotAssumeOwnership} message PayloadIdentityCannotAssumeOwnership
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PayloadIdentityCannotAssumeOwnership.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.owner = "";
            if (message.owner != null && message.hasOwnProperty("owner"))
                object.owner = message.owner;
            return object;
        };

        /**
         * Converts this PayloadIdentityCannotAssumeOwnership to JSON.
         * @function toJSON
         * @memberof api.PayloadIdentityCannotAssumeOwnership
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PayloadIdentityCannotAssumeOwnership.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PayloadIdentityCannotAssumeOwnership;
    })();

    api.PayloadIdentityCannotAssumeAccess = (function() {

        /**
         * Properties of a PayloadIdentityCannotAssumeAccess.
         * @memberof api
         * @interface IPayloadIdentityCannotAssumeAccess
         * @property {api.IdentityAccessKeyKind|null} [kind] PayloadIdentityCannotAssumeAccess kind
         */

        /**
         * Constructs a new PayloadIdentityCannotAssumeAccess.
         * @memberof api
         * @classdesc Represents a PayloadIdentityCannotAssumeAccess.
         * @implements IPayloadIdentityCannotAssumeAccess
         * @constructor
         * @param {api.IPayloadIdentityCannotAssumeAccess=} [properties] Properties to set
         */
        function PayloadIdentityCannotAssumeAccess(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PayloadIdentityCannotAssumeAccess kind.
         * @member {api.IdentityAccessKeyKind} kind
         * @memberof api.PayloadIdentityCannotAssumeAccess
         * @instance
         */
        PayloadIdentityCannotAssumeAccess.prototype.kind = 0;

        /**
         * Creates a new PayloadIdentityCannotAssumeAccess instance using the specified properties.
         * @function create
         * @memberof api.PayloadIdentityCannotAssumeAccess
         * @static
         * @param {api.IPayloadIdentityCannotAssumeAccess=} [properties] Properties to set
         * @returns {api.PayloadIdentityCannotAssumeAccess} PayloadIdentityCannotAssumeAccess instance
         */
        PayloadIdentityCannotAssumeAccess.create = function create(properties) {
            return new PayloadIdentityCannotAssumeAccess(properties);
        };

        /**
         * Encodes the specified PayloadIdentityCannotAssumeAccess message. Does not implicitly {@link api.PayloadIdentityCannotAssumeAccess.verify|verify} messages.
         * @function encode
         * @memberof api.PayloadIdentityCannotAssumeAccess
         * @static
         * @param {api.IPayloadIdentityCannotAssumeAccess} message PayloadIdentityCannotAssumeAccess message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadIdentityCannotAssumeAccess.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.kind != null && message.hasOwnProperty("kind"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.kind);
            return writer;
        };

        /**
         * Encodes the specified PayloadIdentityCannotAssumeAccess message, length delimited. Does not implicitly {@link api.PayloadIdentityCannotAssumeAccess.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.PayloadIdentityCannotAssumeAccess
         * @static
         * @param {api.IPayloadIdentityCannotAssumeAccess} message PayloadIdentityCannotAssumeAccess message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadIdentityCannotAssumeAccess.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PayloadIdentityCannotAssumeAccess message from the specified reader or buffer.
         * @function decode
         * @memberof api.PayloadIdentityCannotAssumeAccess
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.PayloadIdentityCannotAssumeAccess} PayloadIdentityCannotAssumeAccess
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadIdentityCannotAssumeAccess.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.PayloadIdentityCannotAssumeAccess();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.kind = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PayloadIdentityCannotAssumeAccess message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.PayloadIdentityCannotAssumeAccess
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.PayloadIdentityCannotAssumeAccess} PayloadIdentityCannotAssumeAccess
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadIdentityCannotAssumeAccess.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PayloadIdentityCannotAssumeAccess message.
         * @function verify
         * @memberof api.PayloadIdentityCannotAssumeAccess
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PayloadIdentityCannotAssumeAccess.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.kind != null && message.hasOwnProperty("kind"))
                switch (message.kind) {
                default:
                    return "kind: enum value expected";
                case 0:
                case 1:
                    break;
                }
            return null;
        };

        /**
         * Creates a PayloadIdentityCannotAssumeAccess message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.PayloadIdentityCannotAssumeAccess
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.PayloadIdentityCannotAssumeAccess} PayloadIdentityCannotAssumeAccess
         */
        PayloadIdentityCannotAssumeAccess.fromObject = function fromObject(object) {
            if (object instanceof $root.api.PayloadIdentityCannotAssumeAccess)
                return object;
            var message = new $root.api.PayloadIdentityCannotAssumeAccess();
            switch (object.kind) {
            case "READ":
            case 0:
                message.kind = 0;
                break;
            case "WRITE":
            case 1:
                message.kind = 1;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a PayloadIdentityCannotAssumeAccess message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.PayloadIdentityCannotAssumeAccess
         * @static
         * @param {api.PayloadIdentityCannotAssumeAccess} message PayloadIdentityCannotAssumeAccess
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PayloadIdentityCannotAssumeAccess.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.kind = options.enums === String ? "READ" : 0;
            if (message.kind != null && message.hasOwnProperty("kind"))
                object.kind = options.enums === String ? $root.api.IdentityAccessKeyKind[message.kind] : message.kind;
            return object;
        };

        /**
         * Converts this PayloadIdentityCannotAssumeAccess to JSON.
         * @function toJSON
         * @memberof api.PayloadIdentityCannotAssumeAccess
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PayloadIdentityCannotAssumeAccess.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PayloadIdentityCannotAssumeAccess;
    })();

    api.PayloadIdentitySignatureMismatch = (function() {

        /**
         * Properties of a PayloadIdentitySignatureMismatch.
         * @memberof api
         * @interface IPayloadIdentitySignatureMismatch
         * @property {api.IIdentityKeyID|null} [key] PayloadIdentitySignatureMismatch key
         */

        /**
         * Constructs a new PayloadIdentitySignatureMismatch.
         * @memberof api
         * @classdesc Represents a PayloadIdentitySignatureMismatch.
         * @implements IPayloadIdentitySignatureMismatch
         * @constructor
         * @param {api.IPayloadIdentitySignatureMismatch=} [properties] Properties to set
         */
        function PayloadIdentitySignatureMismatch(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PayloadIdentitySignatureMismatch key.
         * @member {api.IIdentityKeyID|null|undefined} key
         * @memberof api.PayloadIdentitySignatureMismatch
         * @instance
         */
        PayloadIdentitySignatureMismatch.prototype.key = null;

        /**
         * Creates a new PayloadIdentitySignatureMismatch instance using the specified properties.
         * @function create
         * @memberof api.PayloadIdentitySignatureMismatch
         * @static
         * @param {api.IPayloadIdentitySignatureMismatch=} [properties] Properties to set
         * @returns {api.PayloadIdentitySignatureMismatch} PayloadIdentitySignatureMismatch instance
         */
        PayloadIdentitySignatureMismatch.create = function create(properties) {
            return new PayloadIdentitySignatureMismatch(properties);
        };

        /**
         * Encodes the specified PayloadIdentitySignatureMismatch message. Does not implicitly {@link api.PayloadIdentitySignatureMismatch.verify|verify} messages.
         * @function encode
         * @memberof api.PayloadIdentitySignatureMismatch
         * @static
         * @param {api.IPayloadIdentitySignatureMismatch} message PayloadIdentitySignatureMismatch message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadIdentitySignatureMismatch.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.key != null && message.hasOwnProperty("key"))
                $root.api.IdentityKeyID.encode(message.key, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified PayloadIdentitySignatureMismatch message, length delimited. Does not implicitly {@link api.PayloadIdentitySignatureMismatch.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.PayloadIdentitySignatureMismatch
         * @static
         * @param {api.IPayloadIdentitySignatureMismatch} message PayloadIdentitySignatureMismatch message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadIdentitySignatureMismatch.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PayloadIdentitySignatureMismatch message from the specified reader or buffer.
         * @function decode
         * @memberof api.PayloadIdentitySignatureMismatch
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.PayloadIdentitySignatureMismatch} PayloadIdentitySignatureMismatch
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadIdentitySignatureMismatch.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.PayloadIdentitySignatureMismatch();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.key = $root.api.IdentityKeyID.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PayloadIdentitySignatureMismatch message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.PayloadIdentitySignatureMismatch
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.PayloadIdentitySignatureMismatch} PayloadIdentitySignatureMismatch
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadIdentitySignatureMismatch.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PayloadIdentitySignatureMismatch message.
         * @function verify
         * @memberof api.PayloadIdentitySignatureMismatch
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PayloadIdentitySignatureMismatch.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.key != null && message.hasOwnProperty("key")) {
                var error = $root.api.IdentityKeyID.verify(message.key);
                if (error)
                    return "key." + error;
            }
            return null;
        };

        /**
         * Creates a PayloadIdentitySignatureMismatch message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.PayloadIdentitySignatureMismatch
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.PayloadIdentitySignatureMismatch} PayloadIdentitySignatureMismatch
         */
        PayloadIdentitySignatureMismatch.fromObject = function fromObject(object) {
            if (object instanceof $root.api.PayloadIdentitySignatureMismatch)
                return object;
            var message = new $root.api.PayloadIdentitySignatureMismatch();
            if (object.key != null) {
                if (typeof object.key !== "object")
                    throw TypeError(".api.PayloadIdentitySignatureMismatch.key: object expected");
                message.key = $root.api.IdentityKeyID.fromObject(object.key);
            }
            return message;
        };

        /**
         * Creates a plain object from a PayloadIdentitySignatureMismatch message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.PayloadIdentitySignatureMismatch
         * @static
         * @param {api.PayloadIdentitySignatureMismatch} message PayloadIdentitySignatureMismatch
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PayloadIdentitySignatureMismatch.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.key = null;
            if (message.key != null && message.hasOwnProperty("key"))
                object.key = $root.api.IdentityKeyID.toObject(message.key, options);
            return object;
        };

        /**
         * Converts this PayloadIdentitySignatureMismatch to JSON.
         * @function toJSON
         * @memberof api.PayloadIdentitySignatureMismatch
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PayloadIdentitySignatureMismatch.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PayloadIdentitySignatureMismatch;
    })();

    api.PayloadIdentityInvalidLogin = (function() {

        /**
         * Properties of a PayloadIdentityInvalidLogin.
         * @memberof api
         * @interface IPayloadIdentityInvalidLogin
         * @property {string|null} [login] PayloadIdentityInvalidLogin login
         */

        /**
         * Constructs a new PayloadIdentityInvalidLogin.
         * @memberof api
         * @classdesc Represents a PayloadIdentityInvalidLogin.
         * @implements IPayloadIdentityInvalidLogin
         * @constructor
         * @param {api.IPayloadIdentityInvalidLogin=} [properties] Properties to set
         */
        function PayloadIdentityInvalidLogin(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PayloadIdentityInvalidLogin login.
         * @member {string} login
         * @memberof api.PayloadIdentityInvalidLogin
         * @instance
         */
        PayloadIdentityInvalidLogin.prototype.login = "";

        /**
         * Creates a new PayloadIdentityInvalidLogin instance using the specified properties.
         * @function create
         * @memberof api.PayloadIdentityInvalidLogin
         * @static
         * @param {api.IPayloadIdentityInvalidLogin=} [properties] Properties to set
         * @returns {api.PayloadIdentityInvalidLogin} PayloadIdentityInvalidLogin instance
         */
        PayloadIdentityInvalidLogin.create = function create(properties) {
            return new PayloadIdentityInvalidLogin(properties);
        };

        /**
         * Encodes the specified PayloadIdentityInvalidLogin message. Does not implicitly {@link api.PayloadIdentityInvalidLogin.verify|verify} messages.
         * @function encode
         * @memberof api.PayloadIdentityInvalidLogin
         * @static
         * @param {api.IPayloadIdentityInvalidLogin} message PayloadIdentityInvalidLogin message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadIdentityInvalidLogin.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            return writer;
        };

        /**
         * Encodes the specified PayloadIdentityInvalidLogin message, length delimited. Does not implicitly {@link api.PayloadIdentityInvalidLogin.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.PayloadIdentityInvalidLogin
         * @static
         * @param {api.IPayloadIdentityInvalidLogin} message PayloadIdentityInvalidLogin message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadIdentityInvalidLogin.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PayloadIdentityInvalidLogin message from the specified reader or buffer.
         * @function decode
         * @memberof api.PayloadIdentityInvalidLogin
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.PayloadIdentityInvalidLogin} PayloadIdentityInvalidLogin
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadIdentityInvalidLogin.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.PayloadIdentityInvalidLogin();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PayloadIdentityInvalidLogin message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.PayloadIdentityInvalidLogin
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.PayloadIdentityInvalidLogin} PayloadIdentityInvalidLogin
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadIdentityInvalidLogin.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PayloadIdentityInvalidLogin message.
         * @function verify
         * @memberof api.PayloadIdentityInvalidLogin
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PayloadIdentityInvalidLogin.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            return null;
        };

        /**
         * Creates a PayloadIdentityInvalidLogin message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.PayloadIdentityInvalidLogin
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.PayloadIdentityInvalidLogin} PayloadIdentityInvalidLogin
         */
        PayloadIdentityInvalidLogin.fromObject = function fromObject(object) {
            if (object instanceof $root.api.PayloadIdentityInvalidLogin)
                return object;
            var message = new $root.api.PayloadIdentityInvalidLogin();
            if (object.login != null)
                message.login = String(object.login);
            return message;
        };

        /**
         * Creates a plain object from a PayloadIdentityInvalidLogin message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.PayloadIdentityInvalidLogin
         * @static
         * @param {api.PayloadIdentityInvalidLogin} message PayloadIdentityInvalidLogin
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PayloadIdentityInvalidLogin.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.login = "";
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            return object;
        };

        /**
         * Converts this PayloadIdentityInvalidLogin to JSON.
         * @function toJSON
         * @memberof api.PayloadIdentityInvalidLogin
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PayloadIdentityInvalidLogin.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PayloadIdentityInvalidLogin;
    })();

    api.PayloadIdentityAlreadyExists = (function() {

        /**
         * Properties of a PayloadIdentityAlreadyExists.
         * @memberof api
         * @interface IPayloadIdentityAlreadyExists
         * @property {string|null} [login] PayloadIdentityAlreadyExists login
         */

        /**
         * Constructs a new PayloadIdentityAlreadyExists.
         * @memberof api
         * @classdesc Represents a PayloadIdentityAlreadyExists.
         * @implements IPayloadIdentityAlreadyExists
         * @constructor
         * @param {api.IPayloadIdentityAlreadyExists=} [properties] Properties to set
         */
        function PayloadIdentityAlreadyExists(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PayloadIdentityAlreadyExists login.
         * @member {string} login
         * @memberof api.PayloadIdentityAlreadyExists
         * @instance
         */
        PayloadIdentityAlreadyExists.prototype.login = "";

        /**
         * Creates a new PayloadIdentityAlreadyExists instance using the specified properties.
         * @function create
         * @memberof api.PayloadIdentityAlreadyExists
         * @static
         * @param {api.IPayloadIdentityAlreadyExists=} [properties] Properties to set
         * @returns {api.PayloadIdentityAlreadyExists} PayloadIdentityAlreadyExists instance
         */
        PayloadIdentityAlreadyExists.create = function create(properties) {
            return new PayloadIdentityAlreadyExists(properties);
        };

        /**
         * Encodes the specified PayloadIdentityAlreadyExists message. Does not implicitly {@link api.PayloadIdentityAlreadyExists.verify|verify} messages.
         * @function encode
         * @memberof api.PayloadIdentityAlreadyExists
         * @static
         * @param {api.IPayloadIdentityAlreadyExists} message PayloadIdentityAlreadyExists message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadIdentityAlreadyExists.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            return writer;
        };

        /**
         * Encodes the specified PayloadIdentityAlreadyExists message, length delimited. Does not implicitly {@link api.PayloadIdentityAlreadyExists.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.PayloadIdentityAlreadyExists
         * @static
         * @param {api.IPayloadIdentityAlreadyExists} message PayloadIdentityAlreadyExists message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadIdentityAlreadyExists.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PayloadIdentityAlreadyExists message from the specified reader or buffer.
         * @function decode
         * @memberof api.PayloadIdentityAlreadyExists
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.PayloadIdentityAlreadyExists} PayloadIdentityAlreadyExists
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadIdentityAlreadyExists.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.PayloadIdentityAlreadyExists();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PayloadIdentityAlreadyExists message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.PayloadIdentityAlreadyExists
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.PayloadIdentityAlreadyExists} PayloadIdentityAlreadyExists
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadIdentityAlreadyExists.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PayloadIdentityAlreadyExists message.
         * @function verify
         * @memberof api.PayloadIdentityAlreadyExists
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PayloadIdentityAlreadyExists.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            return null;
        };

        /**
         * Creates a PayloadIdentityAlreadyExists message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.PayloadIdentityAlreadyExists
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.PayloadIdentityAlreadyExists} PayloadIdentityAlreadyExists
         */
        PayloadIdentityAlreadyExists.fromObject = function fromObject(object) {
            if (object instanceof $root.api.PayloadIdentityAlreadyExists)
                return object;
            var message = new $root.api.PayloadIdentityAlreadyExists();
            if (object.login != null)
                message.login = String(object.login);
            return message;
        };

        /**
         * Creates a plain object from a PayloadIdentityAlreadyExists message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.PayloadIdentityAlreadyExists
         * @static
         * @param {api.PayloadIdentityAlreadyExists} message PayloadIdentityAlreadyExists
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PayloadIdentityAlreadyExists.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.login = "";
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            return object;
        };

        /**
         * Converts this PayloadIdentityAlreadyExists to JSON.
         * @function toJSON
         * @memberof api.PayloadIdentityAlreadyExists
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PayloadIdentityAlreadyExists.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PayloadIdentityAlreadyExists;
    })();

    api.PayloadIdentityNotFound = (function() {

        /**
         * Properties of a PayloadIdentityNotFound.
         * @memberof api
         * @interface IPayloadIdentityNotFound
         * @property {string|null} [login] PayloadIdentityNotFound login
         */

        /**
         * Constructs a new PayloadIdentityNotFound.
         * @memberof api
         * @classdesc Represents a PayloadIdentityNotFound.
         * @implements IPayloadIdentityNotFound
         * @constructor
         * @param {api.IPayloadIdentityNotFound=} [properties] Properties to set
         */
        function PayloadIdentityNotFound(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PayloadIdentityNotFound login.
         * @member {string} login
         * @memberof api.PayloadIdentityNotFound
         * @instance
         */
        PayloadIdentityNotFound.prototype.login = "";

        /**
         * Creates a new PayloadIdentityNotFound instance using the specified properties.
         * @function create
         * @memberof api.PayloadIdentityNotFound
         * @static
         * @param {api.IPayloadIdentityNotFound=} [properties] Properties to set
         * @returns {api.PayloadIdentityNotFound} PayloadIdentityNotFound instance
         */
        PayloadIdentityNotFound.create = function create(properties) {
            return new PayloadIdentityNotFound(properties);
        };

        /**
         * Encodes the specified PayloadIdentityNotFound message. Does not implicitly {@link api.PayloadIdentityNotFound.verify|verify} messages.
         * @function encode
         * @memberof api.PayloadIdentityNotFound
         * @static
         * @param {api.IPayloadIdentityNotFound} message PayloadIdentityNotFound message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadIdentityNotFound.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            return writer;
        };

        /**
         * Encodes the specified PayloadIdentityNotFound message, length delimited. Does not implicitly {@link api.PayloadIdentityNotFound.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.PayloadIdentityNotFound
         * @static
         * @param {api.IPayloadIdentityNotFound} message PayloadIdentityNotFound message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadIdentityNotFound.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PayloadIdentityNotFound message from the specified reader or buffer.
         * @function decode
         * @memberof api.PayloadIdentityNotFound
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.PayloadIdentityNotFound} PayloadIdentityNotFound
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadIdentityNotFound.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.PayloadIdentityNotFound();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PayloadIdentityNotFound message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.PayloadIdentityNotFound
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.PayloadIdentityNotFound} PayloadIdentityNotFound
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadIdentityNotFound.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PayloadIdentityNotFound message.
         * @function verify
         * @memberof api.PayloadIdentityNotFound
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PayloadIdentityNotFound.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            return null;
        };

        /**
         * Creates a PayloadIdentityNotFound message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.PayloadIdentityNotFound
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.PayloadIdentityNotFound} PayloadIdentityNotFound
         */
        PayloadIdentityNotFound.fromObject = function fromObject(object) {
            if (object instanceof $root.api.PayloadIdentityNotFound)
                return object;
            var message = new $root.api.PayloadIdentityNotFound();
            if (object.login != null)
                message.login = String(object.login);
            return message;
        };

        /**
         * Creates a plain object from a PayloadIdentityNotFound message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.PayloadIdentityNotFound
         * @static
         * @param {api.PayloadIdentityNotFound} message PayloadIdentityNotFound
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PayloadIdentityNotFound.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.login = "";
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            return object;
        };

        /**
         * Converts this PayloadIdentityNotFound to JSON.
         * @function toJSON
         * @memberof api.PayloadIdentityNotFound
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PayloadIdentityNotFound.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PayloadIdentityNotFound;
    })();

    api.PayloadIdentityVersionMismatch = (function() {

        /**
         * Properties of a PayloadIdentityVersionMismatch.
         * @memberof api
         * @interface IPayloadIdentityVersionMismatch
         * @property {api.IIdentityKeyID|null} [key] PayloadIdentityVersionMismatch key
         * @property {number|null} [expected] PayloadIdentityVersionMismatch expected
         */

        /**
         * Constructs a new PayloadIdentityVersionMismatch.
         * @memberof api
         * @classdesc Represents a PayloadIdentityVersionMismatch.
         * @implements IPayloadIdentityVersionMismatch
         * @constructor
         * @param {api.IPayloadIdentityVersionMismatch=} [properties] Properties to set
         */
        function PayloadIdentityVersionMismatch(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PayloadIdentityVersionMismatch key.
         * @member {api.IIdentityKeyID|null|undefined} key
         * @memberof api.PayloadIdentityVersionMismatch
         * @instance
         */
        PayloadIdentityVersionMismatch.prototype.key = null;

        /**
         * PayloadIdentityVersionMismatch expected.
         * @member {number} expected
         * @memberof api.PayloadIdentityVersionMismatch
         * @instance
         */
        PayloadIdentityVersionMismatch.prototype.expected = 0;

        /**
         * Creates a new PayloadIdentityVersionMismatch instance using the specified properties.
         * @function create
         * @memberof api.PayloadIdentityVersionMismatch
         * @static
         * @param {api.IPayloadIdentityVersionMismatch=} [properties] Properties to set
         * @returns {api.PayloadIdentityVersionMismatch} PayloadIdentityVersionMismatch instance
         */
        PayloadIdentityVersionMismatch.create = function create(properties) {
            return new PayloadIdentityVersionMismatch(properties);
        };

        /**
         * Encodes the specified PayloadIdentityVersionMismatch message. Does not implicitly {@link api.PayloadIdentityVersionMismatch.verify|verify} messages.
         * @function encode
         * @memberof api.PayloadIdentityVersionMismatch
         * @static
         * @param {api.IPayloadIdentityVersionMismatch} message PayloadIdentityVersionMismatch message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadIdentityVersionMismatch.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.key != null && message.hasOwnProperty("key"))
                $root.api.IdentityKeyID.encode(message.key, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.expected != null && message.hasOwnProperty("expected"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.expected);
            return writer;
        };

        /**
         * Encodes the specified PayloadIdentityVersionMismatch message, length delimited. Does not implicitly {@link api.PayloadIdentityVersionMismatch.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.PayloadIdentityVersionMismatch
         * @static
         * @param {api.IPayloadIdentityVersionMismatch} message PayloadIdentityVersionMismatch message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadIdentityVersionMismatch.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PayloadIdentityVersionMismatch message from the specified reader or buffer.
         * @function decode
         * @memberof api.PayloadIdentityVersionMismatch
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.PayloadIdentityVersionMismatch} PayloadIdentityVersionMismatch
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadIdentityVersionMismatch.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.PayloadIdentityVersionMismatch();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.key = $root.api.IdentityKeyID.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.expected = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PayloadIdentityVersionMismatch message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.PayloadIdentityVersionMismatch
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.PayloadIdentityVersionMismatch} PayloadIdentityVersionMismatch
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadIdentityVersionMismatch.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PayloadIdentityVersionMismatch message.
         * @function verify
         * @memberof api.PayloadIdentityVersionMismatch
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PayloadIdentityVersionMismatch.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.key != null && message.hasOwnProperty("key")) {
                var error = $root.api.IdentityKeyID.verify(message.key);
                if (error)
                    return "key." + error;
            }
            if (message.expected != null && message.hasOwnProperty("expected"))
                if (!$util.isInteger(message.expected))
                    return "expected: integer expected";
            return null;
        };

        /**
         * Creates a PayloadIdentityVersionMismatch message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.PayloadIdentityVersionMismatch
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.PayloadIdentityVersionMismatch} PayloadIdentityVersionMismatch
         */
        PayloadIdentityVersionMismatch.fromObject = function fromObject(object) {
            if (object instanceof $root.api.PayloadIdentityVersionMismatch)
                return object;
            var message = new $root.api.PayloadIdentityVersionMismatch();
            if (object.key != null) {
                if (typeof object.key !== "object")
                    throw TypeError(".api.PayloadIdentityVersionMismatch.key: object expected");
                message.key = $root.api.IdentityKeyID.fromObject(object.key);
            }
            if (object.expected != null)
                message.expected = object.expected >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a PayloadIdentityVersionMismatch message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.PayloadIdentityVersionMismatch
         * @static
         * @param {api.PayloadIdentityVersionMismatch} message PayloadIdentityVersionMismatch
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PayloadIdentityVersionMismatch.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.key = null;
                object.expected = 0;
            }
            if (message.key != null && message.hasOwnProperty("key"))
                object.key = $root.api.IdentityKeyID.toObject(message.key, options);
            if (message.expected != null && message.hasOwnProperty("expected"))
                object.expected = message.expected;
            return object;
        };

        /**
         * Converts this PayloadIdentityVersionMismatch to JSON.
         * @function toJSON
         * @memberof api.PayloadIdentityVersionMismatch
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PayloadIdentityVersionMismatch.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PayloadIdentityVersionMismatch;
    })();

    api.PayloadIdentityNotAdmin = (function() {

        /**
         * Properties of a PayloadIdentityNotAdmin.
         * @memberof api
         * @interface IPayloadIdentityNotAdmin
         * @property {string|null} [login] PayloadIdentityNotAdmin login
         */

        /**
         * Constructs a new PayloadIdentityNotAdmin.
         * @memberof api
         * @classdesc Represents a PayloadIdentityNotAdmin.
         * @implements IPayloadIdentityNotAdmin
         * @constructor
         * @param {api.IPayloadIdentityNotAdmin=} [properties] Properties to set
         */
        function PayloadIdentityNotAdmin(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PayloadIdentityNotAdmin login.
         * @member {string} login
         * @memberof api.PayloadIdentityNotAdmin
         * @instance
         */
        PayloadIdentityNotAdmin.prototype.login = "";

        /**
         * Creates a new PayloadIdentityNotAdmin instance using the specified properties.
         * @function create
         * @memberof api.PayloadIdentityNotAdmin
         * @static
         * @param {api.IPayloadIdentityNotAdmin=} [properties] Properties to set
         * @returns {api.PayloadIdentityNotAdmin} PayloadIdentityNotAdmin instance
         */
        PayloadIdentityNotAdmin.create = function create(properties) {
            return new PayloadIdentityNotAdmin(properties);
        };

        /**
         * Encodes the specified PayloadIdentityNotAdmin message. Does not implicitly {@link api.PayloadIdentityNotAdmin.verify|verify} messages.
         * @function encode
         * @memberof api.PayloadIdentityNotAdmin
         * @static
         * @param {api.IPayloadIdentityNotAdmin} message PayloadIdentityNotAdmin message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadIdentityNotAdmin.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            return writer;
        };

        /**
         * Encodes the specified PayloadIdentityNotAdmin message, length delimited. Does not implicitly {@link api.PayloadIdentityNotAdmin.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.PayloadIdentityNotAdmin
         * @static
         * @param {api.IPayloadIdentityNotAdmin} message PayloadIdentityNotAdmin message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadIdentityNotAdmin.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PayloadIdentityNotAdmin message from the specified reader or buffer.
         * @function decode
         * @memberof api.PayloadIdentityNotAdmin
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.PayloadIdentityNotAdmin} PayloadIdentityNotAdmin
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadIdentityNotAdmin.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.PayloadIdentityNotAdmin();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PayloadIdentityNotAdmin message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.PayloadIdentityNotAdmin
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.PayloadIdentityNotAdmin} PayloadIdentityNotAdmin
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadIdentityNotAdmin.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PayloadIdentityNotAdmin message.
         * @function verify
         * @memberof api.PayloadIdentityNotAdmin
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PayloadIdentityNotAdmin.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            return null;
        };

        /**
         * Creates a PayloadIdentityNotAdmin message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.PayloadIdentityNotAdmin
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.PayloadIdentityNotAdmin} PayloadIdentityNotAdmin
         */
        PayloadIdentityNotAdmin.fromObject = function fromObject(object) {
            if (object instanceof $root.api.PayloadIdentityNotAdmin)
                return object;
            var message = new $root.api.PayloadIdentityNotAdmin();
            if (object.login != null)
                message.login = String(object.login);
            return message;
        };

        /**
         * Creates a plain object from a PayloadIdentityNotAdmin message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.PayloadIdentityNotAdmin
         * @static
         * @param {api.PayloadIdentityNotAdmin} message PayloadIdentityNotAdmin
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PayloadIdentityNotAdmin.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.login = "";
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            return object;
        };

        /**
         * Converts this PayloadIdentityNotAdmin to JSON.
         * @function toJSON
         * @memberof api.PayloadIdentityNotAdmin
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PayloadIdentityNotAdmin.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PayloadIdentityNotAdmin;
    })();

    api.PayloadIdentitiesNotFound = (function() {

        /**
         * Properties of a PayloadIdentitiesNotFound.
         * @memberof api
         * @interface IPayloadIdentitiesNotFound
         * @property {Array.<string>|null} [logins] PayloadIdentitiesNotFound logins
         */

        /**
         * Constructs a new PayloadIdentitiesNotFound.
         * @memberof api
         * @classdesc Represents a PayloadIdentitiesNotFound.
         * @implements IPayloadIdentitiesNotFound
         * @constructor
         * @param {api.IPayloadIdentitiesNotFound=} [properties] Properties to set
         */
        function PayloadIdentitiesNotFound(properties) {
            this.logins = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PayloadIdentitiesNotFound logins.
         * @member {Array.<string>} logins
         * @memberof api.PayloadIdentitiesNotFound
         * @instance
         */
        PayloadIdentitiesNotFound.prototype.logins = $util.emptyArray;

        /**
         * Creates a new PayloadIdentitiesNotFound instance using the specified properties.
         * @function create
         * @memberof api.PayloadIdentitiesNotFound
         * @static
         * @param {api.IPayloadIdentitiesNotFound=} [properties] Properties to set
         * @returns {api.PayloadIdentitiesNotFound} PayloadIdentitiesNotFound instance
         */
        PayloadIdentitiesNotFound.create = function create(properties) {
            return new PayloadIdentitiesNotFound(properties);
        };

        /**
         * Encodes the specified PayloadIdentitiesNotFound message. Does not implicitly {@link api.PayloadIdentitiesNotFound.verify|verify} messages.
         * @function encode
         * @memberof api.PayloadIdentitiesNotFound
         * @static
         * @param {api.IPayloadIdentitiesNotFound} message PayloadIdentitiesNotFound message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadIdentitiesNotFound.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.logins != null && message.logins.length)
                for (var i = 0; i < message.logins.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.logins[i]);
            return writer;
        };

        /**
         * Encodes the specified PayloadIdentitiesNotFound message, length delimited. Does not implicitly {@link api.PayloadIdentitiesNotFound.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.PayloadIdentitiesNotFound
         * @static
         * @param {api.IPayloadIdentitiesNotFound} message PayloadIdentitiesNotFound message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadIdentitiesNotFound.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PayloadIdentitiesNotFound message from the specified reader or buffer.
         * @function decode
         * @memberof api.PayloadIdentitiesNotFound
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.PayloadIdentitiesNotFound} PayloadIdentitiesNotFound
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadIdentitiesNotFound.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.PayloadIdentitiesNotFound();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.logins && message.logins.length))
                        message.logins = [];
                    message.logins.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PayloadIdentitiesNotFound message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.PayloadIdentitiesNotFound
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.PayloadIdentitiesNotFound} PayloadIdentitiesNotFound
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadIdentitiesNotFound.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PayloadIdentitiesNotFound message.
         * @function verify
         * @memberof api.PayloadIdentitiesNotFound
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PayloadIdentitiesNotFound.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.logins != null && message.hasOwnProperty("logins")) {
                if (!Array.isArray(message.logins))
                    return "logins: array expected";
                for (var i = 0; i < message.logins.length; ++i)
                    if (!$util.isString(message.logins[i]))
                        return "logins: string[] expected";
            }
            return null;
        };

        /**
         * Creates a PayloadIdentitiesNotFound message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.PayloadIdentitiesNotFound
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.PayloadIdentitiesNotFound} PayloadIdentitiesNotFound
         */
        PayloadIdentitiesNotFound.fromObject = function fromObject(object) {
            if (object instanceof $root.api.PayloadIdentitiesNotFound)
                return object;
            var message = new $root.api.PayloadIdentitiesNotFound();
            if (object.logins) {
                if (!Array.isArray(object.logins))
                    throw TypeError(".api.PayloadIdentitiesNotFound.logins: array expected");
                message.logins = [];
                for (var i = 0; i < object.logins.length; ++i)
                    message.logins[i] = String(object.logins[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a PayloadIdentitiesNotFound message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.PayloadIdentitiesNotFound
         * @static
         * @param {api.PayloadIdentitiesNotFound} message PayloadIdentitiesNotFound
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PayloadIdentitiesNotFound.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.logins = [];
            if (message.logins && message.logins.length) {
                object.logins = [];
                for (var j = 0; j < message.logins.length; ++j)
                    object.logins[j] = message.logins[j];
            }
            return object;
        };

        /**
         * Converts this PayloadIdentitiesNotFound to JSON.
         * @function toJSON
         * @memberof api.PayloadIdentitiesNotFound
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PayloadIdentitiesNotFound.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PayloadIdentitiesNotFound;
    })();

    api.PayloadResourceNotFound = (function() {

        /**
         * Properties of a PayloadResourceNotFound.
         * @memberof api
         * @interface IPayloadResourceNotFound
         * @property {number|Long|null} [id] PayloadResourceNotFound id
         */

        /**
         * Constructs a new PayloadResourceNotFound.
         * @memberof api
         * @classdesc Represents a PayloadResourceNotFound.
         * @implements IPayloadResourceNotFound
         * @constructor
         * @param {api.IPayloadResourceNotFound=} [properties] Properties to set
         */
        function PayloadResourceNotFound(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PayloadResourceNotFound id.
         * @member {number|Long} id
         * @memberof api.PayloadResourceNotFound
         * @instance
         */
        PayloadResourceNotFound.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new PayloadResourceNotFound instance using the specified properties.
         * @function create
         * @memberof api.PayloadResourceNotFound
         * @static
         * @param {api.IPayloadResourceNotFound=} [properties] Properties to set
         * @returns {api.PayloadResourceNotFound} PayloadResourceNotFound instance
         */
        PayloadResourceNotFound.create = function create(properties) {
            return new PayloadResourceNotFound(properties);
        };

        /**
         * Encodes the specified PayloadResourceNotFound message. Does not implicitly {@link api.PayloadResourceNotFound.verify|verify} messages.
         * @function encode
         * @memberof api.PayloadResourceNotFound
         * @static
         * @param {api.IPayloadResourceNotFound} message PayloadResourceNotFound message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadResourceNotFound.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
            return writer;
        };

        /**
         * Encodes the specified PayloadResourceNotFound message, length delimited. Does not implicitly {@link api.PayloadResourceNotFound.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.PayloadResourceNotFound
         * @static
         * @param {api.IPayloadResourceNotFound} message PayloadResourceNotFound message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadResourceNotFound.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PayloadResourceNotFound message from the specified reader or buffer.
         * @function decode
         * @memberof api.PayloadResourceNotFound
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.PayloadResourceNotFound} PayloadResourceNotFound
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadResourceNotFound.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.PayloadResourceNotFound();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PayloadResourceNotFound message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.PayloadResourceNotFound
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.PayloadResourceNotFound} PayloadResourceNotFound
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadResourceNotFound.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PayloadResourceNotFound message.
         * @function verify
         * @memberof api.PayloadResourceNotFound
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PayloadResourceNotFound.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                    return "id: integer|Long expected";
            return null;
        };

        /**
         * Creates a PayloadResourceNotFound message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.PayloadResourceNotFound
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.PayloadResourceNotFound} PayloadResourceNotFound
         */
        PayloadResourceNotFound.fromObject = function fromObject(object) {
            if (object instanceof $root.api.PayloadResourceNotFound)
                return object;
            var message = new $root.api.PayloadResourceNotFound();
            if (object.id != null)
                if ($util.Long)
                    (message.id = $util.Long.fromValue(object.id)).unsigned = true;
                else if (typeof object.id === "string")
                    message.id = parseInt(object.id, 10);
                else if (typeof object.id === "number")
                    message.id = object.id;
                else if (typeof object.id === "object")
                    message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a PayloadResourceNotFound message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.PayloadResourceNotFound
         * @static
         * @param {api.PayloadResourceNotFound} message PayloadResourceNotFound
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PayloadResourceNotFound.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.id = options.longs === String ? "0" : 0;
            if (message.id != null && message.hasOwnProperty("id"))
                if (typeof message.id === "number")
                    object.id = options.longs === String ? String(message.id) : message.id;
                else
                    object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
            return object;
        };

        /**
         * Converts this PayloadResourceNotFound to JSON.
         * @function toJSON
         * @memberof api.PayloadResourceNotFound
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PayloadResourceNotFound.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PayloadResourceNotFound;
    })();

    api.PayloadRegisterInvalidEmail = (function() {

        /**
         * Properties of a PayloadRegisterInvalidEmail.
         * @memberof api
         * @interface IPayloadRegisterInvalidEmail
         * @property {string|null} [email] PayloadRegisterInvalidEmail email
         */

        /**
         * Constructs a new PayloadRegisterInvalidEmail.
         * @memberof api
         * @classdesc Represents a PayloadRegisterInvalidEmail.
         * @implements IPayloadRegisterInvalidEmail
         * @constructor
         * @param {api.IPayloadRegisterInvalidEmail=} [properties] Properties to set
         */
        function PayloadRegisterInvalidEmail(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PayloadRegisterInvalidEmail email.
         * @member {string} email
         * @memberof api.PayloadRegisterInvalidEmail
         * @instance
         */
        PayloadRegisterInvalidEmail.prototype.email = "";

        /**
         * Creates a new PayloadRegisterInvalidEmail instance using the specified properties.
         * @function create
         * @memberof api.PayloadRegisterInvalidEmail
         * @static
         * @param {api.IPayloadRegisterInvalidEmail=} [properties] Properties to set
         * @returns {api.PayloadRegisterInvalidEmail} PayloadRegisterInvalidEmail instance
         */
        PayloadRegisterInvalidEmail.create = function create(properties) {
            return new PayloadRegisterInvalidEmail(properties);
        };

        /**
         * Encodes the specified PayloadRegisterInvalidEmail message. Does not implicitly {@link api.PayloadRegisterInvalidEmail.verify|verify} messages.
         * @function encode
         * @memberof api.PayloadRegisterInvalidEmail
         * @static
         * @param {api.IPayloadRegisterInvalidEmail} message PayloadRegisterInvalidEmail message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadRegisterInvalidEmail.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.email != null && message.hasOwnProperty("email"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.email);
            return writer;
        };

        /**
         * Encodes the specified PayloadRegisterInvalidEmail message, length delimited. Does not implicitly {@link api.PayloadRegisterInvalidEmail.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.PayloadRegisterInvalidEmail
         * @static
         * @param {api.IPayloadRegisterInvalidEmail} message PayloadRegisterInvalidEmail message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadRegisterInvalidEmail.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PayloadRegisterInvalidEmail message from the specified reader or buffer.
         * @function decode
         * @memberof api.PayloadRegisterInvalidEmail
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.PayloadRegisterInvalidEmail} PayloadRegisterInvalidEmail
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadRegisterInvalidEmail.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.PayloadRegisterInvalidEmail();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.email = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PayloadRegisterInvalidEmail message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.PayloadRegisterInvalidEmail
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.PayloadRegisterInvalidEmail} PayloadRegisterInvalidEmail
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadRegisterInvalidEmail.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PayloadRegisterInvalidEmail message.
         * @function verify
         * @memberof api.PayloadRegisterInvalidEmail
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PayloadRegisterInvalidEmail.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.email != null && message.hasOwnProperty("email"))
                if (!$util.isString(message.email))
                    return "email: string expected";
            return null;
        };

        /**
         * Creates a PayloadRegisterInvalidEmail message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.PayloadRegisterInvalidEmail
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.PayloadRegisterInvalidEmail} PayloadRegisterInvalidEmail
         */
        PayloadRegisterInvalidEmail.fromObject = function fromObject(object) {
            if (object instanceof $root.api.PayloadRegisterInvalidEmail)
                return object;
            var message = new $root.api.PayloadRegisterInvalidEmail();
            if (object.email != null)
                message.email = String(object.email);
            return message;
        };

        /**
         * Creates a plain object from a PayloadRegisterInvalidEmail message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.PayloadRegisterInvalidEmail
         * @static
         * @param {api.PayloadRegisterInvalidEmail} message PayloadRegisterInvalidEmail
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PayloadRegisterInvalidEmail.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.email = "";
            if (message.email != null && message.hasOwnProperty("email"))
                object.email = message.email;
            return object;
        };

        /**
         * Converts this PayloadRegisterInvalidEmail to JSON.
         * @function toJSON
         * @memberof api.PayloadRegisterInvalidEmail
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PayloadRegisterInvalidEmail.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PayloadRegisterInvalidEmail;
    })();

    api.PayloadRegisterTokenNotFound = (function() {

        /**
         * Properties of a PayloadRegisterTokenNotFound.
         * @memberof api
         * @interface IPayloadRegisterTokenNotFound
         * @property {Uint8Array|null} [token] PayloadRegisterTokenNotFound token
         */

        /**
         * Constructs a new PayloadRegisterTokenNotFound.
         * @memberof api
         * @classdesc Represents a PayloadRegisterTokenNotFound.
         * @implements IPayloadRegisterTokenNotFound
         * @constructor
         * @param {api.IPayloadRegisterTokenNotFound=} [properties] Properties to set
         */
        function PayloadRegisterTokenNotFound(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PayloadRegisterTokenNotFound token.
         * @member {Uint8Array} token
         * @memberof api.PayloadRegisterTokenNotFound
         * @instance
         */
        PayloadRegisterTokenNotFound.prototype.token = $util.newBuffer([]);

        /**
         * Creates a new PayloadRegisterTokenNotFound instance using the specified properties.
         * @function create
         * @memberof api.PayloadRegisterTokenNotFound
         * @static
         * @param {api.IPayloadRegisterTokenNotFound=} [properties] Properties to set
         * @returns {api.PayloadRegisterTokenNotFound} PayloadRegisterTokenNotFound instance
         */
        PayloadRegisterTokenNotFound.create = function create(properties) {
            return new PayloadRegisterTokenNotFound(properties);
        };

        /**
         * Encodes the specified PayloadRegisterTokenNotFound message. Does not implicitly {@link api.PayloadRegisterTokenNotFound.verify|verify} messages.
         * @function encode
         * @memberof api.PayloadRegisterTokenNotFound
         * @static
         * @param {api.IPayloadRegisterTokenNotFound} message PayloadRegisterTokenNotFound message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadRegisterTokenNotFound.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.token != null && message.hasOwnProperty("token"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.token);
            return writer;
        };

        /**
         * Encodes the specified PayloadRegisterTokenNotFound message, length delimited. Does not implicitly {@link api.PayloadRegisterTokenNotFound.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.PayloadRegisterTokenNotFound
         * @static
         * @param {api.IPayloadRegisterTokenNotFound} message PayloadRegisterTokenNotFound message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadRegisterTokenNotFound.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PayloadRegisterTokenNotFound message from the specified reader or buffer.
         * @function decode
         * @memberof api.PayloadRegisterTokenNotFound
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.PayloadRegisterTokenNotFound} PayloadRegisterTokenNotFound
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadRegisterTokenNotFound.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.PayloadRegisterTokenNotFound();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.token = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PayloadRegisterTokenNotFound message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.PayloadRegisterTokenNotFound
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.PayloadRegisterTokenNotFound} PayloadRegisterTokenNotFound
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadRegisterTokenNotFound.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PayloadRegisterTokenNotFound message.
         * @function verify
         * @memberof api.PayloadRegisterTokenNotFound
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PayloadRegisterTokenNotFound.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.token != null && message.hasOwnProperty("token"))
                if (!(message.token && typeof message.token.length === "number" || $util.isString(message.token)))
                    return "token: buffer expected";
            return null;
        };

        /**
         * Creates a PayloadRegisterTokenNotFound message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.PayloadRegisterTokenNotFound
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.PayloadRegisterTokenNotFound} PayloadRegisterTokenNotFound
         */
        PayloadRegisterTokenNotFound.fromObject = function fromObject(object) {
            if (object instanceof $root.api.PayloadRegisterTokenNotFound)
                return object;
            var message = new $root.api.PayloadRegisterTokenNotFound();
            if (object.token != null)
                if (typeof object.token === "string")
                    $util.base64.decode(object.token, message.token = $util.newBuffer($util.base64.length(object.token)), 0);
                else if (object.token.length)
                    message.token = object.token;
            return message;
        };

        /**
         * Creates a plain object from a PayloadRegisterTokenNotFound message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.PayloadRegisterTokenNotFound
         * @static
         * @param {api.PayloadRegisterTokenNotFound} message PayloadRegisterTokenNotFound
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PayloadRegisterTokenNotFound.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.token = "";
                else {
                    object.token = [];
                    if (options.bytes !== Array)
                        object.token = $util.newBuffer(object.token);
                }
            if (message.token != null && message.hasOwnProperty("token"))
                object.token = options.bytes === String ? $util.base64.encode(message.token, 0, message.token.length) : options.bytes === Array ? Array.prototype.slice.call(message.token) : message.token;
            return object;
        };

        /**
         * Converts this PayloadRegisterTokenNotFound to JSON.
         * @function toJSON
         * @memberof api.PayloadRegisterTokenNotFound
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PayloadRegisterTokenNotFound.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PayloadRegisterTokenNotFound;
    })();

    api.PayloadChannelNotFound = (function() {

        /**
         * Properties of a PayloadChannelNotFound.
         * @memberof api
         * @interface IPayloadChannelNotFound
         * @property {number|Long|null} [id] PayloadChannelNotFound id
         */

        /**
         * Constructs a new PayloadChannelNotFound.
         * @memberof api
         * @classdesc Represents a PayloadChannelNotFound.
         * @implements IPayloadChannelNotFound
         * @constructor
         * @param {api.IPayloadChannelNotFound=} [properties] Properties to set
         */
        function PayloadChannelNotFound(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PayloadChannelNotFound id.
         * @member {number|Long} id
         * @memberof api.PayloadChannelNotFound
         * @instance
         */
        PayloadChannelNotFound.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new PayloadChannelNotFound instance using the specified properties.
         * @function create
         * @memberof api.PayloadChannelNotFound
         * @static
         * @param {api.IPayloadChannelNotFound=} [properties] Properties to set
         * @returns {api.PayloadChannelNotFound} PayloadChannelNotFound instance
         */
        PayloadChannelNotFound.create = function create(properties) {
            return new PayloadChannelNotFound(properties);
        };

        /**
         * Encodes the specified PayloadChannelNotFound message. Does not implicitly {@link api.PayloadChannelNotFound.verify|verify} messages.
         * @function encode
         * @memberof api.PayloadChannelNotFound
         * @static
         * @param {api.IPayloadChannelNotFound} message PayloadChannelNotFound message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadChannelNotFound.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
            return writer;
        };

        /**
         * Encodes the specified PayloadChannelNotFound message, length delimited. Does not implicitly {@link api.PayloadChannelNotFound.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.PayloadChannelNotFound
         * @static
         * @param {api.IPayloadChannelNotFound} message PayloadChannelNotFound message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadChannelNotFound.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PayloadChannelNotFound message from the specified reader or buffer.
         * @function decode
         * @memberof api.PayloadChannelNotFound
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.PayloadChannelNotFound} PayloadChannelNotFound
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadChannelNotFound.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.PayloadChannelNotFound();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PayloadChannelNotFound message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.PayloadChannelNotFound
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.PayloadChannelNotFound} PayloadChannelNotFound
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadChannelNotFound.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PayloadChannelNotFound message.
         * @function verify
         * @memberof api.PayloadChannelNotFound
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PayloadChannelNotFound.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                    return "id: integer|Long expected";
            return null;
        };

        /**
         * Creates a PayloadChannelNotFound message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.PayloadChannelNotFound
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.PayloadChannelNotFound} PayloadChannelNotFound
         */
        PayloadChannelNotFound.fromObject = function fromObject(object) {
            if (object instanceof $root.api.PayloadChannelNotFound)
                return object;
            var message = new $root.api.PayloadChannelNotFound();
            if (object.id != null)
                if ($util.Long)
                    (message.id = $util.Long.fromValue(object.id)).unsigned = true;
                else if (typeof object.id === "string")
                    message.id = parseInt(object.id, 10);
                else if (typeof object.id === "number")
                    message.id = object.id;
                else if (typeof object.id === "object")
                    message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a PayloadChannelNotFound message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.PayloadChannelNotFound
         * @static
         * @param {api.PayloadChannelNotFound} message PayloadChannelNotFound
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PayloadChannelNotFound.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.id = options.longs === String ? "0" : 0;
            if (message.id != null && message.hasOwnProperty("id"))
                if (typeof message.id === "number")
                    object.id = options.longs === String ? String(message.id) : message.id;
                else
                    object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
            return object;
        };

        /**
         * Converts this PayloadChannelNotFound to JSON.
         * @function toJSON
         * @memberof api.PayloadChannelNotFound
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PayloadChannelNotFound.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PayloadChannelNotFound;
    })();

    api.PayloadDelegatedAccessNotFound = (function() {

        /**
         * Properties of a PayloadDelegatedAccessNotFound.
         * @memberof api
         * @interface IPayloadDelegatedAccessNotFound
         * @property {number|Long|null} [id] PayloadDelegatedAccessNotFound id
         */

        /**
         * Constructs a new PayloadDelegatedAccessNotFound.
         * @memberof api
         * @classdesc Represents a PayloadDelegatedAccessNotFound.
         * @implements IPayloadDelegatedAccessNotFound
         * @constructor
         * @param {api.IPayloadDelegatedAccessNotFound=} [properties] Properties to set
         */
        function PayloadDelegatedAccessNotFound(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PayloadDelegatedAccessNotFound id.
         * @member {number|Long} id
         * @memberof api.PayloadDelegatedAccessNotFound
         * @instance
         */
        PayloadDelegatedAccessNotFound.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new PayloadDelegatedAccessNotFound instance using the specified properties.
         * @function create
         * @memberof api.PayloadDelegatedAccessNotFound
         * @static
         * @param {api.IPayloadDelegatedAccessNotFound=} [properties] Properties to set
         * @returns {api.PayloadDelegatedAccessNotFound} PayloadDelegatedAccessNotFound instance
         */
        PayloadDelegatedAccessNotFound.create = function create(properties) {
            return new PayloadDelegatedAccessNotFound(properties);
        };

        /**
         * Encodes the specified PayloadDelegatedAccessNotFound message. Does not implicitly {@link api.PayloadDelegatedAccessNotFound.verify|verify} messages.
         * @function encode
         * @memberof api.PayloadDelegatedAccessNotFound
         * @static
         * @param {api.IPayloadDelegatedAccessNotFound} message PayloadDelegatedAccessNotFound message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadDelegatedAccessNotFound.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
            return writer;
        };

        /**
         * Encodes the specified PayloadDelegatedAccessNotFound message, length delimited. Does not implicitly {@link api.PayloadDelegatedAccessNotFound.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.PayloadDelegatedAccessNotFound
         * @static
         * @param {api.IPayloadDelegatedAccessNotFound} message PayloadDelegatedAccessNotFound message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadDelegatedAccessNotFound.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PayloadDelegatedAccessNotFound message from the specified reader or buffer.
         * @function decode
         * @memberof api.PayloadDelegatedAccessNotFound
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.PayloadDelegatedAccessNotFound} PayloadDelegatedAccessNotFound
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadDelegatedAccessNotFound.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.PayloadDelegatedAccessNotFound();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PayloadDelegatedAccessNotFound message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.PayloadDelegatedAccessNotFound
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.PayloadDelegatedAccessNotFound} PayloadDelegatedAccessNotFound
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadDelegatedAccessNotFound.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PayloadDelegatedAccessNotFound message.
         * @function verify
         * @memberof api.PayloadDelegatedAccessNotFound
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PayloadDelegatedAccessNotFound.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                    return "id: integer|Long expected";
            return null;
        };

        /**
         * Creates a PayloadDelegatedAccessNotFound message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.PayloadDelegatedAccessNotFound
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.PayloadDelegatedAccessNotFound} PayloadDelegatedAccessNotFound
         */
        PayloadDelegatedAccessNotFound.fromObject = function fromObject(object) {
            if (object instanceof $root.api.PayloadDelegatedAccessNotFound)
                return object;
            var message = new $root.api.PayloadDelegatedAccessNotFound();
            if (object.id != null)
                if ($util.Long)
                    (message.id = $util.Long.fromValue(object.id)).unsigned = true;
                else if (typeof object.id === "string")
                    message.id = parseInt(object.id, 10);
                else if (typeof object.id === "number")
                    message.id = object.id;
                else if (typeof object.id === "object")
                    message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a PayloadDelegatedAccessNotFound message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.PayloadDelegatedAccessNotFound
         * @static
         * @param {api.PayloadDelegatedAccessNotFound} message PayloadDelegatedAccessNotFound
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PayloadDelegatedAccessNotFound.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.id = options.longs === String ? "0" : 0;
            if (message.id != null && message.hasOwnProperty("id"))
                if (typeof message.id === "number")
                    object.id = options.longs === String ? String(message.id) : message.id;
                else
                    object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
            return object;
        };

        /**
         * Converts this PayloadDelegatedAccessNotFound to JSON.
         * @function toJSON
         * @memberof api.PayloadDelegatedAccessNotFound
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PayloadDelegatedAccessNotFound.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PayloadDelegatedAccessNotFound;
    })();

    api.PayloadInvalidToken = (function() {

        /**
         * Properties of a PayloadInvalidToken.
         * @memberof api
         * @interface IPayloadInvalidToken
         * @property {Uint8Array|null} [token] PayloadInvalidToken token
         */

        /**
         * Constructs a new PayloadInvalidToken.
         * @memberof api
         * @classdesc Represents a PayloadInvalidToken.
         * @implements IPayloadInvalidToken
         * @constructor
         * @param {api.IPayloadInvalidToken=} [properties] Properties to set
         */
        function PayloadInvalidToken(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PayloadInvalidToken token.
         * @member {Uint8Array} token
         * @memberof api.PayloadInvalidToken
         * @instance
         */
        PayloadInvalidToken.prototype.token = $util.newBuffer([]);

        /**
         * Creates a new PayloadInvalidToken instance using the specified properties.
         * @function create
         * @memberof api.PayloadInvalidToken
         * @static
         * @param {api.IPayloadInvalidToken=} [properties] Properties to set
         * @returns {api.PayloadInvalidToken} PayloadInvalidToken instance
         */
        PayloadInvalidToken.create = function create(properties) {
            return new PayloadInvalidToken(properties);
        };

        /**
         * Encodes the specified PayloadInvalidToken message. Does not implicitly {@link api.PayloadInvalidToken.verify|verify} messages.
         * @function encode
         * @memberof api.PayloadInvalidToken
         * @static
         * @param {api.IPayloadInvalidToken} message PayloadInvalidToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadInvalidToken.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.token != null && message.hasOwnProperty("token"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.token);
            return writer;
        };

        /**
         * Encodes the specified PayloadInvalidToken message, length delimited. Does not implicitly {@link api.PayloadInvalidToken.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.PayloadInvalidToken
         * @static
         * @param {api.IPayloadInvalidToken} message PayloadInvalidToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadInvalidToken.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PayloadInvalidToken message from the specified reader or buffer.
         * @function decode
         * @memberof api.PayloadInvalidToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.PayloadInvalidToken} PayloadInvalidToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadInvalidToken.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.PayloadInvalidToken();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.token = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PayloadInvalidToken message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.PayloadInvalidToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.PayloadInvalidToken} PayloadInvalidToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadInvalidToken.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PayloadInvalidToken message.
         * @function verify
         * @memberof api.PayloadInvalidToken
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PayloadInvalidToken.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.token != null && message.hasOwnProperty("token"))
                if (!(message.token && typeof message.token.length === "number" || $util.isString(message.token)))
                    return "token: buffer expected";
            return null;
        };

        /**
         * Creates a PayloadInvalidToken message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.PayloadInvalidToken
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.PayloadInvalidToken} PayloadInvalidToken
         */
        PayloadInvalidToken.fromObject = function fromObject(object) {
            if (object instanceof $root.api.PayloadInvalidToken)
                return object;
            var message = new $root.api.PayloadInvalidToken();
            if (object.token != null)
                if (typeof object.token === "string")
                    $util.base64.decode(object.token, message.token = $util.newBuffer($util.base64.length(object.token)), 0);
                else if (object.token.length)
                    message.token = object.token;
            return message;
        };

        /**
         * Creates a plain object from a PayloadInvalidToken message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.PayloadInvalidToken
         * @static
         * @param {api.PayloadInvalidToken} message PayloadInvalidToken
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PayloadInvalidToken.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.token = "";
                else {
                    object.token = [];
                    if (options.bytes !== Array)
                        object.token = $util.newBuffer(object.token);
                }
            if (message.token != null && message.hasOwnProperty("token"))
                object.token = options.bytes === String ? $util.base64.encode(message.token, 0, message.token.length) : options.bytes === Array ? Array.prototype.slice.call(message.token) : message.token;
            return object;
        };

        /**
         * Converts this PayloadInvalidToken to JSON.
         * @function toJSON
         * @memberof api.PayloadInvalidToken
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PayloadInvalidToken.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PayloadInvalidToken;
    })();

    api.PayloadNamedResourceNotFound = (function() {

        /**
         * Properties of a PayloadNamedResourceNotFound.
         * @memberof api
         * @interface IPayloadNamedResourceNotFound
         * @property {string|null} [login] PayloadNamedResourceNotFound login
         * @property {string|null} [name] PayloadNamedResourceNotFound name
         */

        /**
         * Constructs a new PayloadNamedResourceNotFound.
         * @memberof api
         * @classdesc Represents a PayloadNamedResourceNotFound.
         * @implements IPayloadNamedResourceNotFound
         * @constructor
         * @param {api.IPayloadNamedResourceNotFound=} [properties] Properties to set
         */
        function PayloadNamedResourceNotFound(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PayloadNamedResourceNotFound login.
         * @member {string} login
         * @memberof api.PayloadNamedResourceNotFound
         * @instance
         */
        PayloadNamedResourceNotFound.prototype.login = "";

        /**
         * PayloadNamedResourceNotFound name.
         * @member {string} name
         * @memberof api.PayloadNamedResourceNotFound
         * @instance
         */
        PayloadNamedResourceNotFound.prototype.name = "";

        /**
         * Creates a new PayloadNamedResourceNotFound instance using the specified properties.
         * @function create
         * @memberof api.PayloadNamedResourceNotFound
         * @static
         * @param {api.IPayloadNamedResourceNotFound=} [properties] Properties to set
         * @returns {api.PayloadNamedResourceNotFound} PayloadNamedResourceNotFound instance
         */
        PayloadNamedResourceNotFound.create = function create(properties) {
            return new PayloadNamedResourceNotFound(properties);
        };

        /**
         * Encodes the specified PayloadNamedResourceNotFound message. Does not implicitly {@link api.PayloadNamedResourceNotFound.verify|verify} messages.
         * @function encode
         * @memberof api.PayloadNamedResourceNotFound
         * @static
         * @param {api.IPayloadNamedResourceNotFound} message PayloadNamedResourceNotFound message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadNamedResourceNotFound.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            return writer;
        };

        /**
         * Encodes the specified PayloadNamedResourceNotFound message, length delimited. Does not implicitly {@link api.PayloadNamedResourceNotFound.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.PayloadNamedResourceNotFound
         * @static
         * @param {api.IPayloadNamedResourceNotFound} message PayloadNamedResourceNotFound message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadNamedResourceNotFound.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PayloadNamedResourceNotFound message from the specified reader or buffer.
         * @function decode
         * @memberof api.PayloadNamedResourceNotFound
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.PayloadNamedResourceNotFound} PayloadNamedResourceNotFound
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadNamedResourceNotFound.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.PayloadNamedResourceNotFound();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PayloadNamedResourceNotFound message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.PayloadNamedResourceNotFound
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.PayloadNamedResourceNotFound} PayloadNamedResourceNotFound
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadNamedResourceNotFound.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PayloadNamedResourceNotFound message.
         * @function verify
         * @memberof api.PayloadNamedResourceNotFound
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PayloadNamedResourceNotFound.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            return null;
        };

        /**
         * Creates a PayloadNamedResourceNotFound message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.PayloadNamedResourceNotFound
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.PayloadNamedResourceNotFound} PayloadNamedResourceNotFound
         */
        PayloadNamedResourceNotFound.fromObject = function fromObject(object) {
            if (object instanceof $root.api.PayloadNamedResourceNotFound)
                return object;
            var message = new $root.api.PayloadNamedResourceNotFound();
            if (object.login != null)
                message.login = String(object.login);
            if (object.name != null)
                message.name = String(object.name);
            return message;
        };

        /**
         * Creates a plain object from a PayloadNamedResourceNotFound message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.PayloadNamedResourceNotFound
         * @static
         * @param {api.PayloadNamedResourceNotFound} message PayloadNamedResourceNotFound
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PayloadNamedResourceNotFound.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.login = "";
                object.name = "";
            }
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            return object;
        };

        /**
         * Converts this PayloadNamedResourceNotFound to JSON.
         * @function toJSON
         * @memberof api.PayloadNamedResourceNotFound
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PayloadNamedResourceNotFound.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PayloadNamedResourceNotFound;
    })();

    api.PayloadApplicationConfigInvalid = (function() {

        /**
         * Properties of a PayloadApplicationConfigInvalid.
         * @memberof api
         * @interface IPayloadApplicationConfigInvalid
         * @property {string|null} [hint] PayloadApplicationConfigInvalid hint
         */

        /**
         * Constructs a new PayloadApplicationConfigInvalid.
         * @memberof api
         * @classdesc Represents a PayloadApplicationConfigInvalid.
         * @implements IPayloadApplicationConfigInvalid
         * @constructor
         * @param {api.IPayloadApplicationConfigInvalid=} [properties] Properties to set
         */
        function PayloadApplicationConfigInvalid(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PayloadApplicationConfigInvalid hint.
         * @member {string} hint
         * @memberof api.PayloadApplicationConfigInvalid
         * @instance
         */
        PayloadApplicationConfigInvalid.prototype.hint = "";

        /**
         * Creates a new PayloadApplicationConfigInvalid instance using the specified properties.
         * @function create
         * @memberof api.PayloadApplicationConfigInvalid
         * @static
         * @param {api.IPayloadApplicationConfigInvalid=} [properties] Properties to set
         * @returns {api.PayloadApplicationConfigInvalid} PayloadApplicationConfigInvalid instance
         */
        PayloadApplicationConfigInvalid.create = function create(properties) {
            return new PayloadApplicationConfigInvalid(properties);
        };

        /**
         * Encodes the specified PayloadApplicationConfigInvalid message. Does not implicitly {@link api.PayloadApplicationConfigInvalid.verify|verify} messages.
         * @function encode
         * @memberof api.PayloadApplicationConfigInvalid
         * @static
         * @param {api.IPayloadApplicationConfigInvalid} message PayloadApplicationConfigInvalid message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadApplicationConfigInvalid.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.hint != null && message.hasOwnProperty("hint"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.hint);
            return writer;
        };

        /**
         * Encodes the specified PayloadApplicationConfigInvalid message, length delimited. Does not implicitly {@link api.PayloadApplicationConfigInvalid.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.PayloadApplicationConfigInvalid
         * @static
         * @param {api.IPayloadApplicationConfigInvalid} message PayloadApplicationConfigInvalid message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadApplicationConfigInvalid.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PayloadApplicationConfigInvalid message from the specified reader or buffer.
         * @function decode
         * @memberof api.PayloadApplicationConfigInvalid
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.PayloadApplicationConfigInvalid} PayloadApplicationConfigInvalid
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadApplicationConfigInvalid.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.PayloadApplicationConfigInvalid();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.hint = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PayloadApplicationConfigInvalid message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.PayloadApplicationConfigInvalid
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.PayloadApplicationConfigInvalid} PayloadApplicationConfigInvalid
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadApplicationConfigInvalid.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PayloadApplicationConfigInvalid message.
         * @function verify
         * @memberof api.PayloadApplicationConfigInvalid
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PayloadApplicationConfigInvalid.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.hint != null && message.hasOwnProperty("hint"))
                if (!$util.isString(message.hint))
                    return "hint: string expected";
            return null;
        };

        /**
         * Creates a PayloadApplicationConfigInvalid message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.PayloadApplicationConfigInvalid
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.PayloadApplicationConfigInvalid} PayloadApplicationConfigInvalid
         */
        PayloadApplicationConfigInvalid.fromObject = function fromObject(object) {
            if (object instanceof $root.api.PayloadApplicationConfigInvalid)
                return object;
            var message = new $root.api.PayloadApplicationConfigInvalid();
            if (object.hint != null)
                message.hint = String(object.hint);
            return message;
        };

        /**
         * Creates a plain object from a PayloadApplicationConfigInvalid message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.PayloadApplicationConfigInvalid
         * @static
         * @param {api.PayloadApplicationConfigInvalid} message PayloadApplicationConfigInvalid
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PayloadApplicationConfigInvalid.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.hint = "";
            if (message.hint != null && message.hasOwnProperty("hint"))
                object.hint = message.hint;
            return object;
        };

        /**
         * Converts this PayloadApplicationConfigInvalid to JSON.
         * @function toJSON
         * @memberof api.PayloadApplicationConfigInvalid
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PayloadApplicationConfigInvalid.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PayloadApplicationConfigInvalid;
    })();

    api.PayloadApplicationConfigNotFound = (function() {

        /**
         * Properties of a PayloadApplicationConfigNotFound.
         * @memberof api
         * @interface IPayloadApplicationConfigNotFound
         * @property {string|null} [login] PayloadApplicationConfigNotFound login
         * @property {string|null} [version] PayloadApplicationConfigNotFound version
         */

        /**
         * Constructs a new PayloadApplicationConfigNotFound.
         * @memberof api
         * @classdesc Represents a PayloadApplicationConfigNotFound.
         * @implements IPayloadApplicationConfigNotFound
         * @constructor
         * @param {api.IPayloadApplicationConfigNotFound=} [properties] Properties to set
         */
        function PayloadApplicationConfigNotFound(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PayloadApplicationConfigNotFound login.
         * @member {string} login
         * @memberof api.PayloadApplicationConfigNotFound
         * @instance
         */
        PayloadApplicationConfigNotFound.prototype.login = "";

        /**
         * PayloadApplicationConfigNotFound version.
         * @member {string} version
         * @memberof api.PayloadApplicationConfigNotFound
         * @instance
         */
        PayloadApplicationConfigNotFound.prototype.version = "";

        /**
         * Creates a new PayloadApplicationConfigNotFound instance using the specified properties.
         * @function create
         * @memberof api.PayloadApplicationConfigNotFound
         * @static
         * @param {api.IPayloadApplicationConfigNotFound=} [properties] Properties to set
         * @returns {api.PayloadApplicationConfigNotFound} PayloadApplicationConfigNotFound instance
         */
        PayloadApplicationConfigNotFound.create = function create(properties) {
            return new PayloadApplicationConfigNotFound(properties);
        };

        /**
         * Encodes the specified PayloadApplicationConfigNotFound message. Does not implicitly {@link api.PayloadApplicationConfigNotFound.verify|verify} messages.
         * @function encode
         * @memberof api.PayloadApplicationConfigNotFound
         * @static
         * @param {api.IPayloadApplicationConfigNotFound} message PayloadApplicationConfigNotFound message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadApplicationConfigNotFound.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.login != null && message.hasOwnProperty("login"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.login);
            if (message.version != null && message.hasOwnProperty("version"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.version);
            return writer;
        };

        /**
         * Encodes the specified PayloadApplicationConfigNotFound message, length delimited. Does not implicitly {@link api.PayloadApplicationConfigNotFound.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.PayloadApplicationConfigNotFound
         * @static
         * @param {api.IPayloadApplicationConfigNotFound} message PayloadApplicationConfigNotFound message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadApplicationConfigNotFound.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PayloadApplicationConfigNotFound message from the specified reader or buffer.
         * @function decode
         * @memberof api.PayloadApplicationConfigNotFound
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.PayloadApplicationConfigNotFound} PayloadApplicationConfigNotFound
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadApplicationConfigNotFound.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.PayloadApplicationConfigNotFound();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.login = reader.string();
                    break;
                case 2:
                    message.version = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PayloadApplicationConfigNotFound message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.PayloadApplicationConfigNotFound
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.PayloadApplicationConfigNotFound} PayloadApplicationConfigNotFound
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadApplicationConfigNotFound.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PayloadApplicationConfigNotFound message.
         * @function verify
         * @memberof api.PayloadApplicationConfigNotFound
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PayloadApplicationConfigNotFound.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.login != null && message.hasOwnProperty("login"))
                if (!$util.isString(message.login))
                    return "login: string expected";
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isString(message.version))
                    return "version: string expected";
            return null;
        };

        /**
         * Creates a PayloadApplicationConfigNotFound message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.PayloadApplicationConfigNotFound
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.PayloadApplicationConfigNotFound} PayloadApplicationConfigNotFound
         */
        PayloadApplicationConfigNotFound.fromObject = function fromObject(object) {
            if (object instanceof $root.api.PayloadApplicationConfigNotFound)
                return object;
            var message = new $root.api.PayloadApplicationConfigNotFound();
            if (object.login != null)
                message.login = String(object.login);
            if (object.version != null)
                message.version = String(object.version);
            return message;
        };

        /**
         * Creates a plain object from a PayloadApplicationConfigNotFound message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.PayloadApplicationConfigNotFound
         * @static
         * @param {api.PayloadApplicationConfigNotFound} message PayloadApplicationConfigNotFound
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PayloadApplicationConfigNotFound.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.login = "";
                object.version = "";
            }
            if (message.login != null && message.hasOwnProperty("login"))
                object.login = message.login;
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            return object;
        };

        /**
         * Converts this PayloadApplicationConfigNotFound to JSON.
         * @function toJSON
         * @memberof api.PayloadApplicationConfigNotFound
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PayloadApplicationConfigNotFound.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PayloadApplicationConfigNotFound;
    })();

    api.PayloadApplicationInvalidToken = (function() {

        /**
         * Properties of a PayloadApplicationInvalidToken.
         * @memberof api
         * @interface IPayloadApplicationInvalidToken
         * @property {string|null} [token] PayloadApplicationInvalidToken token
         * @property {string|null} [hint] PayloadApplicationInvalidToken hint
         */

        /**
         * Constructs a new PayloadApplicationInvalidToken.
         * @memberof api
         * @classdesc Represents a PayloadApplicationInvalidToken.
         * @implements IPayloadApplicationInvalidToken
         * @constructor
         * @param {api.IPayloadApplicationInvalidToken=} [properties] Properties to set
         */
        function PayloadApplicationInvalidToken(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PayloadApplicationInvalidToken token.
         * @member {string} token
         * @memberof api.PayloadApplicationInvalidToken
         * @instance
         */
        PayloadApplicationInvalidToken.prototype.token = "";

        /**
         * PayloadApplicationInvalidToken hint.
         * @member {string} hint
         * @memberof api.PayloadApplicationInvalidToken
         * @instance
         */
        PayloadApplicationInvalidToken.prototype.hint = "";

        /**
         * Creates a new PayloadApplicationInvalidToken instance using the specified properties.
         * @function create
         * @memberof api.PayloadApplicationInvalidToken
         * @static
         * @param {api.IPayloadApplicationInvalidToken=} [properties] Properties to set
         * @returns {api.PayloadApplicationInvalidToken} PayloadApplicationInvalidToken instance
         */
        PayloadApplicationInvalidToken.create = function create(properties) {
            return new PayloadApplicationInvalidToken(properties);
        };

        /**
         * Encodes the specified PayloadApplicationInvalidToken message. Does not implicitly {@link api.PayloadApplicationInvalidToken.verify|verify} messages.
         * @function encode
         * @memberof api.PayloadApplicationInvalidToken
         * @static
         * @param {api.IPayloadApplicationInvalidToken} message PayloadApplicationInvalidToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadApplicationInvalidToken.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.token != null && message.hasOwnProperty("token"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.token);
            if (message.hint != null && message.hasOwnProperty("hint"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.hint);
            return writer;
        };

        /**
         * Encodes the specified PayloadApplicationInvalidToken message, length delimited. Does not implicitly {@link api.PayloadApplicationInvalidToken.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.PayloadApplicationInvalidToken
         * @static
         * @param {api.IPayloadApplicationInvalidToken} message PayloadApplicationInvalidToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadApplicationInvalidToken.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PayloadApplicationInvalidToken message from the specified reader or buffer.
         * @function decode
         * @memberof api.PayloadApplicationInvalidToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.PayloadApplicationInvalidToken} PayloadApplicationInvalidToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadApplicationInvalidToken.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.PayloadApplicationInvalidToken();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.token = reader.string();
                    break;
                case 2:
                    message.hint = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PayloadApplicationInvalidToken message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.PayloadApplicationInvalidToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.PayloadApplicationInvalidToken} PayloadApplicationInvalidToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadApplicationInvalidToken.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PayloadApplicationInvalidToken message.
         * @function verify
         * @memberof api.PayloadApplicationInvalidToken
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PayloadApplicationInvalidToken.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.token != null && message.hasOwnProperty("token"))
                if (!$util.isString(message.token))
                    return "token: string expected";
            if (message.hint != null && message.hasOwnProperty("hint"))
                if (!$util.isString(message.hint))
                    return "hint: string expected";
            return null;
        };

        /**
         * Creates a PayloadApplicationInvalidToken message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.PayloadApplicationInvalidToken
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.PayloadApplicationInvalidToken} PayloadApplicationInvalidToken
         */
        PayloadApplicationInvalidToken.fromObject = function fromObject(object) {
            if (object instanceof $root.api.PayloadApplicationInvalidToken)
                return object;
            var message = new $root.api.PayloadApplicationInvalidToken();
            if (object.token != null)
                message.token = String(object.token);
            if (object.hint != null)
                message.hint = String(object.hint);
            return message;
        };

        /**
         * Creates a plain object from a PayloadApplicationInvalidToken message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.PayloadApplicationInvalidToken
         * @static
         * @param {api.PayloadApplicationInvalidToken} message PayloadApplicationInvalidToken
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PayloadApplicationInvalidToken.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.token = "";
                object.hint = "";
            }
            if (message.token != null && message.hasOwnProperty("token"))
                object.token = message.token;
            if (message.hint != null && message.hasOwnProperty("hint"))
                object.hint = message.hint;
            return object;
        };

        /**
         * Converts this PayloadApplicationInvalidToken to JSON.
         * @function toJSON
         * @memberof api.PayloadApplicationInvalidToken
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PayloadApplicationInvalidToken.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PayloadApplicationInvalidToken;
    })();

    api.PayloadTenantQuotasReached = (function() {

        /**
         * Properties of a PayloadTenantQuotasReached.
         * @memberof api
         * @interface IPayloadTenantQuotasReached
         * @property {number|null} [nbApps] PayloadTenantQuotasReached nbApps
         * @property {number|null} [maxApps] PayloadTenantQuotasReached maxApps
         */

        /**
         * Constructs a new PayloadTenantQuotasReached.
         * @memberof api
         * @classdesc Represents a PayloadTenantQuotasReached.
         * @implements IPayloadTenantQuotasReached
         * @constructor
         * @param {api.IPayloadTenantQuotasReached=} [properties] Properties to set
         */
        function PayloadTenantQuotasReached(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PayloadTenantQuotasReached nbApps.
         * @member {number} nbApps
         * @memberof api.PayloadTenantQuotasReached
         * @instance
         */
        PayloadTenantQuotasReached.prototype.nbApps = 0;

        /**
         * PayloadTenantQuotasReached maxApps.
         * @member {number} maxApps
         * @memberof api.PayloadTenantQuotasReached
         * @instance
         */
        PayloadTenantQuotasReached.prototype.maxApps = 0;

        /**
         * Creates a new PayloadTenantQuotasReached instance using the specified properties.
         * @function create
         * @memberof api.PayloadTenantQuotasReached
         * @static
         * @param {api.IPayloadTenantQuotasReached=} [properties] Properties to set
         * @returns {api.PayloadTenantQuotasReached} PayloadTenantQuotasReached instance
         */
        PayloadTenantQuotasReached.create = function create(properties) {
            return new PayloadTenantQuotasReached(properties);
        };

        /**
         * Encodes the specified PayloadTenantQuotasReached message. Does not implicitly {@link api.PayloadTenantQuotasReached.verify|verify} messages.
         * @function encode
         * @memberof api.PayloadTenantQuotasReached
         * @static
         * @param {api.IPayloadTenantQuotasReached} message PayloadTenantQuotasReached message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadTenantQuotasReached.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.nbApps != null && message.hasOwnProperty("nbApps"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.nbApps);
            if (message.maxApps != null && message.hasOwnProperty("maxApps"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.maxApps);
            return writer;
        };

        /**
         * Encodes the specified PayloadTenantQuotasReached message, length delimited. Does not implicitly {@link api.PayloadTenantQuotasReached.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.PayloadTenantQuotasReached
         * @static
         * @param {api.IPayloadTenantQuotasReached} message PayloadTenantQuotasReached message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayloadTenantQuotasReached.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PayloadTenantQuotasReached message from the specified reader or buffer.
         * @function decode
         * @memberof api.PayloadTenantQuotasReached
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.PayloadTenantQuotasReached} PayloadTenantQuotasReached
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadTenantQuotasReached.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.PayloadTenantQuotasReached();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.nbApps = reader.uint32();
                    break;
                case 2:
                    message.maxApps = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PayloadTenantQuotasReached message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.PayloadTenantQuotasReached
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.PayloadTenantQuotasReached} PayloadTenantQuotasReached
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayloadTenantQuotasReached.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PayloadTenantQuotasReached message.
         * @function verify
         * @memberof api.PayloadTenantQuotasReached
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PayloadTenantQuotasReached.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.nbApps != null && message.hasOwnProperty("nbApps"))
                if (!$util.isInteger(message.nbApps))
                    return "nbApps: integer expected";
            if (message.maxApps != null && message.hasOwnProperty("maxApps"))
                if (!$util.isInteger(message.maxApps))
                    return "maxApps: integer expected";
            return null;
        };

        /**
         * Creates a PayloadTenantQuotasReached message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.PayloadTenantQuotasReached
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.PayloadTenantQuotasReached} PayloadTenantQuotasReached
         */
        PayloadTenantQuotasReached.fromObject = function fromObject(object) {
            if (object instanceof $root.api.PayloadTenantQuotasReached)
                return object;
            var message = new $root.api.PayloadTenantQuotasReached();
            if (object.nbApps != null)
                message.nbApps = object.nbApps >>> 0;
            if (object.maxApps != null)
                message.maxApps = object.maxApps >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a PayloadTenantQuotasReached message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.PayloadTenantQuotasReached
         * @static
         * @param {api.PayloadTenantQuotasReached} message PayloadTenantQuotasReached
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PayloadTenantQuotasReached.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.nbApps = 0;
                object.maxApps = 0;
            }
            if (message.nbApps != null && message.hasOwnProperty("nbApps"))
                object.nbApps = message.nbApps;
            if (message.maxApps != null && message.hasOwnProperty("maxApps"))
                object.maxApps = message.maxApps;
            return object;
        };

        /**
         * Converts this PayloadTenantQuotasReached to JSON.
         * @function toJSON
         * @memberof api.PayloadTenantQuotasReached
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PayloadTenantQuotasReached.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PayloadTenantQuotasReached;
    })();

    api.LivenessService = (function() {

        /**
         * Constructs a new LivenessService service.
         * @memberof api
         * @classdesc Represents a LivenessService
         * @extends $protobuf.rpc.Service
         * @constructor
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         */
        function LivenessService(rpcImpl, requestDelimited, responseDelimited) {
            $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }

        (LivenessService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = LivenessService;

        /**
         * Creates new LivenessService service using the specified rpc implementation.
         * @function create
         * @memberof api.LivenessService
         * @static
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         * @returns {LivenessService} RPC service. Useful where requests and/or responses are streamed.
         */
        LivenessService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
            return new this(rpcImpl, requestDelimited, responseDelimited);
        };

        /**
         * Callback as used by {@link api.LivenessService#ping}.
         * @memberof api.LivenessService
         * @typedef PingCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {google.protobuf.Empty} [response] Empty
         */

        /**
         * Calls Ping.
         * @function ping
         * @memberof api.LivenessService
         * @instance
         * @param {google.protobuf.IEmpty} request Empty message or plain object
         * @param {api.LivenessService.PingCallback} callback Node-style callback called with the error, if any, and Empty
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(LivenessService.prototype.ping = function ping(request, callback) {
            return this.rpcCall(ping, $root.google.protobuf.Empty, $root.google.protobuf.Empty, request, callback);
        }, "name", { value: "Ping" });

        /**
         * Calls Ping.
         * @function ping
         * @memberof api.LivenessService
         * @instance
         * @param {google.protobuf.IEmpty} request Empty message or plain object
         * @returns {Promise<google.protobuf.Empty>} Promise
         * @variation 2
         */

        return LivenessService;
    })();

    api.RegisterService = (function() {

        /**
         * Constructs a new RegisterService service.
         * @memberof api
         * @classdesc Represents a RegisterService
         * @extends $protobuf.rpc.Service
         * @constructor
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         */
        function RegisterService(rpcImpl, requestDelimited, responseDelimited) {
            $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }

        (RegisterService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = RegisterService;

        /**
         * Creates new RegisterService service using the specified rpc implementation.
         * @function create
         * @memberof api.RegisterService
         * @static
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         * @returns {RegisterService} RPC service. Useful where requests and/or responses are streamed.
         */
        RegisterService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
            return new this(rpcImpl, requestDelimited, responseDelimited);
        };

        /**
         * Callback as used by {@link api.RegisterService#sendLink}.
         * @memberof api.RegisterService
         * @typedef SendLinkCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {google.protobuf.Empty} [response] Empty
         */

        /**
         * Calls SendLink.
         * @function sendLink
         * @memberof api.RegisterService
         * @instance
         * @param {api.IRegisterLinkRequest} request RegisterLinkRequest message or plain object
         * @param {api.RegisterService.SendLinkCallback} callback Node-style callback called with the error, if any, and Empty
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(RegisterService.prototype.sendLink = function sendLink(request, callback) {
            return this.rpcCall(sendLink, $root.api.RegisterLinkRequest, $root.google.protobuf.Empty, request, callback);
        }, "name", { value: "SendLink" });

        /**
         * Calls SendLink.
         * @function sendLink
         * @memberof api.RegisterService
         * @instance
         * @param {api.IRegisterLinkRequest} request RegisterLinkRequest message or plain object
         * @returns {Promise<google.protobuf.Empty>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link api.RegisterService#getLinks}.
         * @memberof api.RegisterService
         * @typedef GetLinksCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {api.LinksGetResponse} [response] LinksGetResponse
         */

        /**
         * Calls GetLinks.
         * @function getLinks
         * @memberof api.RegisterService
         * @instance
         * @param {google.protobuf.IEmpty} request Empty message or plain object
         * @param {api.RegisterService.GetLinksCallback} callback Node-style callback called with the error, if any, and LinksGetResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(RegisterService.prototype.getLinks = function getLinks(request, callback) {
            return this.rpcCall(getLinks, $root.google.protobuf.Empty, $root.api.LinksGetResponse, request, callback);
        }, "name", { value: "GetLinks" });

        /**
         * Calls GetLinks.
         * @function getLinks
         * @memberof api.RegisterService
         * @instance
         * @param {google.protobuf.IEmpty} request Empty message or plain object
         * @returns {Promise<api.LinksGetResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link api.RegisterService#registerInternal}.
         * @memberof api.RegisterService
         * @typedef RegisterInternalCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {google.protobuf.Empty} [response] Empty
         */

        /**
         * Calls RegisterInternal.
         * @function registerInternal
         * @memberof api.RegisterService
         * @instance
         * @param {api.IIdentityRegisterRequest} request IdentityRegisterRequest message or plain object
         * @param {api.RegisterService.RegisterInternalCallback} callback Node-style callback called with the error, if any, and Empty
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(RegisterService.prototype.registerInternal = function registerInternal(request, callback) {
            return this.rpcCall(registerInternal, $root.api.IdentityRegisterRequest, $root.google.protobuf.Empty, request, callback);
        }, "name", { value: "RegisterInternal" });

        /**
         * Calls RegisterInternal.
         * @function registerInternal
         * @memberof api.RegisterService
         * @instance
         * @param {api.IIdentityRegisterRequest} request IdentityRegisterRequest message or plain object
         * @returns {Promise<google.protobuf.Empty>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link api.RegisterService#registerWithToken}.
         * @memberof api.RegisterService
         * @typedef RegisterWithTokenCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {google.protobuf.Empty} [response] Empty
         */

        /**
         * Calls RegisterWithToken.
         * @function registerWithToken
         * @memberof api.RegisterService
         * @instance
         * @param {api.IRegisterPostLinkTokenRequest} request RegisterPostLinkTokenRequest message or plain object
         * @param {api.RegisterService.RegisterWithTokenCallback} callback Node-style callback called with the error, if any, and Empty
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(RegisterService.prototype.registerWithToken = function registerWithToken(request, callback) {
            return this.rpcCall(registerWithToken, $root.api.RegisterPostLinkTokenRequest, $root.google.protobuf.Empty, request, callback);
        }, "name", { value: "RegisterWithToken" });

        /**
         * Calls RegisterWithToken.
         * @function registerWithToken
         * @memberof api.RegisterService
         * @instance
         * @param {api.IRegisterPostLinkTokenRequest} request RegisterPostLinkTokenRequest message or plain object
         * @returns {Promise<google.protobuf.Empty>} Promise
         * @variation 2
         */

        return RegisterService;
    })();

    api.SessionService = (function() {

        /**
         * Constructs a new SessionService service.
         * @memberof api
         * @classdesc Represents a SessionService
         * @extends $protobuf.rpc.Service
         * @constructor
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         */
        function SessionService(rpcImpl, requestDelimited, responseDelimited) {
            $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }

        (SessionService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = SessionService;

        /**
         * Creates new SessionService service using the specified rpc implementation.
         * @function create
         * @memberof api.SessionService
         * @static
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         * @returns {SessionService} RPC service. Useful where requests and/or responses are streamed.
         */
        SessionService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
            return new this(rpcImpl, requestDelimited, responseDelimited);
        };

        /**
         * Callback as used by {@link api.SessionService#createChallenge}.
         * @memberof api.SessionService
         * @typedef CreateChallengeCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {api.SessionCreateChallengeResponse} [response] SessionCreateChallengeResponse
         */

        /**
         * Calls CreateChallenge.
         * @function createChallenge
         * @memberof api.SessionService
         * @instance
         * @param {api.ISessionCreateChallengeRequest} request SessionCreateChallengeRequest message or plain object
         * @param {api.SessionService.CreateChallengeCallback} callback Node-style callback called with the error, if any, and SessionCreateChallengeResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(SessionService.prototype.createChallenge = function createChallenge(request, callback) {
            return this.rpcCall(createChallenge, $root.api.SessionCreateChallengeRequest, $root.api.SessionCreateChallengeResponse, request, callback);
        }, "name", { value: "CreateChallenge" });

        /**
         * Calls CreateChallenge.
         * @function createChallenge
         * @memberof api.SessionService
         * @instance
         * @param {api.ISessionCreateChallengeRequest} request SessionCreateChallengeRequest message or plain object
         * @returns {Promise<api.SessionCreateChallengeResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link api.SessionService#resolveChallenge}.
         * @memberof api.SessionService
         * @typedef ResolveChallengeCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {api.SessionResolveChallengeResponse} [response] SessionResolveChallengeResponse
         */

        /**
         * Calls ResolveChallenge.
         * @function resolveChallenge
         * @memberof api.SessionService
         * @instance
         * @param {api.ISessionResolveChallengeRequest} request SessionResolveChallengeRequest message or plain object
         * @param {api.SessionService.ResolveChallengeCallback} callback Node-style callback called with the error, if any, and SessionResolveChallengeResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(SessionService.prototype.resolveChallenge = function resolveChallenge(request, callback) {
            return this.rpcCall(resolveChallenge, $root.api.SessionResolveChallengeRequest, $root.api.SessionResolveChallengeResponse, request, callback);
        }, "name", { value: "ResolveChallenge" });

        /**
         * Calls ResolveChallenge.
         * @function resolveChallenge
         * @memberof api.SessionService
         * @instance
         * @param {api.ISessionResolveChallengeRequest} request SessionResolveChallengeRequest message or plain object
         * @returns {Promise<api.SessionResolveChallengeResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link api.SessionService#unStale}.
         * @memberof api.SessionService
         * @typedef UnStaleCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {api.SessionUnStaleResponse} [response] SessionUnStaleResponse
         */

        /**
         * Calls UnStale.
         * @function unStale
         * @memberof api.SessionService
         * @instance
         * @param {google.protobuf.IEmpty} request Empty message or plain object
         * @param {api.SessionService.UnStaleCallback} callback Node-style callback called with the error, if any, and SessionUnStaleResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(SessionService.prototype.unStale = function unStale(request, callback) {
            return this.rpcCall(unStale, $root.google.protobuf.Empty, $root.api.SessionUnStaleResponse, request, callback);
        }, "name", { value: "UnStale" });

        /**
         * Calls UnStale.
         * @function unStale
         * @memberof api.SessionService
         * @instance
         * @param {google.protobuf.IEmpty} request Empty message or plain object
         * @returns {Promise<api.SessionUnStaleResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link api.SessionService#close}.
         * @memberof api.SessionService
         * @typedef CloseCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {google.protobuf.Empty} [response] Empty
         */

        /**
         * Calls Close.
         * @function close
         * @memberof api.SessionService
         * @instance
         * @param {google.protobuf.IEmpty} request Empty message or plain object
         * @param {api.SessionService.CloseCallback} callback Node-style callback called with the error, if any, and Empty
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(SessionService.prototype.close = function close(request, callback) {
            return this.rpcCall(close, $root.google.protobuf.Empty, $root.google.protobuf.Empty, request, callback);
        }, "name", { value: "Close" });

        /**
         * Calls Close.
         * @function close
         * @memberof api.SessionService
         * @instance
         * @param {google.protobuf.IEmpty} request Empty message or plain object
         * @returns {Promise<google.protobuf.Empty>} Promise
         * @variation 2
         */

        return SessionService;
    })();

    api.IdentityService = (function() {

        /**
         * Constructs a new IdentityService service.
         * @memberof api
         * @classdesc Represents an IdentityService
         * @extends $protobuf.rpc.Service
         * @constructor
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         */
        function IdentityService(rpcImpl, requestDelimited, responseDelimited) {
            $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }

        (IdentityService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = IdentityService;

        /**
         * Creates new IdentityService service using the specified rpc implementation.
         * @function create
         * @memberof api.IdentityService
         * @static
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         * @returns {IdentityService} RPC service. Useful where requests and/or responses are streamed.
         */
        IdentityService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
            return new this(rpcImpl, requestDelimited, responseDelimited);
        };

        /**
         * Callback as used by {@link api.IdentityService#create}.
         * @memberof api.IdentityService
         * @typedef CreateCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {google.protobuf.Empty} [response] Empty
         */

        /**
         * Calls Create.
         * @function create
         * @memberof api.IdentityService
         * @instance
         * @param {api.IIdentityCreateRequest} request IdentityCreateRequest message or plain object
         * @param {api.IdentityService.CreateCallback} callback Node-style callback called with the error, if any, and Empty
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(IdentityService.prototype.create = function create(request, callback) {
            return this.rpcCall(create, $root.api.IdentityCreateRequest, $root.google.protobuf.Empty, request, callback);
        }, "name", { value: "Create" });

        /**
         * Calls Create.
         * @function create
         * @memberof api.IdentityService
         * @instance
         * @param {api.IIdentityCreateRequest} request IdentityCreateRequest message or plain object
         * @returns {Promise<google.protobuf.Empty>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link api.IdentityService#get}.
         * @memberof api.IdentityService
         * @typedef GetCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {api.Identity} [response] Identity
         */

        /**
         * Calls Get.
         * @function get
         * @memberof api.IdentityService
         * @instance
         * @param {api.IIdentityGetRequest} request IdentityGetRequest message or plain object
         * @param {api.IdentityService.GetCallback} callback Node-style callback called with the error, if any, and Identity
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(IdentityService.prototype.get = function get(request, callback) {
            return this.rpcCall(get, $root.api.IdentityGetRequest, $root.api.Identity, request, callback);
        }, "name", { value: "Get" });

        /**
         * Calls Get.
         * @function get
         * @memberof api.IdentityService
         * @instance
         * @param {api.IIdentityGetRequest} request IdentityGetRequest message or plain object
         * @returns {Promise<api.Identity>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link api.IdentityService#update}.
         * @memberof api.IdentityService
         * @typedef UpdateCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {google.protobuf.Empty} [response] Empty
         */

        /**
         * Calls Update.
         * @function update
         * @memberof api.IdentityService
         * @instance
         * @param {api.IIdentityFields} request IdentityFields message or plain object
         * @param {api.IdentityService.UpdateCallback} callback Node-style callback called with the error, if any, and Empty
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(IdentityService.prototype.update = function update(request, callback) {
            return this.rpcCall(update, $root.api.IdentityFields, $root.google.protobuf.Empty, request, callback);
        }, "name", { value: "Update" });

        /**
         * Calls Update.
         * @function update
         * @memberof api.IdentityService
         * @instance
         * @param {api.IIdentityFields} request IdentityFields message or plain object
         * @returns {Promise<google.protobuf.Empty>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link api.IdentityService#list}.
         * @memberof api.IdentityService
         * @typedef ListCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {api.IdentityListResponse} [response] IdentityListResponse
         */

        /**
         * Calls List.
         * @function list
         * @memberof api.IdentityService
         * @instance
         * @param {api.IIdentityListRequest} request IdentityListRequest message or plain object
         * @param {api.IdentityService.ListCallback} callback Node-style callback called with the error, if any, and IdentityListResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(IdentityService.prototype.list = function list(request, callback) {
            return this.rpcCall(list, $root.api.IdentityListRequest, $root.api.IdentityListResponse, request, callback);
        }, "name", { value: "List" });

        /**
         * Calls List.
         * @function list
         * @memberof api.IdentityService
         * @instance
         * @param {api.IIdentityListRequest} request IdentityListRequest message or plain object
         * @returns {Promise<api.IdentityListResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link api.IdentityService#toogleActiveStatus}.
         * @memberof api.IdentityService
         * @typedef ToogleActiveStatusCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {google.protobuf.Empty} [response] Empty
         */

        /**
         * Calls ToogleActiveStatus.
         * @function toogleActiveStatus
         * @memberof api.IdentityService
         * @instance
         * @param {api.IIdentityToggleActiveStatusRequest} request IdentityToggleActiveStatusRequest message or plain object
         * @param {api.IdentityService.ToogleActiveStatusCallback} callback Node-style callback called with the error, if any, and Empty
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(IdentityService.prototype.toogleActiveStatus = function toogleActiveStatus(request, callback) {
            return this.rpcCall(toogleActiveStatus, $root.api.IdentityToggleActiveStatusRequest, $root.google.protobuf.Empty, request, callback);
        }, "name", { value: "ToogleActiveStatus" });

        /**
         * Calls ToogleActiveStatus.
         * @function toogleActiveStatus
         * @memberof api.IdentityService
         * @instance
         * @param {api.IIdentityToggleActiveStatusRequest} request IdentityToggleActiveStatusRequest message or plain object
         * @returns {Promise<google.protobuf.Empty>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link api.IdentityService#getPublicKeys}.
         * @memberof api.IdentityService
         * @typedef GetPublicKeysCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {api.IdentityGetPublicKeysResponse} [response] IdentityGetPublicKeysResponse
         */

        /**
         * Calls GetPublicKeys.
         * @function getPublicKeys
         * @memberof api.IdentityService
         * @instance
         * @param {api.IIdentityGetPublicKeysRequest} request IdentityGetPublicKeysRequest message or plain object
         * @param {api.IdentityService.GetPublicKeysCallback} callback Node-style callback called with the error, if any, and IdentityGetPublicKeysResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(IdentityService.prototype.getPublicKeys = function getPublicKeys(request, callback) {
            return this.rpcCall(getPublicKeys, $root.api.IdentityGetPublicKeysRequest, $root.api.IdentityGetPublicKeysResponse, request, callback);
        }, "name", { value: "GetPublicKeys" });

        /**
         * Calls GetPublicKeys.
         * @function getPublicKeys
         * @memberof api.IdentityService
         * @instance
         * @param {api.IIdentityGetPublicKeysRequest} request IdentityGetPublicKeysRequest message or plain object
         * @returns {Promise<api.IdentityGetPublicKeysResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link api.IdentityService#getPublicChains}.
         * @memberof api.IdentityService
         * @typedef GetPublicChainsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {api.IdentityGetPublicChainsResponse} [response] IdentityGetPublicChainsResponse
         */

        /**
         * Calls GetPublicChains.
         * @function getPublicChains
         * @memberof api.IdentityService
         * @instance
         * @param {api.IIdentityGetPublicChainsRequest} request IdentityGetPublicChainsRequest message or plain object
         * @param {api.IdentityService.GetPublicChainsCallback} callback Node-style callback called with the error, if any, and IdentityGetPublicChainsResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(IdentityService.prototype.getPublicChains = function getPublicChains(request, callback) {
            return this.rpcCall(getPublicChains, $root.api.IdentityGetPublicChainsRequest, $root.api.IdentityGetPublicChainsResponse, request, callback);
        }, "name", { value: "GetPublicChains" });

        /**
         * Calls GetPublicChains.
         * @function getPublicChains
         * @memberof api.IdentityService
         * @instance
         * @param {api.IIdentityGetPublicChainsRequest} request IdentityGetPublicChainsRequest message or plain object
         * @returns {Promise<api.IdentityGetPublicChainsResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link api.IdentityService#getLatestPublicKeys}.
         * @memberof api.IdentityService
         * @typedef GetLatestPublicKeysCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {api.IdentityGetLatestPublicKeysResponse} [response] IdentityGetLatestPublicKeysResponse
         */

        /**
         * Calls GetLatestPublicKeys.
         * @function getLatestPublicKeys
         * @memberof api.IdentityService
         * @instance
         * @param {api.IIdentityGetLatestPublicKeysRequest} request IdentityGetLatestPublicKeysRequest message or plain object
         * @param {api.IdentityService.GetLatestPublicKeysCallback} callback Node-style callback called with the error, if any, and IdentityGetLatestPublicKeysResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(IdentityService.prototype.getLatestPublicKeys = function getLatestPublicKeys(request, callback) {
            return this.rpcCall(getLatestPublicKeys, $root.api.IdentityGetLatestPublicKeysRequest, $root.api.IdentityGetLatestPublicKeysResponse, request, callback);
        }, "name", { value: "GetLatestPublicKeys" });

        /**
         * Calls GetLatestPublicKeys.
         * @function getLatestPublicKeys
         * @memberof api.IdentityService
         * @instance
         * @param {api.IIdentityGetLatestPublicKeysRequest} request IdentityGetLatestPublicKeysRequest message or plain object
         * @returns {Promise<api.IdentityGetLatestPublicKeysResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link api.IdentityService#getLatestPublicChains}.
         * @memberof api.IdentityService
         * @typedef GetLatestPublicChainsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {api.IdentityGetLatestPublicChainsResponse} [response] IdentityGetLatestPublicChainsResponse
         */

        /**
         * Calls GetLatestPublicChains.
         * @function getLatestPublicChains
         * @memberof api.IdentityService
         * @instance
         * @param {api.IIdentityGetLatestPublicChainsRequest} request IdentityGetLatestPublicChainsRequest message or plain object
         * @param {api.IdentityService.GetLatestPublicChainsCallback} callback Node-style callback called with the error, if any, and IdentityGetLatestPublicChainsResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(IdentityService.prototype.getLatestPublicChains = function getLatestPublicChains(request, callback) {
            return this.rpcCall(getLatestPublicChains, $root.api.IdentityGetLatestPublicChainsRequest, $root.api.IdentityGetLatestPublicChainsResponse, request, callback);
        }, "name", { value: "GetLatestPublicChains" });

        /**
         * Calls GetLatestPublicChains.
         * @function getLatestPublicChains
         * @memberof api.IdentityService
         * @instance
         * @param {api.IIdentityGetLatestPublicChainsRequest} request IdentityGetLatestPublicChainsRequest message or plain object
         * @returns {Promise<api.IdentityGetLatestPublicChainsResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link api.IdentityService#getKeySet}.
         * @memberof api.IdentityService
         * @typedef GetKeySetCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {api.IdentityGetKeySetResponse} [response] IdentityGetKeySetResponse
         */

        /**
         * Calls GetKeySet.
         * @function getKeySet
         * @memberof api.IdentityService
         * @instance
         * @param {api.IIdentityGetKeySetRequest} request IdentityGetKeySetRequest message or plain object
         * @param {api.IdentityService.GetKeySetCallback} callback Node-style callback called with the error, if any, and IdentityGetKeySetResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(IdentityService.prototype.getKeySet = function getKeySet(request, callback) {
            return this.rpcCall(getKeySet, $root.api.IdentityGetKeySetRequest, $root.api.IdentityGetKeySetResponse, request, callback);
        }, "name", { value: "GetKeySet" });

        /**
         * Calls GetKeySet.
         * @function getKeySet
         * @memberof api.IdentityService
         * @instance
         * @param {api.IIdentityGetKeySetRequest} request IdentityGetKeySetRequest message or plain object
         * @returns {Promise<api.IdentityGetKeySetResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link api.IdentityService#getSharingGroup}.
         * @memberof api.IdentityService
         * @typedef GetSharingGroupCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {api.IdentityGetSharingGroupResponse} [response] IdentityGetSharingGroupResponse
         */

        /**
         * Calls GetSharingGroup.
         * @function getSharingGroup
         * @memberof api.IdentityService
         * @instance
         * @param {api.IIdentityGetSharingGroupRequest} request IdentityGetSharingGroupRequest message or plain object
         * @param {api.IdentityService.GetSharingGroupCallback} callback Node-style callback called with the error, if any, and IdentityGetSharingGroupResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(IdentityService.prototype.getSharingGroup = function getSharingGroup(request, callback) {
            return this.rpcCall(getSharingGroup, $root.api.IdentityGetSharingGroupRequest, $root.api.IdentityGetSharingGroupResponse, request, callback);
        }, "name", { value: "GetSharingGroup" });

        /**
         * Calls GetSharingGroup.
         * @function getSharingGroup
         * @memberof api.IdentityService
         * @instance
         * @param {api.IIdentityGetSharingGroupRequest} request IdentityGetSharingGroupRequest message or plain object
         * @returns {Promise<api.IdentityGetSharingGroupResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link api.IdentityService#getAccessGroup}.
         * @memberof api.IdentityService
         * @typedef GetAccessGroupCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {api.IdentityGetAccessGroupResponse} [response] IdentityGetAccessGroupResponse
         */

        /**
         * Calls GetAccessGroup.
         * @function getAccessGroup
         * @memberof api.IdentityService
         * @instance
         * @param {api.IIdentityGetAccessGroupRequest} request IdentityGetAccessGroupRequest message or plain object
         * @param {api.IdentityService.GetAccessGroupCallback} callback Node-style callback called with the error, if any, and IdentityGetAccessGroupResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(IdentityService.prototype.getAccessGroup = function getAccessGroup(request, callback) {
            return this.rpcCall(getAccessGroup, $root.api.IdentityGetAccessGroupRequest, $root.api.IdentityGetAccessGroupResponse, request, callback);
        }, "name", { value: "GetAccessGroup" });

        /**
         * Calls GetAccessGroup.
         * @function getAccessGroup
         * @memberof api.IdentityService
         * @instance
         * @param {api.IIdentityGetAccessGroupRequest} request IdentityGetAccessGroupRequest message or plain object
         * @returns {Promise<api.IdentityGetAccessGroupResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link api.IdentityService#extendSharingGroup}.
         * @memberof api.IdentityService
         * @typedef ExtendSharingGroupCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {google.protobuf.Empty} [response] Empty
         */

        /**
         * Calls ExtendSharingGroup.
         * @function extendSharingGroup
         * @memberof api.IdentityService
         * @instance
         * @param {api.IIdentityShareRequest} request IdentityShareRequest message or plain object
         * @param {api.IdentityService.ExtendSharingGroupCallback} callback Node-style callback called with the error, if any, and Empty
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(IdentityService.prototype.extendSharingGroup = function extendSharingGroup(request, callback) {
            return this.rpcCall(extendSharingGroup, $root.api.IdentityShareRequest, $root.google.protobuf.Empty, request, callback);
        }, "name", { value: "ExtendSharingGroup" });

        /**
         * Calls ExtendSharingGroup.
         * @function extendSharingGroup
         * @memberof api.IdentityService
         * @instance
         * @param {api.IIdentityShareRequest} request IdentityShareRequest message or plain object
         * @returns {Promise<google.protobuf.Empty>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link api.IdentityService#getSharingGraph}.
         * @memberof api.IdentityService
         * @typedef GetSharingGraphCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {api.IdentityGetSharingGraphResponse} [response] IdentityGetSharingGraphResponse
         */

        /**
         * Calls GetSharingGraph.
         * @function getSharingGraph
         * @memberof api.IdentityService
         * @instance
         * @param {api.IIdentityGetSharingGraphRequest} request IdentityGetSharingGraphRequest message or plain object
         * @param {api.IdentityService.GetSharingGraphCallback} callback Node-style callback called with the error, if any, and IdentityGetSharingGraphResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(IdentityService.prototype.getSharingGraph = function getSharingGraph(request, callback) {
            return this.rpcCall(getSharingGraph, $root.api.IdentityGetSharingGraphRequest, $root.api.IdentityGetSharingGraphResponse, request, callback);
        }, "name", { value: "GetSharingGraph" });

        /**
         * Calls GetSharingGraph.
         * @function getSharingGraph
         * @memberof api.IdentityService
         * @instance
         * @param {api.IIdentityGetSharingGraphRequest} request IdentityGetSharingGraphRequest message or plain object
         * @returns {Promise<api.IdentityGetSharingGraphResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link api.IdentityService#postSharingGraph}.
         * @memberof api.IdentityService
         * @typedef PostSharingGraphCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {google.protobuf.Empty} [response] Empty
         */

        /**
         * Calls PostSharingGraph.
         * @function postSharingGraph
         * @memberof api.IdentityService
         * @instance
         * @param {api.IIdentityPostSharingGraphRequest} request IdentityPostSharingGraphRequest message or plain object
         * @param {api.IdentityService.PostSharingGraphCallback} callback Node-style callback called with the error, if any, and Empty
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(IdentityService.prototype.postSharingGraph = function postSharingGraph(request, callback) {
            return this.rpcCall(postSharingGraph, $root.api.IdentityPostSharingGraphRequest, $root.google.protobuf.Empty, request, callback);
        }, "name", { value: "PostSharingGraph" });

        /**
         * Calls PostSharingGraph.
         * @function postSharingGraph
         * @memberof api.IdentityService
         * @instance
         * @param {api.IIdentityPostSharingGraphRequest} request IdentityPostSharingGraphRequest message or plain object
         * @returns {Promise<google.protobuf.Empty>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link api.IdentityService#getKeysToRenew}.
         * @memberof api.IdentityService
         * @typedef GetKeysToRenewCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {api.IdentityGetKeysToRenewResponse} [response] IdentityGetKeysToRenewResponse
         */

        /**
         * Calls GetKeysToRenew.
         * @function getKeysToRenew
         * @memberof api.IdentityService
         * @instance
         * @param {api.IIdentityGetKeysToRenewRequest} request IdentityGetKeysToRenewRequest message or plain object
         * @param {api.IdentityService.GetKeysToRenewCallback} callback Node-style callback called with the error, if any, and IdentityGetKeysToRenewResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(IdentityService.prototype.getKeysToRenew = function getKeysToRenew(request, callback) {
            return this.rpcCall(getKeysToRenew, $root.api.IdentityGetKeysToRenewRequest, $root.api.IdentityGetKeysToRenewResponse, request, callback);
        }, "name", { value: "GetKeysToRenew" });

        /**
         * Calls GetKeysToRenew.
         * @function getKeysToRenew
         * @memberof api.IdentityService
         * @instance
         * @param {api.IIdentityGetKeysToRenewRequest} request IdentityGetKeysToRenewRequest message or plain object
         * @returns {Promise<api.IdentityGetKeysToRenewResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link api.IdentityService#postKeysToRenew}.
         * @memberof api.IdentityService
         * @typedef PostKeysToRenewCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {google.protobuf.Empty} [response] Empty
         */

        /**
         * Calls PostKeysToRenew.
         * @function postKeysToRenew
         * @memberof api.IdentityService
         * @instance
         * @param {api.IIdentityPostKeysToRenewRequest} request IdentityPostKeysToRenewRequest message or plain object
         * @param {api.IdentityService.PostKeysToRenewCallback} callback Node-style callback called with the error, if any, and Empty
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(IdentityService.prototype.postKeysToRenew = function postKeysToRenew(request, callback) {
            return this.rpcCall(postKeysToRenew, $root.api.IdentityPostKeysToRenewRequest, $root.google.protobuf.Empty, request, callback);
        }, "name", { value: "PostKeysToRenew" });

        /**
         * Calls PostKeysToRenew.
         * @function postKeysToRenew
         * @memberof api.IdentityService
         * @instance
         * @param {api.IIdentityPostKeysToRenewRequest} request IdentityPostKeysToRenewRequest message or plain object
         * @returns {Promise<google.protobuf.Empty>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link api.IdentityService#promote}.
         * @memberof api.IdentityService
         * @typedef PromoteCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {google.protobuf.Empty} [response] Empty
         */

        /**
         * Calls Promote.
         * @function promote
         * @memberof api.IdentityService
         * @instance
         * @param {api.IIdentityPromoteRequest} request IdentityPromoteRequest message or plain object
         * @param {api.IdentityService.PromoteCallback} callback Node-style callback called with the error, if any, and Empty
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(IdentityService.prototype.promote = function promote(request, callback) {
            return this.rpcCall(promote, $root.api.IdentityPromoteRequest, $root.google.protobuf.Empty, request, callback);
        }, "name", { value: "Promote" });

        /**
         * Calls Promote.
         * @function promote
         * @memberof api.IdentityService
         * @instance
         * @param {api.IIdentityPromoteRequest} request IdentityPromoteRequest message or plain object
         * @returns {Promise<google.protobuf.Empty>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link api.IdentityService#getLockedVersions}.
         * @memberof api.IdentityService
         * @typedef GetLockedVersionsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {api.IdentityGetLockedVersionsResponse} [response] IdentityGetLockedVersionsResponse
         */

        /**
         * Calls GetLockedVersions.
         * @function getLockedVersions
         * @memberof api.IdentityService
         * @instance
         * @param {api.IIdentityGetLockedVersionsRequest} request IdentityGetLockedVersionsRequest message or plain object
         * @param {api.IdentityService.GetLockedVersionsCallback} callback Node-style callback called with the error, if any, and IdentityGetLockedVersionsResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(IdentityService.prototype.getLockedVersions = function getLockedVersions(request, callback) {
            return this.rpcCall(getLockedVersions, $root.api.IdentityGetLockedVersionsRequest, $root.api.IdentityGetLockedVersionsResponse, request, callback);
        }, "name", { value: "GetLockedVersions" });

        /**
         * Calls GetLockedVersions.
         * @function getLockedVersions
         * @memberof api.IdentityService
         * @instance
         * @param {api.IIdentityGetLockedVersionsRequest} request IdentityGetLockedVersionsRequest message or plain object
         * @returns {Promise<api.IdentityGetLockedVersionsResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link api.IdentityService#unlockVersions}.
         * @memberof api.IdentityService
         * @typedef UnlockVersionsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {google.protobuf.Empty} [response] Empty
         */

        /**
         * Calls UnlockVersions.
         * @function unlockVersions
         * @memberof api.IdentityService
         * @instance
         * @param {api.IIdentityUnlockVersionsRequest} request IdentityUnlockVersionsRequest message or plain object
         * @param {api.IdentityService.UnlockVersionsCallback} callback Node-style callback called with the error, if any, and Empty
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(IdentityService.prototype.unlockVersions = function unlockVersions(request, callback) {
            return this.rpcCall(unlockVersions, $root.api.IdentityUnlockVersionsRequest, $root.google.protobuf.Empty, request, callback);
        }, "name", { value: "UnlockVersions" });

        /**
         * Calls UnlockVersions.
         * @function unlockVersions
         * @memberof api.IdentityService
         * @instance
         * @param {api.IIdentityUnlockVersionsRequest} request IdentityUnlockVersionsRequest message or plain object
         * @returns {Promise<google.protobuf.Empty>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link api.IdentityService#setNamedResource}.
         * @memberof api.IdentityService
         * @typedef SetNamedResourceCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {google.protobuf.Empty} [response] Empty
         */

        /**
         * Calls SetNamedResource.
         * @function setNamedResource
         * @memberof api.IdentityService
         * @instance
         * @param {api.IIdentitySetNamedResourceRequest} request IdentitySetNamedResourceRequest message or plain object
         * @param {api.IdentityService.SetNamedResourceCallback} callback Node-style callback called with the error, if any, and Empty
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(IdentityService.prototype.setNamedResource = function setNamedResource(request, callback) {
            return this.rpcCall(setNamedResource, $root.api.IdentitySetNamedResourceRequest, $root.google.protobuf.Empty, request, callback);
        }, "name", { value: "SetNamedResource" });

        /**
         * Calls SetNamedResource.
         * @function setNamedResource
         * @memberof api.IdentityService
         * @instance
         * @param {api.IIdentitySetNamedResourceRequest} request IdentitySetNamedResourceRequest message or plain object
         * @returns {Promise<google.protobuf.Empty>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link api.IdentityService#getNamedResource}.
         * @memberof api.IdentityService
         * @typedef GetNamedResourceCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {api.IdentityGetNamedResourceResponse} [response] IdentityGetNamedResourceResponse
         */

        /**
         * Calls GetNamedResource.
         * @function getNamedResource
         * @memberof api.IdentityService
         * @instance
         * @param {api.IIdentityGetNamedResourceRequest} request IdentityGetNamedResourceRequest message or plain object
         * @param {api.IdentityService.GetNamedResourceCallback} callback Node-style callback called with the error, if any, and IdentityGetNamedResourceResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(IdentityService.prototype.getNamedResource = function getNamedResource(request, callback) {
            return this.rpcCall(getNamedResource, $root.api.IdentityGetNamedResourceRequest, $root.api.IdentityGetNamedResourceResponse, request, callback);
        }, "name", { value: "GetNamedResource" });

        /**
         * Calls GetNamedResource.
         * @function getNamedResource
         * @memberof api.IdentityService
         * @instance
         * @param {api.IIdentityGetNamedResourceRequest} request IdentityGetNamedResourceRequest message or plain object
         * @returns {Promise<api.IdentityGetNamedResourceResponse>} Promise
         * @variation 2
         */

        return IdentityService;
    })();

    api.ResourceService = (function() {

        /**
         * Constructs a new ResourceService service.
         * @memberof api
         * @classdesc Represents a ResourceService
         * @extends $protobuf.rpc.Service
         * @constructor
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         */
        function ResourceService(rpcImpl, requestDelimited, responseDelimited) {
            $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }

        (ResourceService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = ResourceService;

        /**
         * Creates new ResourceService service using the specified rpc implementation.
         * @function create
         * @memberof api.ResourceService
         * @static
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         * @returns {ResourceService} RPC service. Useful where requests and/or responses are streamed.
         */
        ResourceService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
            return new this(rpcImpl, requestDelimited, responseDelimited);
        };

        /**
         * Callback as used by {@link api.ResourceService#list}.
         * @memberof api.ResourceService
         * @typedef ListCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {api.ResourceListResponse} [response] ResourceListResponse
         */

        /**
         * Calls List.
         * @function list
         * @memberof api.ResourceService
         * @instance
         * @param {api.IResourceListRequest} request ResourceListRequest message or plain object
         * @param {api.ResourceService.ListCallback} callback Node-style callback called with the error, if any, and ResourceListResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ResourceService.prototype.list = function list(request, callback) {
            return this.rpcCall(list, $root.api.ResourceListRequest, $root.api.ResourceListResponse, request, callback);
        }, "name", { value: "List" });

        /**
         * Calls List.
         * @function list
         * @memberof api.ResourceService
         * @instance
         * @param {api.IResourceListRequest} request ResourceListRequest message or plain object
         * @returns {Promise<api.ResourceListResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link api.ResourceService#create}.
         * @memberof api.ResourceService
         * @typedef CreateCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {api.ResourcePostResponse} [response] ResourcePostResponse
         */

        /**
         * Calls Create.
         * @function create
         * @memberof api.ResourceService
         * @instance
         * @param {api.IResourcePostRequest} request ResourcePostRequest message or plain object
         * @param {api.ResourceService.CreateCallback} callback Node-style callback called with the error, if any, and ResourcePostResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ResourceService.prototype.create = function create(request, callback) {
            return this.rpcCall(create, $root.api.ResourcePostRequest, $root.api.ResourcePostResponse, request, callback);
        }, "name", { value: "Create" });

        /**
         * Calls Create.
         * @function create
         * @memberof api.ResourceService
         * @instance
         * @param {api.IResourcePostRequest} request ResourcePostRequest message or plain object
         * @returns {Promise<api.ResourcePostResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link api.ResourceService#getAccessLogs}.
         * @memberof api.ResourceService
         * @typedef GetAccessLogsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {api.ResourceGetAccessLogsResponse} [response] ResourceGetAccessLogsResponse
         */

        /**
         * Calls GetAccessLogs.
         * @function getAccessLogs
         * @memberof api.ResourceService
         * @instance
         * @param {api.IResourceGetAccessLogsRequest} request ResourceGetAccessLogsRequest message or plain object
         * @param {api.ResourceService.GetAccessLogsCallback} callback Node-style callback called with the error, if any, and ResourceGetAccessLogsResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ResourceService.prototype.getAccessLogs = function getAccessLogs(request, callback) {
            return this.rpcCall(getAccessLogs, $root.api.ResourceGetAccessLogsRequest, $root.api.ResourceGetAccessLogsResponse, request, callback);
        }, "name", { value: "GetAccessLogs" });

        /**
         * Calls GetAccessLogs.
         * @function getAccessLogs
         * @memberof api.ResourceService
         * @instance
         * @param {api.IResourceGetAccessLogsRequest} request ResourceGetAccessLogsRequest message or plain object
         * @returns {Promise<api.ResourceGetAccessLogsResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link api.ResourceService#get}.
         * @memberof api.ResourceService
         * @typedef GetCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {api.ResourceGetResponse} [response] ResourceGetResponse
         */

        /**
         * Calls Get.
         * @function get
         * @memberof api.ResourceService
         * @instance
         * @param {api.IResourceGetRequest} request ResourceGetRequest message or plain object
         * @param {api.ResourceService.GetCallback} callback Node-style callback called with the error, if any, and ResourceGetResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ResourceService.prototype.get = function get(request, callback) {
            return this.rpcCall(get, $root.api.ResourceGetRequest, $root.api.ResourceGetResponse, request, callback);
        }, "name", { value: "Get" });

        /**
         * Calls Get.
         * @function get
         * @memberof api.ResourceService
         * @instance
         * @param {api.IResourceGetRequest} request ResourceGetRequest message or plain object
         * @returns {Promise<api.ResourceGetResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link api.ResourceService#delete_}.
         * @memberof api.ResourceService
         * @typedef DeleteCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {google.protobuf.Empty} [response] Empty
         */

        /**
         * Calls Delete.
         * @function delete
         * @memberof api.ResourceService
         * @instance
         * @param {api.IResourceDeleteRequest} request ResourceDeleteRequest message or plain object
         * @param {api.ResourceService.DeleteCallback} callback Node-style callback called with the error, if any, and Empty
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ResourceService.prototype["delete"] = function delete_(request, callback) {
            return this.rpcCall(delete_, $root.api.ResourceDeleteRequest, $root.google.protobuf.Empty, request, callback);
        }, "name", { value: "Delete" });

        /**
         * Calls Delete.
         * @function delete
         * @memberof api.ResourceService
         * @instance
         * @param {api.IResourceDeleteRequest} request ResourceDeleteRequest message or plain object
         * @returns {Promise<google.protobuf.Empty>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link api.ResourceService#getKey}.
         * @memberof api.ResourceService
         * @typedef GetKeyCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {api.ResourceGetKeyResponse} [response] ResourceGetKeyResponse
         */

        /**
         * Calls GetKey.
         * @function getKey
         * @memberof api.ResourceService
         * @instance
         * @param {api.IResourceGetKeyRequest} request ResourceGetKeyRequest message or plain object
         * @param {api.ResourceService.GetKeyCallback} callback Node-style callback called with the error, if any, and ResourceGetKeyResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ResourceService.prototype.getKey = function getKey(request, callback) {
            return this.rpcCall(getKey, $root.api.ResourceGetKeyRequest, $root.api.ResourceGetKeyResponse, request, callback);
        }, "name", { value: "GetKey" });

        /**
         * Calls GetKey.
         * @function getKey
         * @memberof api.ResourceService
         * @instance
         * @param {api.IResourceGetKeyRequest} request ResourceGetKeyRequest message or plain object
         * @returns {Promise<api.ResourceGetKeyResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link api.ResourceService#getSharingGroup}.
         * @memberof api.ResourceService
         * @typedef GetSharingGroupCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {api.ResourceGetSharingGroupResponse} [response] ResourceGetSharingGroupResponse
         */

        /**
         * Calls GetSharingGroup.
         * @function getSharingGroup
         * @memberof api.ResourceService
         * @instance
         * @param {api.IResourceGetSharingGroupRequest} request ResourceGetSharingGroupRequest message or plain object
         * @param {api.ResourceService.GetSharingGroupCallback} callback Node-style callback called with the error, if any, and ResourceGetSharingGroupResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ResourceService.prototype.getSharingGroup = function getSharingGroup(request, callback) {
            return this.rpcCall(getSharingGroup, $root.api.ResourceGetSharingGroupRequest, $root.api.ResourceGetSharingGroupResponse, request, callback);
        }, "name", { value: "GetSharingGroup" });

        /**
         * Calls GetSharingGroup.
         * @function getSharingGroup
         * @memberof api.ResourceService
         * @instance
         * @param {api.IResourceGetSharingGroupRequest} request ResourceGetSharingGroupRequest message or plain object
         * @returns {Promise<api.ResourceGetSharingGroupResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link api.ResourceService#extendSharingGroup}.
         * @memberof api.ResourceService
         * @typedef ExtendSharingGroupCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {google.protobuf.Empty} [response] Empty
         */

        /**
         * Calls ExtendSharingGroup.
         * @function extendSharingGroup
         * @memberof api.ResourceService
         * @instance
         * @param {api.IResourceExtendSharingGroupRequest} request ResourceExtendSharingGroupRequest message or plain object
         * @param {api.ResourceService.ExtendSharingGroupCallback} callback Node-style callback called with the error, if any, and Empty
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ResourceService.prototype.extendSharingGroup = function extendSharingGroup(request, callback) {
            return this.rpcCall(extendSharingGroup, $root.api.ResourceExtendSharingGroupRequest, $root.google.protobuf.Empty, request, callback);
        }, "name", { value: "ExtendSharingGroup" });

        /**
         * Calls ExtendSharingGroup.
         * @function extendSharingGroup
         * @memberof api.ResourceService
         * @instance
         * @param {api.IResourceExtendSharingGroupRequest} request ResourceExtendSharingGroupRequest message or plain object
         * @returns {Promise<google.protobuf.Empty>} Promise
         * @variation 2
         */

        return ResourceService;
    })();

    api.ApplicationService = (function() {

        /**
         * Constructs a new ApplicationService service.
         * @memberof api
         * @classdesc Represents an ApplicationService
         * @extends $protobuf.rpc.Service
         * @constructor
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         */
        function ApplicationService(rpcImpl, requestDelimited, responseDelimited) {
            $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }

        (ApplicationService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = ApplicationService;

        /**
         * Creates new ApplicationService service using the specified rpc implementation.
         * @function create
         * @memberof api.ApplicationService
         * @static
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         * @returns {ApplicationService} RPC service. Useful where requests and/or responses are streamed.
         */
        ApplicationService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
            return new this(rpcImpl, requestDelimited, responseDelimited);
        };

        /**
         * Callback as used by {@link api.ApplicationService#configure}.
         * @memberof api.ApplicationService
         * @typedef ConfigureCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {api.ApplicationConfigID} [response] ApplicationConfigID
         */

        /**
         * Calls Configure.
         * @function configure
         * @memberof api.ApplicationService
         * @instance
         * @param {api.IIdentityConfigurationAsApplicationRequest} request IdentityConfigurationAsApplicationRequest message or plain object
         * @param {api.ApplicationService.ConfigureCallback} callback Node-style callback called with the error, if any, and ApplicationConfigID
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ApplicationService.prototype.configure = function configure(request, callback) {
            return this.rpcCall(configure, $root.api.IdentityConfigurationAsApplicationRequest, $root.api.ApplicationConfigID, request, callback);
        }, "name", { value: "Configure" });

        /**
         * Calls Configure.
         * @function configure
         * @memberof api.ApplicationService
         * @instance
         * @param {api.IIdentityConfigurationAsApplicationRequest} request IdentityConfigurationAsApplicationRequest message or plain object
         * @returns {Promise<api.ApplicationConfigID>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link api.ApplicationService#usageOverview}.
         * @memberof api.ApplicationService
         * @typedef UsageOverviewCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {api.ApplicationUsageOverviewResponse} [response] ApplicationUsageOverviewResponse
         */

        /**
         * Calls UsageOverview.
         * @function usageOverview
         * @memberof api.ApplicationService
         * @instance
         * @param {api.IApplicationUsageOverviewRequest} request ApplicationUsageOverviewRequest message or plain object
         * @param {api.ApplicationService.UsageOverviewCallback} callback Node-style callback called with the error, if any, and ApplicationUsageOverviewResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ApplicationService.prototype.usageOverview = function usageOverview(request, callback) {
            return this.rpcCall(usageOverview, $root.api.ApplicationUsageOverviewRequest, $root.api.ApplicationUsageOverviewResponse, request, callback);
        }, "name", { value: "UsageOverview" });

        /**
         * Calls UsageOverview.
         * @function usageOverview
         * @memberof api.ApplicationService
         * @instance
         * @param {api.IApplicationUsageOverviewRequest} request ApplicationUsageOverviewRequest message or plain object
         * @returns {Promise<api.ApplicationUsageOverviewResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link api.ApplicationService#registerApplicationIdentity}.
         * @memberof api.ApplicationService
         * @typedef RegisterApplicationIdentityCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {api.RegisterApplicationIdentityResponse} [response] RegisterApplicationIdentityResponse
         */

        /**
         * Calls RegisterApplicationIdentity.
         * @function registerApplicationIdentity
         * @memberof api.ApplicationService
         * @instance
         * @param {api.IRegisterApplicationIdentityRequest} request RegisterApplicationIdentityRequest message or plain object
         * @param {api.ApplicationService.RegisterApplicationIdentityCallback} callback Node-style callback called with the error, if any, and RegisterApplicationIdentityResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ApplicationService.prototype.registerApplicationIdentity = function registerApplicationIdentity(request, callback) {
            return this.rpcCall(registerApplicationIdentity, $root.api.RegisterApplicationIdentityRequest, $root.api.RegisterApplicationIdentityResponse, request, callback);
        }, "name", { value: "RegisterApplicationIdentity" });

        /**
         * Calls RegisterApplicationIdentity.
         * @function registerApplicationIdentity
         * @memberof api.ApplicationService
         * @instance
         * @param {api.IRegisterApplicationIdentityRequest} request RegisterApplicationIdentityRequest message or plain object
         * @returns {Promise<api.RegisterApplicationIdentityResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link api.ApplicationService#listIdentities}.
         * @memberof api.ApplicationService
         * @typedef ListIdentitiesCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {api.ApplicationListIdentitiesResponse} [response] ApplicationListIdentitiesResponse
         */

        /**
         * Calls ListIdentities.
         * @function listIdentities
         * @memberof api.ApplicationService
         * @instance
         * @param {api.IApplicationListIdentitiesRequest} request ApplicationListIdentitiesRequest message or plain object
         * @param {api.ApplicationService.ListIdentitiesCallback} callback Node-style callback called with the error, if any, and ApplicationListIdentitiesResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ApplicationService.prototype.listIdentities = function listIdentities(request, callback) {
            return this.rpcCall(listIdentities, $root.api.ApplicationListIdentitiesRequest, $root.api.ApplicationListIdentitiesResponse, request, callback);
        }, "name", { value: "ListIdentities" });

        /**
         * Calls ListIdentities.
         * @function listIdentities
         * @memberof api.ApplicationService
         * @instance
         * @param {api.IApplicationListIdentitiesRequest} request ApplicationListIdentitiesRequest message or plain object
         * @returns {Promise<api.ApplicationListIdentitiesResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link api.ApplicationService#listIdentitySession}.
         * @memberof api.ApplicationService
         * @typedef ListIdentitySessionCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {api.ApplicationIdentitySessionListResponse} [response] ApplicationIdentitySessionListResponse
         */

        /**
         * Calls ListIdentitySession.
         * @function listIdentitySession
         * @memberof api.ApplicationService
         * @instance
         * @param {api.IApplicationIdentitySessionListRequest} request ApplicationIdentitySessionListRequest message or plain object
         * @param {api.ApplicationService.ListIdentitySessionCallback} callback Node-style callback called with the error, if any, and ApplicationIdentitySessionListResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ApplicationService.prototype.listIdentitySession = function listIdentitySession(request, callback) {
            return this.rpcCall(listIdentitySession, $root.api.ApplicationIdentitySessionListRequest, $root.api.ApplicationIdentitySessionListResponse, request, callback);
        }, "name", { value: "ListIdentitySession" });

        /**
         * Calls ListIdentitySession.
         * @function listIdentitySession
         * @memberof api.ApplicationService
         * @instance
         * @param {api.IApplicationIdentitySessionListRequest} request ApplicationIdentitySessionListRequest message or plain object
         * @returns {Promise<api.ApplicationIdentitySessionListResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link api.ApplicationService#getIdentityAuth}.
         * @memberof api.ApplicationService
         * @typedef GetIdentityAuthCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {api.ApplicationGetIdentityAuthResponse} [response] ApplicationGetIdentityAuthResponse
         */

        /**
         * Calls GetIdentityAuth.
         * @function getIdentityAuth
         * @memberof api.ApplicationService
         * @instance
         * @param {api.IApplicationGetIdentityAuthRequest} request ApplicationGetIdentityAuthRequest message or plain object
         * @param {api.ApplicationService.GetIdentityAuthCallback} callback Node-style callback called with the error, if any, and ApplicationGetIdentityAuthResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ApplicationService.prototype.getIdentityAuth = function getIdentityAuth(request, callback) {
            return this.rpcCall(getIdentityAuth, $root.api.ApplicationGetIdentityAuthRequest, $root.api.ApplicationGetIdentityAuthResponse, request, callback);
        }, "name", { value: "GetIdentityAuth" });

        /**
         * Calls GetIdentityAuth.
         * @function getIdentityAuth
         * @memberof api.ApplicationService
         * @instance
         * @param {api.IApplicationGetIdentityAuthRequest} request ApplicationGetIdentityAuthRequest message or plain object
         * @returns {Promise<api.ApplicationGetIdentityAuthResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link api.ApplicationService#getConfiguration}.
         * @memberof api.ApplicationService
         * @typedef GetConfigurationCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {api.IdentityGetConfigurationResponse} [response] IdentityGetConfigurationResponse
         */

        /**
         * Calls GetConfiguration.
         * @function getConfiguration
         * @memberof api.ApplicationService
         * @instance
         * @param {api.IApplicationConfigID} request ApplicationConfigID message or plain object
         * @param {api.ApplicationService.GetConfigurationCallback} callback Node-style callback called with the error, if any, and IdentityGetConfigurationResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ApplicationService.prototype.getConfiguration = function getConfiguration(request, callback) {
            return this.rpcCall(getConfiguration, $root.api.ApplicationConfigID, $root.api.IdentityGetConfigurationResponse, request, callback);
        }, "name", { value: "GetConfiguration" });

        /**
         * Calls GetConfiguration.
         * @function getConfiguration
         * @memberof api.ApplicationService
         * @instance
         * @param {api.IApplicationConfigID} request ApplicationConfigID message or plain object
         * @returns {Promise<api.IdentityGetConfigurationResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link api.ApplicationService#getLatestConfiguration}.
         * @memberof api.ApplicationService
         * @typedef GetLatestConfigurationCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {api.IdentityGetConfigurationResponse} [response] IdentityGetConfigurationResponse
         */

        /**
         * Calls GetLatestConfiguration.
         * @function getLatestConfiguration
         * @memberof api.ApplicationService
         * @instance
         * @param {api.IApplicationGetLatestConfigurationRequest} request ApplicationGetLatestConfigurationRequest message or plain object
         * @param {api.ApplicationService.GetLatestConfigurationCallback} callback Node-style callback called with the error, if any, and IdentityGetConfigurationResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ApplicationService.prototype.getLatestConfiguration = function getLatestConfiguration(request, callback) {
            return this.rpcCall(getLatestConfiguration, $root.api.ApplicationGetLatestConfigurationRequest, $root.api.IdentityGetConfigurationResponse, request, callback);
        }, "name", { value: "GetLatestConfiguration" });

        /**
         * Calls GetLatestConfiguration.
         * @function getLatestConfiguration
         * @memberof api.ApplicationService
         * @instance
         * @param {api.IApplicationGetLatestConfigurationRequest} request ApplicationGetLatestConfigurationRequest message or plain object
         * @returns {Promise<api.IdentityGetConfigurationResponse>} Promise
         * @variation 2
         */

        return ApplicationService;
    })();

    api.DelegatedAccessService = (function() {

        /**
         * Constructs a new DelegatedAccessService service.
         * @memberof api
         * @classdesc Represents a DelegatedAccessService
         * @extends $protobuf.rpc.Service
         * @constructor
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         */
        function DelegatedAccessService(rpcImpl, requestDelimited, responseDelimited) {
            $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }

        (DelegatedAccessService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = DelegatedAccessService;

        /**
         * Creates new DelegatedAccessService service using the specified rpc implementation.
         * @function create
         * @memberof api.DelegatedAccessService
         * @static
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         * @returns {DelegatedAccessService} RPC service. Useful where requests and/or responses are streamed.
         */
        DelegatedAccessService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
            return new this(rpcImpl, requestDelimited, responseDelimited);
        };

        /**
         * Callback as used by {@link api.DelegatedAccessService#create}.
         * @memberof api.DelegatedAccessService
         * @typedef CreateCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {api.DelegatedAccessPostResponse} [response] DelegatedAccessPostResponse
         */

        /**
         * Calls Create.
         * @function create
         * @memberof api.DelegatedAccessService
         * @instance
         * @param {api.IDelegatedAccessPostRequest} request DelegatedAccessPostRequest message or plain object
         * @param {api.DelegatedAccessService.CreateCallback} callback Node-style callback called with the error, if any, and DelegatedAccessPostResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(DelegatedAccessService.prototype.create = function create(request, callback) {
            return this.rpcCall(create, $root.api.DelegatedAccessPostRequest, $root.api.DelegatedAccessPostResponse, request, callback);
        }, "name", { value: "Create" });

        /**
         * Calls Create.
         * @function create
         * @memberof api.DelegatedAccessService
         * @instance
         * @param {api.IDelegatedAccessPostRequest} request DelegatedAccessPostRequest message or plain object
         * @returns {Promise<api.DelegatedAccessPostResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link api.DelegatedAccessService#get}.
         * @memberof api.DelegatedAccessService
         * @typedef GetCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {api.DelegatedAccessGetResponse} [response] DelegatedAccessGetResponse
         */

        /**
         * Calls Get.
         * @function get
         * @memberof api.DelegatedAccessService
         * @instance
         * @param {api.IDelegatedAccessGetRequest} request DelegatedAccessGetRequest message or plain object
         * @param {api.DelegatedAccessService.GetCallback} callback Node-style callback called with the error, if any, and DelegatedAccessGetResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(DelegatedAccessService.prototype.get = function get(request, callback) {
            return this.rpcCall(get, $root.api.DelegatedAccessGetRequest, $root.api.DelegatedAccessGetResponse, request, callback);
        }, "name", { value: "Get" });

        /**
         * Calls Get.
         * @function get
         * @memberof api.DelegatedAccessService
         * @instance
         * @param {api.IDelegatedAccessGetRequest} request DelegatedAccessGetRequest message or plain object
         * @returns {Promise<api.DelegatedAccessGetResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link api.DelegatedAccessService#getKeys}.
         * @memberof api.DelegatedAccessService
         * @typedef GetKeysCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {api.DelegatedAccessGetKeysResponse} [response] DelegatedAccessGetKeysResponse
         */

        /**
         * Calls GetKeys.
         * @function getKeys
         * @memberof api.DelegatedAccessService
         * @instance
         * @param {api.IDelegatedAccessGetKeysRequest} request DelegatedAccessGetKeysRequest message or plain object
         * @param {api.DelegatedAccessService.GetKeysCallback} callback Node-style callback called with the error, if any, and DelegatedAccessGetKeysResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(DelegatedAccessService.prototype.getKeys = function getKeys(request, callback) {
            return this.rpcCall(getKeys, $root.api.DelegatedAccessGetKeysRequest, $root.api.DelegatedAccessGetKeysResponse, request, callback);
        }, "name", { value: "GetKeys" });

        /**
         * Calls GetKeys.
         * @function getKeys
         * @memberof api.DelegatedAccessService
         * @instance
         * @param {api.IDelegatedAccessGetKeysRequest} request DelegatedAccessGetKeysRequest message or plain object
         * @returns {Promise<api.DelegatedAccessGetKeysResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link api.DelegatedAccessService#putKeys}.
         * @memberof api.DelegatedAccessService
         * @typedef PutKeysCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {google.protobuf.Empty} [response] Empty
         */

        /**
         * Calls PutKeys.
         * @function putKeys
         * @memberof api.DelegatedAccessService
         * @instance
         * @param {api.IDelegatedAccessPostKeysRequest} request DelegatedAccessPostKeysRequest message or plain object
         * @param {api.DelegatedAccessService.PutKeysCallback} callback Node-style callback called with the error, if any, and Empty
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(DelegatedAccessService.prototype.putKeys = function putKeys(request, callback) {
            return this.rpcCall(putKeys, $root.api.DelegatedAccessPostKeysRequest, $root.google.protobuf.Empty, request, callback);
        }, "name", { value: "PutKeys" });

        /**
         * Calls PutKeys.
         * @function putKeys
         * @memberof api.DelegatedAccessService
         * @instance
         * @param {api.IDelegatedAccessPostKeysRequest} request DelegatedAccessPostKeysRequest message or plain object
         * @returns {Promise<google.protobuf.Empty>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link api.DelegatedAccessService#list}.
         * @memberof api.DelegatedAccessService
         * @typedef ListCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {api.DelegatedAccessListResponse} [response] DelegatedAccessListResponse
         */

        /**
         * Calls List.
         * @function list
         * @memberof api.DelegatedAccessService
         * @instance
         * @param {api.IDelegatedAccessListRequest} request DelegatedAccessListRequest message or plain object
         * @param {api.DelegatedAccessService.ListCallback} callback Node-style callback called with the error, if any, and DelegatedAccessListResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(DelegatedAccessService.prototype.list = function list(request, callback) {
            return this.rpcCall(list, $root.api.DelegatedAccessListRequest, $root.api.DelegatedAccessListResponse, request, callback);
        }, "name", { value: "List" });

        /**
         * Calls List.
         * @function list
         * @memberof api.DelegatedAccessService
         * @instance
         * @param {api.IDelegatedAccessListRequest} request DelegatedAccessListRequest message or plain object
         * @returns {Promise<api.DelegatedAccessListResponse>} Promise
         * @variation 2
         */

        return DelegatedAccessService;
    })();

    api.TenantCustomer = (function() {

        /**
         * Properties of a TenantCustomer.
         * @memberof api
         * @interface ITenantCustomer
         * @property {number|null} [id] TenantCustomer id
         * @property {string|null} [name] TenantCustomer name
         */

        /**
         * Constructs a new TenantCustomer.
         * @memberof api
         * @classdesc Represents a TenantCustomer.
         * @implements ITenantCustomer
         * @constructor
         * @param {api.ITenantCustomer=} [properties] Properties to set
         */
        function TenantCustomer(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TenantCustomer id.
         * @member {number} id
         * @memberof api.TenantCustomer
         * @instance
         */
        TenantCustomer.prototype.id = 0;

        /**
         * TenantCustomer name.
         * @member {string} name
         * @memberof api.TenantCustomer
         * @instance
         */
        TenantCustomer.prototype.name = "";

        /**
         * Creates a new TenantCustomer instance using the specified properties.
         * @function create
         * @memberof api.TenantCustomer
         * @static
         * @param {api.ITenantCustomer=} [properties] Properties to set
         * @returns {api.TenantCustomer} TenantCustomer instance
         */
        TenantCustomer.create = function create(properties) {
            return new TenantCustomer(properties);
        };

        /**
         * Encodes the specified TenantCustomer message. Does not implicitly {@link api.TenantCustomer.verify|verify} messages.
         * @function encode
         * @memberof api.TenantCustomer
         * @static
         * @param {api.ITenantCustomer} message TenantCustomer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TenantCustomer.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            return writer;
        };

        /**
         * Encodes the specified TenantCustomer message, length delimited. Does not implicitly {@link api.TenantCustomer.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.TenantCustomer
         * @static
         * @param {api.ITenantCustomer} message TenantCustomer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TenantCustomer.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TenantCustomer message from the specified reader or buffer.
         * @function decode
         * @memberof api.TenantCustomer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.TenantCustomer} TenantCustomer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TenantCustomer.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.TenantCustomer();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.uint32();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TenantCustomer message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.TenantCustomer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.TenantCustomer} TenantCustomer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TenantCustomer.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TenantCustomer message.
         * @function verify
         * @memberof api.TenantCustomer
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TenantCustomer.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            return null;
        };

        /**
         * Creates a TenantCustomer message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.TenantCustomer
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.TenantCustomer} TenantCustomer
         */
        TenantCustomer.fromObject = function fromObject(object) {
            if (object instanceof $root.api.TenantCustomer)
                return object;
            var message = new $root.api.TenantCustomer();
            if (object.id != null)
                message.id = object.id >>> 0;
            if (object.name != null)
                message.name = String(object.name);
            return message;
        };

        /**
         * Creates a plain object from a TenantCustomer message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.TenantCustomer
         * @static
         * @param {api.TenantCustomer} message TenantCustomer
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TenantCustomer.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = 0;
                object.name = "";
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            return object;
        };

        /**
         * Converts this TenantCustomer to JSON.
         * @function toJSON
         * @memberof api.TenantCustomer
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TenantCustomer.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TenantCustomer;
    })();

    api.TenantGetCustomersResponse = (function() {

        /**
         * Properties of a TenantGetCustomersResponse.
         * @memberof api
         * @interface ITenantGetCustomersResponse
         * @property {Array.<api.ITenantCustomer>|null} [customers] TenantGetCustomersResponse customers
         */

        /**
         * Constructs a new TenantGetCustomersResponse.
         * @memberof api
         * @classdesc Represents a TenantGetCustomersResponse.
         * @implements ITenantGetCustomersResponse
         * @constructor
         * @param {api.ITenantGetCustomersResponse=} [properties] Properties to set
         */
        function TenantGetCustomersResponse(properties) {
            this.customers = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TenantGetCustomersResponse customers.
         * @member {Array.<api.ITenantCustomer>} customers
         * @memberof api.TenantGetCustomersResponse
         * @instance
         */
        TenantGetCustomersResponse.prototype.customers = $util.emptyArray;

        /**
         * Creates a new TenantGetCustomersResponse instance using the specified properties.
         * @function create
         * @memberof api.TenantGetCustomersResponse
         * @static
         * @param {api.ITenantGetCustomersResponse=} [properties] Properties to set
         * @returns {api.TenantGetCustomersResponse} TenantGetCustomersResponse instance
         */
        TenantGetCustomersResponse.create = function create(properties) {
            return new TenantGetCustomersResponse(properties);
        };

        /**
         * Encodes the specified TenantGetCustomersResponse message. Does not implicitly {@link api.TenantGetCustomersResponse.verify|verify} messages.
         * @function encode
         * @memberof api.TenantGetCustomersResponse
         * @static
         * @param {api.ITenantGetCustomersResponse} message TenantGetCustomersResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TenantGetCustomersResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.customers != null && message.customers.length)
                for (var i = 0; i < message.customers.length; ++i)
                    $root.api.TenantCustomer.encode(message.customers[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified TenantGetCustomersResponse message, length delimited. Does not implicitly {@link api.TenantGetCustomersResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof api.TenantGetCustomersResponse
         * @static
         * @param {api.ITenantGetCustomersResponse} message TenantGetCustomersResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TenantGetCustomersResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TenantGetCustomersResponse message from the specified reader or buffer.
         * @function decode
         * @memberof api.TenantGetCustomersResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {api.TenantGetCustomersResponse} TenantGetCustomersResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TenantGetCustomersResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.TenantGetCustomersResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.customers && message.customers.length))
                        message.customers = [];
                    message.customers.push($root.api.TenantCustomer.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TenantGetCustomersResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof api.TenantGetCustomersResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {api.TenantGetCustomersResponse} TenantGetCustomersResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TenantGetCustomersResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TenantGetCustomersResponse message.
         * @function verify
         * @memberof api.TenantGetCustomersResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TenantGetCustomersResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.customers != null && message.hasOwnProperty("customers")) {
                if (!Array.isArray(message.customers))
                    return "customers: array expected";
                for (var i = 0; i < message.customers.length; ++i) {
                    var error = $root.api.TenantCustomer.verify(message.customers[i]);
                    if (error)
                        return "customers." + error;
                }
            }
            return null;
        };

        /**
         * Creates a TenantGetCustomersResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof api.TenantGetCustomersResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {api.TenantGetCustomersResponse} TenantGetCustomersResponse
         */
        TenantGetCustomersResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.api.TenantGetCustomersResponse)
                return object;
            var message = new $root.api.TenantGetCustomersResponse();
            if (object.customers) {
                if (!Array.isArray(object.customers))
                    throw TypeError(".api.TenantGetCustomersResponse.customers: array expected");
                message.customers = [];
                for (var i = 0; i < object.customers.length; ++i) {
                    if (typeof object.customers[i] !== "object")
                        throw TypeError(".api.TenantGetCustomersResponse.customers: object expected");
                    message.customers[i] = $root.api.TenantCustomer.fromObject(object.customers[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a TenantGetCustomersResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof api.TenantGetCustomersResponse
         * @static
         * @param {api.TenantGetCustomersResponse} message TenantGetCustomersResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TenantGetCustomersResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.customers = [];
            if (message.customers && message.customers.length) {
                object.customers = [];
                for (var j = 0; j < message.customers.length; ++j)
                    object.customers[j] = $root.api.TenantCustomer.toObject(message.customers[j], options);
            }
            return object;
        };

        /**
         * Converts this TenantGetCustomersResponse to JSON.
         * @function toJSON
         * @memberof api.TenantGetCustomersResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TenantGetCustomersResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TenantGetCustomersResponse;
    })();

    api.TenantService = (function() {

        /**
         * Constructs a new TenantService service.
         * @memberof api
         * @classdesc Represents a TenantService
         * @extends $protobuf.rpc.Service
         * @constructor
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         */
        function TenantService(rpcImpl, requestDelimited, responseDelimited) {
            $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }

        (TenantService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = TenantService;

        /**
         * Creates new TenantService service using the specified rpc implementation.
         * @function create
         * @memberof api.TenantService
         * @static
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         * @returns {TenantService} RPC service. Useful where requests and/or responses are streamed.
         */
        TenantService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
            return new this(rpcImpl, requestDelimited, responseDelimited);
        };

        /**
         * Callback as used by {@link api.TenantService#getCustomers}.
         * @memberof api.TenantService
         * @typedef GetCustomersCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {api.TenantGetCustomersResponse} [response] TenantGetCustomersResponse
         */

        /**
         * Calls GetCustomers.
         * @function getCustomers
         * @memberof api.TenantService
         * @instance
         * @param {google.protobuf.IEmpty} request Empty message or plain object
         * @param {api.TenantService.GetCustomersCallback} callback Node-style callback called with the error, if any, and TenantGetCustomersResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(TenantService.prototype.getCustomers = function getCustomers(request, callback) {
            return this.rpcCall(getCustomers, $root.google.protobuf.Empty, $root.api.TenantGetCustomersResponse, request, callback);
        }, "name", { value: "GetCustomers" });

        /**
         * Calls GetCustomers.
         * @function getCustomers
         * @memberof api.TenantService
         * @instance
         * @param {google.protobuf.IEmpty} request Empty message or plain object
         * @returns {Promise<api.TenantGetCustomersResponse>} Promise
         * @variation 2
         */

        return TenantService;
    })();

    return api;
})();

$root.google = (function() {

    /**
     * Namespace google.
     * @exports google
     * @namespace
     */
    var google = {};

    google.protobuf = (function() {

        /**
         * Namespace protobuf.
         * @memberof google
         * @namespace
         */
        var protobuf = {};

        protobuf.Any = (function() {

            /**
             * Properties of an Any.
             * @memberof google.protobuf
             * @interface IAny
             * @property {string|null} [type_url] Any type_url
             * @property {Uint8Array|null} [value] Any value
             */

            /**
             * Constructs a new Any.
             * @memberof google.protobuf
             * @classdesc Represents an Any.
             * @implements IAny
             * @constructor
             * @param {google.protobuf.IAny=} [properties] Properties to set
             */
            function Any(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Any type_url.
             * @member {string} type_url
             * @memberof google.protobuf.Any
             * @instance
             */
            Any.prototype.type_url = "";

            /**
             * Any value.
             * @member {Uint8Array} value
             * @memberof google.protobuf.Any
             * @instance
             */
            Any.prototype.value = $util.newBuffer([]);

            /**
             * Creates a new Any instance using the specified properties.
             * @function create
             * @memberof google.protobuf.Any
             * @static
             * @param {google.protobuf.IAny=} [properties] Properties to set
             * @returns {google.protobuf.Any} Any instance
             */
            Any.create = function create(properties) {
                return new Any(properties);
            };

            /**
             * Encodes the specified Any message. Does not implicitly {@link google.protobuf.Any.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.Any
             * @static
             * @param {google.protobuf.IAny} message Any message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Any.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type_url != null && message.hasOwnProperty("type_url"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.type_url);
                if (message.value != null && message.hasOwnProperty("value"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.value);
                return writer;
            };

            /**
             * Encodes the specified Any message, length delimited. Does not implicitly {@link google.protobuf.Any.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.Any
             * @static
             * @param {google.protobuf.IAny} message Any message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Any.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Any message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.Any
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.Any} Any
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Any.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Any();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type_url = reader.string();
                        break;
                    case 2:
                        message.value = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Any message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.Any
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.Any} Any
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Any.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Any message.
             * @function verify
             * @memberof google.protobuf.Any
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Any.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type_url != null && message.hasOwnProperty("type_url"))
                    if (!$util.isString(message.type_url))
                        return "type_url: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                return null;
            };

            /**
             * Creates an Any message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.Any
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Any} Any
             */
            Any.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Any)
                    return object;
                var message = new $root.google.protobuf.Any();
                if (object.type_url != null)
                    message.type_url = String(object.type_url);
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                return message;
            };

            /**
             * Creates a plain object from an Any message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.Any
             * @static
             * @param {google.protobuf.Any} message Any
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Any.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.type_url = "";
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                }
                if (message.type_url != null && message.hasOwnProperty("type_url"))
                    object.type_url = message.type_url;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                return object;
            };

            /**
             * Converts this Any to JSON.
             * @function toJSON
             * @memberof google.protobuf.Any
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Any.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Any;
        })();

        protobuf.Empty = (function() {

            /**
             * Properties of an Empty.
             * @memberof google.protobuf
             * @interface IEmpty
             */

            /**
             * Constructs a new Empty.
             * @memberof google.protobuf
             * @classdesc Represents an Empty.
             * @implements IEmpty
             * @constructor
             * @param {google.protobuf.IEmpty=} [properties] Properties to set
             */
            function Empty(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new Empty instance using the specified properties.
             * @function create
             * @memberof google.protobuf.Empty
             * @static
             * @param {google.protobuf.IEmpty=} [properties] Properties to set
             * @returns {google.protobuf.Empty} Empty instance
             */
            Empty.create = function create(properties) {
                return new Empty(properties);
            };

            /**
             * Encodes the specified Empty message. Does not implicitly {@link google.protobuf.Empty.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.Empty
             * @static
             * @param {google.protobuf.IEmpty} message Empty message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Empty.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified Empty message, length delimited. Does not implicitly {@link google.protobuf.Empty.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.Empty
             * @static
             * @param {google.protobuf.IEmpty} message Empty message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Empty.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Empty message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.Empty
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.Empty} Empty
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Empty.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Empty();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Empty message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.Empty
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.Empty} Empty
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Empty.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Empty message.
             * @function verify
             * @memberof google.protobuf.Empty
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Empty.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates an Empty message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.Empty
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Empty} Empty
             */
            Empty.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Empty)
                    return object;
                return new $root.google.protobuf.Empty();
            };

            /**
             * Creates a plain object from an Empty message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.Empty
             * @static
             * @param {google.protobuf.Empty} message Empty
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Empty.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this Empty to JSON.
             * @function toJSON
             * @memberof google.protobuf.Empty
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Empty.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Empty;
        })();

        protobuf.FileDescriptorSet = (function() {

            /**
             * Properties of a FileDescriptorSet.
             * @memberof google.protobuf
             * @interface IFileDescriptorSet
             * @property {Array.<google.protobuf.IFileDescriptorProto>|null} [file] FileDescriptorSet file
             */

            /**
             * Constructs a new FileDescriptorSet.
             * @memberof google.protobuf
             * @classdesc Represents a FileDescriptorSet.
             * @implements IFileDescriptorSet
             * @constructor
             * @param {google.protobuf.IFileDescriptorSet=} [properties] Properties to set
             */
            function FileDescriptorSet(properties) {
                this.file = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FileDescriptorSet file.
             * @member {Array.<google.protobuf.IFileDescriptorProto>} file
             * @memberof google.protobuf.FileDescriptorSet
             * @instance
             */
            FileDescriptorSet.prototype.file = $util.emptyArray;

            /**
             * Creates a new FileDescriptorSet instance using the specified properties.
             * @function create
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {google.protobuf.IFileDescriptorSet=} [properties] Properties to set
             * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet instance
             */
            FileDescriptorSet.create = function create(properties) {
                return new FileDescriptorSet(properties);
            };

            /**
             * Encodes the specified FileDescriptorSet message. Does not implicitly {@link google.protobuf.FileDescriptorSet.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {google.protobuf.IFileDescriptorSet} message FileDescriptorSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileDescriptorSet.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.file != null && message.file.length)
                    for (var i = 0; i < message.file.length; ++i)
                        $root.google.protobuf.FileDescriptorProto.encode(message.file[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified FileDescriptorSet message, length delimited. Does not implicitly {@link google.protobuf.FileDescriptorSet.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {google.protobuf.IFileDescriptorSet} message FileDescriptorSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileDescriptorSet.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FileDescriptorSet message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileDescriptorSet.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileDescriptorSet();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.file && message.file.length))
                            message.file = [];
                        message.file.push($root.google.protobuf.FileDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FileDescriptorSet message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileDescriptorSet.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FileDescriptorSet message.
             * @function verify
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FileDescriptorSet.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.file != null && message.hasOwnProperty("file")) {
                    if (!Array.isArray(message.file))
                        return "file: array expected";
                    for (var i = 0; i < message.file.length; ++i) {
                        var error = $root.google.protobuf.FileDescriptorProto.verify(message.file[i]);
                        if (error)
                            return "file." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a FileDescriptorSet message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
             */
            FileDescriptorSet.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.FileDescriptorSet)
                    return object;
                var message = new $root.google.protobuf.FileDescriptorSet();
                if (object.file) {
                    if (!Array.isArray(object.file))
                        throw TypeError(".google.protobuf.FileDescriptorSet.file: array expected");
                    message.file = [];
                    for (var i = 0; i < object.file.length; ++i) {
                        if (typeof object.file[i] !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorSet.file: object expected");
                        message.file[i] = $root.google.protobuf.FileDescriptorProto.fromObject(object.file[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a FileDescriptorSet message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {google.protobuf.FileDescriptorSet} message FileDescriptorSet
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FileDescriptorSet.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.file = [];
                if (message.file && message.file.length) {
                    object.file = [];
                    for (var j = 0; j < message.file.length; ++j)
                        object.file[j] = $root.google.protobuf.FileDescriptorProto.toObject(message.file[j], options);
                }
                return object;
            };

            /**
             * Converts this FileDescriptorSet to JSON.
             * @function toJSON
             * @memberof google.protobuf.FileDescriptorSet
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FileDescriptorSet.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return FileDescriptorSet;
        })();

        protobuf.FileDescriptorProto = (function() {

            /**
             * Properties of a FileDescriptorProto.
             * @memberof google.protobuf
             * @interface IFileDescriptorProto
             * @property {string|null} [name] FileDescriptorProto name
             * @property {string|null} ["package"] FileDescriptorProto package
             * @property {Array.<string>|null} [dependency] FileDescriptorProto dependency
             * @property {Array.<number>|null} [publicDependency] FileDescriptorProto publicDependency
             * @property {Array.<number>|null} [weakDependency] FileDescriptorProto weakDependency
             * @property {Array.<google.protobuf.IDescriptorProto>|null} [messageType] FileDescriptorProto messageType
             * @property {Array.<google.protobuf.IEnumDescriptorProto>|null} [enumType] FileDescriptorProto enumType
             * @property {Array.<google.protobuf.IServiceDescriptorProto>|null} [service] FileDescriptorProto service
             * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [extension] FileDescriptorProto extension
             * @property {google.protobuf.IFileOptions|null} [options] FileDescriptorProto options
             * @property {google.protobuf.ISourceCodeInfo|null} [sourceCodeInfo] FileDescriptorProto sourceCodeInfo
             * @property {string|null} [syntax] FileDescriptorProto syntax
             */

            /**
             * Constructs a new FileDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents a FileDescriptorProto.
             * @implements IFileDescriptorProto
             * @constructor
             * @param {google.protobuf.IFileDescriptorProto=} [properties] Properties to set
             */
            function FileDescriptorProto(properties) {
                this.dependency = [];
                this.publicDependency = [];
                this.weakDependency = [];
                this.messageType = [];
                this.enumType = [];
                this.service = [];
                this.extension = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FileDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.name = "";

            /**
             * FileDescriptorProto package.
             * @member {string} package
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype["package"] = "";

            /**
             * FileDescriptorProto dependency.
             * @member {Array.<string>} dependency
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.dependency = $util.emptyArray;

            /**
             * FileDescriptorProto publicDependency.
             * @member {Array.<number>} publicDependency
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.publicDependency = $util.emptyArray;

            /**
             * FileDescriptorProto weakDependency.
             * @member {Array.<number>} weakDependency
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.weakDependency = $util.emptyArray;

            /**
             * FileDescriptorProto messageType.
             * @member {Array.<google.protobuf.IDescriptorProto>} messageType
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.messageType = $util.emptyArray;

            /**
             * FileDescriptorProto enumType.
             * @member {Array.<google.protobuf.IEnumDescriptorProto>} enumType
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.enumType = $util.emptyArray;

            /**
             * FileDescriptorProto service.
             * @member {Array.<google.protobuf.IServiceDescriptorProto>} service
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.service = $util.emptyArray;

            /**
             * FileDescriptorProto extension.
             * @member {Array.<google.protobuf.IFieldDescriptorProto>} extension
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.extension = $util.emptyArray;

            /**
             * FileDescriptorProto options.
             * @member {google.protobuf.IFileOptions|null|undefined} options
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.options = null;

            /**
             * FileDescriptorProto sourceCodeInfo.
             * @member {google.protobuf.ISourceCodeInfo|null|undefined} sourceCodeInfo
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.sourceCodeInfo = null;

            /**
             * FileDescriptorProto syntax.
             * @member {string} syntax
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.syntax = "";

            /**
             * Creates a new FileDescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {google.protobuf.IFileDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto instance
             */
            FileDescriptorProto.create = function create(properties) {
                return new FileDescriptorProto(properties);
            };

            /**
             * Encodes the specified FileDescriptorProto message. Does not implicitly {@link google.protobuf.FileDescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {google.protobuf.IFileDescriptorProto} message FileDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message["package"] != null && message.hasOwnProperty("package"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message["package"]);
                if (message.dependency != null && message.dependency.length)
                    for (var i = 0; i < message.dependency.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.dependency[i]);
                if (message.messageType != null && message.messageType.length)
                    for (var i = 0; i < message.messageType.length; ++i)
                        $root.google.protobuf.DescriptorProto.encode(message.messageType[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.enumType != null && message.enumType.length)
                    for (var i = 0; i < message.enumType.length; ++i)
                        $root.google.protobuf.EnumDescriptorProto.encode(message.enumType[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.service != null && message.service.length)
                    for (var i = 0; i < message.service.length; ++i)
                        $root.google.protobuf.ServiceDescriptorProto.encode(message.service[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.extension != null && message.extension.length)
                    for (var i = 0; i < message.extension.length; ++i)
                        $root.google.protobuf.FieldDescriptorProto.encode(message.extension[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.options != null && message.hasOwnProperty("options"))
                    $root.google.protobuf.FileOptions.encode(message.options, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.sourceCodeInfo != null && message.hasOwnProperty("sourceCodeInfo"))
                    $root.google.protobuf.SourceCodeInfo.encode(message.sourceCodeInfo, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                if (message.publicDependency != null && message.publicDependency.length)
                    for (var i = 0; i < message.publicDependency.length; ++i)
                        writer.uint32(/* id 10, wireType 0 =*/80).int32(message.publicDependency[i]);
                if (message.weakDependency != null && message.weakDependency.length)
                    for (var i = 0; i < message.weakDependency.length; ++i)
                        writer.uint32(/* id 11, wireType 0 =*/88).int32(message.weakDependency[i]);
                if (message.syntax != null && message.hasOwnProperty("syntax"))
                    writer.uint32(/* id 12, wireType 2 =*/98).string(message.syntax);
                return writer;
            };

            /**
             * Encodes the specified FileDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.FileDescriptorProto.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {google.protobuf.IFileDescriptorProto} message FileDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FileDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileDescriptorProto();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message["package"] = reader.string();
                        break;
                    case 3:
                        if (!(message.dependency && message.dependency.length))
                            message.dependency = [];
                        message.dependency.push(reader.string());
                        break;
                    case 10:
                        if (!(message.publicDependency && message.publicDependency.length))
                            message.publicDependency = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.publicDependency.push(reader.int32());
                        } else
                            message.publicDependency.push(reader.int32());
                        break;
                    case 11:
                        if (!(message.weakDependency && message.weakDependency.length))
                            message.weakDependency = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.weakDependency.push(reader.int32());
                        } else
                            message.weakDependency.push(reader.int32());
                        break;
                    case 4:
                        if (!(message.messageType && message.messageType.length))
                            message.messageType = [];
                        message.messageType.push($root.google.protobuf.DescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        if (!(message.enumType && message.enumType.length))
                            message.enumType = [];
                        message.enumType.push($root.google.protobuf.EnumDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        if (!(message.service && message.service.length))
                            message.service = [];
                        message.service.push($root.google.protobuf.ServiceDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 7:
                        if (!(message.extension && message.extension.length))
                            message.extension = [];
                        message.extension.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 8:
                        message.options = $root.google.protobuf.FileOptions.decode(reader, reader.uint32());
                        break;
                    case 9:
                        message.sourceCodeInfo = $root.google.protobuf.SourceCodeInfo.decode(reader, reader.uint32());
                        break;
                    case 12:
                        message.syntax = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FileDescriptorProto message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FileDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FileDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message["package"] != null && message.hasOwnProperty("package"))
                    if (!$util.isString(message["package"]))
                        return "package: string expected";
                if (message.dependency != null && message.hasOwnProperty("dependency")) {
                    if (!Array.isArray(message.dependency))
                        return "dependency: array expected";
                    for (var i = 0; i < message.dependency.length; ++i)
                        if (!$util.isString(message.dependency[i]))
                            return "dependency: string[] expected";
                }
                if (message.publicDependency != null && message.hasOwnProperty("publicDependency")) {
                    if (!Array.isArray(message.publicDependency))
                        return "publicDependency: array expected";
                    for (var i = 0; i < message.publicDependency.length; ++i)
                        if (!$util.isInteger(message.publicDependency[i]))
                            return "publicDependency: integer[] expected";
                }
                if (message.weakDependency != null && message.hasOwnProperty("weakDependency")) {
                    if (!Array.isArray(message.weakDependency))
                        return "weakDependency: array expected";
                    for (var i = 0; i < message.weakDependency.length; ++i)
                        if (!$util.isInteger(message.weakDependency[i]))
                            return "weakDependency: integer[] expected";
                }
                if (message.messageType != null && message.hasOwnProperty("messageType")) {
                    if (!Array.isArray(message.messageType))
                        return "messageType: array expected";
                    for (var i = 0; i < message.messageType.length; ++i) {
                        var error = $root.google.protobuf.DescriptorProto.verify(message.messageType[i]);
                        if (error)
                            return "messageType." + error;
                    }
                }
                if (message.enumType != null && message.hasOwnProperty("enumType")) {
                    if (!Array.isArray(message.enumType))
                        return "enumType: array expected";
                    for (var i = 0; i < message.enumType.length; ++i) {
                        var error = $root.google.protobuf.EnumDescriptorProto.verify(message.enumType[i]);
                        if (error)
                            return "enumType." + error;
                    }
                }
                if (message.service != null && message.hasOwnProperty("service")) {
                    if (!Array.isArray(message.service))
                        return "service: array expected";
                    for (var i = 0; i < message.service.length; ++i) {
                        var error = $root.google.protobuf.ServiceDescriptorProto.verify(message.service[i]);
                        if (error)
                            return "service." + error;
                    }
                }
                if (message.extension != null && message.hasOwnProperty("extension")) {
                    if (!Array.isArray(message.extension))
                        return "extension: array expected";
                    for (var i = 0; i < message.extension.length; ++i) {
                        var error = $root.google.protobuf.FieldDescriptorProto.verify(message.extension[i]);
                        if (error)
                            return "extension." + error;
                    }
                }
                if (message.options != null && message.hasOwnProperty("options")) {
                    var error = $root.google.protobuf.FileOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                if (message.sourceCodeInfo != null && message.hasOwnProperty("sourceCodeInfo")) {
                    var error = $root.google.protobuf.SourceCodeInfo.verify(message.sourceCodeInfo);
                    if (error)
                        return "sourceCodeInfo." + error;
                }
                if (message.syntax != null && message.hasOwnProperty("syntax"))
                    if (!$util.isString(message.syntax))
                        return "syntax: string expected";
                return null;
            };

            /**
             * Creates a FileDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
             */
            FileDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.FileDescriptorProto)
                    return object;
                var message = new $root.google.protobuf.FileDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object["package"] != null)
                    message["package"] = String(object["package"]);
                if (object.dependency) {
                    if (!Array.isArray(object.dependency))
                        throw TypeError(".google.protobuf.FileDescriptorProto.dependency: array expected");
                    message.dependency = [];
                    for (var i = 0; i < object.dependency.length; ++i)
                        message.dependency[i] = String(object.dependency[i]);
                }
                if (object.publicDependency) {
                    if (!Array.isArray(object.publicDependency))
                        throw TypeError(".google.protobuf.FileDescriptorProto.publicDependency: array expected");
                    message.publicDependency = [];
                    for (var i = 0; i < object.publicDependency.length; ++i)
                        message.publicDependency[i] = object.publicDependency[i] | 0;
                }
                if (object.weakDependency) {
                    if (!Array.isArray(object.weakDependency))
                        throw TypeError(".google.protobuf.FileDescriptorProto.weakDependency: array expected");
                    message.weakDependency = [];
                    for (var i = 0; i < object.weakDependency.length; ++i)
                        message.weakDependency[i] = object.weakDependency[i] | 0;
                }
                if (object.messageType) {
                    if (!Array.isArray(object.messageType))
                        throw TypeError(".google.protobuf.FileDescriptorProto.messageType: array expected");
                    message.messageType = [];
                    for (var i = 0; i < object.messageType.length; ++i) {
                        if (typeof object.messageType[i] !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorProto.messageType: object expected");
                        message.messageType[i] = $root.google.protobuf.DescriptorProto.fromObject(object.messageType[i]);
                    }
                }
                if (object.enumType) {
                    if (!Array.isArray(object.enumType))
                        throw TypeError(".google.protobuf.FileDescriptorProto.enumType: array expected");
                    message.enumType = [];
                    for (var i = 0; i < object.enumType.length; ++i) {
                        if (typeof object.enumType[i] !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorProto.enumType: object expected");
                        message.enumType[i] = $root.google.protobuf.EnumDescriptorProto.fromObject(object.enumType[i]);
                    }
                }
                if (object.service) {
                    if (!Array.isArray(object.service))
                        throw TypeError(".google.protobuf.FileDescriptorProto.service: array expected");
                    message.service = [];
                    for (var i = 0; i < object.service.length; ++i) {
                        if (typeof object.service[i] !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorProto.service: object expected");
                        message.service[i] = $root.google.protobuf.ServiceDescriptorProto.fromObject(object.service[i]);
                    }
                }
                if (object.extension) {
                    if (!Array.isArray(object.extension))
                        throw TypeError(".google.protobuf.FileDescriptorProto.extension: array expected");
                    message.extension = [];
                    for (var i = 0; i < object.extension.length; ++i) {
                        if (typeof object.extension[i] !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorProto.extension: object expected");
                        message.extension[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.extension[i]);
                    }
                }
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.FileDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.FileOptions.fromObject(object.options);
                }
                if (object.sourceCodeInfo != null) {
                    if (typeof object.sourceCodeInfo !== "object")
                        throw TypeError(".google.protobuf.FileDescriptorProto.sourceCodeInfo: object expected");
                    message.sourceCodeInfo = $root.google.protobuf.SourceCodeInfo.fromObject(object.sourceCodeInfo);
                }
                if (object.syntax != null)
                    message.syntax = String(object.syntax);
                return message;
            };

            /**
             * Creates a plain object from a FileDescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {google.protobuf.FileDescriptorProto} message FileDescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FileDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.dependency = [];
                    object.messageType = [];
                    object.enumType = [];
                    object.service = [];
                    object.extension = [];
                    object.publicDependency = [];
                    object.weakDependency = [];
                }
                if (options.defaults) {
                    object.name = "";
                    object["package"] = "";
                    object.options = null;
                    object.sourceCodeInfo = null;
                    object.syntax = "";
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message["package"] != null && message.hasOwnProperty("package"))
                    object["package"] = message["package"];
                if (message.dependency && message.dependency.length) {
                    object.dependency = [];
                    for (var j = 0; j < message.dependency.length; ++j)
                        object.dependency[j] = message.dependency[j];
                }
                if (message.messageType && message.messageType.length) {
                    object.messageType = [];
                    for (var j = 0; j < message.messageType.length; ++j)
                        object.messageType[j] = $root.google.protobuf.DescriptorProto.toObject(message.messageType[j], options);
                }
                if (message.enumType && message.enumType.length) {
                    object.enumType = [];
                    for (var j = 0; j < message.enumType.length; ++j)
                        object.enumType[j] = $root.google.protobuf.EnumDescriptorProto.toObject(message.enumType[j], options);
                }
                if (message.service && message.service.length) {
                    object.service = [];
                    for (var j = 0; j < message.service.length; ++j)
                        object.service[j] = $root.google.protobuf.ServiceDescriptorProto.toObject(message.service[j], options);
                }
                if (message.extension && message.extension.length) {
                    object.extension = [];
                    for (var j = 0; j < message.extension.length; ++j)
                        object.extension[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.extension[j], options);
                }
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.FileOptions.toObject(message.options, options);
                if (message.sourceCodeInfo != null && message.hasOwnProperty("sourceCodeInfo"))
                    object.sourceCodeInfo = $root.google.protobuf.SourceCodeInfo.toObject(message.sourceCodeInfo, options);
                if (message.publicDependency && message.publicDependency.length) {
                    object.publicDependency = [];
                    for (var j = 0; j < message.publicDependency.length; ++j)
                        object.publicDependency[j] = message.publicDependency[j];
                }
                if (message.weakDependency && message.weakDependency.length) {
                    object.weakDependency = [];
                    for (var j = 0; j < message.weakDependency.length; ++j)
                        object.weakDependency[j] = message.weakDependency[j];
                }
                if (message.syntax != null && message.hasOwnProperty("syntax"))
                    object.syntax = message.syntax;
                return object;
            };

            /**
             * Converts this FileDescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FileDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return FileDescriptorProto;
        })();

        protobuf.DescriptorProto = (function() {

            /**
             * Properties of a DescriptorProto.
             * @memberof google.protobuf
             * @interface IDescriptorProto
             * @property {string|null} [name] DescriptorProto name
             * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [field] DescriptorProto field
             * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [extension] DescriptorProto extension
             * @property {Array.<google.protobuf.IDescriptorProto>|null} [nestedType] DescriptorProto nestedType
             * @property {Array.<google.protobuf.IEnumDescriptorProto>|null} [enumType] DescriptorProto enumType
             * @property {Array.<google.protobuf.DescriptorProto.IExtensionRange>|null} [extensionRange] DescriptorProto extensionRange
             * @property {Array.<google.protobuf.IOneofDescriptorProto>|null} [oneofDecl] DescriptorProto oneofDecl
             * @property {google.protobuf.IMessageOptions|null} [options] DescriptorProto options
             * @property {Array.<google.protobuf.DescriptorProto.IReservedRange>|null} [reservedRange] DescriptorProto reservedRange
             * @property {Array.<string>|null} [reservedName] DescriptorProto reservedName
             */

            /**
             * Constructs a new DescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents a DescriptorProto.
             * @implements IDescriptorProto
             * @constructor
             * @param {google.protobuf.IDescriptorProto=} [properties] Properties to set
             */
            function DescriptorProto(properties) {
                this.field = [];
                this.extension = [];
                this.nestedType = [];
                this.enumType = [];
                this.extensionRange = [];
                this.oneofDecl = [];
                this.reservedRange = [];
                this.reservedName = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.name = "";

            /**
             * DescriptorProto field.
             * @member {Array.<google.protobuf.IFieldDescriptorProto>} field
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.field = $util.emptyArray;

            /**
             * DescriptorProto extension.
             * @member {Array.<google.protobuf.IFieldDescriptorProto>} extension
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.extension = $util.emptyArray;

            /**
             * DescriptorProto nestedType.
             * @member {Array.<google.protobuf.IDescriptorProto>} nestedType
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.nestedType = $util.emptyArray;

            /**
             * DescriptorProto enumType.
             * @member {Array.<google.protobuf.IEnumDescriptorProto>} enumType
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.enumType = $util.emptyArray;

            /**
             * DescriptorProto extensionRange.
             * @member {Array.<google.protobuf.DescriptorProto.IExtensionRange>} extensionRange
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.extensionRange = $util.emptyArray;

            /**
             * DescriptorProto oneofDecl.
             * @member {Array.<google.protobuf.IOneofDescriptorProto>} oneofDecl
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.oneofDecl = $util.emptyArray;

            /**
             * DescriptorProto options.
             * @member {google.protobuf.IMessageOptions|null|undefined} options
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.options = null;

            /**
             * DescriptorProto reservedRange.
             * @member {Array.<google.protobuf.DescriptorProto.IReservedRange>} reservedRange
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.reservedRange = $util.emptyArray;

            /**
             * DescriptorProto reservedName.
             * @member {Array.<string>} reservedName
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.reservedName = $util.emptyArray;

            /**
             * Creates a new DescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {google.protobuf.IDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.DescriptorProto} DescriptorProto instance
             */
            DescriptorProto.create = function create(properties) {
                return new DescriptorProto(properties);
            };

            /**
             * Encodes the specified DescriptorProto message. Does not implicitly {@link google.protobuf.DescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {google.protobuf.IDescriptorProto} message DescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.field != null && message.field.length)
                    for (var i = 0; i < message.field.length; ++i)
                        $root.google.protobuf.FieldDescriptorProto.encode(message.field[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.nestedType != null && message.nestedType.length)
                    for (var i = 0; i < message.nestedType.length; ++i)
                        $root.google.protobuf.DescriptorProto.encode(message.nestedType[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.enumType != null && message.enumType.length)
                    for (var i = 0; i < message.enumType.length; ++i)
                        $root.google.protobuf.EnumDescriptorProto.encode(message.enumType[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.extensionRange != null && message.extensionRange.length)
                    for (var i = 0; i < message.extensionRange.length; ++i)
                        $root.google.protobuf.DescriptorProto.ExtensionRange.encode(message.extensionRange[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.extension != null && message.extension.length)
                    for (var i = 0; i < message.extension.length; ++i)
                        $root.google.protobuf.FieldDescriptorProto.encode(message.extension[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.options != null && message.hasOwnProperty("options"))
                    $root.google.protobuf.MessageOptions.encode(message.options, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.oneofDecl != null && message.oneofDecl.length)
                    for (var i = 0; i < message.oneofDecl.length; ++i)
                        $root.google.protobuf.OneofDescriptorProto.encode(message.oneofDecl[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.reservedRange != null && message.reservedRange.length)
                    for (var i = 0; i < message.reservedRange.length; ++i)
                        $root.google.protobuf.DescriptorProto.ReservedRange.encode(message.reservedRange[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                if (message.reservedName != null && message.reservedName.length)
                    for (var i = 0; i < message.reservedName.length; ++i)
                        writer.uint32(/* id 10, wireType 2 =*/82).string(message.reservedName[i]);
                return writer;
            };

            /**
             * Encodes the specified DescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.DescriptorProto.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {google.protobuf.IDescriptorProto} message DescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.DescriptorProto} DescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        if (!(message.field && message.field.length))
                            message.field = [];
                        message.field.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        if (!(message.extension && message.extension.length))
                            message.extension = [];
                        message.extension.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        if (!(message.nestedType && message.nestedType.length))
                            message.nestedType = [];
                        message.nestedType.push($root.google.protobuf.DescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 4:
                        if (!(message.enumType && message.enumType.length))
                            message.enumType = [];
                        message.enumType.push($root.google.protobuf.EnumDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        if (!(message.extensionRange && message.extensionRange.length))
                            message.extensionRange = [];
                        message.extensionRange.push($root.google.protobuf.DescriptorProto.ExtensionRange.decode(reader, reader.uint32()));
                        break;
                    case 8:
                        if (!(message.oneofDecl && message.oneofDecl.length))
                            message.oneofDecl = [];
                        message.oneofDecl.push($root.google.protobuf.OneofDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 7:
                        message.options = $root.google.protobuf.MessageOptions.decode(reader, reader.uint32());
                        break;
                    case 9:
                        if (!(message.reservedRange && message.reservedRange.length))
                            message.reservedRange = [];
                        message.reservedRange.push($root.google.protobuf.DescriptorProto.ReservedRange.decode(reader, reader.uint32()));
                        break;
                    case 10:
                        if (!(message.reservedName && message.reservedName.length))
                            message.reservedName = [];
                        message.reservedName.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DescriptorProto message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.DescriptorProto} DescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DescriptorProto message.
             * @function verify
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.field != null && message.hasOwnProperty("field")) {
                    if (!Array.isArray(message.field))
                        return "field: array expected";
                    for (var i = 0; i < message.field.length; ++i) {
                        var error = $root.google.protobuf.FieldDescriptorProto.verify(message.field[i]);
                        if (error)
                            return "field." + error;
                    }
                }
                if (message.extension != null && message.hasOwnProperty("extension")) {
                    if (!Array.isArray(message.extension))
                        return "extension: array expected";
                    for (var i = 0; i < message.extension.length; ++i) {
                        var error = $root.google.protobuf.FieldDescriptorProto.verify(message.extension[i]);
                        if (error)
                            return "extension." + error;
                    }
                }
                if (message.nestedType != null && message.hasOwnProperty("nestedType")) {
                    if (!Array.isArray(message.nestedType))
                        return "nestedType: array expected";
                    for (var i = 0; i < message.nestedType.length; ++i) {
                        var error = $root.google.protobuf.DescriptorProto.verify(message.nestedType[i]);
                        if (error)
                            return "nestedType." + error;
                    }
                }
                if (message.enumType != null && message.hasOwnProperty("enumType")) {
                    if (!Array.isArray(message.enumType))
                        return "enumType: array expected";
                    for (var i = 0; i < message.enumType.length; ++i) {
                        var error = $root.google.protobuf.EnumDescriptorProto.verify(message.enumType[i]);
                        if (error)
                            return "enumType." + error;
                    }
                }
                if (message.extensionRange != null && message.hasOwnProperty("extensionRange")) {
                    if (!Array.isArray(message.extensionRange))
                        return "extensionRange: array expected";
                    for (var i = 0; i < message.extensionRange.length; ++i) {
                        var error = $root.google.protobuf.DescriptorProto.ExtensionRange.verify(message.extensionRange[i]);
                        if (error)
                            return "extensionRange." + error;
                    }
                }
                if (message.oneofDecl != null && message.hasOwnProperty("oneofDecl")) {
                    if (!Array.isArray(message.oneofDecl))
                        return "oneofDecl: array expected";
                    for (var i = 0; i < message.oneofDecl.length; ++i) {
                        var error = $root.google.protobuf.OneofDescriptorProto.verify(message.oneofDecl[i]);
                        if (error)
                            return "oneofDecl." + error;
                    }
                }
                if (message.options != null && message.hasOwnProperty("options")) {
                    var error = $root.google.protobuf.MessageOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                if (message.reservedRange != null && message.hasOwnProperty("reservedRange")) {
                    if (!Array.isArray(message.reservedRange))
                        return "reservedRange: array expected";
                    for (var i = 0; i < message.reservedRange.length; ++i) {
                        var error = $root.google.protobuf.DescriptorProto.ReservedRange.verify(message.reservedRange[i]);
                        if (error)
                            return "reservedRange." + error;
                    }
                }
                if (message.reservedName != null && message.hasOwnProperty("reservedName")) {
                    if (!Array.isArray(message.reservedName))
                        return "reservedName: array expected";
                    for (var i = 0; i < message.reservedName.length; ++i)
                        if (!$util.isString(message.reservedName[i]))
                            return "reservedName: string[] expected";
                }
                return null;
            };

            /**
             * Creates a DescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.DescriptorProto} DescriptorProto
             */
            DescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.DescriptorProto)
                    return object;
                var message = new $root.google.protobuf.DescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.field) {
                    if (!Array.isArray(object.field))
                        throw TypeError(".google.protobuf.DescriptorProto.field: array expected");
                    message.field = [];
                    for (var i = 0; i < object.field.length; ++i) {
                        if (typeof object.field[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.field: object expected");
                        message.field[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.field[i]);
                    }
                }
                if (object.extension) {
                    if (!Array.isArray(object.extension))
                        throw TypeError(".google.protobuf.DescriptorProto.extension: array expected");
                    message.extension = [];
                    for (var i = 0; i < object.extension.length; ++i) {
                        if (typeof object.extension[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.extension: object expected");
                        message.extension[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.extension[i]);
                    }
                }
                if (object.nestedType) {
                    if (!Array.isArray(object.nestedType))
                        throw TypeError(".google.protobuf.DescriptorProto.nestedType: array expected");
                    message.nestedType = [];
                    for (var i = 0; i < object.nestedType.length; ++i) {
                        if (typeof object.nestedType[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.nestedType: object expected");
                        message.nestedType[i] = $root.google.protobuf.DescriptorProto.fromObject(object.nestedType[i]);
                    }
                }
                if (object.enumType) {
                    if (!Array.isArray(object.enumType))
                        throw TypeError(".google.protobuf.DescriptorProto.enumType: array expected");
                    message.enumType = [];
                    for (var i = 0; i < object.enumType.length; ++i) {
                        if (typeof object.enumType[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.enumType: object expected");
                        message.enumType[i] = $root.google.protobuf.EnumDescriptorProto.fromObject(object.enumType[i]);
                    }
                }
                if (object.extensionRange) {
                    if (!Array.isArray(object.extensionRange))
                        throw TypeError(".google.protobuf.DescriptorProto.extensionRange: array expected");
                    message.extensionRange = [];
                    for (var i = 0; i < object.extensionRange.length; ++i) {
                        if (typeof object.extensionRange[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.extensionRange: object expected");
                        message.extensionRange[i] = $root.google.protobuf.DescriptorProto.ExtensionRange.fromObject(object.extensionRange[i]);
                    }
                }
                if (object.oneofDecl) {
                    if (!Array.isArray(object.oneofDecl))
                        throw TypeError(".google.protobuf.DescriptorProto.oneofDecl: array expected");
                    message.oneofDecl = [];
                    for (var i = 0; i < object.oneofDecl.length; ++i) {
                        if (typeof object.oneofDecl[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.oneofDecl: object expected");
                        message.oneofDecl[i] = $root.google.protobuf.OneofDescriptorProto.fromObject(object.oneofDecl[i]);
                    }
                }
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.DescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.MessageOptions.fromObject(object.options);
                }
                if (object.reservedRange) {
                    if (!Array.isArray(object.reservedRange))
                        throw TypeError(".google.protobuf.DescriptorProto.reservedRange: array expected");
                    message.reservedRange = [];
                    for (var i = 0; i < object.reservedRange.length; ++i) {
                        if (typeof object.reservedRange[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.reservedRange: object expected");
                        message.reservedRange[i] = $root.google.protobuf.DescriptorProto.ReservedRange.fromObject(object.reservedRange[i]);
                    }
                }
                if (object.reservedName) {
                    if (!Array.isArray(object.reservedName))
                        throw TypeError(".google.protobuf.DescriptorProto.reservedName: array expected");
                    message.reservedName = [];
                    for (var i = 0; i < object.reservedName.length; ++i)
                        message.reservedName[i] = String(object.reservedName[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a DescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {google.protobuf.DescriptorProto} message DescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.field = [];
                    object.nestedType = [];
                    object.enumType = [];
                    object.extensionRange = [];
                    object.extension = [];
                    object.oneofDecl = [];
                    object.reservedRange = [];
                    object.reservedName = [];
                }
                if (options.defaults) {
                    object.name = "";
                    object.options = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.field && message.field.length) {
                    object.field = [];
                    for (var j = 0; j < message.field.length; ++j)
                        object.field[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.field[j], options);
                }
                if (message.nestedType && message.nestedType.length) {
                    object.nestedType = [];
                    for (var j = 0; j < message.nestedType.length; ++j)
                        object.nestedType[j] = $root.google.protobuf.DescriptorProto.toObject(message.nestedType[j], options);
                }
                if (message.enumType && message.enumType.length) {
                    object.enumType = [];
                    for (var j = 0; j < message.enumType.length; ++j)
                        object.enumType[j] = $root.google.protobuf.EnumDescriptorProto.toObject(message.enumType[j], options);
                }
                if (message.extensionRange && message.extensionRange.length) {
                    object.extensionRange = [];
                    for (var j = 0; j < message.extensionRange.length; ++j)
                        object.extensionRange[j] = $root.google.protobuf.DescriptorProto.ExtensionRange.toObject(message.extensionRange[j], options);
                }
                if (message.extension && message.extension.length) {
                    object.extension = [];
                    for (var j = 0; j < message.extension.length; ++j)
                        object.extension[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.extension[j], options);
                }
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.MessageOptions.toObject(message.options, options);
                if (message.oneofDecl && message.oneofDecl.length) {
                    object.oneofDecl = [];
                    for (var j = 0; j < message.oneofDecl.length; ++j)
                        object.oneofDecl[j] = $root.google.protobuf.OneofDescriptorProto.toObject(message.oneofDecl[j], options);
                }
                if (message.reservedRange && message.reservedRange.length) {
                    object.reservedRange = [];
                    for (var j = 0; j < message.reservedRange.length; ++j)
                        object.reservedRange[j] = $root.google.protobuf.DescriptorProto.ReservedRange.toObject(message.reservedRange[j], options);
                }
                if (message.reservedName && message.reservedName.length) {
                    object.reservedName = [];
                    for (var j = 0; j < message.reservedName.length; ++j)
                        object.reservedName[j] = message.reservedName[j];
                }
                return object;
            };

            /**
             * Converts this DescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.DescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            DescriptorProto.ExtensionRange = (function() {

                /**
                 * Properties of an ExtensionRange.
                 * @memberof google.protobuf.DescriptorProto
                 * @interface IExtensionRange
                 * @property {number|null} [start] ExtensionRange start
                 * @property {number|null} [end] ExtensionRange end
                 */

                /**
                 * Constructs a new ExtensionRange.
                 * @memberof google.protobuf.DescriptorProto
                 * @classdesc Represents an ExtensionRange.
                 * @implements IExtensionRange
                 * @constructor
                 * @param {google.protobuf.DescriptorProto.IExtensionRange=} [properties] Properties to set
                 */
                function ExtensionRange(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ExtensionRange start.
                 * @member {number} start
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @instance
                 */
                ExtensionRange.prototype.start = 0;

                /**
                 * ExtensionRange end.
                 * @member {number} end
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @instance
                 */
                ExtensionRange.prototype.end = 0;

                /**
                 * Creates a new ExtensionRange instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.IExtensionRange=} [properties] Properties to set
                 * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange instance
                 */
                ExtensionRange.create = function create(properties) {
                    return new ExtensionRange(properties);
                };

                /**
                 * Encodes the specified ExtensionRange message. Does not implicitly {@link google.protobuf.DescriptorProto.ExtensionRange.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.IExtensionRange} message ExtensionRange message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ExtensionRange.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.start != null && message.hasOwnProperty("start"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.start);
                    if (message.end != null && message.hasOwnProperty("end"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.end);
                    return writer;
                };

                /**
                 * Encodes the specified ExtensionRange message, length delimited. Does not implicitly {@link google.protobuf.DescriptorProto.ExtensionRange.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.IExtensionRange} message ExtensionRange message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ExtensionRange.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an ExtensionRange message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ExtensionRange.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto.ExtensionRange();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.start = reader.int32();
                            break;
                        case 2:
                            message.end = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an ExtensionRange message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ExtensionRange.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an ExtensionRange message.
                 * @function verify
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ExtensionRange.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.start != null && message.hasOwnProperty("start"))
                        if (!$util.isInteger(message.start))
                            return "start: integer expected";
                    if (message.end != null && message.hasOwnProperty("end"))
                        if (!$util.isInteger(message.end))
                            return "end: integer expected";
                    return null;
                };

                /**
                 * Creates an ExtensionRange message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
                 */
                ExtensionRange.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.DescriptorProto.ExtensionRange)
                        return object;
                    var message = new $root.google.protobuf.DescriptorProto.ExtensionRange();
                    if (object.start != null)
                        message.start = object.start | 0;
                    if (object.end != null)
                        message.end = object.end | 0;
                    return message;
                };

                /**
                 * Creates a plain object from an ExtensionRange message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.ExtensionRange} message ExtensionRange
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ExtensionRange.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.start = 0;
                        object.end = 0;
                    }
                    if (message.start != null && message.hasOwnProperty("start"))
                        object.start = message.start;
                    if (message.end != null && message.hasOwnProperty("end"))
                        object.end = message.end;
                    return object;
                };

                /**
                 * Converts this ExtensionRange to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ExtensionRange.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ExtensionRange;
            })();

            DescriptorProto.ReservedRange = (function() {

                /**
                 * Properties of a ReservedRange.
                 * @memberof google.protobuf.DescriptorProto
                 * @interface IReservedRange
                 * @property {number|null} [start] ReservedRange start
                 * @property {number|null} [end] ReservedRange end
                 */

                /**
                 * Constructs a new ReservedRange.
                 * @memberof google.protobuf.DescriptorProto
                 * @classdesc Represents a ReservedRange.
                 * @implements IReservedRange
                 * @constructor
                 * @param {google.protobuf.DescriptorProto.IReservedRange=} [properties] Properties to set
                 */
                function ReservedRange(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ReservedRange start.
                 * @member {number} start
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @instance
                 */
                ReservedRange.prototype.start = 0;

                /**
                 * ReservedRange end.
                 * @member {number} end
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @instance
                 */
                ReservedRange.prototype.end = 0;

                /**
                 * Creates a new ReservedRange instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.IReservedRange=} [properties] Properties to set
                 * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange instance
                 */
                ReservedRange.create = function create(properties) {
                    return new ReservedRange(properties);
                };

                /**
                 * Encodes the specified ReservedRange message. Does not implicitly {@link google.protobuf.DescriptorProto.ReservedRange.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.IReservedRange} message ReservedRange message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ReservedRange.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.start != null && message.hasOwnProperty("start"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.start);
                    if (message.end != null && message.hasOwnProperty("end"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.end);
                    return writer;
                };

                /**
                 * Encodes the specified ReservedRange message, length delimited. Does not implicitly {@link google.protobuf.DescriptorProto.ReservedRange.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.IReservedRange} message ReservedRange message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ReservedRange.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ReservedRange message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ReservedRange.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto.ReservedRange();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.start = reader.int32();
                            break;
                        case 2:
                            message.end = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ReservedRange message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ReservedRange.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ReservedRange message.
                 * @function verify
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ReservedRange.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.start != null && message.hasOwnProperty("start"))
                        if (!$util.isInteger(message.start))
                            return "start: integer expected";
                    if (message.end != null && message.hasOwnProperty("end"))
                        if (!$util.isInteger(message.end))
                            return "end: integer expected";
                    return null;
                };

                /**
                 * Creates a ReservedRange message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange
                 */
                ReservedRange.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.DescriptorProto.ReservedRange)
                        return object;
                    var message = new $root.google.protobuf.DescriptorProto.ReservedRange();
                    if (object.start != null)
                        message.start = object.start | 0;
                    if (object.end != null)
                        message.end = object.end | 0;
                    return message;
                };

                /**
                 * Creates a plain object from a ReservedRange message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.ReservedRange} message ReservedRange
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ReservedRange.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.start = 0;
                        object.end = 0;
                    }
                    if (message.start != null && message.hasOwnProperty("start"))
                        object.start = message.start;
                    if (message.end != null && message.hasOwnProperty("end"))
                        object.end = message.end;
                    return object;
                };

                /**
                 * Converts this ReservedRange to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ReservedRange.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ReservedRange;
            })();

            return DescriptorProto;
        })();

        protobuf.FieldDescriptorProto = (function() {

            /**
             * Properties of a FieldDescriptorProto.
             * @memberof google.protobuf
             * @interface IFieldDescriptorProto
             * @property {string|null} [name] FieldDescriptorProto name
             * @property {number|null} [number] FieldDescriptorProto number
             * @property {google.protobuf.FieldDescriptorProto.Label|null} [label] FieldDescriptorProto label
             * @property {google.protobuf.FieldDescriptorProto.Type|null} [type] FieldDescriptorProto type
             * @property {string|null} [typeName] FieldDescriptorProto typeName
             * @property {string|null} [extendee] FieldDescriptorProto extendee
             * @property {string|null} [defaultValue] FieldDescriptorProto defaultValue
             * @property {number|null} [oneofIndex] FieldDescriptorProto oneofIndex
             * @property {string|null} [jsonName] FieldDescriptorProto jsonName
             * @property {google.protobuf.IFieldOptions|null} [options] FieldDescriptorProto options
             */

            /**
             * Constructs a new FieldDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents a FieldDescriptorProto.
             * @implements IFieldDescriptorProto
             * @constructor
             * @param {google.protobuf.IFieldDescriptorProto=} [properties] Properties to set
             */
            function FieldDescriptorProto(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FieldDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.name = "";

            /**
             * FieldDescriptorProto number.
             * @member {number} number
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.number = 0;

            /**
             * FieldDescriptorProto label.
             * @member {google.protobuf.FieldDescriptorProto.Label} label
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.label = 1;

            /**
             * FieldDescriptorProto type.
             * @member {google.protobuf.FieldDescriptorProto.Type} type
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.type = 1;

            /**
             * FieldDescriptorProto typeName.
             * @member {string} typeName
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.typeName = "";

            /**
             * FieldDescriptorProto extendee.
             * @member {string} extendee
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.extendee = "";

            /**
             * FieldDescriptorProto defaultValue.
             * @member {string} defaultValue
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.defaultValue = "";

            /**
             * FieldDescriptorProto oneofIndex.
             * @member {number} oneofIndex
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.oneofIndex = 0;

            /**
             * FieldDescriptorProto jsonName.
             * @member {string} jsonName
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.jsonName = "";

            /**
             * FieldDescriptorProto options.
             * @member {google.protobuf.IFieldOptions|null|undefined} options
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.options = null;

            /**
             * Creates a new FieldDescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {google.protobuf.IFieldDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto instance
             */
            FieldDescriptorProto.create = function create(properties) {
                return new FieldDescriptorProto(properties);
            };

            /**
             * Encodes the specified FieldDescriptorProto message. Does not implicitly {@link google.protobuf.FieldDescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {google.protobuf.IFieldDescriptorProto} message FieldDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FieldDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.extendee != null && message.hasOwnProperty("extendee"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.extendee);
                if (message.number != null && message.hasOwnProperty("number"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.number);
                if (message.label != null && message.hasOwnProperty("label"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.label);
                if (message.type != null && message.hasOwnProperty("type"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.type);
                if (message.typeName != null && message.hasOwnProperty("typeName"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.typeName);
                if (message.defaultValue != null && message.hasOwnProperty("defaultValue"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.defaultValue);
                if (message.options != null && message.hasOwnProperty("options"))
                    $root.google.protobuf.FieldOptions.encode(message.options, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.oneofIndex != null && message.hasOwnProperty("oneofIndex"))
                    writer.uint32(/* id 9, wireType 0 =*/72).int32(message.oneofIndex);
                if (message.jsonName != null && message.hasOwnProperty("jsonName"))
                    writer.uint32(/* id 10, wireType 2 =*/82).string(message.jsonName);
                return writer;
            };

            /**
             * Encodes the specified FieldDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.FieldDescriptorProto.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {google.protobuf.IFieldDescriptorProto} message FieldDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FieldDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FieldDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FieldDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FieldDescriptorProto();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 3:
                        message.number = reader.int32();
                        break;
                    case 4:
                        message.label = reader.int32();
                        break;
                    case 5:
                        message.type = reader.int32();
                        break;
                    case 6:
                        message.typeName = reader.string();
                        break;
                    case 2:
                        message.extendee = reader.string();
                        break;
                    case 7:
                        message.defaultValue = reader.string();
                        break;
                    case 9:
                        message.oneofIndex = reader.int32();
                        break;
                    case 10:
                        message.jsonName = reader.string();
                        break;
                    case 8:
                        message.options = $root.google.protobuf.FieldOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FieldDescriptorProto message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FieldDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FieldDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FieldDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.number != null && message.hasOwnProperty("number"))
                    if (!$util.isInteger(message.number))
                        return "number: integer expected";
                if (message.label != null && message.hasOwnProperty("label"))
                    switch (message.label) {
                    default:
                        return "label: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                    case 13:
                    case 14:
                    case 15:
                    case 16:
                    case 17:
                    case 18:
                        break;
                    }
                if (message.typeName != null && message.hasOwnProperty("typeName"))
                    if (!$util.isString(message.typeName))
                        return "typeName: string expected";
                if (message.extendee != null && message.hasOwnProperty("extendee"))
                    if (!$util.isString(message.extendee))
                        return "extendee: string expected";
                if (message.defaultValue != null && message.hasOwnProperty("defaultValue"))
                    if (!$util.isString(message.defaultValue))
                        return "defaultValue: string expected";
                if (message.oneofIndex != null && message.hasOwnProperty("oneofIndex"))
                    if (!$util.isInteger(message.oneofIndex))
                        return "oneofIndex: integer expected";
                if (message.jsonName != null && message.hasOwnProperty("jsonName"))
                    if (!$util.isString(message.jsonName))
                        return "jsonName: string expected";
                if (message.options != null && message.hasOwnProperty("options")) {
                    var error = $root.google.protobuf.FieldOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                return null;
            };

            /**
             * Creates a FieldDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
             */
            FieldDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.FieldDescriptorProto)
                    return object;
                var message = new $root.google.protobuf.FieldDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.number != null)
                    message.number = object.number | 0;
                switch (object.label) {
                case "LABEL_OPTIONAL":
                case 1:
                    message.label = 1;
                    break;
                case "LABEL_REQUIRED":
                case 2:
                    message.label = 2;
                    break;
                case "LABEL_REPEATED":
                case 3:
                    message.label = 3;
                    break;
                }
                switch (object.type) {
                case "TYPE_DOUBLE":
                case 1:
                    message.type = 1;
                    break;
                case "TYPE_FLOAT":
                case 2:
                    message.type = 2;
                    break;
                case "TYPE_INT64":
                case 3:
                    message.type = 3;
                    break;
                case "TYPE_UINT64":
                case 4:
                    message.type = 4;
                    break;
                case "TYPE_INT32":
                case 5:
                    message.type = 5;
                    break;
                case "TYPE_FIXED64":
                case 6:
                    message.type = 6;
                    break;
                case "TYPE_FIXED32":
                case 7:
                    message.type = 7;
                    break;
                case "TYPE_BOOL":
                case 8:
                    message.type = 8;
                    break;
                case "TYPE_STRING":
                case 9:
                    message.type = 9;
                    break;
                case "TYPE_GROUP":
                case 10:
                    message.type = 10;
                    break;
                case "TYPE_MESSAGE":
                case 11:
                    message.type = 11;
                    break;
                case "TYPE_BYTES":
                case 12:
                    message.type = 12;
                    break;
                case "TYPE_UINT32":
                case 13:
                    message.type = 13;
                    break;
                case "TYPE_ENUM":
                case 14:
                    message.type = 14;
                    break;
                case "TYPE_SFIXED32":
                case 15:
                    message.type = 15;
                    break;
                case "TYPE_SFIXED64":
                case 16:
                    message.type = 16;
                    break;
                case "TYPE_SINT32":
                case 17:
                    message.type = 17;
                    break;
                case "TYPE_SINT64":
                case 18:
                    message.type = 18;
                    break;
                }
                if (object.typeName != null)
                    message.typeName = String(object.typeName);
                if (object.extendee != null)
                    message.extendee = String(object.extendee);
                if (object.defaultValue != null)
                    message.defaultValue = String(object.defaultValue);
                if (object.oneofIndex != null)
                    message.oneofIndex = object.oneofIndex | 0;
                if (object.jsonName != null)
                    message.jsonName = String(object.jsonName);
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.FieldDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.FieldOptions.fromObject(object.options);
                }
                return message;
            };

            /**
             * Creates a plain object from a FieldDescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {google.protobuf.FieldDescriptorProto} message FieldDescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FieldDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.extendee = "";
                    object.number = 0;
                    object.label = options.enums === String ? "LABEL_OPTIONAL" : 1;
                    object.type = options.enums === String ? "TYPE_DOUBLE" : 1;
                    object.typeName = "";
                    object.defaultValue = "";
                    object.options = null;
                    object.oneofIndex = 0;
                    object.jsonName = "";
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.extendee != null && message.hasOwnProperty("extendee"))
                    object.extendee = message.extendee;
                if (message.number != null && message.hasOwnProperty("number"))
                    object.number = message.number;
                if (message.label != null && message.hasOwnProperty("label"))
                    object.label = options.enums === String ? $root.google.protobuf.FieldDescriptorProto.Label[message.label] : message.label;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.google.protobuf.FieldDescriptorProto.Type[message.type] : message.type;
                if (message.typeName != null && message.hasOwnProperty("typeName"))
                    object.typeName = message.typeName;
                if (message.defaultValue != null && message.hasOwnProperty("defaultValue"))
                    object.defaultValue = message.defaultValue;
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.FieldOptions.toObject(message.options, options);
                if (message.oneofIndex != null && message.hasOwnProperty("oneofIndex"))
                    object.oneofIndex = message.oneofIndex;
                if (message.jsonName != null && message.hasOwnProperty("jsonName"))
                    object.jsonName = message.jsonName;
                return object;
            };

            /**
             * Converts this FieldDescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FieldDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Type enum.
             * @name google.protobuf.FieldDescriptorProto.Type
             * @enum {string}
             * @property {number} TYPE_DOUBLE=1 TYPE_DOUBLE value
             * @property {number} TYPE_FLOAT=2 TYPE_FLOAT value
             * @property {number} TYPE_INT64=3 TYPE_INT64 value
             * @property {number} TYPE_UINT64=4 TYPE_UINT64 value
             * @property {number} TYPE_INT32=5 TYPE_INT32 value
             * @property {number} TYPE_FIXED64=6 TYPE_FIXED64 value
             * @property {number} TYPE_FIXED32=7 TYPE_FIXED32 value
             * @property {number} TYPE_BOOL=8 TYPE_BOOL value
             * @property {number} TYPE_STRING=9 TYPE_STRING value
             * @property {number} TYPE_GROUP=10 TYPE_GROUP value
             * @property {number} TYPE_MESSAGE=11 TYPE_MESSAGE value
             * @property {number} TYPE_BYTES=12 TYPE_BYTES value
             * @property {number} TYPE_UINT32=13 TYPE_UINT32 value
             * @property {number} TYPE_ENUM=14 TYPE_ENUM value
             * @property {number} TYPE_SFIXED32=15 TYPE_SFIXED32 value
             * @property {number} TYPE_SFIXED64=16 TYPE_SFIXED64 value
             * @property {number} TYPE_SINT32=17 TYPE_SINT32 value
             * @property {number} TYPE_SINT64=18 TYPE_SINT64 value
             */
            FieldDescriptorProto.Type = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[1] = "TYPE_DOUBLE"] = 1;
                values[valuesById[2] = "TYPE_FLOAT"] = 2;
                values[valuesById[3] = "TYPE_INT64"] = 3;
                values[valuesById[4] = "TYPE_UINT64"] = 4;
                values[valuesById[5] = "TYPE_INT32"] = 5;
                values[valuesById[6] = "TYPE_FIXED64"] = 6;
                values[valuesById[7] = "TYPE_FIXED32"] = 7;
                values[valuesById[8] = "TYPE_BOOL"] = 8;
                values[valuesById[9] = "TYPE_STRING"] = 9;
                values[valuesById[10] = "TYPE_GROUP"] = 10;
                values[valuesById[11] = "TYPE_MESSAGE"] = 11;
                values[valuesById[12] = "TYPE_BYTES"] = 12;
                values[valuesById[13] = "TYPE_UINT32"] = 13;
                values[valuesById[14] = "TYPE_ENUM"] = 14;
                values[valuesById[15] = "TYPE_SFIXED32"] = 15;
                values[valuesById[16] = "TYPE_SFIXED64"] = 16;
                values[valuesById[17] = "TYPE_SINT32"] = 17;
                values[valuesById[18] = "TYPE_SINT64"] = 18;
                return values;
            })();

            /**
             * Label enum.
             * @name google.protobuf.FieldDescriptorProto.Label
             * @enum {string}
             * @property {number} LABEL_OPTIONAL=1 LABEL_OPTIONAL value
             * @property {number} LABEL_REQUIRED=2 LABEL_REQUIRED value
             * @property {number} LABEL_REPEATED=3 LABEL_REPEATED value
             */
            FieldDescriptorProto.Label = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[1] = "LABEL_OPTIONAL"] = 1;
                values[valuesById[2] = "LABEL_REQUIRED"] = 2;
                values[valuesById[3] = "LABEL_REPEATED"] = 3;
                return values;
            })();

            return FieldDescriptorProto;
        })();

        protobuf.OneofDescriptorProto = (function() {

            /**
             * Properties of an OneofDescriptorProto.
             * @memberof google.protobuf
             * @interface IOneofDescriptorProto
             * @property {string|null} [name] OneofDescriptorProto name
             * @property {google.protobuf.IOneofOptions|null} [options] OneofDescriptorProto options
             */

            /**
             * Constructs a new OneofDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents an OneofDescriptorProto.
             * @implements IOneofDescriptorProto
             * @constructor
             * @param {google.protobuf.IOneofDescriptorProto=} [properties] Properties to set
             */
            function OneofDescriptorProto(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * OneofDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.OneofDescriptorProto
             * @instance
             */
            OneofDescriptorProto.prototype.name = "";

            /**
             * OneofDescriptorProto options.
             * @member {google.protobuf.IOneofOptions|null|undefined} options
             * @memberof google.protobuf.OneofDescriptorProto
             * @instance
             */
            OneofDescriptorProto.prototype.options = null;

            /**
             * Creates a new OneofDescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {google.protobuf.IOneofDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto instance
             */
            OneofDescriptorProto.create = function create(properties) {
                return new OneofDescriptorProto(properties);
            };

            /**
             * Encodes the specified OneofDescriptorProto message. Does not implicitly {@link google.protobuf.OneofDescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {google.protobuf.IOneofDescriptorProto} message OneofDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OneofDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.options != null && message.hasOwnProperty("options"))
                    $root.google.protobuf.OneofOptions.encode(message.options, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified OneofDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.OneofDescriptorProto.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {google.protobuf.IOneofDescriptorProto} message OneofDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OneofDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an OneofDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OneofDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.OneofDescriptorProto();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.options = $root.google.protobuf.OneofOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an OneofDescriptorProto message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OneofDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an OneofDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            OneofDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.options != null && message.hasOwnProperty("options")) {
                    var error = $root.google.protobuf.OneofOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                return null;
            };

            /**
             * Creates an OneofDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto
             */
            OneofDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.OneofDescriptorProto)
                    return object;
                var message = new $root.google.protobuf.OneofDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.OneofDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.OneofOptions.fromObject(object.options);
                }
                return message;
            };

            /**
             * Creates a plain object from an OneofDescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {google.protobuf.OneofDescriptorProto} message OneofDescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            OneofDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.options = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.OneofOptions.toObject(message.options, options);
                return object;
            };

            /**
             * Converts this OneofDescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.OneofDescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            OneofDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return OneofDescriptorProto;
        })();

        protobuf.EnumDescriptorProto = (function() {

            /**
             * Properties of an EnumDescriptorProto.
             * @memberof google.protobuf
             * @interface IEnumDescriptorProto
             * @property {string|null} [name] EnumDescriptorProto name
             * @property {Array.<google.protobuf.IEnumValueDescriptorProto>|null} [value] EnumDescriptorProto value
             * @property {google.protobuf.IEnumOptions|null} [options] EnumDescriptorProto options
             */

            /**
             * Constructs a new EnumDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents an EnumDescriptorProto.
             * @implements IEnumDescriptorProto
             * @constructor
             * @param {google.protobuf.IEnumDescriptorProto=} [properties] Properties to set
             */
            function EnumDescriptorProto(properties) {
                this.value = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EnumDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.EnumDescriptorProto
             * @instance
             */
            EnumDescriptorProto.prototype.name = "";

            /**
             * EnumDescriptorProto value.
             * @member {Array.<google.protobuf.IEnumValueDescriptorProto>} value
             * @memberof google.protobuf.EnumDescriptorProto
             * @instance
             */
            EnumDescriptorProto.prototype.value = $util.emptyArray;

            /**
             * EnumDescriptorProto options.
             * @member {google.protobuf.IEnumOptions|null|undefined} options
             * @memberof google.protobuf.EnumDescriptorProto
             * @instance
             */
            EnumDescriptorProto.prototype.options = null;

            /**
             * Creates a new EnumDescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {google.protobuf.IEnumDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto instance
             */
            EnumDescriptorProto.create = function create(properties) {
                return new EnumDescriptorProto(properties);
            };

            /**
             * Encodes the specified EnumDescriptorProto message. Does not implicitly {@link google.protobuf.EnumDescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {google.protobuf.IEnumDescriptorProto} message EnumDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.value != null && message.value.length)
                    for (var i = 0; i < message.value.length; ++i)
                        $root.google.protobuf.EnumValueDescriptorProto.encode(message.value[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.options != null && message.hasOwnProperty("options"))
                    $root.google.protobuf.EnumOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified EnumDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.EnumDescriptorProto.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {google.protobuf.IEnumDescriptorProto} message EnumDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EnumDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumDescriptorProto();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        if (!(message.value && message.value.length))
                            message.value = [];
                        message.value.push($root.google.protobuf.EnumValueDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        message.options = $root.google.protobuf.EnumOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an EnumDescriptorProto message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EnumDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EnumDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.value != null && message.hasOwnProperty("value")) {
                    if (!Array.isArray(message.value))
                        return "value: array expected";
                    for (var i = 0; i < message.value.length; ++i) {
                        var error = $root.google.protobuf.EnumValueDescriptorProto.verify(message.value[i]);
                        if (error)
                            return "value." + error;
                    }
                }
                if (message.options != null && message.hasOwnProperty("options")) {
                    var error = $root.google.protobuf.EnumOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                return null;
            };

            /**
             * Creates an EnumDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
             */
            EnumDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.EnumDescriptorProto)
                    return object;
                var message = new $root.google.protobuf.EnumDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.value) {
                    if (!Array.isArray(object.value))
                        throw TypeError(".google.protobuf.EnumDescriptorProto.value: array expected");
                    message.value = [];
                    for (var i = 0; i < object.value.length; ++i) {
                        if (typeof object.value[i] !== "object")
                            throw TypeError(".google.protobuf.EnumDescriptorProto.value: object expected");
                        message.value[i] = $root.google.protobuf.EnumValueDescriptorProto.fromObject(object.value[i]);
                    }
                }
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.EnumDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.EnumOptions.fromObject(object.options);
                }
                return message;
            };

            /**
             * Creates a plain object from an EnumDescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {google.protobuf.EnumDescriptorProto} message EnumDescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EnumDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.value = [];
                if (options.defaults) {
                    object.name = "";
                    object.options = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.value && message.value.length) {
                    object.value = [];
                    for (var j = 0; j < message.value.length; ++j)
                        object.value[j] = $root.google.protobuf.EnumValueDescriptorProto.toObject(message.value[j], options);
                }
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.EnumOptions.toObject(message.options, options);
                return object;
            };

            /**
             * Converts this EnumDescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.EnumDescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EnumDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return EnumDescriptorProto;
        })();

        protobuf.EnumValueDescriptorProto = (function() {

            /**
             * Properties of an EnumValueDescriptorProto.
             * @memberof google.protobuf
             * @interface IEnumValueDescriptorProto
             * @property {string|null} [name] EnumValueDescriptorProto name
             * @property {number|null} [number] EnumValueDescriptorProto number
             * @property {google.protobuf.IEnumValueOptions|null} [options] EnumValueDescriptorProto options
             */

            /**
             * Constructs a new EnumValueDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents an EnumValueDescriptorProto.
             * @implements IEnumValueDescriptorProto
             * @constructor
             * @param {google.protobuf.IEnumValueDescriptorProto=} [properties] Properties to set
             */
            function EnumValueDescriptorProto(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EnumValueDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @instance
             */
            EnumValueDescriptorProto.prototype.name = "";

            /**
             * EnumValueDescriptorProto number.
             * @member {number} number
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @instance
             */
            EnumValueDescriptorProto.prototype.number = 0;

            /**
             * EnumValueDescriptorProto options.
             * @member {google.protobuf.IEnumValueOptions|null|undefined} options
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @instance
             */
            EnumValueDescriptorProto.prototype.options = null;

            /**
             * Creates a new EnumValueDescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {google.protobuf.IEnumValueDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto instance
             */
            EnumValueDescriptorProto.create = function create(properties) {
                return new EnumValueDescriptorProto(properties);
            };

            /**
             * Encodes the specified EnumValueDescriptorProto message. Does not implicitly {@link google.protobuf.EnumValueDescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {google.protobuf.IEnumValueDescriptorProto} message EnumValueDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumValueDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.number != null && message.hasOwnProperty("number"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.number);
                if (message.options != null && message.hasOwnProperty("options"))
                    $root.google.protobuf.EnumValueOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified EnumValueDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.EnumValueDescriptorProto.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {google.protobuf.IEnumValueDescriptorProto} message EnumValueDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumValueDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EnumValueDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumValueDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumValueDescriptorProto();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.number = reader.int32();
                        break;
                    case 3:
                        message.options = $root.google.protobuf.EnumValueOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an EnumValueDescriptorProto message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumValueDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EnumValueDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EnumValueDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.number != null && message.hasOwnProperty("number"))
                    if (!$util.isInteger(message.number))
                        return "number: integer expected";
                if (message.options != null && message.hasOwnProperty("options")) {
                    var error = $root.google.protobuf.EnumValueOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                return null;
            };

            /**
             * Creates an EnumValueDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
             */
            EnumValueDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.EnumValueDescriptorProto)
                    return object;
                var message = new $root.google.protobuf.EnumValueDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.number != null)
                    message.number = object.number | 0;
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.EnumValueDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.EnumValueOptions.fromObject(object.options);
                }
                return message;
            };

            /**
             * Creates a plain object from an EnumValueDescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {google.protobuf.EnumValueDescriptorProto} message EnumValueDescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EnumValueDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.number = 0;
                    object.options = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.number != null && message.hasOwnProperty("number"))
                    object.number = message.number;
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.EnumValueOptions.toObject(message.options, options);
                return object;
            };

            /**
             * Converts this EnumValueDescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EnumValueDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return EnumValueDescriptorProto;
        })();

        protobuf.ServiceDescriptorProto = (function() {

            /**
             * Properties of a ServiceDescriptorProto.
             * @memberof google.protobuf
             * @interface IServiceDescriptorProto
             * @property {string|null} [name] ServiceDescriptorProto name
             * @property {Array.<google.protobuf.IMethodDescriptorProto>|null} [method] ServiceDescriptorProto method
             * @property {google.protobuf.IServiceOptions|null} [options] ServiceDescriptorProto options
             */

            /**
             * Constructs a new ServiceDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents a ServiceDescriptorProto.
             * @implements IServiceDescriptorProto
             * @constructor
             * @param {google.protobuf.IServiceDescriptorProto=} [properties] Properties to set
             */
            function ServiceDescriptorProto(properties) {
                this.method = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ServiceDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.ServiceDescriptorProto
             * @instance
             */
            ServiceDescriptorProto.prototype.name = "";

            /**
             * ServiceDescriptorProto method.
             * @member {Array.<google.protobuf.IMethodDescriptorProto>} method
             * @memberof google.protobuf.ServiceDescriptorProto
             * @instance
             */
            ServiceDescriptorProto.prototype.method = $util.emptyArray;

            /**
             * ServiceDescriptorProto options.
             * @member {google.protobuf.IServiceOptions|null|undefined} options
             * @memberof google.protobuf.ServiceDescriptorProto
             * @instance
             */
            ServiceDescriptorProto.prototype.options = null;

            /**
             * Creates a new ServiceDescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {google.protobuf.IServiceDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto instance
             */
            ServiceDescriptorProto.create = function create(properties) {
                return new ServiceDescriptorProto(properties);
            };

            /**
             * Encodes the specified ServiceDescriptorProto message. Does not implicitly {@link google.protobuf.ServiceDescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {google.protobuf.IServiceDescriptorProto} message ServiceDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServiceDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.method != null && message.method.length)
                    for (var i = 0; i < message.method.length; ++i)
                        $root.google.protobuf.MethodDescriptorProto.encode(message.method[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.options != null && message.hasOwnProperty("options"))
                    $root.google.protobuf.ServiceOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ServiceDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.ServiceDescriptorProto.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {google.protobuf.IServiceDescriptorProto} message ServiceDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServiceDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ServiceDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServiceDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.ServiceDescriptorProto();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        if (!(message.method && message.method.length))
                            message.method = [];
                        message.method.push($root.google.protobuf.MethodDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        message.options = $root.google.protobuf.ServiceOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ServiceDescriptorProto message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServiceDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ServiceDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ServiceDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.method != null && message.hasOwnProperty("method")) {
                    if (!Array.isArray(message.method))
                        return "method: array expected";
                    for (var i = 0; i < message.method.length; ++i) {
                        var error = $root.google.protobuf.MethodDescriptorProto.verify(message.method[i]);
                        if (error)
                            return "method." + error;
                    }
                }
                if (message.options != null && message.hasOwnProperty("options")) {
                    var error = $root.google.protobuf.ServiceOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                return null;
            };

            /**
             * Creates a ServiceDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
             */
            ServiceDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.ServiceDescriptorProto)
                    return object;
                var message = new $root.google.protobuf.ServiceDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.method) {
                    if (!Array.isArray(object.method))
                        throw TypeError(".google.protobuf.ServiceDescriptorProto.method: array expected");
                    message.method = [];
                    for (var i = 0; i < object.method.length; ++i) {
                        if (typeof object.method[i] !== "object")
                            throw TypeError(".google.protobuf.ServiceDescriptorProto.method: object expected");
                        message.method[i] = $root.google.protobuf.MethodDescriptorProto.fromObject(object.method[i]);
                    }
                }
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.ServiceDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.ServiceOptions.fromObject(object.options);
                }
                return message;
            };

            /**
             * Creates a plain object from a ServiceDescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {google.protobuf.ServiceDescriptorProto} message ServiceDescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ServiceDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.method = [];
                if (options.defaults) {
                    object.name = "";
                    object.options = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.method && message.method.length) {
                    object.method = [];
                    for (var j = 0; j < message.method.length; ++j)
                        object.method[j] = $root.google.protobuf.MethodDescriptorProto.toObject(message.method[j], options);
                }
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.ServiceOptions.toObject(message.options, options);
                return object;
            };

            /**
             * Converts this ServiceDescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.ServiceDescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ServiceDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ServiceDescriptorProto;
        })();

        protobuf.MethodDescriptorProto = (function() {

            /**
             * Properties of a MethodDescriptorProto.
             * @memberof google.protobuf
             * @interface IMethodDescriptorProto
             * @property {string|null} [name] MethodDescriptorProto name
             * @property {string|null} [inputType] MethodDescriptorProto inputType
             * @property {string|null} [outputType] MethodDescriptorProto outputType
             * @property {google.protobuf.IMethodOptions|null} [options] MethodDescriptorProto options
             * @property {boolean|null} [clientStreaming] MethodDescriptorProto clientStreaming
             * @property {boolean|null} [serverStreaming] MethodDescriptorProto serverStreaming
             */

            /**
             * Constructs a new MethodDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents a MethodDescriptorProto.
             * @implements IMethodDescriptorProto
             * @constructor
             * @param {google.protobuf.IMethodDescriptorProto=} [properties] Properties to set
             */
            function MethodDescriptorProto(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MethodDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.name = "";

            /**
             * MethodDescriptorProto inputType.
             * @member {string} inputType
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.inputType = "";

            /**
             * MethodDescriptorProto outputType.
             * @member {string} outputType
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.outputType = "";

            /**
             * MethodDescriptorProto options.
             * @member {google.protobuf.IMethodOptions|null|undefined} options
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.options = null;

            /**
             * MethodDescriptorProto clientStreaming.
             * @member {boolean} clientStreaming
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.clientStreaming = false;

            /**
             * MethodDescriptorProto serverStreaming.
             * @member {boolean} serverStreaming
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.serverStreaming = false;

            /**
             * Creates a new MethodDescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {google.protobuf.IMethodDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto instance
             */
            MethodDescriptorProto.create = function create(properties) {
                return new MethodDescriptorProto(properties);
            };

            /**
             * Encodes the specified MethodDescriptorProto message. Does not implicitly {@link google.protobuf.MethodDescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {google.protobuf.IMethodDescriptorProto} message MethodDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MethodDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.inputType != null && message.hasOwnProperty("inputType"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.inputType);
                if (message.outputType != null && message.hasOwnProperty("outputType"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.outputType);
                if (message.options != null && message.hasOwnProperty("options"))
                    $root.google.protobuf.MethodOptions.encode(message.options, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.clientStreaming != null && message.hasOwnProperty("clientStreaming"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.clientStreaming);
                if (message.serverStreaming != null && message.hasOwnProperty("serverStreaming"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.serverStreaming);
                return writer;
            };

            /**
             * Encodes the specified MethodDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.MethodDescriptorProto.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {google.protobuf.IMethodDescriptorProto} message MethodDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MethodDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MethodDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MethodDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MethodDescriptorProto();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.inputType = reader.string();
                        break;
                    case 3:
                        message.outputType = reader.string();
                        break;
                    case 4:
                        message.options = $root.google.protobuf.MethodOptions.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.clientStreaming = reader.bool();
                        break;
                    case 6:
                        message.serverStreaming = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MethodDescriptorProto message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MethodDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MethodDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MethodDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.inputType != null && message.hasOwnProperty("inputType"))
                    if (!$util.isString(message.inputType))
                        return "inputType: string expected";
                if (message.outputType != null && message.hasOwnProperty("outputType"))
                    if (!$util.isString(message.outputType))
                        return "outputType: string expected";
                if (message.options != null && message.hasOwnProperty("options")) {
                    var error = $root.google.protobuf.MethodOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                if (message.clientStreaming != null && message.hasOwnProperty("clientStreaming"))
                    if (typeof message.clientStreaming !== "boolean")
                        return "clientStreaming: boolean expected";
                if (message.serverStreaming != null && message.hasOwnProperty("serverStreaming"))
                    if (typeof message.serverStreaming !== "boolean")
                        return "serverStreaming: boolean expected";
                return null;
            };

            /**
             * Creates a MethodDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
             */
            MethodDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.MethodDescriptorProto)
                    return object;
                var message = new $root.google.protobuf.MethodDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.inputType != null)
                    message.inputType = String(object.inputType);
                if (object.outputType != null)
                    message.outputType = String(object.outputType);
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.MethodDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.MethodOptions.fromObject(object.options);
                }
                if (object.clientStreaming != null)
                    message.clientStreaming = Boolean(object.clientStreaming);
                if (object.serverStreaming != null)
                    message.serverStreaming = Boolean(object.serverStreaming);
                return message;
            };

            /**
             * Creates a plain object from a MethodDescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {google.protobuf.MethodDescriptorProto} message MethodDescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MethodDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.inputType = "";
                    object.outputType = "";
                    object.options = null;
                    object.clientStreaming = false;
                    object.serverStreaming = false;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.inputType != null && message.hasOwnProperty("inputType"))
                    object.inputType = message.inputType;
                if (message.outputType != null && message.hasOwnProperty("outputType"))
                    object.outputType = message.outputType;
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.MethodOptions.toObject(message.options, options);
                if (message.clientStreaming != null && message.hasOwnProperty("clientStreaming"))
                    object.clientStreaming = message.clientStreaming;
                if (message.serverStreaming != null && message.hasOwnProperty("serverStreaming"))
                    object.serverStreaming = message.serverStreaming;
                return object;
            };

            /**
             * Converts this MethodDescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MethodDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MethodDescriptorProto;
        })();

        protobuf.FileOptions = (function() {

            /**
             * Properties of a FileOptions.
             * @memberof google.protobuf
             * @interface IFileOptions
             * @property {string|null} [javaPackage] FileOptions javaPackage
             * @property {string|null} [javaOuterClassname] FileOptions javaOuterClassname
             * @property {boolean|null} [javaMultipleFiles] FileOptions javaMultipleFiles
             * @property {boolean|null} [javaGenerateEqualsAndHash] FileOptions javaGenerateEqualsAndHash
             * @property {boolean|null} [javaStringCheckUtf8] FileOptions javaStringCheckUtf8
             * @property {google.protobuf.FileOptions.OptimizeMode|null} [optimizeFor] FileOptions optimizeFor
             * @property {string|null} [goPackage] FileOptions goPackage
             * @property {boolean|null} [ccGenericServices] FileOptions ccGenericServices
             * @property {boolean|null} [javaGenericServices] FileOptions javaGenericServices
             * @property {boolean|null} [pyGenericServices] FileOptions pyGenericServices
             * @property {boolean|null} [deprecated] FileOptions deprecated
             * @property {boolean|null} [ccEnableArenas] FileOptions ccEnableArenas
             * @property {string|null} [objcClassPrefix] FileOptions objcClassPrefix
             * @property {string|null} [csharpNamespace] FileOptions csharpNamespace
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] FileOptions uninterpretedOption
             */

            /**
             * Constructs a new FileOptions.
             * @memberof google.protobuf
             * @classdesc Represents a FileOptions.
             * @implements IFileOptions
             * @constructor
             * @param {google.protobuf.IFileOptions=} [properties] Properties to set
             */
            function FileOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FileOptions javaPackage.
             * @member {string} javaPackage
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaPackage = "";

            /**
             * FileOptions javaOuterClassname.
             * @member {string} javaOuterClassname
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaOuterClassname = "";

            /**
             * FileOptions javaMultipleFiles.
             * @member {boolean} javaMultipleFiles
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaMultipleFiles = false;

            /**
             * FileOptions javaGenerateEqualsAndHash.
             * @member {boolean} javaGenerateEqualsAndHash
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaGenerateEqualsAndHash = false;

            /**
             * FileOptions javaStringCheckUtf8.
             * @member {boolean} javaStringCheckUtf8
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaStringCheckUtf8 = false;

            /**
             * FileOptions optimizeFor.
             * @member {google.protobuf.FileOptions.OptimizeMode} optimizeFor
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.optimizeFor = 1;

            /**
             * FileOptions goPackage.
             * @member {string} goPackage
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.goPackage = "";

            /**
             * FileOptions ccGenericServices.
             * @member {boolean} ccGenericServices
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.ccGenericServices = false;

            /**
             * FileOptions javaGenericServices.
             * @member {boolean} javaGenericServices
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaGenericServices = false;

            /**
             * FileOptions pyGenericServices.
             * @member {boolean} pyGenericServices
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.pyGenericServices = false;

            /**
             * FileOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.deprecated = false;

            /**
             * FileOptions ccEnableArenas.
             * @member {boolean} ccEnableArenas
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.ccEnableArenas = false;

            /**
             * FileOptions objcClassPrefix.
             * @member {string} objcClassPrefix
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.objcClassPrefix = "";

            /**
             * FileOptions csharpNamespace.
             * @member {string} csharpNamespace
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.csharpNamespace = "";

            /**
             * FileOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Creates a new FileOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {google.protobuf.IFileOptions=} [properties] Properties to set
             * @returns {google.protobuf.FileOptions} FileOptions instance
             */
            FileOptions.create = function create(properties) {
                return new FileOptions(properties);
            };

            /**
             * Encodes the specified FileOptions message. Does not implicitly {@link google.protobuf.FileOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {google.protobuf.IFileOptions} message FileOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.javaPackage != null && message.hasOwnProperty("javaPackage"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.javaPackage);
                if (message.javaOuterClassname != null && message.hasOwnProperty("javaOuterClassname"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.javaOuterClassname);
                if (message.optimizeFor != null && message.hasOwnProperty("optimizeFor"))
                    writer.uint32(/* id 9, wireType 0 =*/72).int32(message.optimizeFor);
                if (message.javaMultipleFiles != null && message.hasOwnProperty("javaMultipleFiles"))
                    writer.uint32(/* id 10, wireType 0 =*/80).bool(message.javaMultipleFiles);
                if (message.goPackage != null && message.hasOwnProperty("goPackage"))
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.goPackage);
                if (message.ccGenericServices != null && message.hasOwnProperty("ccGenericServices"))
                    writer.uint32(/* id 16, wireType 0 =*/128).bool(message.ccGenericServices);
                if (message.javaGenericServices != null && message.hasOwnProperty("javaGenericServices"))
                    writer.uint32(/* id 17, wireType 0 =*/136).bool(message.javaGenericServices);
                if (message.pyGenericServices != null && message.hasOwnProperty("pyGenericServices"))
                    writer.uint32(/* id 18, wireType 0 =*/144).bool(message.pyGenericServices);
                if (message.javaGenerateEqualsAndHash != null && message.hasOwnProperty("javaGenerateEqualsAndHash"))
                    writer.uint32(/* id 20, wireType 0 =*/160).bool(message.javaGenerateEqualsAndHash);
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    writer.uint32(/* id 23, wireType 0 =*/184).bool(message.deprecated);
                if (message.javaStringCheckUtf8 != null && message.hasOwnProperty("javaStringCheckUtf8"))
                    writer.uint32(/* id 27, wireType 0 =*/216).bool(message.javaStringCheckUtf8);
                if (message.ccEnableArenas != null && message.hasOwnProperty("ccEnableArenas"))
                    writer.uint32(/* id 31, wireType 0 =*/248).bool(message.ccEnableArenas);
                if (message.objcClassPrefix != null && message.hasOwnProperty("objcClassPrefix"))
                    writer.uint32(/* id 36, wireType 2 =*/290).string(message.objcClassPrefix);
                if (message.csharpNamespace != null && message.hasOwnProperty("csharpNamespace"))
                    writer.uint32(/* id 37, wireType 2 =*/298).string(message.csharpNamespace);
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (var i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified FileOptions message, length delimited. Does not implicitly {@link google.protobuf.FileOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {google.protobuf.IFileOptions} message FileOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FileOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FileOptions} FileOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.javaPackage = reader.string();
                        break;
                    case 8:
                        message.javaOuterClassname = reader.string();
                        break;
                    case 10:
                        message.javaMultipleFiles = reader.bool();
                        break;
                    case 20:
                        message.javaGenerateEqualsAndHash = reader.bool();
                        break;
                    case 27:
                        message.javaStringCheckUtf8 = reader.bool();
                        break;
                    case 9:
                        message.optimizeFor = reader.int32();
                        break;
                    case 11:
                        message.goPackage = reader.string();
                        break;
                    case 16:
                        message.ccGenericServices = reader.bool();
                        break;
                    case 17:
                        message.javaGenericServices = reader.bool();
                        break;
                    case 18:
                        message.pyGenericServices = reader.bool();
                        break;
                    case 23:
                        message.deprecated = reader.bool();
                        break;
                    case 31:
                        message.ccEnableArenas = reader.bool();
                        break;
                    case 36:
                        message.objcClassPrefix = reader.string();
                        break;
                    case 37:
                        message.csharpNamespace = reader.string();
                        break;
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FileOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.FileOptions} FileOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FileOptions message.
             * @function verify
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FileOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.javaPackage != null && message.hasOwnProperty("javaPackage"))
                    if (!$util.isString(message.javaPackage))
                        return "javaPackage: string expected";
                if (message.javaOuterClassname != null && message.hasOwnProperty("javaOuterClassname"))
                    if (!$util.isString(message.javaOuterClassname))
                        return "javaOuterClassname: string expected";
                if (message.javaMultipleFiles != null && message.hasOwnProperty("javaMultipleFiles"))
                    if (typeof message.javaMultipleFiles !== "boolean")
                        return "javaMultipleFiles: boolean expected";
                if (message.javaGenerateEqualsAndHash != null && message.hasOwnProperty("javaGenerateEqualsAndHash"))
                    if (typeof message.javaGenerateEqualsAndHash !== "boolean")
                        return "javaGenerateEqualsAndHash: boolean expected";
                if (message.javaStringCheckUtf8 != null && message.hasOwnProperty("javaStringCheckUtf8"))
                    if (typeof message.javaStringCheckUtf8 !== "boolean")
                        return "javaStringCheckUtf8: boolean expected";
                if (message.optimizeFor != null && message.hasOwnProperty("optimizeFor"))
                    switch (message.optimizeFor) {
                    default:
                        return "optimizeFor: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                if (message.goPackage != null && message.hasOwnProperty("goPackage"))
                    if (!$util.isString(message.goPackage))
                        return "goPackage: string expected";
                if (message.ccGenericServices != null && message.hasOwnProperty("ccGenericServices"))
                    if (typeof message.ccGenericServices !== "boolean")
                        return "ccGenericServices: boolean expected";
                if (message.javaGenericServices != null && message.hasOwnProperty("javaGenericServices"))
                    if (typeof message.javaGenericServices !== "boolean")
                        return "javaGenericServices: boolean expected";
                if (message.pyGenericServices != null && message.hasOwnProperty("pyGenericServices"))
                    if (typeof message.pyGenericServices !== "boolean")
                        return "pyGenericServices: boolean expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.ccEnableArenas != null && message.hasOwnProperty("ccEnableArenas"))
                    if (typeof message.ccEnableArenas !== "boolean")
                        return "ccEnableArenas: boolean expected";
                if (message.objcClassPrefix != null && message.hasOwnProperty("objcClassPrefix"))
                    if (!$util.isString(message.objcClassPrefix))
                        return "objcClassPrefix: string expected";
                if (message.csharpNamespace != null && message.hasOwnProperty("csharpNamespace"))
                    if (!$util.isString(message.csharpNamespace))
                        return "csharpNamespace: string expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (var i = 0; i < message.uninterpretedOption.length; ++i) {
                        var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a FileOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FileOptions} FileOptions
             */
            FileOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.FileOptions)
                    return object;
                var message = new $root.google.protobuf.FileOptions();
                if (object.javaPackage != null)
                    message.javaPackage = String(object.javaPackage);
                if (object.javaOuterClassname != null)
                    message.javaOuterClassname = String(object.javaOuterClassname);
                if (object.javaMultipleFiles != null)
                    message.javaMultipleFiles = Boolean(object.javaMultipleFiles);
                if (object.javaGenerateEqualsAndHash != null)
                    message.javaGenerateEqualsAndHash = Boolean(object.javaGenerateEqualsAndHash);
                if (object.javaStringCheckUtf8 != null)
                    message.javaStringCheckUtf8 = Boolean(object.javaStringCheckUtf8);
                switch (object.optimizeFor) {
                case "SPEED":
                case 1:
                    message.optimizeFor = 1;
                    break;
                case "CODE_SIZE":
                case 2:
                    message.optimizeFor = 2;
                    break;
                case "LITE_RUNTIME":
                case 3:
                    message.optimizeFor = 3;
                    break;
                }
                if (object.goPackage != null)
                    message.goPackage = String(object.goPackage);
                if (object.ccGenericServices != null)
                    message.ccGenericServices = Boolean(object.ccGenericServices);
                if (object.javaGenericServices != null)
                    message.javaGenericServices = Boolean(object.javaGenericServices);
                if (object.pyGenericServices != null)
                    message.pyGenericServices = Boolean(object.pyGenericServices);
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.ccEnableArenas != null)
                    message.ccEnableArenas = Boolean(object.ccEnableArenas);
                if (object.objcClassPrefix != null)
                    message.objcClassPrefix = String(object.objcClassPrefix);
                if (object.csharpNamespace != null)
                    message.csharpNamespace = String(object.csharpNamespace);
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.FileOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (var i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.FileOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a FileOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {google.protobuf.FileOptions} message FileOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FileOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults) {
                    object.javaPackage = "";
                    object.javaOuterClassname = "";
                    object.optimizeFor = options.enums === String ? "SPEED" : 1;
                    object.javaMultipleFiles = false;
                    object.goPackage = "";
                    object.ccGenericServices = false;
                    object.javaGenericServices = false;
                    object.pyGenericServices = false;
                    object.javaGenerateEqualsAndHash = false;
                    object.deprecated = false;
                    object.javaStringCheckUtf8 = false;
                    object.ccEnableArenas = false;
                    object.objcClassPrefix = "";
                    object.csharpNamespace = "";
                }
                if (message.javaPackage != null && message.hasOwnProperty("javaPackage"))
                    object.javaPackage = message.javaPackage;
                if (message.javaOuterClassname != null && message.hasOwnProperty("javaOuterClassname"))
                    object.javaOuterClassname = message.javaOuterClassname;
                if (message.optimizeFor != null && message.hasOwnProperty("optimizeFor"))
                    object.optimizeFor = options.enums === String ? $root.google.protobuf.FileOptions.OptimizeMode[message.optimizeFor] : message.optimizeFor;
                if (message.javaMultipleFiles != null && message.hasOwnProperty("javaMultipleFiles"))
                    object.javaMultipleFiles = message.javaMultipleFiles;
                if (message.goPackage != null && message.hasOwnProperty("goPackage"))
                    object.goPackage = message.goPackage;
                if (message.ccGenericServices != null && message.hasOwnProperty("ccGenericServices"))
                    object.ccGenericServices = message.ccGenericServices;
                if (message.javaGenericServices != null && message.hasOwnProperty("javaGenericServices"))
                    object.javaGenericServices = message.javaGenericServices;
                if (message.pyGenericServices != null && message.hasOwnProperty("pyGenericServices"))
                    object.pyGenericServices = message.pyGenericServices;
                if (message.javaGenerateEqualsAndHash != null && message.hasOwnProperty("javaGenerateEqualsAndHash"))
                    object.javaGenerateEqualsAndHash = message.javaGenerateEqualsAndHash;
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.javaStringCheckUtf8 != null && message.hasOwnProperty("javaStringCheckUtf8"))
                    object.javaStringCheckUtf8 = message.javaStringCheckUtf8;
                if (message.ccEnableArenas != null && message.hasOwnProperty("ccEnableArenas"))
                    object.ccEnableArenas = message.ccEnableArenas;
                if (message.objcClassPrefix != null && message.hasOwnProperty("objcClassPrefix"))
                    object.objcClassPrefix = message.objcClassPrefix;
                if (message.csharpNamespace != null && message.hasOwnProperty("csharpNamespace"))
                    object.csharpNamespace = message.csharpNamespace;
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (var j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                return object;
            };

            /**
             * Converts this FileOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.FileOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FileOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * OptimizeMode enum.
             * @name google.protobuf.FileOptions.OptimizeMode
             * @enum {string}
             * @property {number} SPEED=1 SPEED value
             * @property {number} CODE_SIZE=2 CODE_SIZE value
             * @property {number} LITE_RUNTIME=3 LITE_RUNTIME value
             */
            FileOptions.OptimizeMode = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[1] = "SPEED"] = 1;
                values[valuesById[2] = "CODE_SIZE"] = 2;
                values[valuesById[3] = "LITE_RUNTIME"] = 3;
                return values;
            })();

            return FileOptions;
        })();

        protobuf.MessageOptions = (function() {

            /**
             * Properties of a MessageOptions.
             * @memberof google.protobuf
             * @interface IMessageOptions
             * @property {boolean|null} [messageSetWireFormat] MessageOptions messageSetWireFormat
             * @property {boolean|null} [noStandardDescriptorAccessor] MessageOptions noStandardDescriptorAccessor
             * @property {boolean|null} [deprecated] MessageOptions deprecated
             * @property {boolean|null} [mapEntry] MessageOptions mapEntry
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] MessageOptions uninterpretedOption
             */

            /**
             * Constructs a new MessageOptions.
             * @memberof google.protobuf
             * @classdesc Represents a MessageOptions.
             * @implements IMessageOptions
             * @constructor
             * @param {google.protobuf.IMessageOptions=} [properties] Properties to set
             */
            function MessageOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MessageOptions messageSetWireFormat.
             * @member {boolean} messageSetWireFormat
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype.messageSetWireFormat = false;

            /**
             * MessageOptions noStandardDescriptorAccessor.
             * @member {boolean} noStandardDescriptorAccessor
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype.noStandardDescriptorAccessor = false;

            /**
             * MessageOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype.deprecated = false;

            /**
             * MessageOptions mapEntry.
             * @member {boolean} mapEntry
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype.mapEntry = false;

            /**
             * MessageOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Creates a new MessageOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {google.protobuf.IMessageOptions=} [properties] Properties to set
             * @returns {google.protobuf.MessageOptions} MessageOptions instance
             */
            MessageOptions.create = function create(properties) {
                return new MessageOptions(properties);
            };

            /**
             * Encodes the specified MessageOptions message. Does not implicitly {@link google.protobuf.MessageOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {google.protobuf.IMessageOptions} message MessageOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MessageOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.messageSetWireFormat != null && message.hasOwnProperty("messageSetWireFormat"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.messageSetWireFormat);
                if (message.noStandardDescriptorAccessor != null && message.hasOwnProperty("noStandardDescriptorAccessor"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.noStandardDescriptorAccessor);
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.deprecated);
                if (message.mapEntry != null && message.hasOwnProperty("mapEntry"))
                    writer.uint32(/* id 7, wireType 0 =*/56).bool(message.mapEntry);
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (var i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified MessageOptions message, length delimited. Does not implicitly {@link google.protobuf.MessageOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {google.protobuf.IMessageOptions} message MessageOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MessageOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MessageOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.MessageOptions} MessageOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MessageOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MessageOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.messageSetWireFormat = reader.bool();
                        break;
                    case 2:
                        message.noStandardDescriptorAccessor = reader.bool();
                        break;
                    case 3:
                        message.deprecated = reader.bool();
                        break;
                    case 7:
                        message.mapEntry = reader.bool();
                        break;
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MessageOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.MessageOptions} MessageOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MessageOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MessageOptions message.
             * @function verify
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MessageOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.messageSetWireFormat != null && message.hasOwnProperty("messageSetWireFormat"))
                    if (typeof message.messageSetWireFormat !== "boolean")
                        return "messageSetWireFormat: boolean expected";
                if (message.noStandardDescriptorAccessor != null && message.hasOwnProperty("noStandardDescriptorAccessor"))
                    if (typeof message.noStandardDescriptorAccessor !== "boolean")
                        return "noStandardDescriptorAccessor: boolean expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.mapEntry != null && message.hasOwnProperty("mapEntry"))
                    if (typeof message.mapEntry !== "boolean")
                        return "mapEntry: boolean expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (var i = 0; i < message.uninterpretedOption.length; ++i) {
                        var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a MessageOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.MessageOptions} MessageOptions
             */
            MessageOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.MessageOptions)
                    return object;
                var message = new $root.google.protobuf.MessageOptions();
                if (object.messageSetWireFormat != null)
                    message.messageSetWireFormat = Boolean(object.messageSetWireFormat);
                if (object.noStandardDescriptorAccessor != null)
                    message.noStandardDescriptorAccessor = Boolean(object.noStandardDescriptorAccessor);
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.mapEntry != null)
                    message.mapEntry = Boolean(object.mapEntry);
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.MessageOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (var i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.MessageOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a MessageOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {google.protobuf.MessageOptions} message MessageOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MessageOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults) {
                    object.messageSetWireFormat = false;
                    object.noStandardDescriptorAccessor = false;
                    object.deprecated = false;
                    object.mapEntry = false;
                }
                if (message.messageSetWireFormat != null && message.hasOwnProperty("messageSetWireFormat"))
                    object.messageSetWireFormat = message.messageSetWireFormat;
                if (message.noStandardDescriptorAccessor != null && message.hasOwnProperty("noStandardDescriptorAccessor"))
                    object.noStandardDescriptorAccessor = message.noStandardDescriptorAccessor;
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.mapEntry != null && message.hasOwnProperty("mapEntry"))
                    object.mapEntry = message.mapEntry;
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (var j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                return object;
            };

            /**
             * Converts this MessageOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.MessageOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MessageOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MessageOptions;
        })();

        protobuf.FieldOptions = (function() {

            /**
             * Properties of a FieldOptions.
             * @memberof google.protobuf
             * @interface IFieldOptions
             * @property {google.protobuf.FieldOptions.CType|null} [ctype] FieldOptions ctype
             * @property {boolean|null} [packed] FieldOptions packed
             * @property {google.protobuf.FieldOptions.JSType|null} [jstype] FieldOptions jstype
             * @property {boolean|null} [lazy] FieldOptions lazy
             * @property {boolean|null} [deprecated] FieldOptions deprecated
             * @property {boolean|null} [weak] FieldOptions weak
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] FieldOptions uninterpretedOption
             */

            /**
             * Constructs a new FieldOptions.
             * @memberof google.protobuf
             * @classdesc Represents a FieldOptions.
             * @implements IFieldOptions
             * @constructor
             * @param {google.protobuf.IFieldOptions=} [properties] Properties to set
             */
            function FieldOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FieldOptions ctype.
             * @member {google.protobuf.FieldOptions.CType} ctype
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.ctype = 0;

            /**
             * FieldOptions packed.
             * @member {boolean} packed
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.packed = false;

            /**
             * FieldOptions jstype.
             * @member {google.protobuf.FieldOptions.JSType} jstype
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.jstype = 0;

            /**
             * FieldOptions lazy.
             * @member {boolean} lazy
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.lazy = false;

            /**
             * FieldOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.deprecated = false;

            /**
             * FieldOptions weak.
             * @member {boolean} weak
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.weak = false;

            /**
             * FieldOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Creates a new FieldOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {google.protobuf.IFieldOptions=} [properties] Properties to set
             * @returns {google.protobuf.FieldOptions} FieldOptions instance
             */
            FieldOptions.create = function create(properties) {
                return new FieldOptions(properties);
            };

            /**
             * Encodes the specified FieldOptions message. Does not implicitly {@link google.protobuf.FieldOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {google.protobuf.IFieldOptions} message FieldOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FieldOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.ctype != null && message.hasOwnProperty("ctype"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ctype);
                if (message.packed != null && message.hasOwnProperty("packed"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.packed);
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.deprecated);
                if (message.lazy != null && message.hasOwnProperty("lazy"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.lazy);
                if (message.jstype != null && message.hasOwnProperty("jstype"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.jstype);
                if (message.weak != null && message.hasOwnProperty("weak"))
                    writer.uint32(/* id 10, wireType 0 =*/80).bool(message.weak);
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (var i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified FieldOptions message, length delimited. Does not implicitly {@link google.protobuf.FieldOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {google.protobuf.IFieldOptions} message FieldOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FieldOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FieldOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FieldOptions} FieldOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FieldOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FieldOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.ctype = reader.int32();
                        break;
                    case 2:
                        message.packed = reader.bool();
                        break;
                    case 6:
                        message.jstype = reader.int32();
                        break;
                    case 5:
                        message.lazy = reader.bool();
                        break;
                    case 3:
                        message.deprecated = reader.bool();
                        break;
                    case 10:
                        message.weak = reader.bool();
                        break;
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FieldOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.FieldOptions} FieldOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FieldOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FieldOptions message.
             * @function verify
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FieldOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.ctype != null && message.hasOwnProperty("ctype"))
                    switch (message.ctype) {
                    default:
                        return "ctype: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.packed != null && message.hasOwnProperty("packed"))
                    if (typeof message.packed !== "boolean")
                        return "packed: boolean expected";
                if (message.jstype != null && message.hasOwnProperty("jstype"))
                    switch (message.jstype) {
                    default:
                        return "jstype: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.lazy != null && message.hasOwnProperty("lazy"))
                    if (typeof message.lazy !== "boolean")
                        return "lazy: boolean expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.weak != null && message.hasOwnProperty("weak"))
                    if (typeof message.weak !== "boolean")
                        return "weak: boolean expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (var i = 0; i < message.uninterpretedOption.length; ++i) {
                        var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a FieldOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FieldOptions} FieldOptions
             */
            FieldOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.FieldOptions)
                    return object;
                var message = new $root.google.protobuf.FieldOptions();
                switch (object.ctype) {
                case "STRING":
                case 0:
                    message.ctype = 0;
                    break;
                case "CORD":
                case 1:
                    message.ctype = 1;
                    break;
                case "STRING_PIECE":
                case 2:
                    message.ctype = 2;
                    break;
                }
                if (object.packed != null)
                    message.packed = Boolean(object.packed);
                switch (object.jstype) {
                case "JS_NORMAL":
                case 0:
                    message.jstype = 0;
                    break;
                case "JS_STRING":
                case 1:
                    message.jstype = 1;
                    break;
                case "JS_NUMBER":
                case 2:
                    message.jstype = 2;
                    break;
                }
                if (object.lazy != null)
                    message.lazy = Boolean(object.lazy);
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.weak != null)
                    message.weak = Boolean(object.weak);
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.FieldOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (var i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.FieldOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a FieldOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {google.protobuf.FieldOptions} message FieldOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FieldOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults) {
                    object.ctype = options.enums === String ? "STRING" : 0;
                    object.packed = false;
                    object.deprecated = false;
                    object.lazy = false;
                    object.jstype = options.enums === String ? "JS_NORMAL" : 0;
                    object.weak = false;
                }
                if (message.ctype != null && message.hasOwnProperty("ctype"))
                    object.ctype = options.enums === String ? $root.google.protobuf.FieldOptions.CType[message.ctype] : message.ctype;
                if (message.packed != null && message.hasOwnProperty("packed"))
                    object.packed = message.packed;
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.lazy != null && message.hasOwnProperty("lazy"))
                    object.lazy = message.lazy;
                if (message.jstype != null && message.hasOwnProperty("jstype"))
                    object.jstype = options.enums === String ? $root.google.protobuf.FieldOptions.JSType[message.jstype] : message.jstype;
                if (message.weak != null && message.hasOwnProperty("weak"))
                    object.weak = message.weak;
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (var j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                return object;
            };

            /**
             * Converts this FieldOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.FieldOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FieldOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * CType enum.
             * @name google.protobuf.FieldOptions.CType
             * @enum {string}
             * @property {number} STRING=0 STRING value
             * @property {number} CORD=1 CORD value
             * @property {number} STRING_PIECE=2 STRING_PIECE value
             */
            FieldOptions.CType = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "STRING"] = 0;
                values[valuesById[1] = "CORD"] = 1;
                values[valuesById[2] = "STRING_PIECE"] = 2;
                return values;
            })();

            /**
             * JSType enum.
             * @name google.protobuf.FieldOptions.JSType
             * @enum {string}
             * @property {number} JS_NORMAL=0 JS_NORMAL value
             * @property {number} JS_STRING=1 JS_STRING value
             * @property {number} JS_NUMBER=2 JS_NUMBER value
             */
            FieldOptions.JSType = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "JS_NORMAL"] = 0;
                values[valuesById[1] = "JS_STRING"] = 1;
                values[valuesById[2] = "JS_NUMBER"] = 2;
                return values;
            })();

            return FieldOptions;
        })();

        protobuf.OneofOptions = (function() {

            /**
             * Properties of an OneofOptions.
             * @memberof google.protobuf
             * @interface IOneofOptions
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] OneofOptions uninterpretedOption
             */

            /**
             * Constructs a new OneofOptions.
             * @memberof google.protobuf
             * @classdesc Represents an OneofOptions.
             * @implements IOneofOptions
             * @constructor
             * @param {google.protobuf.IOneofOptions=} [properties] Properties to set
             */
            function OneofOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * OneofOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.OneofOptions
             * @instance
             */
            OneofOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Creates a new OneofOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {google.protobuf.IOneofOptions=} [properties] Properties to set
             * @returns {google.protobuf.OneofOptions} OneofOptions instance
             */
            OneofOptions.create = function create(properties) {
                return new OneofOptions(properties);
            };

            /**
             * Encodes the specified OneofOptions message. Does not implicitly {@link google.protobuf.OneofOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {google.protobuf.IOneofOptions} message OneofOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OneofOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (var i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified OneofOptions message, length delimited. Does not implicitly {@link google.protobuf.OneofOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {google.protobuf.IOneofOptions} message OneofOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OneofOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an OneofOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.OneofOptions} OneofOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OneofOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.OneofOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an OneofOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.OneofOptions} OneofOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OneofOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an OneofOptions message.
             * @function verify
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            OneofOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (var i = 0; i < message.uninterpretedOption.length; ++i) {
                        var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an OneofOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.OneofOptions} OneofOptions
             */
            OneofOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.OneofOptions)
                    return object;
                var message = new $root.google.protobuf.OneofOptions();
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.OneofOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (var i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.OneofOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from an OneofOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {google.protobuf.OneofOptions} message OneofOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            OneofOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (var j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                return object;
            };

            /**
             * Converts this OneofOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.OneofOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            OneofOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return OneofOptions;
        })();

        protobuf.EnumOptions = (function() {

            /**
             * Properties of an EnumOptions.
             * @memberof google.protobuf
             * @interface IEnumOptions
             * @property {boolean|null} [allowAlias] EnumOptions allowAlias
             * @property {boolean|null} [deprecated] EnumOptions deprecated
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] EnumOptions uninterpretedOption
             */

            /**
             * Constructs a new EnumOptions.
             * @memberof google.protobuf
             * @classdesc Represents an EnumOptions.
             * @implements IEnumOptions
             * @constructor
             * @param {google.protobuf.IEnumOptions=} [properties] Properties to set
             */
            function EnumOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EnumOptions allowAlias.
             * @member {boolean} allowAlias
             * @memberof google.protobuf.EnumOptions
             * @instance
             */
            EnumOptions.prototype.allowAlias = false;

            /**
             * EnumOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.EnumOptions
             * @instance
             */
            EnumOptions.prototype.deprecated = false;

            /**
             * EnumOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.EnumOptions
             * @instance
             */
            EnumOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Creates a new EnumOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {google.protobuf.IEnumOptions=} [properties] Properties to set
             * @returns {google.protobuf.EnumOptions} EnumOptions instance
             */
            EnumOptions.create = function create(properties) {
                return new EnumOptions(properties);
            };

            /**
             * Encodes the specified EnumOptions message. Does not implicitly {@link google.protobuf.EnumOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {google.protobuf.IEnumOptions} message EnumOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.allowAlias != null && message.hasOwnProperty("allowAlias"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.allowAlias);
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.deprecated);
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (var i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified EnumOptions message, length delimited. Does not implicitly {@link google.protobuf.EnumOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {google.protobuf.IEnumOptions} message EnumOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EnumOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.EnumOptions} EnumOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 2:
                        message.allowAlias = reader.bool();
                        break;
                    case 3:
                        message.deprecated = reader.bool();
                        break;
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an EnumOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.EnumOptions} EnumOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EnumOptions message.
             * @function verify
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EnumOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.allowAlias != null && message.hasOwnProperty("allowAlias"))
                    if (typeof message.allowAlias !== "boolean")
                        return "allowAlias: boolean expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (var i = 0; i < message.uninterpretedOption.length; ++i) {
                        var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an EnumOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.EnumOptions} EnumOptions
             */
            EnumOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.EnumOptions)
                    return object;
                var message = new $root.google.protobuf.EnumOptions();
                if (object.allowAlias != null)
                    message.allowAlias = Boolean(object.allowAlias);
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.EnumOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (var i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.EnumOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from an EnumOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {google.protobuf.EnumOptions} message EnumOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EnumOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults) {
                    object.allowAlias = false;
                    object.deprecated = false;
                }
                if (message.allowAlias != null && message.hasOwnProperty("allowAlias"))
                    object.allowAlias = message.allowAlias;
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (var j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                return object;
            };

            /**
             * Converts this EnumOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.EnumOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EnumOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return EnumOptions;
        })();

        protobuf.EnumValueOptions = (function() {

            /**
             * Properties of an EnumValueOptions.
             * @memberof google.protobuf
             * @interface IEnumValueOptions
             * @property {boolean|null} [deprecated] EnumValueOptions deprecated
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] EnumValueOptions uninterpretedOption
             */

            /**
             * Constructs a new EnumValueOptions.
             * @memberof google.protobuf
             * @classdesc Represents an EnumValueOptions.
             * @implements IEnumValueOptions
             * @constructor
             * @param {google.protobuf.IEnumValueOptions=} [properties] Properties to set
             */
            function EnumValueOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EnumValueOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.EnumValueOptions
             * @instance
             */
            EnumValueOptions.prototype.deprecated = false;

            /**
             * EnumValueOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.EnumValueOptions
             * @instance
             */
            EnumValueOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Creates a new EnumValueOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {google.protobuf.IEnumValueOptions=} [properties] Properties to set
             * @returns {google.protobuf.EnumValueOptions} EnumValueOptions instance
             */
            EnumValueOptions.create = function create(properties) {
                return new EnumValueOptions(properties);
            };

            /**
             * Encodes the specified EnumValueOptions message. Does not implicitly {@link google.protobuf.EnumValueOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {google.protobuf.IEnumValueOptions} message EnumValueOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumValueOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.deprecated);
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (var i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified EnumValueOptions message, length delimited. Does not implicitly {@link google.protobuf.EnumValueOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {google.protobuf.IEnumValueOptions} message EnumValueOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumValueOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EnumValueOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumValueOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumValueOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.deprecated = reader.bool();
                        break;
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an EnumValueOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumValueOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EnumValueOptions message.
             * @function verify
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EnumValueOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (var i = 0; i < message.uninterpretedOption.length; ++i) {
                        var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an EnumValueOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
             */
            EnumValueOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.EnumValueOptions)
                    return object;
                var message = new $root.google.protobuf.EnumValueOptions();
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.EnumValueOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (var i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.EnumValueOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from an EnumValueOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {google.protobuf.EnumValueOptions} message EnumValueOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EnumValueOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults)
                    object.deprecated = false;
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (var j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                return object;
            };

            /**
             * Converts this EnumValueOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.EnumValueOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EnumValueOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return EnumValueOptions;
        })();

        protobuf.ServiceOptions = (function() {

            /**
             * Properties of a ServiceOptions.
             * @memberof google.protobuf
             * @interface IServiceOptions
             * @property {boolean|null} [deprecated] ServiceOptions deprecated
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] ServiceOptions uninterpretedOption
             */

            /**
             * Constructs a new ServiceOptions.
             * @memberof google.protobuf
             * @classdesc Represents a ServiceOptions.
             * @implements IServiceOptions
             * @constructor
             * @param {google.protobuf.IServiceOptions=} [properties] Properties to set
             */
            function ServiceOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ServiceOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.ServiceOptions
             * @instance
             */
            ServiceOptions.prototype.deprecated = false;

            /**
             * ServiceOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.ServiceOptions
             * @instance
             */
            ServiceOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Creates a new ServiceOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {google.protobuf.IServiceOptions=} [properties] Properties to set
             * @returns {google.protobuf.ServiceOptions} ServiceOptions instance
             */
            ServiceOptions.create = function create(properties) {
                return new ServiceOptions(properties);
            };

            /**
             * Encodes the specified ServiceOptions message. Does not implicitly {@link google.protobuf.ServiceOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {google.protobuf.IServiceOptions} message ServiceOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServiceOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    writer.uint32(/* id 33, wireType 0 =*/264).bool(message.deprecated);
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (var i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ServiceOptions message, length delimited. Does not implicitly {@link google.protobuf.ServiceOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {google.protobuf.IServiceOptions} message ServiceOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServiceOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ServiceOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.ServiceOptions} ServiceOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServiceOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.ServiceOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 33:
                        message.deprecated = reader.bool();
                        break;
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ServiceOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.ServiceOptions} ServiceOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServiceOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ServiceOptions message.
             * @function verify
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ServiceOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (var i = 0; i < message.uninterpretedOption.length; ++i) {
                        var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a ServiceOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.ServiceOptions} ServiceOptions
             */
            ServiceOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.ServiceOptions)
                    return object;
                var message = new $root.google.protobuf.ServiceOptions();
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.ServiceOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (var i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.ServiceOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a ServiceOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {google.protobuf.ServiceOptions} message ServiceOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ServiceOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults)
                    object.deprecated = false;
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (var j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                return object;
            };

            /**
             * Converts this ServiceOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.ServiceOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ServiceOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ServiceOptions;
        })();

        protobuf.MethodOptions = (function() {

            /**
             * Properties of a MethodOptions.
             * @memberof google.protobuf
             * @interface IMethodOptions
             * @property {boolean|null} [deprecated] MethodOptions deprecated
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] MethodOptions uninterpretedOption
             * @property {google.api.IHttpRule|null} [".google.api.http"] MethodOptions .google.api.http
             */

            /**
             * Constructs a new MethodOptions.
             * @memberof google.protobuf
             * @classdesc Represents a MethodOptions.
             * @implements IMethodOptions
             * @constructor
             * @param {google.protobuf.IMethodOptions=} [properties] Properties to set
             */
            function MethodOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MethodOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.MethodOptions
             * @instance
             */
            MethodOptions.prototype.deprecated = false;

            /**
             * MethodOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.MethodOptions
             * @instance
             */
            MethodOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * MethodOptions .google.api.http.
             * @member {google.api.IHttpRule|null|undefined} .google.api.http
             * @memberof google.protobuf.MethodOptions
             * @instance
             */
            MethodOptions.prototype[".google.api.http"] = null;

            /**
             * Creates a new MethodOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {google.protobuf.IMethodOptions=} [properties] Properties to set
             * @returns {google.protobuf.MethodOptions} MethodOptions instance
             */
            MethodOptions.create = function create(properties) {
                return new MethodOptions(properties);
            };

            /**
             * Encodes the specified MethodOptions message. Does not implicitly {@link google.protobuf.MethodOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {google.protobuf.IMethodOptions} message MethodOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MethodOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    writer.uint32(/* id 33, wireType 0 =*/264).bool(message.deprecated);
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (var i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                if (message[".google.api.http"] != null && message.hasOwnProperty(".google.api.http"))
                    $root.google.api.HttpRule.encode(message[".google.api.http"], writer.uint32(/* id 72295728, wireType 2 =*/578365826).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified MethodOptions message, length delimited. Does not implicitly {@link google.protobuf.MethodOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {google.protobuf.IMethodOptions} message MethodOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MethodOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MethodOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.MethodOptions} MethodOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MethodOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MethodOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 33:
                        message.deprecated = reader.bool();
                        break;
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    case 72295728:
                        message[".google.api.http"] = $root.google.api.HttpRule.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MethodOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.MethodOptions} MethodOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MethodOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MethodOptions message.
             * @function verify
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MethodOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (var i = 0; i < message.uninterpretedOption.length; ++i) {
                        var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                if (message[".google.api.http"] != null && message.hasOwnProperty(".google.api.http")) {
                    var error = $root.google.api.HttpRule.verify(message[".google.api.http"]);
                    if (error)
                        return ".google.api.http." + error;
                }
                return null;
            };

            /**
             * Creates a MethodOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.MethodOptions} MethodOptions
             */
            MethodOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.MethodOptions)
                    return object;
                var message = new $root.google.protobuf.MethodOptions();
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.MethodOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (var i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.MethodOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                if (object[".google.api.http"] != null) {
                    if (typeof object[".google.api.http"] !== "object")
                        throw TypeError(".google.protobuf.MethodOptions..google.api.http: object expected");
                    message[".google.api.http"] = $root.google.api.HttpRule.fromObject(object[".google.api.http"]);
                }
                return message;
            };

            /**
             * Creates a plain object from a MethodOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {google.protobuf.MethodOptions} message MethodOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MethodOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults) {
                    object.deprecated = false;
                    object[".google.api.http"] = null;
                }
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (var j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                if (message[".google.api.http"] != null && message.hasOwnProperty(".google.api.http"))
                    object[".google.api.http"] = $root.google.api.HttpRule.toObject(message[".google.api.http"], options);
                return object;
            };

            /**
             * Converts this MethodOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.MethodOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MethodOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MethodOptions;
        })();

        protobuf.UninterpretedOption = (function() {

            /**
             * Properties of an UninterpretedOption.
             * @memberof google.protobuf
             * @interface IUninterpretedOption
             * @property {Array.<google.protobuf.UninterpretedOption.INamePart>|null} [name] UninterpretedOption name
             * @property {string|null} [identifierValue] UninterpretedOption identifierValue
             * @property {number|Long|null} [positiveIntValue] UninterpretedOption positiveIntValue
             * @property {number|Long|null} [negativeIntValue] UninterpretedOption negativeIntValue
             * @property {number|null} [doubleValue] UninterpretedOption doubleValue
             * @property {Uint8Array|null} [stringValue] UninterpretedOption stringValue
             * @property {string|null} [aggregateValue] UninterpretedOption aggregateValue
             */

            /**
             * Constructs a new UninterpretedOption.
             * @memberof google.protobuf
             * @classdesc Represents an UninterpretedOption.
             * @implements IUninterpretedOption
             * @constructor
             * @param {google.protobuf.IUninterpretedOption=} [properties] Properties to set
             */
            function UninterpretedOption(properties) {
                this.name = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * UninterpretedOption name.
             * @member {Array.<google.protobuf.UninterpretedOption.INamePart>} name
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.name = $util.emptyArray;

            /**
             * UninterpretedOption identifierValue.
             * @member {string} identifierValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.identifierValue = "";

            /**
             * UninterpretedOption positiveIntValue.
             * @member {number|Long} positiveIntValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.positiveIntValue = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * UninterpretedOption negativeIntValue.
             * @member {number|Long} negativeIntValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.negativeIntValue = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * UninterpretedOption doubleValue.
             * @member {number} doubleValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.doubleValue = 0;

            /**
             * UninterpretedOption stringValue.
             * @member {Uint8Array} stringValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.stringValue = $util.newBuffer([]);

            /**
             * UninterpretedOption aggregateValue.
             * @member {string} aggregateValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.aggregateValue = "";

            /**
             * Creates a new UninterpretedOption instance using the specified properties.
             * @function create
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {google.protobuf.IUninterpretedOption=} [properties] Properties to set
             * @returns {google.protobuf.UninterpretedOption} UninterpretedOption instance
             */
            UninterpretedOption.create = function create(properties) {
                return new UninterpretedOption(properties);
            };

            /**
             * Encodes the specified UninterpretedOption message. Does not implicitly {@link google.protobuf.UninterpretedOption.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {google.protobuf.IUninterpretedOption} message UninterpretedOption message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UninterpretedOption.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.name.length)
                    for (var i = 0; i < message.name.length; ++i)
                        $root.google.protobuf.UninterpretedOption.NamePart.encode(message.name[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.identifierValue != null && message.hasOwnProperty("identifierValue"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.identifierValue);
                if (message.positiveIntValue != null && message.hasOwnProperty("positiveIntValue"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.positiveIntValue);
                if (message.negativeIntValue != null && message.hasOwnProperty("negativeIntValue"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int64(message.negativeIntValue);
                if (message.doubleValue != null && message.hasOwnProperty("doubleValue"))
                    writer.uint32(/* id 6, wireType 1 =*/49).double(message.doubleValue);
                if (message.stringValue != null && message.hasOwnProperty("stringValue"))
                    writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.stringValue);
                if (message.aggregateValue != null && message.hasOwnProperty("aggregateValue"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.aggregateValue);
                return writer;
            };

            /**
             * Encodes the specified UninterpretedOption message, length delimited. Does not implicitly {@link google.protobuf.UninterpretedOption.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {google.protobuf.IUninterpretedOption} message UninterpretedOption message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UninterpretedOption.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an UninterpretedOption message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UninterpretedOption.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.UninterpretedOption();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 2:
                        if (!(message.name && message.name.length))
                            message.name = [];
                        message.name.push($root.google.protobuf.UninterpretedOption.NamePart.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        message.identifierValue = reader.string();
                        break;
                    case 4:
                        message.positiveIntValue = reader.uint64();
                        break;
                    case 5:
                        message.negativeIntValue = reader.int64();
                        break;
                    case 6:
                        message.doubleValue = reader.double();
                        break;
                    case 7:
                        message.stringValue = reader.bytes();
                        break;
                    case 8:
                        message.aggregateValue = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an UninterpretedOption message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UninterpretedOption.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an UninterpretedOption message.
             * @function verify
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UninterpretedOption.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name")) {
                    if (!Array.isArray(message.name))
                        return "name: array expected";
                    for (var i = 0; i < message.name.length; ++i) {
                        var error = $root.google.protobuf.UninterpretedOption.NamePart.verify(message.name[i]);
                        if (error)
                            return "name." + error;
                    }
                }
                if (message.identifierValue != null && message.hasOwnProperty("identifierValue"))
                    if (!$util.isString(message.identifierValue))
                        return "identifierValue: string expected";
                if (message.positiveIntValue != null && message.hasOwnProperty("positiveIntValue"))
                    if (!$util.isInteger(message.positiveIntValue) && !(message.positiveIntValue && $util.isInteger(message.positiveIntValue.low) && $util.isInteger(message.positiveIntValue.high)))
                        return "positiveIntValue: integer|Long expected";
                if (message.negativeIntValue != null && message.hasOwnProperty("negativeIntValue"))
                    if (!$util.isInteger(message.negativeIntValue) && !(message.negativeIntValue && $util.isInteger(message.negativeIntValue.low) && $util.isInteger(message.negativeIntValue.high)))
                        return "negativeIntValue: integer|Long expected";
                if (message.doubleValue != null && message.hasOwnProperty("doubleValue"))
                    if (typeof message.doubleValue !== "number")
                        return "doubleValue: number expected";
                if (message.stringValue != null && message.hasOwnProperty("stringValue"))
                    if (!(message.stringValue && typeof message.stringValue.length === "number" || $util.isString(message.stringValue)))
                        return "stringValue: buffer expected";
                if (message.aggregateValue != null && message.hasOwnProperty("aggregateValue"))
                    if (!$util.isString(message.aggregateValue))
                        return "aggregateValue: string expected";
                return null;
            };

            /**
             * Creates an UninterpretedOption message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
             */
            UninterpretedOption.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.UninterpretedOption)
                    return object;
                var message = new $root.google.protobuf.UninterpretedOption();
                if (object.name) {
                    if (!Array.isArray(object.name))
                        throw TypeError(".google.protobuf.UninterpretedOption.name: array expected");
                    message.name = [];
                    for (var i = 0; i < object.name.length; ++i) {
                        if (typeof object.name[i] !== "object")
                            throw TypeError(".google.protobuf.UninterpretedOption.name: object expected");
                        message.name[i] = $root.google.protobuf.UninterpretedOption.NamePart.fromObject(object.name[i]);
                    }
                }
                if (object.identifierValue != null)
                    message.identifierValue = String(object.identifierValue);
                if (object.positiveIntValue != null)
                    if ($util.Long)
                        (message.positiveIntValue = $util.Long.fromValue(object.positiveIntValue)).unsigned = true;
                    else if (typeof object.positiveIntValue === "string")
                        message.positiveIntValue = parseInt(object.positiveIntValue, 10);
                    else if (typeof object.positiveIntValue === "number")
                        message.positiveIntValue = object.positiveIntValue;
                    else if (typeof object.positiveIntValue === "object")
                        message.positiveIntValue = new $util.LongBits(object.positiveIntValue.low >>> 0, object.positiveIntValue.high >>> 0).toNumber(true);
                if (object.negativeIntValue != null)
                    if ($util.Long)
                        (message.negativeIntValue = $util.Long.fromValue(object.negativeIntValue)).unsigned = false;
                    else if (typeof object.negativeIntValue === "string")
                        message.negativeIntValue = parseInt(object.negativeIntValue, 10);
                    else if (typeof object.negativeIntValue === "number")
                        message.negativeIntValue = object.negativeIntValue;
                    else if (typeof object.negativeIntValue === "object")
                        message.negativeIntValue = new $util.LongBits(object.negativeIntValue.low >>> 0, object.negativeIntValue.high >>> 0).toNumber();
                if (object.doubleValue != null)
                    message.doubleValue = Number(object.doubleValue);
                if (object.stringValue != null)
                    if (typeof object.stringValue === "string")
                        $util.base64.decode(object.stringValue, message.stringValue = $util.newBuffer($util.base64.length(object.stringValue)), 0);
                    else if (object.stringValue.length)
                        message.stringValue = object.stringValue;
                if (object.aggregateValue != null)
                    message.aggregateValue = String(object.aggregateValue);
                return message;
            };

            /**
             * Creates a plain object from an UninterpretedOption message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {google.protobuf.UninterpretedOption} message UninterpretedOption
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UninterpretedOption.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.name = [];
                if (options.defaults) {
                    object.identifierValue = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.positiveIntValue = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.positiveIntValue = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.negativeIntValue = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.negativeIntValue = options.longs === String ? "0" : 0;
                    object.doubleValue = 0;
                    if (options.bytes === String)
                        object.stringValue = "";
                    else {
                        object.stringValue = [];
                        if (options.bytes !== Array)
                            object.stringValue = $util.newBuffer(object.stringValue);
                    }
                    object.aggregateValue = "";
                }
                if (message.name && message.name.length) {
                    object.name = [];
                    for (var j = 0; j < message.name.length; ++j)
                        object.name[j] = $root.google.protobuf.UninterpretedOption.NamePart.toObject(message.name[j], options);
                }
                if (message.identifierValue != null && message.hasOwnProperty("identifierValue"))
                    object.identifierValue = message.identifierValue;
                if (message.positiveIntValue != null && message.hasOwnProperty("positiveIntValue"))
                    if (typeof message.positiveIntValue === "number")
                        object.positiveIntValue = options.longs === String ? String(message.positiveIntValue) : message.positiveIntValue;
                    else
                        object.positiveIntValue = options.longs === String ? $util.Long.prototype.toString.call(message.positiveIntValue) : options.longs === Number ? new $util.LongBits(message.positiveIntValue.low >>> 0, message.positiveIntValue.high >>> 0).toNumber(true) : message.positiveIntValue;
                if (message.negativeIntValue != null && message.hasOwnProperty("negativeIntValue"))
                    if (typeof message.negativeIntValue === "number")
                        object.negativeIntValue = options.longs === String ? String(message.negativeIntValue) : message.negativeIntValue;
                    else
                        object.negativeIntValue = options.longs === String ? $util.Long.prototype.toString.call(message.negativeIntValue) : options.longs === Number ? new $util.LongBits(message.negativeIntValue.low >>> 0, message.negativeIntValue.high >>> 0).toNumber() : message.negativeIntValue;
                if (message.doubleValue != null && message.hasOwnProperty("doubleValue"))
                    object.doubleValue = options.json && !isFinite(message.doubleValue) ? String(message.doubleValue) : message.doubleValue;
                if (message.stringValue != null && message.hasOwnProperty("stringValue"))
                    object.stringValue = options.bytes === String ? $util.base64.encode(message.stringValue, 0, message.stringValue.length) : options.bytes === Array ? Array.prototype.slice.call(message.stringValue) : message.stringValue;
                if (message.aggregateValue != null && message.hasOwnProperty("aggregateValue"))
                    object.aggregateValue = message.aggregateValue;
                return object;
            };

            /**
             * Converts this UninterpretedOption to JSON.
             * @function toJSON
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UninterpretedOption.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            UninterpretedOption.NamePart = (function() {

                /**
                 * Properties of a NamePart.
                 * @memberof google.protobuf.UninterpretedOption
                 * @interface INamePart
                 * @property {string} namePart NamePart namePart
                 * @property {boolean} isExtension NamePart isExtension
                 */

                /**
                 * Constructs a new NamePart.
                 * @memberof google.protobuf.UninterpretedOption
                 * @classdesc Represents a NamePart.
                 * @implements INamePart
                 * @constructor
                 * @param {google.protobuf.UninterpretedOption.INamePart=} [properties] Properties to set
                 */
                function NamePart(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * NamePart namePart.
                 * @member {string} namePart
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @instance
                 */
                NamePart.prototype.namePart = "";

                /**
                 * NamePart isExtension.
                 * @member {boolean} isExtension
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @instance
                 */
                NamePart.prototype.isExtension = false;

                /**
                 * Creates a new NamePart instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {google.protobuf.UninterpretedOption.INamePart=} [properties] Properties to set
                 * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart instance
                 */
                NamePart.create = function create(properties) {
                    return new NamePart(properties);
                };

                /**
                 * Encodes the specified NamePart message. Does not implicitly {@link google.protobuf.UninterpretedOption.NamePart.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {google.protobuf.UninterpretedOption.INamePart} message NamePart message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NamePart.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.namePart);
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isExtension);
                    return writer;
                };

                /**
                 * Encodes the specified NamePart message, length delimited. Does not implicitly {@link google.protobuf.UninterpretedOption.NamePart.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {google.protobuf.UninterpretedOption.INamePart} message NamePart message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NamePart.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a NamePart message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NamePart.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.UninterpretedOption.NamePart();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.namePart = reader.string();
                            break;
                        case 2:
                            message.isExtension = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    if (!message.hasOwnProperty("namePart"))
                        throw $util.ProtocolError("missing required 'namePart'", { instance: message });
                    if (!message.hasOwnProperty("isExtension"))
                        throw $util.ProtocolError("missing required 'isExtension'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a NamePart message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NamePart.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a NamePart message.
                 * @function verify
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                NamePart.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (!$util.isString(message.namePart))
                        return "namePart: string expected";
                    if (typeof message.isExtension !== "boolean")
                        return "isExtension: boolean expected";
                    return null;
                };

                /**
                 * Creates a NamePart message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
                 */
                NamePart.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.UninterpretedOption.NamePart)
                        return object;
                    var message = new $root.google.protobuf.UninterpretedOption.NamePart();
                    if (object.namePart != null)
                        message.namePart = String(object.namePart);
                    if (object.isExtension != null)
                        message.isExtension = Boolean(object.isExtension);
                    return message;
                };

                /**
                 * Creates a plain object from a NamePart message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {google.protobuf.UninterpretedOption.NamePart} message NamePart
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                NamePart.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.namePart = "";
                        object.isExtension = false;
                    }
                    if (message.namePart != null && message.hasOwnProperty("namePart"))
                        object.namePart = message.namePart;
                    if (message.isExtension != null && message.hasOwnProperty("isExtension"))
                        object.isExtension = message.isExtension;
                    return object;
                };

                /**
                 * Converts this NamePart to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                NamePart.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return NamePart;
            })();

            return UninterpretedOption;
        })();

        protobuf.SourceCodeInfo = (function() {

            /**
             * Properties of a SourceCodeInfo.
             * @memberof google.protobuf
             * @interface ISourceCodeInfo
             * @property {Array.<google.protobuf.SourceCodeInfo.ILocation>|null} [location] SourceCodeInfo location
             */

            /**
             * Constructs a new SourceCodeInfo.
             * @memberof google.protobuf
             * @classdesc Represents a SourceCodeInfo.
             * @implements ISourceCodeInfo
             * @constructor
             * @param {google.protobuf.ISourceCodeInfo=} [properties] Properties to set
             */
            function SourceCodeInfo(properties) {
                this.location = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SourceCodeInfo location.
             * @member {Array.<google.protobuf.SourceCodeInfo.ILocation>} location
             * @memberof google.protobuf.SourceCodeInfo
             * @instance
             */
            SourceCodeInfo.prototype.location = $util.emptyArray;

            /**
             * Creates a new SourceCodeInfo instance using the specified properties.
             * @function create
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {google.protobuf.ISourceCodeInfo=} [properties] Properties to set
             * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo instance
             */
            SourceCodeInfo.create = function create(properties) {
                return new SourceCodeInfo(properties);
            };

            /**
             * Encodes the specified SourceCodeInfo message. Does not implicitly {@link google.protobuf.SourceCodeInfo.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {google.protobuf.ISourceCodeInfo} message SourceCodeInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SourceCodeInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.location != null && message.location.length)
                    for (var i = 0; i < message.location.length; ++i)
                        $root.google.protobuf.SourceCodeInfo.Location.encode(message.location[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified SourceCodeInfo message, length delimited. Does not implicitly {@link google.protobuf.SourceCodeInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {google.protobuf.ISourceCodeInfo} message SourceCodeInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SourceCodeInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SourceCodeInfo message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SourceCodeInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.SourceCodeInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.location && message.location.length))
                            message.location = [];
                        message.location.push($root.google.protobuf.SourceCodeInfo.Location.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SourceCodeInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SourceCodeInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SourceCodeInfo message.
             * @function verify
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SourceCodeInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.location != null && message.hasOwnProperty("location")) {
                    if (!Array.isArray(message.location))
                        return "location: array expected";
                    for (var i = 0; i < message.location.length; ++i) {
                        var error = $root.google.protobuf.SourceCodeInfo.Location.verify(message.location[i]);
                        if (error)
                            return "location." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a SourceCodeInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
             */
            SourceCodeInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.SourceCodeInfo)
                    return object;
                var message = new $root.google.protobuf.SourceCodeInfo();
                if (object.location) {
                    if (!Array.isArray(object.location))
                        throw TypeError(".google.protobuf.SourceCodeInfo.location: array expected");
                    message.location = [];
                    for (var i = 0; i < object.location.length; ++i) {
                        if (typeof object.location[i] !== "object")
                            throw TypeError(".google.protobuf.SourceCodeInfo.location: object expected");
                        message.location[i] = $root.google.protobuf.SourceCodeInfo.Location.fromObject(object.location[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a SourceCodeInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {google.protobuf.SourceCodeInfo} message SourceCodeInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SourceCodeInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.location = [];
                if (message.location && message.location.length) {
                    object.location = [];
                    for (var j = 0; j < message.location.length; ++j)
                        object.location[j] = $root.google.protobuf.SourceCodeInfo.Location.toObject(message.location[j], options);
                }
                return object;
            };

            /**
             * Converts this SourceCodeInfo to JSON.
             * @function toJSON
             * @memberof google.protobuf.SourceCodeInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SourceCodeInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            SourceCodeInfo.Location = (function() {

                /**
                 * Properties of a Location.
                 * @memberof google.protobuf.SourceCodeInfo
                 * @interface ILocation
                 * @property {Array.<number>|null} [path] Location path
                 * @property {Array.<number>|null} [span] Location span
                 * @property {string|null} [leadingComments] Location leadingComments
                 * @property {string|null} [trailingComments] Location trailingComments
                 * @property {Array.<string>|null} [leadingDetachedComments] Location leadingDetachedComments
                 */

                /**
                 * Constructs a new Location.
                 * @memberof google.protobuf.SourceCodeInfo
                 * @classdesc Represents a Location.
                 * @implements ILocation
                 * @constructor
                 * @param {google.protobuf.SourceCodeInfo.ILocation=} [properties] Properties to set
                 */
                function Location(properties) {
                    this.path = [];
                    this.span = [];
                    this.leadingDetachedComments = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Location path.
                 * @member {Array.<number>} path
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 */
                Location.prototype.path = $util.emptyArray;

                /**
                 * Location span.
                 * @member {Array.<number>} span
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 */
                Location.prototype.span = $util.emptyArray;

                /**
                 * Location leadingComments.
                 * @member {string} leadingComments
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 */
                Location.prototype.leadingComments = "";

                /**
                 * Location trailingComments.
                 * @member {string} trailingComments
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 */
                Location.prototype.trailingComments = "";

                /**
                 * Location leadingDetachedComments.
                 * @member {Array.<string>} leadingDetachedComments
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 */
                Location.prototype.leadingDetachedComments = $util.emptyArray;

                /**
                 * Creates a new Location instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {google.protobuf.SourceCodeInfo.ILocation=} [properties] Properties to set
                 * @returns {google.protobuf.SourceCodeInfo.Location} Location instance
                 */
                Location.create = function create(properties) {
                    return new Location(properties);
                };

                /**
                 * Encodes the specified Location message. Does not implicitly {@link google.protobuf.SourceCodeInfo.Location.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {google.protobuf.SourceCodeInfo.ILocation} message Location message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Location.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.path != null && message.path.length) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork();
                        for (var i = 0; i < message.path.length; ++i)
                            writer.int32(message.path[i]);
                        writer.ldelim();
                    }
                    if (message.span != null && message.span.length) {
                        writer.uint32(/* id 2, wireType 2 =*/18).fork();
                        for (var i = 0; i < message.span.length; ++i)
                            writer.int32(message.span[i]);
                        writer.ldelim();
                    }
                    if (message.leadingComments != null && message.hasOwnProperty("leadingComments"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.leadingComments);
                    if (message.trailingComments != null && message.hasOwnProperty("trailingComments"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.trailingComments);
                    if (message.leadingDetachedComments != null && message.leadingDetachedComments.length)
                        for (var i = 0; i < message.leadingDetachedComments.length; ++i)
                            writer.uint32(/* id 6, wireType 2 =*/50).string(message.leadingDetachedComments[i]);
                    return writer;
                };

                /**
                 * Encodes the specified Location message, length delimited. Does not implicitly {@link google.protobuf.SourceCodeInfo.Location.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {google.protobuf.SourceCodeInfo.ILocation} message Location message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Location.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Location message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.SourceCodeInfo.Location} Location
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Location.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.SourceCodeInfo.Location();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.path && message.path.length))
                                message.path = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.path.push(reader.int32());
                            } else
                                message.path.push(reader.int32());
                            break;
                        case 2:
                            if (!(message.span && message.span.length))
                                message.span = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.span.push(reader.int32());
                            } else
                                message.span.push(reader.int32());
                            break;
                        case 3:
                            message.leadingComments = reader.string();
                            break;
                        case 4:
                            message.trailingComments = reader.string();
                            break;
                        case 6:
                            if (!(message.leadingDetachedComments && message.leadingDetachedComments.length))
                                message.leadingDetachedComments = [];
                            message.leadingDetachedComments.push(reader.string());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Location message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.SourceCodeInfo.Location} Location
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Location.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Location message.
                 * @function verify
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Location.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.path != null && message.hasOwnProperty("path")) {
                        if (!Array.isArray(message.path))
                            return "path: array expected";
                        for (var i = 0; i < message.path.length; ++i)
                            if (!$util.isInteger(message.path[i]))
                                return "path: integer[] expected";
                    }
                    if (message.span != null && message.hasOwnProperty("span")) {
                        if (!Array.isArray(message.span))
                            return "span: array expected";
                        for (var i = 0; i < message.span.length; ++i)
                            if (!$util.isInteger(message.span[i]))
                                return "span: integer[] expected";
                    }
                    if (message.leadingComments != null && message.hasOwnProperty("leadingComments"))
                        if (!$util.isString(message.leadingComments))
                            return "leadingComments: string expected";
                    if (message.trailingComments != null && message.hasOwnProperty("trailingComments"))
                        if (!$util.isString(message.trailingComments))
                            return "trailingComments: string expected";
                    if (message.leadingDetachedComments != null && message.hasOwnProperty("leadingDetachedComments")) {
                        if (!Array.isArray(message.leadingDetachedComments))
                            return "leadingDetachedComments: array expected";
                        for (var i = 0; i < message.leadingDetachedComments.length; ++i)
                            if (!$util.isString(message.leadingDetachedComments[i]))
                                return "leadingDetachedComments: string[] expected";
                    }
                    return null;
                };

                /**
                 * Creates a Location message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.SourceCodeInfo.Location} Location
                 */
                Location.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.SourceCodeInfo.Location)
                        return object;
                    var message = new $root.google.protobuf.SourceCodeInfo.Location();
                    if (object.path) {
                        if (!Array.isArray(object.path))
                            throw TypeError(".google.protobuf.SourceCodeInfo.Location.path: array expected");
                        message.path = [];
                        for (var i = 0; i < object.path.length; ++i)
                            message.path[i] = object.path[i] | 0;
                    }
                    if (object.span) {
                        if (!Array.isArray(object.span))
                            throw TypeError(".google.protobuf.SourceCodeInfo.Location.span: array expected");
                        message.span = [];
                        for (var i = 0; i < object.span.length; ++i)
                            message.span[i] = object.span[i] | 0;
                    }
                    if (object.leadingComments != null)
                        message.leadingComments = String(object.leadingComments);
                    if (object.trailingComments != null)
                        message.trailingComments = String(object.trailingComments);
                    if (object.leadingDetachedComments) {
                        if (!Array.isArray(object.leadingDetachedComments))
                            throw TypeError(".google.protobuf.SourceCodeInfo.Location.leadingDetachedComments: array expected");
                        message.leadingDetachedComments = [];
                        for (var i = 0; i < object.leadingDetachedComments.length; ++i)
                            message.leadingDetachedComments[i] = String(object.leadingDetachedComments[i]);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Location message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {google.protobuf.SourceCodeInfo.Location} message Location
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Location.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.path = [];
                        object.span = [];
                        object.leadingDetachedComments = [];
                    }
                    if (options.defaults) {
                        object.leadingComments = "";
                        object.trailingComments = "";
                    }
                    if (message.path && message.path.length) {
                        object.path = [];
                        for (var j = 0; j < message.path.length; ++j)
                            object.path[j] = message.path[j];
                    }
                    if (message.span && message.span.length) {
                        object.span = [];
                        for (var j = 0; j < message.span.length; ++j)
                            object.span[j] = message.span[j];
                    }
                    if (message.leadingComments != null && message.hasOwnProperty("leadingComments"))
                        object.leadingComments = message.leadingComments;
                    if (message.trailingComments != null && message.hasOwnProperty("trailingComments"))
                        object.trailingComments = message.trailingComments;
                    if (message.leadingDetachedComments && message.leadingDetachedComments.length) {
                        object.leadingDetachedComments = [];
                        for (var j = 0; j < message.leadingDetachedComments.length; ++j)
                            object.leadingDetachedComments[j] = message.leadingDetachedComments[j];
                    }
                    return object;
                };

                /**
                 * Converts this Location to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Location.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Location;
            })();

            return SourceCodeInfo;
        })();

        protobuf.GeneratedCodeInfo = (function() {

            /**
             * Properties of a GeneratedCodeInfo.
             * @memberof google.protobuf
             * @interface IGeneratedCodeInfo
             * @property {Array.<google.protobuf.GeneratedCodeInfo.IAnnotation>|null} [annotation] GeneratedCodeInfo annotation
             */

            /**
             * Constructs a new GeneratedCodeInfo.
             * @memberof google.protobuf
             * @classdesc Represents a GeneratedCodeInfo.
             * @implements IGeneratedCodeInfo
             * @constructor
             * @param {google.protobuf.IGeneratedCodeInfo=} [properties] Properties to set
             */
            function GeneratedCodeInfo(properties) {
                this.annotation = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GeneratedCodeInfo annotation.
             * @member {Array.<google.protobuf.GeneratedCodeInfo.IAnnotation>} annotation
             * @memberof google.protobuf.GeneratedCodeInfo
             * @instance
             */
            GeneratedCodeInfo.prototype.annotation = $util.emptyArray;

            /**
             * Creates a new GeneratedCodeInfo instance using the specified properties.
             * @function create
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {google.protobuf.IGeneratedCodeInfo=} [properties] Properties to set
             * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo instance
             */
            GeneratedCodeInfo.create = function create(properties) {
                return new GeneratedCodeInfo(properties);
            };

            /**
             * Encodes the specified GeneratedCodeInfo message. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {google.protobuf.IGeneratedCodeInfo} message GeneratedCodeInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GeneratedCodeInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.annotation != null && message.annotation.length)
                    for (var i = 0; i < message.annotation.length; ++i)
                        $root.google.protobuf.GeneratedCodeInfo.Annotation.encode(message.annotation[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GeneratedCodeInfo message, length delimited. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {google.protobuf.IGeneratedCodeInfo} message GeneratedCodeInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GeneratedCodeInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GeneratedCodeInfo message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GeneratedCodeInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.GeneratedCodeInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.annotation && message.annotation.length))
                            message.annotation = [];
                        message.annotation.push($root.google.protobuf.GeneratedCodeInfo.Annotation.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GeneratedCodeInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GeneratedCodeInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GeneratedCodeInfo message.
             * @function verify
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GeneratedCodeInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.annotation != null && message.hasOwnProperty("annotation")) {
                    if (!Array.isArray(message.annotation))
                        return "annotation: array expected";
                    for (var i = 0; i < message.annotation.length; ++i) {
                        var error = $root.google.protobuf.GeneratedCodeInfo.Annotation.verify(message.annotation[i]);
                        if (error)
                            return "annotation." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a GeneratedCodeInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo
             */
            GeneratedCodeInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.GeneratedCodeInfo)
                    return object;
                var message = new $root.google.protobuf.GeneratedCodeInfo();
                if (object.annotation) {
                    if (!Array.isArray(object.annotation))
                        throw TypeError(".google.protobuf.GeneratedCodeInfo.annotation: array expected");
                    message.annotation = [];
                    for (var i = 0; i < object.annotation.length; ++i) {
                        if (typeof object.annotation[i] !== "object")
                            throw TypeError(".google.protobuf.GeneratedCodeInfo.annotation: object expected");
                        message.annotation[i] = $root.google.protobuf.GeneratedCodeInfo.Annotation.fromObject(object.annotation[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a GeneratedCodeInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {google.protobuf.GeneratedCodeInfo} message GeneratedCodeInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GeneratedCodeInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.annotation = [];
                if (message.annotation && message.annotation.length) {
                    object.annotation = [];
                    for (var j = 0; j < message.annotation.length; ++j)
                        object.annotation[j] = $root.google.protobuf.GeneratedCodeInfo.Annotation.toObject(message.annotation[j], options);
                }
                return object;
            };

            /**
             * Converts this GeneratedCodeInfo to JSON.
             * @function toJSON
             * @memberof google.protobuf.GeneratedCodeInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GeneratedCodeInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            GeneratedCodeInfo.Annotation = (function() {

                /**
                 * Properties of an Annotation.
                 * @memberof google.protobuf.GeneratedCodeInfo
                 * @interface IAnnotation
                 * @property {Array.<number>|null} [path] Annotation path
                 * @property {string|null} [sourceFile] Annotation sourceFile
                 * @property {number|null} [begin] Annotation begin
                 * @property {number|null} [end] Annotation end
                 */

                /**
                 * Constructs a new Annotation.
                 * @memberof google.protobuf.GeneratedCodeInfo
                 * @classdesc Represents an Annotation.
                 * @implements IAnnotation
                 * @constructor
                 * @param {google.protobuf.GeneratedCodeInfo.IAnnotation=} [properties] Properties to set
                 */
                function Annotation(properties) {
                    this.path = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Annotation path.
                 * @member {Array.<number>} path
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @instance
                 */
                Annotation.prototype.path = $util.emptyArray;

                /**
                 * Annotation sourceFile.
                 * @member {string} sourceFile
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @instance
                 */
                Annotation.prototype.sourceFile = "";

                /**
                 * Annotation begin.
                 * @member {number} begin
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @instance
                 */
                Annotation.prototype.begin = 0;

                /**
                 * Annotation end.
                 * @member {number} end
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @instance
                 */
                Annotation.prototype.end = 0;

                /**
                 * Creates a new Annotation instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {google.protobuf.GeneratedCodeInfo.IAnnotation=} [properties] Properties to set
                 * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation instance
                 */
                Annotation.create = function create(properties) {
                    return new Annotation(properties);
                };

                /**
                 * Encodes the specified Annotation message. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.Annotation.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {google.protobuf.GeneratedCodeInfo.IAnnotation} message Annotation message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Annotation.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.path != null && message.path.length) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork();
                        for (var i = 0; i < message.path.length; ++i)
                            writer.int32(message.path[i]);
                        writer.ldelim();
                    }
                    if (message.sourceFile != null && message.hasOwnProperty("sourceFile"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.sourceFile);
                    if (message.begin != null && message.hasOwnProperty("begin"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.begin);
                    if (message.end != null && message.hasOwnProperty("end"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.end);
                    return writer;
                };

                /**
                 * Encodes the specified Annotation message, length delimited. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.Annotation.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {google.protobuf.GeneratedCodeInfo.IAnnotation} message Annotation message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Annotation.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an Annotation message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Annotation.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.GeneratedCodeInfo.Annotation();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.path && message.path.length))
                                message.path = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.path.push(reader.int32());
                            } else
                                message.path.push(reader.int32());
                            break;
                        case 2:
                            message.sourceFile = reader.string();
                            break;
                        case 3:
                            message.begin = reader.int32();
                            break;
                        case 4:
                            message.end = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an Annotation message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Annotation.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an Annotation message.
                 * @function verify
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Annotation.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.path != null && message.hasOwnProperty("path")) {
                        if (!Array.isArray(message.path))
                            return "path: array expected";
                        for (var i = 0; i < message.path.length; ++i)
                            if (!$util.isInteger(message.path[i]))
                                return "path: integer[] expected";
                    }
                    if (message.sourceFile != null && message.hasOwnProperty("sourceFile"))
                        if (!$util.isString(message.sourceFile))
                            return "sourceFile: string expected";
                    if (message.begin != null && message.hasOwnProperty("begin"))
                        if (!$util.isInteger(message.begin))
                            return "begin: integer expected";
                    if (message.end != null && message.hasOwnProperty("end"))
                        if (!$util.isInteger(message.end))
                            return "end: integer expected";
                    return null;
                };

                /**
                 * Creates an Annotation message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation
                 */
                Annotation.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.GeneratedCodeInfo.Annotation)
                        return object;
                    var message = new $root.google.protobuf.GeneratedCodeInfo.Annotation();
                    if (object.path) {
                        if (!Array.isArray(object.path))
                            throw TypeError(".google.protobuf.GeneratedCodeInfo.Annotation.path: array expected");
                        message.path = [];
                        for (var i = 0; i < object.path.length; ++i)
                            message.path[i] = object.path[i] | 0;
                    }
                    if (object.sourceFile != null)
                        message.sourceFile = String(object.sourceFile);
                    if (object.begin != null)
                        message.begin = object.begin | 0;
                    if (object.end != null)
                        message.end = object.end | 0;
                    return message;
                };

                /**
                 * Creates a plain object from an Annotation message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {google.protobuf.GeneratedCodeInfo.Annotation} message Annotation
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Annotation.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.path = [];
                    if (options.defaults) {
                        object.sourceFile = "";
                        object.begin = 0;
                        object.end = 0;
                    }
                    if (message.path && message.path.length) {
                        object.path = [];
                        for (var j = 0; j < message.path.length; ++j)
                            object.path[j] = message.path[j];
                    }
                    if (message.sourceFile != null && message.hasOwnProperty("sourceFile"))
                        object.sourceFile = message.sourceFile;
                    if (message.begin != null && message.hasOwnProperty("begin"))
                        object.begin = message.begin;
                    if (message.end != null && message.hasOwnProperty("end"))
                        object.end = message.end;
                    return object;
                };

                /**
                 * Converts this Annotation to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Annotation.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Annotation;
            })();

            return GeneratedCodeInfo;
        })();

        return protobuf;
    })();

    google.api = (function() {

        /**
         * Namespace api.
         * @memberof google
         * @namespace
         */
        var api = {};

        api.Http = (function() {

            /**
             * Properties of a Http.
             * @memberof google.api
             * @interface IHttp
             * @property {Array.<google.api.IHttpRule>|null} [rules] Http rules
             */

            /**
             * Constructs a new Http.
             * @memberof google.api
             * @classdesc Represents a Http.
             * @implements IHttp
             * @constructor
             * @param {google.api.IHttp=} [properties] Properties to set
             */
            function Http(properties) {
                this.rules = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Http rules.
             * @member {Array.<google.api.IHttpRule>} rules
             * @memberof google.api.Http
             * @instance
             */
            Http.prototype.rules = $util.emptyArray;

            /**
             * Creates a new Http instance using the specified properties.
             * @function create
             * @memberof google.api.Http
             * @static
             * @param {google.api.IHttp=} [properties] Properties to set
             * @returns {google.api.Http} Http instance
             */
            Http.create = function create(properties) {
                return new Http(properties);
            };

            /**
             * Encodes the specified Http message. Does not implicitly {@link google.api.Http.verify|verify} messages.
             * @function encode
             * @memberof google.api.Http
             * @static
             * @param {google.api.IHttp} message Http message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Http.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.rules != null && message.rules.length)
                    for (var i = 0; i < message.rules.length; ++i)
                        $root.google.api.HttpRule.encode(message.rules[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Http message, length delimited. Does not implicitly {@link google.api.Http.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.api.Http
             * @static
             * @param {google.api.IHttp} message Http message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Http.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Http message from the specified reader or buffer.
             * @function decode
             * @memberof google.api.Http
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.api.Http} Http
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Http.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.api.Http();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.rules && message.rules.length))
                            message.rules = [];
                        message.rules.push($root.google.api.HttpRule.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Http message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.api.Http
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.api.Http} Http
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Http.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Http message.
             * @function verify
             * @memberof google.api.Http
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Http.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.rules != null && message.hasOwnProperty("rules")) {
                    if (!Array.isArray(message.rules))
                        return "rules: array expected";
                    for (var i = 0; i < message.rules.length; ++i) {
                        var error = $root.google.api.HttpRule.verify(message.rules[i]);
                        if (error)
                            return "rules." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Http message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.api.Http
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.api.Http} Http
             */
            Http.fromObject = function fromObject(object) {
                if (object instanceof $root.google.api.Http)
                    return object;
                var message = new $root.google.api.Http();
                if (object.rules) {
                    if (!Array.isArray(object.rules))
                        throw TypeError(".google.api.Http.rules: array expected");
                    message.rules = [];
                    for (var i = 0; i < object.rules.length; ++i) {
                        if (typeof object.rules[i] !== "object")
                            throw TypeError(".google.api.Http.rules: object expected");
                        message.rules[i] = $root.google.api.HttpRule.fromObject(object.rules[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a Http message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.api.Http
             * @static
             * @param {google.api.Http} message Http
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Http.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.rules = [];
                if (message.rules && message.rules.length) {
                    object.rules = [];
                    for (var j = 0; j < message.rules.length; ++j)
                        object.rules[j] = $root.google.api.HttpRule.toObject(message.rules[j], options);
                }
                return object;
            };

            /**
             * Converts this Http to JSON.
             * @function toJSON
             * @memberof google.api.Http
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Http.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Http;
        })();

        api.HttpRule = (function() {

            /**
             * Properties of a HttpRule.
             * @memberof google.api
             * @interface IHttpRule
             * @property {string|null} [get] HttpRule get
             * @property {string|null} [put] HttpRule put
             * @property {string|null} [post] HttpRule post
             * @property {string|null} ["delete"] HttpRule delete
             * @property {string|null} [patch] HttpRule patch
             * @property {google.api.ICustomHttpPattern|null} [custom] HttpRule custom
             * @property {string|null} [selector] HttpRule selector
             * @property {string|null} [body] HttpRule body
             * @property {Array.<google.api.IHttpRule>|null} [additionalBindings] HttpRule additionalBindings
             */

            /**
             * Constructs a new HttpRule.
             * @memberof google.api
             * @classdesc Represents a HttpRule.
             * @implements IHttpRule
             * @constructor
             * @param {google.api.IHttpRule=} [properties] Properties to set
             */
            function HttpRule(properties) {
                this.additionalBindings = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * HttpRule get.
             * @member {string} get
             * @memberof google.api.HttpRule
             * @instance
             */
            HttpRule.prototype.get = "";

            /**
             * HttpRule put.
             * @member {string} put
             * @memberof google.api.HttpRule
             * @instance
             */
            HttpRule.prototype.put = "";

            /**
             * HttpRule post.
             * @member {string} post
             * @memberof google.api.HttpRule
             * @instance
             */
            HttpRule.prototype.post = "";

            /**
             * HttpRule delete.
             * @member {string} delete
             * @memberof google.api.HttpRule
             * @instance
             */
            HttpRule.prototype["delete"] = "";

            /**
             * HttpRule patch.
             * @member {string} patch
             * @memberof google.api.HttpRule
             * @instance
             */
            HttpRule.prototype.patch = "";

            /**
             * HttpRule custom.
             * @member {google.api.ICustomHttpPattern|null|undefined} custom
             * @memberof google.api.HttpRule
             * @instance
             */
            HttpRule.prototype.custom = null;

            /**
             * HttpRule selector.
             * @member {string} selector
             * @memberof google.api.HttpRule
             * @instance
             */
            HttpRule.prototype.selector = "";

            /**
             * HttpRule body.
             * @member {string} body
             * @memberof google.api.HttpRule
             * @instance
             */
            HttpRule.prototype.body = "";

            /**
             * HttpRule additionalBindings.
             * @member {Array.<google.api.IHttpRule>} additionalBindings
             * @memberof google.api.HttpRule
             * @instance
             */
            HttpRule.prototype.additionalBindings = $util.emptyArray;

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            /**
             * HttpRule pattern.
             * @member {"get"|"put"|"post"|"delete"|"patch"|"custom"|undefined} pattern
             * @memberof google.api.HttpRule
             * @instance
             */
            Object.defineProperty(HttpRule.prototype, "pattern", {
                get: $util.oneOfGetter($oneOfFields = ["get", "put", "post", "delete", "patch", "custom"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new HttpRule instance using the specified properties.
             * @function create
             * @memberof google.api.HttpRule
             * @static
             * @param {google.api.IHttpRule=} [properties] Properties to set
             * @returns {google.api.HttpRule} HttpRule instance
             */
            HttpRule.create = function create(properties) {
                return new HttpRule(properties);
            };

            /**
             * Encodes the specified HttpRule message. Does not implicitly {@link google.api.HttpRule.verify|verify} messages.
             * @function encode
             * @memberof google.api.HttpRule
             * @static
             * @param {google.api.IHttpRule} message HttpRule message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HttpRule.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.selector != null && message.hasOwnProperty("selector"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.selector);
                if (message.get != null && message.hasOwnProperty("get"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.get);
                if (message.put != null && message.hasOwnProperty("put"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.put);
                if (message.post != null && message.hasOwnProperty("post"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.post);
                if (message["delete"] != null && message.hasOwnProperty("delete"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message["delete"]);
                if (message.patch != null && message.hasOwnProperty("patch"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.patch);
                if (message.body != null && message.hasOwnProperty("body"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.body);
                if (message.custom != null && message.hasOwnProperty("custom"))
                    $root.google.api.CustomHttpPattern.encode(message.custom, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.additionalBindings != null && message.additionalBindings.length)
                    for (var i = 0; i < message.additionalBindings.length; ++i)
                        $root.google.api.HttpRule.encode(message.additionalBindings[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified HttpRule message, length delimited. Does not implicitly {@link google.api.HttpRule.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.api.HttpRule
             * @static
             * @param {google.api.IHttpRule} message HttpRule message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HttpRule.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a HttpRule message from the specified reader or buffer.
             * @function decode
             * @memberof google.api.HttpRule
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.api.HttpRule} HttpRule
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HttpRule.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.api.HttpRule();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 2:
                        message.get = reader.string();
                        break;
                    case 3:
                        message.put = reader.string();
                        break;
                    case 4:
                        message.post = reader.string();
                        break;
                    case 5:
                        message["delete"] = reader.string();
                        break;
                    case 6:
                        message.patch = reader.string();
                        break;
                    case 8:
                        message.custom = $root.google.api.CustomHttpPattern.decode(reader, reader.uint32());
                        break;
                    case 1:
                        message.selector = reader.string();
                        break;
                    case 7:
                        message.body = reader.string();
                        break;
                    case 11:
                        if (!(message.additionalBindings && message.additionalBindings.length))
                            message.additionalBindings = [];
                        message.additionalBindings.push($root.google.api.HttpRule.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a HttpRule message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.api.HttpRule
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.api.HttpRule} HttpRule
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HttpRule.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a HttpRule message.
             * @function verify
             * @memberof google.api.HttpRule
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            HttpRule.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.get != null && message.hasOwnProperty("get")) {
                    properties.pattern = 1;
                    if (!$util.isString(message.get))
                        return "get: string expected";
                }
                if (message.put != null && message.hasOwnProperty("put")) {
                    if (properties.pattern === 1)
                        return "pattern: multiple values";
                    properties.pattern = 1;
                    if (!$util.isString(message.put))
                        return "put: string expected";
                }
                if (message.post != null && message.hasOwnProperty("post")) {
                    if (properties.pattern === 1)
                        return "pattern: multiple values";
                    properties.pattern = 1;
                    if (!$util.isString(message.post))
                        return "post: string expected";
                }
                if (message["delete"] != null && message.hasOwnProperty("delete")) {
                    if (properties.pattern === 1)
                        return "pattern: multiple values";
                    properties.pattern = 1;
                    if (!$util.isString(message["delete"]))
                        return "delete: string expected";
                }
                if (message.patch != null && message.hasOwnProperty("patch")) {
                    if (properties.pattern === 1)
                        return "pattern: multiple values";
                    properties.pattern = 1;
                    if (!$util.isString(message.patch))
                        return "patch: string expected";
                }
                if (message.custom != null && message.hasOwnProperty("custom")) {
                    if (properties.pattern === 1)
                        return "pattern: multiple values";
                    properties.pattern = 1;
                    {
                        var error = $root.google.api.CustomHttpPattern.verify(message.custom);
                        if (error)
                            return "custom." + error;
                    }
                }
                if (message.selector != null && message.hasOwnProperty("selector"))
                    if (!$util.isString(message.selector))
                        return "selector: string expected";
                if (message.body != null && message.hasOwnProperty("body"))
                    if (!$util.isString(message.body))
                        return "body: string expected";
                if (message.additionalBindings != null && message.hasOwnProperty("additionalBindings")) {
                    if (!Array.isArray(message.additionalBindings))
                        return "additionalBindings: array expected";
                    for (var i = 0; i < message.additionalBindings.length; ++i) {
                        var error = $root.google.api.HttpRule.verify(message.additionalBindings[i]);
                        if (error)
                            return "additionalBindings." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a HttpRule message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.api.HttpRule
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.api.HttpRule} HttpRule
             */
            HttpRule.fromObject = function fromObject(object) {
                if (object instanceof $root.google.api.HttpRule)
                    return object;
                var message = new $root.google.api.HttpRule();
                if (object.get != null)
                    message.get = String(object.get);
                if (object.put != null)
                    message.put = String(object.put);
                if (object.post != null)
                    message.post = String(object.post);
                if (object["delete"] != null)
                    message["delete"] = String(object["delete"]);
                if (object.patch != null)
                    message.patch = String(object.patch);
                if (object.custom != null) {
                    if (typeof object.custom !== "object")
                        throw TypeError(".google.api.HttpRule.custom: object expected");
                    message.custom = $root.google.api.CustomHttpPattern.fromObject(object.custom);
                }
                if (object.selector != null)
                    message.selector = String(object.selector);
                if (object.body != null)
                    message.body = String(object.body);
                if (object.additionalBindings) {
                    if (!Array.isArray(object.additionalBindings))
                        throw TypeError(".google.api.HttpRule.additionalBindings: array expected");
                    message.additionalBindings = [];
                    for (var i = 0; i < object.additionalBindings.length; ++i) {
                        if (typeof object.additionalBindings[i] !== "object")
                            throw TypeError(".google.api.HttpRule.additionalBindings: object expected");
                        message.additionalBindings[i] = $root.google.api.HttpRule.fromObject(object.additionalBindings[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a HttpRule message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.api.HttpRule
             * @static
             * @param {google.api.HttpRule} message HttpRule
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            HttpRule.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.additionalBindings = [];
                if (options.defaults) {
                    object.selector = "";
                    object.body = "";
                }
                if (message.selector != null && message.hasOwnProperty("selector"))
                    object.selector = message.selector;
                if (message.get != null && message.hasOwnProperty("get")) {
                    object.get = message.get;
                    if (options.oneofs)
                        object.pattern = "get";
                }
                if (message.put != null && message.hasOwnProperty("put")) {
                    object.put = message.put;
                    if (options.oneofs)
                        object.pattern = "put";
                }
                if (message.post != null && message.hasOwnProperty("post")) {
                    object.post = message.post;
                    if (options.oneofs)
                        object.pattern = "post";
                }
                if (message["delete"] != null && message.hasOwnProperty("delete")) {
                    object["delete"] = message["delete"];
                    if (options.oneofs)
                        object.pattern = "delete";
                }
                if (message.patch != null && message.hasOwnProperty("patch")) {
                    object.patch = message.patch;
                    if (options.oneofs)
                        object.pattern = "patch";
                }
                if (message.body != null && message.hasOwnProperty("body"))
                    object.body = message.body;
                if (message.custom != null && message.hasOwnProperty("custom")) {
                    object.custom = $root.google.api.CustomHttpPattern.toObject(message.custom, options);
                    if (options.oneofs)
                        object.pattern = "custom";
                }
                if (message.additionalBindings && message.additionalBindings.length) {
                    object.additionalBindings = [];
                    for (var j = 0; j < message.additionalBindings.length; ++j)
                        object.additionalBindings[j] = $root.google.api.HttpRule.toObject(message.additionalBindings[j], options);
                }
                return object;
            };

            /**
             * Converts this HttpRule to JSON.
             * @function toJSON
             * @memberof google.api.HttpRule
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            HttpRule.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return HttpRule;
        })();

        api.CustomHttpPattern = (function() {

            /**
             * Properties of a CustomHttpPattern.
             * @memberof google.api
             * @interface ICustomHttpPattern
             * @property {string|null} [kind] CustomHttpPattern kind
             * @property {string|null} [path] CustomHttpPattern path
             */

            /**
             * Constructs a new CustomHttpPattern.
             * @memberof google.api
             * @classdesc Represents a CustomHttpPattern.
             * @implements ICustomHttpPattern
             * @constructor
             * @param {google.api.ICustomHttpPattern=} [properties] Properties to set
             */
            function CustomHttpPattern(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CustomHttpPattern kind.
             * @member {string} kind
             * @memberof google.api.CustomHttpPattern
             * @instance
             */
            CustomHttpPattern.prototype.kind = "";

            /**
             * CustomHttpPattern path.
             * @member {string} path
             * @memberof google.api.CustomHttpPattern
             * @instance
             */
            CustomHttpPattern.prototype.path = "";

            /**
             * Creates a new CustomHttpPattern instance using the specified properties.
             * @function create
             * @memberof google.api.CustomHttpPattern
             * @static
             * @param {google.api.ICustomHttpPattern=} [properties] Properties to set
             * @returns {google.api.CustomHttpPattern} CustomHttpPattern instance
             */
            CustomHttpPattern.create = function create(properties) {
                return new CustomHttpPattern(properties);
            };

            /**
             * Encodes the specified CustomHttpPattern message. Does not implicitly {@link google.api.CustomHttpPattern.verify|verify} messages.
             * @function encode
             * @memberof google.api.CustomHttpPattern
             * @static
             * @param {google.api.ICustomHttpPattern} message CustomHttpPattern message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CustomHttpPattern.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.kind != null && message.hasOwnProperty("kind"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.kind);
                if (message.path != null && message.hasOwnProperty("path"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.path);
                return writer;
            };

            /**
             * Encodes the specified CustomHttpPattern message, length delimited. Does not implicitly {@link google.api.CustomHttpPattern.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.api.CustomHttpPattern
             * @static
             * @param {google.api.ICustomHttpPattern} message CustomHttpPattern message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CustomHttpPattern.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CustomHttpPattern message from the specified reader or buffer.
             * @function decode
             * @memberof google.api.CustomHttpPattern
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.api.CustomHttpPattern} CustomHttpPattern
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CustomHttpPattern.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.api.CustomHttpPattern();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.kind = reader.string();
                        break;
                    case 2:
                        message.path = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CustomHttpPattern message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.api.CustomHttpPattern
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.api.CustomHttpPattern} CustomHttpPattern
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CustomHttpPattern.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CustomHttpPattern message.
             * @function verify
             * @memberof google.api.CustomHttpPattern
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CustomHttpPattern.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.kind != null && message.hasOwnProperty("kind"))
                    if (!$util.isString(message.kind))
                        return "kind: string expected";
                if (message.path != null && message.hasOwnProperty("path"))
                    if (!$util.isString(message.path))
                        return "path: string expected";
                return null;
            };

            /**
             * Creates a CustomHttpPattern message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.api.CustomHttpPattern
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.api.CustomHttpPattern} CustomHttpPattern
             */
            CustomHttpPattern.fromObject = function fromObject(object) {
                if (object instanceof $root.google.api.CustomHttpPattern)
                    return object;
                var message = new $root.google.api.CustomHttpPattern();
                if (object.kind != null)
                    message.kind = String(object.kind);
                if (object.path != null)
                    message.path = String(object.path);
                return message;
            };

            /**
             * Creates a plain object from a CustomHttpPattern message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.api.CustomHttpPattern
             * @static
             * @param {google.api.CustomHttpPattern} message CustomHttpPattern
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CustomHttpPattern.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.kind = "";
                    object.path = "";
                }
                if (message.kind != null && message.hasOwnProperty("kind"))
                    object.kind = message.kind;
                if (message.path != null && message.hasOwnProperty("path"))
                    object.path = message.path;
                return object;
            };

            /**
             * Converts this CustomHttpPattern to JSON.
             * @function toJSON
             * @memberof google.api.CustomHttpPattern
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CustomHttpPattern.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CustomHttpPattern;
        })();

        return api;
    })();

    return google;
})();

module.exports = $root;
